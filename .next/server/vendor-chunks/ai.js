"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(rsc)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError),\n/* harmony export */   AbstractChat: () => (/* binding */ AbstractChat),\n/* harmony export */   DefaultChatTransport: () => (/* binding */ DefaultChatTransport),\n/* harmony export */   DownloadError: () => (/* binding */ DownloadError),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError),\n/* harmony export */   Experimental_Agent: () => (/* binding */ Agent),\n/* harmony export */   HttpChatTransport: () => (/* binding */ HttpChatTransport),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* binding */ InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidResponseDataError),\n/* harmony export */   InvalidStreamPartError: () => (/* binding */ InvalidStreamPartError),\n/* harmony export */   InvalidToolInputError: () => (/* binding */ InvalidToolInputError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError),\n/* harmony export */   JsonToSseTransformStream: () => (/* binding */ JsonToSseTransformStream),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError),\n/* harmony export */   MCPClientError: () => (/* binding */ MCPClientError),\n/* harmony export */   MessageConversionError: () => (/* binding */ MessageConversionError),\n/* harmony export */   NoContentGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoContentGeneratedError),\n/* harmony export */   NoImageGeneratedError: () => (/* binding */ NoImageGeneratedError),\n/* harmony export */   NoObjectGeneratedError: () => (/* binding */ NoObjectGeneratedError),\n/* harmony export */   NoOutputGeneratedError: () => (/* binding */ NoOutputGeneratedError),\n/* harmony export */   NoOutputSpecifiedError: () => (/* binding */ NoOutputSpecifiedError),\n/* harmony export */   NoSuchModelError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* binding */ NoSuchToolError),\n/* harmony export */   Output: () => (/* binding */ output_exports),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   SerialJobExecutor: () => (/* binding */ SerialJobExecutor),\n/* harmony export */   TextStreamChatTransport: () => (/* binding */ TextStreamChatTransport),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TooManyEmbeddingValuesForCallError),\n/* harmony export */   ToolCallRepairError: () => (/* binding */ ToolCallRepairError),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError),\n/* harmony export */   UI_MESSAGE_STREAM_HEADERS: () => (/* binding */ UI_MESSAGE_STREAM_HEADERS),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError),\n/* harmony export */   UnsupportedModelVersionError: () => (/* binding */ UnsupportedModelVersionError),\n/* harmony export */   asSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema),\n/* harmony export */   assistantModelMessageSchema: () => (/* binding */ assistantModelMessageSchema),\n/* harmony export */   callCompletionApi: () => (/* binding */ callCompletionApi),\n/* harmony export */   consumeStream: () => (/* binding */ consumeStream),\n/* harmony export */   convertFileListToFileUIParts: () => (/* binding */ convertFileListToFileUIParts),\n/* harmony export */   convertToCoreMessages: () => (/* binding */ convertToCoreMessages),\n/* harmony export */   convertToModelMessages: () => (/* binding */ convertToModelMessages),\n/* harmony export */   coreAssistantMessageSchema: () => (/* binding */ coreAssistantMessageSchema),\n/* harmony export */   coreMessageSchema: () => (/* binding */ coreMessageSchema),\n/* harmony export */   coreSystemMessageSchema: () => (/* binding */ coreSystemMessageSchema),\n/* harmony export */   coreToolMessageSchema: () => (/* binding */ coreToolMessageSchema),\n/* harmony export */   coreUserMessageSchema: () => (/* binding */ coreUserMessageSchema),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createGateway: () => (/* reexport safe */ _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.createGateway),\n/* harmony export */   createIdGenerator: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator),\n/* harmony export */   createProviderRegistry: () => (/* binding */ createProviderRegistry),\n/* harmony export */   createTextStreamResponse: () => (/* binding */ createTextStreamResponse),\n/* harmony export */   createUIMessageStream: () => (/* binding */ createUIMessageStream),\n/* harmony export */   createUIMessageStreamResponse: () => (/* binding */ createUIMessageStreamResponse),\n/* harmony export */   customProvider: () => (/* binding */ customProvider),\n/* harmony export */   defaultSettingsMiddleware: () => (/* binding */ defaultSettingsMiddleware),\n/* harmony export */   dynamicTool: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.dynamicTool),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_createMCPClient: () => (/* binding */ createMCPClient),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_customProvider: () => (/* binding */ experimental_customProvider),\n/* harmony export */   experimental_generateImage: () => (/* binding */ generateImage),\n/* harmony export */   experimental_generateSpeech: () => (/* binding */ generateSpeech),\n/* harmony export */   experimental_transcribe: () => (/* binding */ transcribe),\n/* harmony export */   extractReasoningMiddleware: () => (/* binding */ extractReasoningMiddleware),\n/* harmony export */   gateway: () => (/* reexport safe */ _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.gateway),\n/* harmony export */   generateId: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   getTextFromDataUrl: () => (/* binding */ getTextFromDataUrl),\n/* harmony export */   getToolName: () => (/* binding */ getToolName),\n/* harmony export */   getToolOrDynamicToolName: () => (/* binding */ getToolOrDynamicToolName),\n/* harmony export */   hasToolCall: () => (/* binding */ hasToolCall),\n/* harmony export */   isDeepEqualData: () => (/* binding */ isDeepEqualData),\n/* harmony export */   isToolOrDynamicToolUIPart: () => (/* binding */ isToolOrDynamicToolUIPart),\n/* harmony export */   isToolUIPart: () => (/* binding */ isToolUIPart),\n/* harmony export */   jsonSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.jsonSchema),\n/* harmony export */   lastAssistantMessageIsCompleteWithToolCalls: () => (/* binding */ lastAssistantMessageIsCompleteWithToolCalls),\n/* harmony export */   modelMessageSchema: () => (/* binding */ modelMessageSchema),\n/* harmony export */   parsePartialJson: () => (/* binding */ parsePartialJson),\n/* harmony export */   pipeTextStreamToResponse: () => (/* binding */ pipeTextStreamToResponse),\n/* harmony export */   pipeUIMessageStreamToResponse: () => (/* binding */ pipeUIMessageStreamToResponse),\n/* harmony export */   readUIMessageStream: () => (/* binding */ readUIMessageStream),\n/* harmony export */   simulateReadableStream: () => (/* binding */ simulateReadableStream),\n/* harmony export */   simulateStreamingMiddleware: () => (/* binding */ simulateStreamingMiddleware),\n/* harmony export */   smoothStream: () => (/* binding */ smoothStream),\n/* harmony export */   stepCountIs: () => (/* binding */ stepCountIs),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   systemModelMessageSchema: () => (/* binding */ systemModelMessageSchema),\n/* harmony export */   tool: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.tool),\n/* harmony export */   toolModelMessageSchema: () => (/* binding */ toolModelMessageSchema),\n/* harmony export */   userModelMessageSchema: () => (/* binding */ userModelMessageSchema),\n/* harmony export */   validateUIMessages: () => (/* binding */ validateUIMessages),\n/* harmony export */   wrapLanguageModel: () => (/* binding */ wrapLanguageModel),\n/* harmony export */   wrapProvider: () => (/* binding */ wrapProvider),\n/* harmony export */   zodSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.zodSchema)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/gateway */ \"(rsc)/./node_modules/@ai-sdk/gateway/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var zod_v4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod/v4 */ \"(rsc)/./node_modules/zod/v4/classic/schemas.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/trace-api.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/trace/status.js\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/eventsource-parser/dist/stream.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name17 in all)\n    __defProp(target, name17, { get: all[name17], enumerable: true });\n};\n\n// src/index.ts\n\n\n\n// src/generate-text/generate-text.ts\n\n\n// src/error/no-output-specified-error.ts\n\nvar name = \"AI_NoOutputSpecifiedError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar NoOutputSpecifiedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  // used in isInstance\n  constructor({ message = \"No output specified.\" } = {}) {\n    super({ name, message });\n    this[_a] = true;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker);\n  }\n};\n_a = symbol;\n\n// src/logger/log-warnings.ts\nfunction formatWarning(warning) {\n  const prefix = \"AI SDK Warning:\";\n  switch (warning.type) {\n    case \"unsupported-setting\": {\n      let message = `${prefix} The \"${warning.setting}\" setting is not supported by this model`;\n      if (warning.details) {\n        message += ` - ${warning.details}`;\n      }\n      return message;\n    }\n    case \"unsupported-tool\": {\n      const toolName = \"name\" in warning.tool ? warning.tool.name : \"unknown tool\";\n      let message = `${prefix} The tool \"${toolName}\" is not supported by this model`;\n      if (warning.details) {\n        message += ` - ${warning.details}`;\n      }\n      return message;\n    }\n    case \"other\": {\n      return `${prefix} ${warning.message}`;\n    }\n    default: {\n      return `${prefix} ${JSON.stringify(warning, null, 2)}`;\n    }\n  }\n}\nvar FIRST_WARNING_INFO_MESSAGE = \"AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.\";\nvar hasLoggedBefore = false;\nvar logWarnings = (warnings) => {\n  if (warnings.length === 0) {\n    return;\n  }\n  const logger = globalThis.AI_SDK_LOG_WARNINGS;\n  if (logger === false) {\n    return;\n  }\n  if (typeof logger === \"function\") {\n    logger(warnings);\n    return;\n  }\n  if (!hasLoggedBefore) {\n    hasLoggedBefore = true;\n    console.info(FIRST_WARNING_INFO_MESSAGE);\n  }\n  for (const warning of warnings) {\n    console.warn(formatWarning(warning));\n  }\n};\n\n// src/model/resolve-model.ts\n\n\n// src/error/index.ts\n\n\n// src/error/invalid-argument-error.ts\n\nvar name2 = \"AI_InvalidArgumentError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    parameter,\n    value,\n    message\n  }) {\n    super({\n      name: name2,\n      message: `Invalid argument for parameter ${parameter}: ${message}`\n    });\n    this[_a2] = true;\n    this.parameter = parameter;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker2);\n  }\n};\n_a2 = symbol2;\n\n// src/error/invalid-stream-part-error.ts\n\nvar name3 = \"AI_InvalidStreamPartError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidStreamPartError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    chunk,\n    message\n  }) {\n    super({ name: name3, message });\n    this[_a3] = true;\n    this.chunk = chunk;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker3);\n  }\n};\n_a3 = symbol3;\n\n// src/error/invalid-tool-input-error.ts\n\nvar name4 = \"AI_InvalidToolInputError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidToolInputError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolInput,\n    toolName,\n    cause,\n    message = `Invalid input for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(cause)}`\n  }) {\n    super({ name: name4, message, cause });\n    this[_a4] = true;\n    this.toolInput = toolInput;\n    this.toolName = toolName;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\n\n// src/error/mcp-client-error.ts\n\nvar name5 = \"AI_MCPClientError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar MCPClientError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    name: name17 = \"MCPClientError\",\n    message,\n    cause\n  }) {\n    super({ name: name17, message, cause });\n    this[_a5] = true;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker5);\n  }\n};\n_a5 = symbol5;\n\n// src/error/no-image-generated-error.ts\n\nvar name6 = \"AI_NoImageGeneratedError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar NoImageGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message = \"No image generated.\",\n    cause,\n    responses\n  }) {\n    super({ name: name6, message, cause });\n    this[_a6] = true;\n    this.responses = responses;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker6);\n  }\n};\n_a6 = symbol6;\n\n// src/error/no-object-generated-error.ts\n\nvar name7 = \"AI_NoObjectGeneratedError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar NoObjectGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message = \"No object generated.\",\n    cause,\n    text: text2,\n    response,\n    usage,\n    finishReason\n  }) {\n    super({ name: name7, message, cause });\n    this[_a7] = true;\n    this.text = text2;\n    this.response = response;\n    this.usage = usage;\n    this.finishReason = finishReason;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\n\n// src/error/no-output-generated-error.ts\n\nvar name8 = \"AI_NoOutputGeneratedError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar NoOutputGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  // used in isInstance\n  constructor({\n    message = \"No output generated.\",\n    cause\n  } = {}) {\n    super({ name: name8, message, cause });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker8);\n  }\n};\n_a8 = symbol8;\n\n// src/error/no-such-tool-error.ts\n\nvar name9 = \"AI_NoSuchToolError\";\nvar marker9 = `vercel.ai.error.${name9}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolName,\n    availableTools = void 0,\n    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}`\n  }) {\n    super({ name: name9, message });\n    this[_a9] = true;\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker9);\n  }\n};\n_a9 = symbol9;\n\n// src/error/tool-call-repair-error.ts\n\nvar name10 = \"AI_ToolCallRepairError\";\nvar marker10 = `vercel.ai.error.${name10}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar ToolCallRepairError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    cause,\n    originalError,\n    message = `Error repairing tool call: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(cause)}`\n  }) {\n    super({ name: name10, message, cause });\n    this[_a10] = true;\n    this.originalError = originalError;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker10);\n  }\n};\n_a10 = symbol10;\n\n// src/error/unsupported-model-version-error.ts\n\nvar UnsupportedModelVersionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor(options) {\n    super({\n      name: \"AI_UnsupportedModelVersionError\",\n      message: `Unsupported model version ${options.version} for provider \"${options.provider}\" and model \"${options.modelId}\". AI SDK 5 only supports models that implement specification version \"v2\".`\n    });\n    this.version = options.version;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n  }\n};\n\n// src/prompt/invalid-data-content-error.ts\n\nvar name11 = \"AI_InvalidDataContentError\";\nvar marker11 = `vercel.ai.error.${name11}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`\n  }) {\n    super({ name: name11, message, cause });\n    this[_a11] = true;\n    this.content = content;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker11);\n  }\n};\n_a11 = symbol11;\n\n// src/prompt/invalid-message-role-error.ts\n\nvar name12 = \"AI_InvalidMessageRoleError\";\nvar marker12 = `vercel.ai.error.${name12}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`\n  }) {\n    super({ name: name12, message });\n    this[_a12] = true;\n    this.role = role;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker12);\n  }\n};\n_a12 = symbol12;\n\n// src/prompt/message-conversion-error.ts\n\nvar name13 = \"AI_MessageConversionError\";\nvar marker13 = `vercel.ai.error.${name13}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar MessageConversionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    originalMessage,\n    message\n  }) {\n    super({ name: name13, message });\n    this[_a13] = true;\n    this.originalMessage = originalMessage;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker13);\n  }\n};\n_a13 = symbol13;\n\n// src/util/download/download-error.ts\n\nvar name14 = \"AI_DownloadError\";\nvar marker14 = `vercel.ai.error.${name14}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}`\n  }) {\n    super({ name: name14, message, cause });\n    this[_a14] = true;\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker14);\n  }\n};\n_a14 = symbol14;\n\n// src/util/retry-error.ts\n\nvar name15 = \"AI_RetryError\";\nvar marker15 = `vercel.ai.error.${name15}`;\nvar symbol15 = Symbol.for(marker15);\nvar _a15;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message,\n    reason,\n    errors\n  }) {\n    super({ name: name15, message });\n    this[_a15] = true;\n    this.reason = reason;\n    this.errors = errors;\n    this.lastError = errors[errors.length - 1];\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker15);\n  }\n};\n_a15 = symbol15;\n\n// src/model/resolve-model.ts\nfunction resolveLanguageModel(model) {\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v2\") {\n      throw new UnsupportedModelVersionError({\n        version: model.specificationVersion,\n        provider: model.provider,\n        modelId: model.modelId\n      });\n    }\n    return model;\n  }\n  return getGlobalProvider().languageModel(model);\n}\nfunction resolveEmbeddingModel(model) {\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v2\") {\n      throw new UnsupportedModelVersionError({\n        version: model.specificationVersion,\n        provider: model.provider,\n        modelId: model.modelId\n      });\n    }\n    return model;\n  }\n  return getGlobalProvider().textEmbeddingModel(\n    model\n  );\n}\nfunction getGlobalProvider() {\n  var _a17;\n  return (_a17 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a17 : _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.gateway;\n}\n\n// src/prompt/convert-to-language-model-prompt.ts\n\n\n// src/util/detect-media-type.ts\n\nvar imageMediaTypeSignatures = [\n  {\n    mediaType: \"image/gif\",\n    bytesPrefix: [71, 73, 70],\n    base64Prefix: \"R0lG\"\n  },\n  {\n    mediaType: \"image/png\",\n    bytesPrefix: [137, 80, 78, 71],\n    base64Prefix: \"iVBORw\"\n  },\n  {\n    mediaType: \"image/jpeg\",\n    bytesPrefix: [255, 216],\n    base64Prefix: \"/9j/\"\n  },\n  {\n    mediaType: \"image/webp\",\n    bytesPrefix: [82, 73, 70, 70],\n    base64Prefix: \"UklGRg\"\n  },\n  {\n    mediaType: \"image/bmp\",\n    bytesPrefix: [66, 77],\n    base64Prefix: \"Qk\"\n  },\n  {\n    mediaType: \"image/tiff\",\n    bytesPrefix: [73, 73, 42, 0],\n    base64Prefix: \"SUkqAA\"\n  },\n  {\n    mediaType: \"image/tiff\",\n    bytesPrefix: [77, 77, 0, 42],\n    base64Prefix: \"TU0AKg\"\n  },\n  {\n    mediaType: \"image/avif\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      32,\n      102,\n      116,\n      121,\n      112,\n      97,\n      118,\n      105,\n      102\n    ],\n    base64Prefix: \"AAAAIGZ0eXBhdmlm\"\n  },\n  {\n    mediaType: \"image/heic\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      32,\n      102,\n      116,\n      121,\n      112,\n      104,\n      101,\n      105,\n      99\n    ],\n    base64Prefix: \"AAAAIGZ0eXBoZWlj\"\n  }\n];\nvar audioMediaTypeSignatures = [\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 251],\n    base64Prefix: \"//s=\"\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 250],\n    base64Prefix: \"//o=\"\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 243],\n    base64Prefix: \"//M=\"\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 242],\n    base64Prefix: \"//I=\"\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 227],\n    base64Prefix: \"/+M=\"\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 226],\n    base64Prefix: \"/+I=\"\n  },\n  {\n    mediaType: \"audio/wav\",\n    bytesPrefix: [82, 73, 70, 70],\n    base64Prefix: \"UklGR\"\n  },\n  {\n    mediaType: \"audio/ogg\",\n    bytesPrefix: [79, 103, 103, 83],\n    base64Prefix: \"T2dnUw\"\n  },\n  {\n    mediaType: \"audio/flac\",\n    bytesPrefix: [102, 76, 97, 67],\n    base64Prefix: \"ZkxhQw\"\n  },\n  {\n    mediaType: \"audio/aac\",\n    bytesPrefix: [64, 21, 0, 0],\n    base64Prefix: \"QBUA\"\n  },\n  {\n    mediaType: \"audio/mp4\",\n    bytesPrefix: [102, 116, 121, 112],\n    base64Prefix: \"ZnR5cA\"\n  },\n  {\n    mediaType: \"audio/webm\",\n    bytesPrefix: [26, 69, 223, 163],\n    base64Prefix: \"GkXf\"\n  }\n];\nvar stripID3 = (data) => {\n  const bytes = typeof data === \"string\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(data) : data;\n  const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;\n  return bytes.slice(id3Size + 10);\n};\nfunction stripID3TagsIfPresent(data) {\n  const hasId3 = typeof data === \"string\" && data.startsWith(\"SUQz\") || typeof data !== \"string\" && data.length > 10 && data[0] === 73 && // 'I'\n  data[1] === 68 && // 'D'\n  data[2] === 51;\n  return hasId3 ? stripID3(data) : data;\n}\nfunction detectMediaType({\n  data,\n  signatures\n}) {\n  const processedData = stripID3TagsIfPresent(data);\n  for (const signature of signatures) {\n    if (typeof processedData === \"string\" ? processedData.startsWith(signature.base64Prefix) : processedData.length >= signature.bytesPrefix.length && signature.bytesPrefix.every(\n      (byte, index) => processedData[index] === byte\n    )) {\n      return signature.mediaType;\n    }\n  }\n  return void 0;\n}\n\n// src/util/download/download.ts\nvar download = async ({ url }) => {\n  var _a17;\n  const urlText = url.toString();\n  try {\n    const response = await fetch(urlText);\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText\n      });\n    }\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mediaType: (_a17 = response.headers.get(\"content-type\")) != null ? _a17 : void 0\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n};\n\n// src/util/download/download-function.ts\nvar createDefaultDownloadFunction = (download2 = download) => (requestedDownloads) => Promise.all(\n  requestedDownloads.map(\n    async (requestedDownload) => requestedDownload.isUrlSupportedByModel ? null : download2(requestedDownload)\n  )\n);\n\n// src/prompt/data-content.ts\n\n\n\n\n// src/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n  try {\n    const [header, base64Content] = dataUrl.split(\",\");\n    return {\n      mediaType: header.split(\";\")[0].split(\":\")[1],\n      base64Content\n    };\n  } catch (error) {\n    return {\n      mediaType: void 0,\n      base64Content: void 0\n    };\n  }\n}\n\n// src/prompt/data-content.ts\nvar dataContentSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](Uint8Array),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](ArrayBuffer),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value) => {\n      var _a17, _b;\n      return (_b = (_a17 = globalThis.Buffer) == null ? void 0 : _a17.isBuffer(value)) != null ? _b : false;\n    },\n    { message: \"Must be a Buffer\" }\n  )\n]);\nfunction convertToLanguageModelV2DataContent(content) {\n  if (content instanceof Uint8Array) {\n    return { data: content, mediaType: void 0 };\n  }\n  if (content instanceof ArrayBuffer) {\n    return { data: new Uint8Array(content), mediaType: void 0 };\n  }\n  if (typeof content === \"string\") {\n    try {\n      content = new URL(content);\n    } catch (error) {\n    }\n  }\n  if (content instanceof URL && content.protocol === \"data:\") {\n    const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(\n      content.toString()\n    );\n    if (dataUrlMediaType == null || base64Content == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError({\n        name: \"InvalidDataContentError\",\n        message: `Invalid data URL format in content ${content.toString()}`\n      });\n    }\n    return { data: base64Content, mediaType: dataUrlMediaType };\n  }\n  return { data: content, mediaType: void 0 };\n}\nfunction convertDataContentToBase64String(content) {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  if (content instanceof ArrayBuffer) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(new Uint8Array(content));\n  }\n  return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n  if (typeof content === \"string\") {\n    try {\n      return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message: \"Invalid data content. Content string is not a base64-encoded media.\",\n        content,\n        cause: error\n      });\n    }\n  }\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n  throw new InvalidDataContentError({ content });\n}\n\n// src/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({\n  prompt,\n  supportedUrls,\n  download: download2 = createDefaultDownloadFunction()\n}) {\n  const downloadedAssets = await downloadAssets(\n    prompt.messages,\n    download2,\n    supportedUrls\n  );\n  return [\n    ...prompt.system != null ? [{ role: \"system\", content: prompt.system }] : [],\n    ...prompt.messages.map(\n      (message) => convertToLanguageModelMessage({ message, downloadedAssets })\n    )\n  ];\n}\nfunction convertToLanguageModelMessage({\n  message,\n  downloadedAssets\n}) {\n  const role = message.role;\n  switch (role) {\n    case \"system\": {\n      return {\n        role: \"system\",\n        content: message.content,\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"user\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"user\",\n          content: [{ type: \"text\", text: message.content }],\n          providerOptions: message.providerOptions\n        };\n      }\n      return {\n        role: \"user\",\n        content: message.content.map((part) => convertPartToLanguageModelPart(part, downloadedAssets)).filter((part) => part.type !== \"text\" || part.text !== \"\"),\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"assistant\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"assistant\",\n          content: [{ type: \"text\", text: message.content }],\n          providerOptions: message.providerOptions\n        };\n      }\n      return {\n        role: \"assistant\",\n        content: message.content.filter(\n          // remove empty text parts:\n          (part) => part.type !== \"text\" || part.text !== \"\"\n        ).map((part) => {\n          const providerOptions = part.providerOptions;\n          switch (part.type) {\n            case \"file\": {\n              const { data, mediaType } = convertToLanguageModelV2DataContent(\n                part.data\n              );\n              return {\n                type: \"file\",\n                data,\n                filename: part.filename,\n                mediaType: mediaType != null ? mediaType : part.mediaType,\n                providerOptions\n              };\n            }\n            case \"reasoning\": {\n              return {\n                type: \"reasoning\",\n                text: part.text,\n                providerOptions\n              };\n            }\n            case \"text\": {\n              return {\n                type: \"text\",\n                text: part.text,\n                providerOptions\n              };\n            }\n            case \"tool-call\": {\n              return {\n                type: \"tool-call\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                input: part.input,\n                providerExecuted: part.providerExecuted,\n                providerOptions\n              };\n            }\n            case \"tool-result\": {\n              return {\n                type: \"tool-result\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                output: part.output,\n                providerOptions\n              };\n            }\n          }\n        }),\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"tool\": {\n      return {\n        role: \"tool\",\n        content: message.content.map((part) => ({\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          output: part.output,\n          providerOptions: part.providerOptions\n        })),\n        providerOptions: message.providerOptions\n      };\n    }\n    default: {\n      const _exhaustiveCheck = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\nasync function downloadAssets(messages, download2, supportedUrls) {\n  const plannedDownloads = messages.filter((message) => message.role === \"user\").map((message) => message.content).filter(\n    (content) => Array.isArray(content)\n  ).flat().filter(\n    (part) => part.type === \"image\" || part.type === \"file\"\n  ).map((part) => {\n    var _a17;\n    const mediaType = (_a17 = part.mediaType) != null ? _a17 : part.type === \"image\" ? \"image/*\" : void 0;\n    let data = part.type === \"image\" ? part.image : part.data;\n    if (typeof data === \"string\") {\n      try {\n        data = new URL(data);\n      } catch (ignored) {\n      }\n    }\n    return { mediaType, data };\n  }).filter(\n    (part) => part.data instanceof URL\n  ).map((part) => ({\n    url: part.data,\n    isUrlSupportedByModel: part.mediaType != null && (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isUrlSupported)({\n      url: part.data.toString(),\n      mediaType: part.mediaType,\n      supportedUrls\n    })\n  }));\n  const downloadedFiles = await download2(plannedDownloads);\n  return Object.fromEntries(\n    downloadedFiles.filter(\n      (downloadedFile) => (downloadedFile == null ? void 0 : downloadedFile.data) != null\n    ).map(({ data, mediaType }, index) => [\n      plannedDownloads[index].url.toString(),\n      { data, mediaType }\n    ])\n  );\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n  var _a17;\n  if (part.type === \"text\") {\n    return {\n      type: \"text\",\n      text: part.text,\n      providerOptions: part.providerOptions\n    };\n  }\n  let originalData;\n  const type = part.type;\n  switch (type) {\n    case \"image\":\n      originalData = part.image;\n      break;\n    case \"file\":\n      originalData = part.data;\n      break;\n    default:\n      throw new Error(`Unsupported part type: ${type}`);\n  }\n  const { data: convertedData, mediaType: convertedMediaType } = convertToLanguageModelV2DataContent(originalData);\n  let mediaType = convertedMediaType != null ? convertedMediaType : part.mediaType;\n  let data = convertedData;\n  if (data instanceof URL) {\n    const downloadedFile = downloadedAssets[data.toString()];\n    if (downloadedFile) {\n      data = downloadedFile.data;\n      mediaType != null ? mediaType : mediaType = downloadedFile.mediaType;\n    }\n  }\n  switch (type) {\n    case \"image\": {\n      if (data instanceof Uint8Array || typeof data === \"string\") {\n        mediaType = (_a17 = detectMediaType({ data, signatures: imageMediaTypeSignatures })) != null ? _a17 : mediaType;\n      }\n      return {\n        type: \"file\",\n        mediaType: mediaType != null ? mediaType : \"image/*\",\n        // any image\n        filename: void 0,\n        data,\n        providerOptions: part.providerOptions\n      };\n    }\n    case \"file\": {\n      if (mediaType == null) {\n        throw new Error(`Media type is missing for file part`);\n      }\n      return {\n        type: \"file\",\n        mediaType,\n        filename: part.filename,\n        data,\n        providerOptions: part.providerOptions\n      };\n    }\n  }\n}\n\n// src/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({\n  maxOutputTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  seed,\n  stopSequences\n}) {\n  if (maxOutputTokens != null) {\n    if (!Number.isInteger(maxOutputTokens)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxOutputTokens\",\n        value: maxOutputTokens,\n        message: \"maxOutputTokens must be an integer\"\n      });\n    }\n    if (maxOutputTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: \"maxOutputTokens\",\n        value: maxOutputTokens,\n        message: \"maxOutputTokens must be >= 1\"\n      });\n    }\n  }\n  if (temperature != null) {\n    if (typeof temperature !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"temperature\",\n        value: temperature,\n        message: \"temperature must be a number\"\n      });\n    }\n  }\n  if (topP != null) {\n    if (typeof topP !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topP\",\n        value: topP,\n        message: \"topP must be a number\"\n      });\n    }\n  }\n  if (topK != null) {\n    if (typeof topK !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topK\",\n        value: topK,\n        message: \"topK must be a number\"\n      });\n    }\n  }\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"presencePenalty\",\n        value: presencePenalty,\n        message: \"presencePenalty must be a number\"\n      });\n    }\n  }\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"frequencyPenalty\",\n        value: frequencyPenalty,\n        message: \"frequencyPenalty must be a number\"\n      });\n    }\n  }\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: \"seed\",\n        value: seed,\n        message: \"seed must be an integer\"\n      });\n    }\n  }\n  return {\n    maxOutputTokens,\n    temperature,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences,\n    seed\n  };\n}\n\n// src/prompt/prepare-tools-and-tool-choice.ts\n\n\n// src/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object2) {\n  return object2 != null && Object.keys(object2).length > 0;\n}\n\n// src/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({\n  tools,\n  toolChoice,\n  activeTools\n}) {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: void 0,\n      toolChoice: void 0\n    };\n  }\n  const filteredTools = activeTools != null ? Object.entries(tools).filter(\n    ([name17]) => activeTools.includes(name17)\n  ) : Object.entries(tools);\n  return {\n    tools: filteredTools.map(([name17, tool3]) => {\n      const toolType = tool3.type;\n      switch (toolType) {\n        case void 0:\n        case \"dynamic\":\n        case \"function\":\n          return {\n            type: \"function\",\n            name: name17,\n            description: tool3.description,\n            inputSchema: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(tool3.inputSchema).jsonSchema,\n            providerOptions: tool3.providerOptions\n          };\n        case \"provider-defined\":\n          return {\n            type: \"provider-defined\",\n            name: name17,\n            id: tool3.id,\n            args: tool3.args\n          };\n        default: {\n          const exhaustiveCheck = toolType;\n          throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n        }\n      }\n    }),\n    toolChoice: toolChoice == null ? { type: \"auto\" } : typeof toolChoice === \"string\" ? { type: toolChoice } : { type: \"tool\", toolName: toolChoice.toolName }\n  };\n}\n\n// src/prompt/standardize-prompt.ts\n\n\n\n\n// src/prompt/message.ts\n\n\n// src/types/provider-metadata.ts\n\n\n// src/types/json-value.ts\n\nvar jsonValueSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.lazy(\n  () => zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"null\"](),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.number(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), jsonValueSchema),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(jsonValueSchema)\n  ])\n);\n\n// src/types/provider-metadata.ts\nvar providerMetadataSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.record(\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), jsonValueSchema)\n);\n\n// src/prompt/content-part.ts\n\nvar textPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"image\"),\n  image: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([dataContentSchema, zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](URL)]),\n  mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar filePartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file\"),\n  data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([dataContentSchema, zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](URL)]),\n  filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n  mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar reasoningPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning\"),\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-call\"),\n  toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n  providerOptions: providerMetadataSchema.optional(),\n  providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n});\nvar outputSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.discriminatedUnion(\"type\", [\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n    value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"json\"),\n    value: jsonValueSchema\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"error-text\"),\n    value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"error-json\"),\n    value: jsonValueSchema\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"content\"),\n    value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n          type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n          text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n          type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"media\"),\n          data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n          mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n        })\n      ])\n    )\n  })\n]);\nvar toolResultPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-result\"),\n  toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  output: outputSchema,\n  providerOptions: providerMetadataSchema.optional()\n});\n\n// src/prompt/message.ts\nvar systemModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object(\n  {\n    role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"system\"),\n    content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerOptions: providerMetadataSchema.optional()\n  }\n);\nvar coreSystemMessageSchema = systemModelMessageSchema;\nvar userModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"user\"),\n  content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([textPartSchema, imagePartSchema, filePartSchema]))\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar coreUserMessageSchema = userModelMessageSchema;\nvar assistantModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"assistant\"),\n  content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n        textPartSchema,\n        filePartSchema,\n        reasoningPartSchema,\n        toolCallPartSchema,\n        toolResultPartSchema\n      ])\n    )\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar coreAssistantMessageSchema = assistantModelMessageSchema;\nvar toolModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool\"),\n  content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(toolResultPartSchema),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar coreToolMessageSchema = toolModelMessageSchema;\nvar modelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n  systemModelMessageSchema,\n  userModelMessageSchema,\n  assistantModelMessageSchema,\n  toolModelMessageSchema\n]);\nvar coreMessageSchema = modelMessageSchema;\n\n// src/prompt/standardize-prompt.ts\nasync function standardizePrompt(prompt) {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt and messages cannot be defined at the same time\"\n    });\n  }\n  if (prompt.system != null && typeof prompt.system !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"system must be a string\"\n    });\n  }\n  let messages;\n  if (prompt.prompt != null && typeof prompt.prompt === \"string\") {\n    messages = [{ role: \"user\", content: prompt.prompt }];\n  } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {\n    messages = prompt.prompt;\n  } else if (prompt.messages != null) {\n    messages = prompt.messages;\n  } else {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (messages.length === 0) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"messages must not be empty\"\n    });\n  }\n  const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n    value: messages,\n    schema: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(modelMessageSchema)\n  });\n  if (!validationResult.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"The messages must be a ModelMessage[]. If you have passed a UIMessage[], you can use convertToModelMessages to convert them.\",\n      cause: validationResult.error\n    });\n  }\n  return {\n    messages,\n    system: prompt.system\n  };\n}\n\n// src/prompt/wrap-gateway-error.ts\n\n\nfunction wrapGatewayError(error) {\n  if (_ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.GatewayAuthenticationError.isInstance(error) || _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.GatewayModelNotFoundError.isInstance(error)) {\n    return new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError({\n      name: \"GatewayError\",\n      message: \"Vercel AI Gateway access failed. If you want to use AI SDK providers directly, use the providers, e.g. @ai-sdk/openai, or register a different global default provider.\",\n      cause: error\n    });\n  }\n  return error;\n}\n\n// src/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({\n  operationId,\n  telemetry\n}) {\n  return {\n    // standardized operation and resource name:\n    \"operation.name\": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`,\n    \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n    // detailed, AI SDK specific data:\n    \"ai.operationId\": operationId,\n    \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId\n  };\n}\n\n// src/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers\n}) {\n  var _a17;\n  return {\n    \"ai.model.provider\": model.provider,\n    \"ai.model.id\": model.modelId,\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      attributes[`ai.settings.${key}`] = value;\n      return attributes;\n    }, {}),\n    // add metadata as attributes:\n    ...Object.entries((_a17 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a17 : {}).reduce(\n      (attributes, [key, value]) => {\n        attributes[`ai.telemetry.metadata.${key}`] = value;\n        return attributes;\n      },\n      {}\n    ),\n    // request headers\n    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {\n      if (value !== void 0) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {})\n  };\n}\n\n// src/telemetry/get-tracer.ts\n\n\n// src/telemetry/noop-tracer.ts\nvar noopTracer = {\n  startSpan() {\n    return noopSpan;\n  },\n  startActiveSpan(name17, arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === \"function\") {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === \"function\") {\n      return arg3(noopSpan);\n    }\n  }\n};\nvar noopSpan = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  }\n};\nvar noopSpanContext = {\n  traceId: \"\",\n  spanId: \"\",\n  traceFlags: 0\n};\n\n// src/telemetry/get-tracer.ts\nfunction getTracer({\n  isEnabled = false,\n  tracer\n} = {}) {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n  if (tracer) {\n    return tracer;\n  }\n  return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.trace.getTracer(\"ai\");\n}\n\n// src/telemetry/record-span.ts\n\nfunction recordSpan({\n  name: name17,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true\n}) {\n  return tracer.startActiveSpan(name17, { attributes }, async (span) => {\n    try {\n      const result = await fn(span);\n      if (endWhenDone) {\n        span.end();\n      }\n      return result;\n    } catch (error) {\n      try {\n        recordErrorOnSpan(span, error);\n      } finally {\n        span.end();\n      }\n      throw error;\n    }\n  });\n}\nfunction recordErrorOnSpan(span, error) {\n  if (error instanceof Error) {\n    span.recordException({\n      name: error.name,\n      message: error.message,\n      stack: error.stack\n    });\n    span.setStatus({\n      code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_5__.SpanStatusCode.ERROR,\n      message: error.message\n    });\n  } else {\n    span.setStatus({ code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_5__.SpanStatusCode.ERROR });\n  }\n}\n\n// src/telemetry/select-telemetry-attributes.ts\nfunction selectTelemetryAttributes({\n  telemetry,\n  attributes\n}) {\n  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {\n    return {};\n  }\n  return Object.entries(attributes).reduce((attributes2, [key, value]) => {\n    if (value == null) {\n      return attributes2;\n    }\n    if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n        return attributes2;\n      }\n      const result = value.input();\n      return result == null ? attributes2 : { ...attributes2, [key]: result };\n    }\n    if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n        return attributes2;\n      }\n      const result = value.output();\n      return result == null ? attributes2 : { ...attributes2, [key]: result };\n    }\n    return { ...attributes2, [key]: value };\n  }, {});\n}\n\n// src/telemetry/stringify-for-telemetry.ts\nfunction stringifyForTelemetry(prompt) {\n  return JSON.stringify(\n    prompt.map((message) => ({\n      ...message,\n      content: typeof message.content === \"string\" ? message.content : message.content.map(\n        (part) => part.type === \"file\" ? {\n          ...part,\n          data: part.data instanceof Uint8Array ? convertDataContentToBase64String(part.data) : part.data\n        } : part\n      )\n    }))\n  );\n}\n\n// src/types/usage.ts\nfunction addLanguageModelUsage(usage1, usage2) {\n  return {\n    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),\n    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),\n    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),\n    reasoningTokens: addTokenCounts(\n      usage1.reasoningTokens,\n      usage2.reasoningTokens\n    ),\n    cachedInputTokens: addTokenCounts(\n      usage1.cachedInputTokens,\n      usage2.cachedInputTokens\n    )\n  };\n}\nfunction addTokenCounts(tokenCount1, tokenCount2) {\n  return tokenCount1 == null && tokenCount2 == null ? void 0 : (tokenCount1 != null ? tokenCount1 : 0) + (tokenCount2 != null ? tokenCount2 : 0);\n}\n\n// src/util/as-array.ts\nfunction asArray(value) {\n  return value === void 0 ? [] : Array.isArray(value) ? value : [value];\n}\n\n// src/util/retry-with-exponential-backoff.ts\n\n\nfunction getRetryDelayInMs({\n  error,\n  exponentialBackoffDelay\n}) {\n  const headers = error.responseHeaders;\n  if (!headers)\n    return exponentialBackoffDelay;\n  let ms;\n  const retryAfterMs = headers[\"retry-after-ms\"];\n  if (retryAfterMs) {\n    const timeoutMs = parseFloat(retryAfterMs);\n    if (!Number.isNaN(timeoutMs)) {\n      ms = timeoutMs;\n    }\n  }\n  const retryAfter = headers[\"retry-after\"];\n  if (retryAfter && ms === void 0) {\n    const timeoutSeconds = parseFloat(retryAfter);\n    if (!Number.isNaN(timeoutSeconds)) {\n      ms = timeoutSeconds * 1e3;\n    } else {\n      ms = Date.parse(retryAfter) - Date.now();\n    }\n  }\n  if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {\n    return ms;\n  }\n  return exponentialBackoffDelay;\n}\nvar retryWithExponentialBackoffRespectingRetryHeaders = ({\n  maxRetries = 2,\n  initialDelayInMs = 2e3,\n  backoffFactor = 2,\n  abortSignal\n} = {}) => async (f) => _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs: initialDelayInMs,\n  backoffFactor,\n  abortSignal\n});\nasync function _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs,\n  backoffFactor,\n  abortSignal\n}, errors = []) {\n  try {\n    return await f();\n  } catch (error) {\n    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isAbortError)(error)) {\n      throw error;\n    }\n    if (maxRetries === 0) {\n      throw error;\n    }\n    const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: \"maxRetriesExceeded\",\n        errors: newErrors\n      });\n    }\n    if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n      await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay)(\n        getRetryDelayInMs({\n          error,\n          exponentialBackoffDelay: delayInMs\n        }),\n        { abortSignal }\n      );\n      return _retryWithExponentialBackoff(\n        f,\n        {\n          maxRetries,\n          delayInMs: backoffFactor * delayInMs,\n          backoffFactor,\n          abortSignal\n        },\n        newErrors\n      );\n    }\n    if (tryNumber === 1) {\n      throw error;\n    }\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: \"errorNotRetryable\",\n      errors: newErrors\n    });\n  }\n}\n\n// src/util/prepare-retries.ts\nfunction prepareRetries({\n  maxRetries,\n  abortSignal\n}) {\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be an integer\"\n      });\n    }\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be >= 0\"\n      });\n    }\n  }\n  const maxRetriesResult = maxRetries != null ? maxRetries : 2;\n  return {\n    maxRetries: maxRetriesResult,\n    retry: retryWithExponentialBackoffRespectingRetryHeaders({\n      maxRetries: maxRetriesResult,\n      abortSignal\n    })\n  };\n}\n\n// src/generate-text/extract-text-content.ts\nfunction extractTextContent(content) {\n  const parts = content.filter(\n    (content2) => content2.type === \"text\"\n  );\n  if (parts.length === 0) {\n    return void 0;\n  }\n  return parts.map((content2) => content2.text).join(\"\");\n}\n\n// src/generate-text/generated-file.ts\n\nvar DefaultGeneratedFile = class {\n  constructor({\n    data,\n    mediaType\n  }) {\n    const isUint8Array = data instanceof Uint8Array;\n    this.base64Data = isUint8Array ? void 0 : data;\n    this.uint8ArrayData = isUint8Array ? data : void 0;\n    this.mediaType = mediaType;\n  }\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get base64() {\n    if (this.base64Data == null) {\n      this.base64Data = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(this.uint8ArrayData);\n    }\n    return this.base64Data;\n  }\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get uint8Array() {\n    if (this.uint8ArrayData == null) {\n      this.uint8ArrayData = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(this.base64Data);\n    }\n    return this.uint8ArrayData;\n  }\n};\nvar DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {\n  constructor(options) {\n    super(options);\n    this.type = \"file\";\n  }\n};\n\n// src/generate-text/parse-tool-call.ts\n\nasync function parseToolCall({\n  toolCall,\n  tools,\n  repairToolCall,\n  system,\n  messages\n}) {\n  try {\n    if (tools == null) {\n      throw new NoSuchToolError({ toolName: toolCall.toolName });\n    }\n    try {\n      return await doParseToolCall({ toolCall, tools });\n    } catch (error) {\n      if (repairToolCall == null || !(NoSuchToolError.isInstance(error) || InvalidToolInputError.isInstance(error))) {\n        throw error;\n      }\n      let repairedToolCall = null;\n      try {\n        repairedToolCall = await repairToolCall({\n          toolCall,\n          tools,\n          inputSchema: ({ toolName }) => {\n            const { inputSchema } = tools[toolName];\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(inputSchema).jsonSchema;\n          },\n          system,\n          messages,\n          error\n        });\n      } catch (repairError) {\n        throw new ToolCallRepairError({\n          cause: repairError,\n          originalError: error\n        });\n      }\n      if (repairedToolCall == null) {\n        throw error;\n      }\n      return await doParseToolCall({ toolCall: repairedToolCall, tools });\n    }\n  } catch (error) {\n    const parsedInput = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: toolCall.input });\n    const input = parsedInput.success ? parsedInput.value : toolCall.input;\n    return {\n      type: \"tool-call\",\n      toolCallId: toolCall.toolCallId,\n      toolName: toolCall.toolName,\n      input,\n      dynamic: true,\n      invalid: true,\n      error\n    };\n  }\n}\nasync function doParseToolCall({\n  toolCall,\n  tools\n}) {\n  const toolName = toolCall.toolName;\n  const tool3 = tools[toolName];\n  if (tool3 == null) {\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools)\n    });\n  }\n  const schema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(tool3.inputSchema);\n  const parseResult = toolCall.input.trim() === \"\" ? await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: {}, schema }) : await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: toolCall.input, schema });\n  if (parseResult.success === false) {\n    throw new InvalidToolInputError({\n      toolName,\n      toolInput: toolCall.input,\n      cause: parseResult.error\n    });\n  }\n  return tool3.type === \"dynamic\" ? {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    input: parseResult.value,\n    providerExecuted: toolCall.providerExecuted,\n    providerMetadata: toolCall.providerMetadata,\n    dynamic: true\n  } : {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    input: parseResult.value,\n    providerExecuted: toolCall.providerExecuted,\n    providerMetadata: toolCall.providerMetadata\n  };\n}\n\n// src/generate-text/step-result.ts\nvar DefaultStepResult = class {\n  constructor({\n    content,\n    finishReason,\n    usage,\n    warnings,\n    request,\n    response,\n    providerMetadata\n  }) {\n    this.content = content;\n    this.finishReason = finishReason;\n    this.usage = usage;\n    this.warnings = warnings;\n    this.request = request;\n    this.response = response;\n    this.providerMetadata = providerMetadata;\n  }\n  get text() {\n    return this.content.filter((part) => part.type === \"text\").map((part) => part.text).join(\"\");\n  }\n  get reasoning() {\n    return this.content.filter((part) => part.type === \"reasoning\");\n  }\n  get reasoningText() {\n    return this.reasoning.length === 0 ? void 0 : this.reasoning.map((part) => part.text).join(\"\");\n  }\n  get files() {\n    return this.content.filter((part) => part.type === \"file\").map((part) => part.file);\n  }\n  get sources() {\n    return this.content.filter((part) => part.type === \"source\");\n  }\n  get toolCalls() {\n    return this.content.filter((part) => part.type === \"tool-call\");\n  }\n  get staticToolCalls() {\n    return this.toolCalls.filter(\n      (toolCall) => toolCall.dynamic === false\n    );\n  }\n  get dynamicToolCalls() {\n    return this.toolCalls.filter(\n      (toolCall) => toolCall.dynamic === true\n    );\n  }\n  get toolResults() {\n    return this.content.filter((part) => part.type === \"tool-result\");\n  }\n  get staticToolResults() {\n    return this.toolResults.filter(\n      (toolResult) => toolResult.dynamic === false\n    );\n  }\n  get dynamicToolResults() {\n    return this.toolResults.filter(\n      (toolResult) => toolResult.dynamic === true\n    );\n  }\n};\n\n// src/generate-text/stop-condition.ts\nfunction stepCountIs(stepCount) {\n  return ({ steps }) => steps.length === stepCount;\n}\nfunction hasToolCall(toolName) {\n  return ({ steps }) => {\n    var _a17, _b, _c;\n    return (_c = (_b = (_a17 = steps[steps.length - 1]) == null ? void 0 : _a17.toolCalls) == null ? void 0 : _b.some(\n      (toolCall) => toolCall.toolName === toolName\n    )) != null ? _c : false;\n  };\n}\nasync function isStopConditionMet({\n  stopConditions,\n  steps\n}) {\n  return (await Promise.all(stopConditions.map((condition) => condition({ steps })))).some((result) => result);\n}\n\n// src/prompt/create-tool-model-output.ts\n\nfunction createToolModelOutput({\n  output,\n  tool: tool3,\n  errorMode\n}) {\n  if (errorMode === \"text\") {\n    return { type: \"error-text\", value: (0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(output) };\n  } else if (errorMode === \"json\") {\n    return { type: \"error-json\", value: toJSONValue(output) };\n  }\n  if (tool3 == null ? void 0 : tool3.toModelOutput) {\n    return tool3.toModelOutput(output);\n  }\n  return typeof output === \"string\" ? { type: \"text\", value: output } : { type: \"json\", value: toJSONValue(output) };\n}\nfunction toJSONValue(value) {\n  return value === void 0 ? null : value;\n}\n\n// src/generate-text/to-response-messages.ts\nfunction toResponseMessages({\n  content: inputContent,\n  tools\n}) {\n  const responseMessages = [];\n  const content = inputContent.filter((part) => part.type !== \"source\").filter(\n    (part) => (part.type !== \"tool-result\" || part.providerExecuted) && (part.type !== \"tool-error\" || part.providerExecuted)\n  ).filter((part) => part.type !== \"text\" || part.text.length > 0).map((part) => {\n    switch (part.type) {\n      case \"text\":\n        return {\n          type: \"text\",\n          text: part.text,\n          providerOptions: part.providerMetadata\n        };\n      case \"reasoning\":\n        return {\n          type: \"reasoning\",\n          text: part.text,\n          providerOptions: part.providerMetadata\n        };\n      case \"file\":\n        return {\n          type: \"file\",\n          data: part.file.base64,\n          mediaType: part.file.mediaType,\n          providerOptions: part.providerMetadata\n        };\n      case \"tool-call\":\n        return {\n          type: \"tool-call\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          input: part.input,\n          providerExecuted: part.providerExecuted,\n          providerOptions: part.providerMetadata\n        };\n      case \"tool-result\":\n        return {\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          output: createToolModelOutput({\n            tool: tools == null ? void 0 : tools[part.toolName],\n            output: part.output,\n            errorMode: \"none\"\n          }),\n          providerExecuted: true,\n          providerOptions: part.providerMetadata\n        };\n      case \"tool-error\":\n        return {\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          output: createToolModelOutput({\n            tool: tools == null ? void 0 : tools[part.toolName],\n            output: part.error,\n            errorMode: \"json\"\n          }),\n          providerOptions: part.providerMetadata\n        };\n    }\n  });\n  if (content.length > 0) {\n    responseMessages.push({\n      role: \"assistant\",\n      content\n    });\n  }\n  const toolResultContent = inputContent.filter((part) => part.type === \"tool-result\" || part.type === \"tool-error\").filter((part) => !part.providerExecuted).map((toolResult) => ({\n    type: \"tool-result\",\n    toolCallId: toolResult.toolCallId,\n    toolName: toolResult.toolName,\n    output: createToolModelOutput({\n      tool: tools == null ? void 0 : tools[toolResult.toolName],\n      output: toolResult.type === \"tool-result\" ? toolResult.output : toolResult.error,\n      errorMode: toolResult.type === \"tool-error\" ? \"text\" : \"none\"\n    })\n  }));\n  if (toolResultContent.length > 0) {\n    responseMessages.push({\n      role: \"tool\",\n      content: toolResultContent\n    });\n  }\n  return responseMessages;\n}\n\n// src/generate-text/generate-text.ts\nvar originalGenerateId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n  prefix: \"aitxt\",\n  size: 24\n});\nasync function generateText({\n  model: modelArg,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  stopWhen = stepCountIs(1),\n  experimental_output: output,\n  experimental_telemetry: telemetry,\n  providerOptions,\n  experimental_activeTools,\n  activeTools = experimental_activeTools,\n  experimental_prepareStep,\n  prepareStep = experimental_prepareStep,\n  experimental_repairToolCall: repairToolCall,\n  experimental_download: download2,\n  experimental_context,\n  _internal: {\n    generateId: generateId3 = originalGenerateId,\n    currentDate = () => /* @__PURE__ */ new Date()\n  } = {},\n  onStepFinish,\n  ...settings\n}) {\n  const model = resolveLanguageModel(modelArg);\n  const stopConditions = asArray(stopWhen);\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const callSettings = prepareCallSettings(settings);\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...callSettings, maxRetries }\n  });\n  const initialPrompt = await standardizePrompt({\n    system,\n    prompt,\n    messages\n  });\n  const tracer = getTracer(telemetry);\n  try {\n    return await recordSpan({\n      name: \"ai.generateText\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.generateText\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // model:\n          \"ai.model.provider\": model.provider,\n          \"ai.model.id\": model.modelId,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          }\n        }\n      }),\n      tracer,\n      fn: async (span) => {\n        var _a17, _b, _c, _d, _e, _f, _g;\n        const callSettings2 = prepareCallSettings(settings);\n        let currentModelResponse;\n        let clientToolCalls = [];\n        let clientToolOutputs = [];\n        const responseMessages = [];\n        const steps = [];\n        do {\n          const stepInputMessages = [\n            ...initialPrompt.messages,\n            ...responseMessages\n          ];\n          const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n            model,\n            steps,\n            stepNumber: steps.length,\n            messages: stepInputMessages\n          }));\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: {\n              system: (_a17 = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _a17 : initialPrompt.system,\n              messages: (_b = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _b : stepInputMessages\n            },\n            supportedUrls: await model.supportedUrls,\n            download: download2\n          });\n          const stepModel = resolveLanguageModel(\n            (_c = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _c : model\n          );\n          const { toolChoice: stepToolChoice, tools: stepTools } = prepareToolsAndToolChoice({\n            tools,\n            toolChoice: (_d = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _d : toolChoice,\n            activeTools: (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools\n          });\n          currentModelResponse = await retry(\n            () => {\n              var _a18;\n              return recordSpan({\n                name: \"ai.generateText.doGenerate\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.generateText.doGenerate\",\n                      telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // model:\n                    \"ai.model.provider\": stepModel.provider,\n                    \"ai.model.id\": stepModel.modelId,\n                    // prompt:\n                    \"ai.prompt.messages\": {\n                      input: () => stringifyForTelemetry(promptMessages)\n                    },\n                    \"ai.prompt.tools\": {\n                      // convert the language model level tools:\n                      input: () => stepTools == null ? void 0 : stepTools.map((tool3) => JSON.stringify(tool3))\n                    },\n                    \"ai.prompt.toolChoice\": {\n                      input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0\n                    },\n                    // standardized gen-ai llm span attributes:\n                    \"gen_ai.system\": stepModel.provider,\n                    \"gen_ai.request.model\": stepModel.modelId,\n                    \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                    \"gen_ai.request.max_tokens\": settings.maxOutputTokens,\n                    \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                    \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                    \"gen_ai.request.temperature\": (_a18 = settings.temperature) != null ? _a18 : void 0,\n                    \"gen_ai.request.top_k\": settings.topK,\n                    \"gen_ai.request.top_p\": settings.topP\n                  }\n                }),\n                tracer,\n                fn: async (span2) => {\n                  var _a19, _b2, _c2, _d2, _e2, _f2, _g2, _h;\n                  const result = await stepModel.doGenerate({\n                    ...callSettings2,\n                    tools: stepTools,\n                    toolChoice: stepToolChoice,\n                    responseFormat: output == null ? void 0 : output.responseFormat,\n                    prompt: promptMessages,\n                    providerOptions,\n                    abortSignal,\n                    headers\n                  });\n                  const responseData = {\n                    id: (_b2 = (_a19 = result.response) == null ? void 0 : _a19.id) != null ? _b2 : generateId3(),\n                    timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),\n                    modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : stepModel.modelId,\n                    headers: (_g2 = result.response) == null ? void 0 : _g2.headers,\n                    body: (_h = result.response) == null ? void 0 : _h.body\n                  };\n                  span2.setAttributes(\n                    selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        \"ai.response.finishReason\": result.finishReason,\n                        \"ai.response.text\": {\n                          output: () => extractTextContent(result.content)\n                        },\n                        \"ai.response.toolCalls\": {\n                          output: () => {\n                            const toolCalls = asToolCalls(result.content);\n                            return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n                          }\n                        },\n                        \"ai.response.id\": responseData.id,\n                        \"ai.response.model\": responseData.modelId,\n                        \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                        \"ai.response.providerMetadata\": JSON.stringify(\n                          result.providerMetadata\n                        ),\n                        // TODO rename telemetry attributes to inputTokens and outputTokens\n                        \"ai.usage.promptTokens\": result.usage.inputTokens,\n                        \"ai.usage.completionTokens\": result.usage.outputTokens,\n                        // standardized gen-ai llm span attributes:\n                        \"gen_ai.response.finish_reasons\": [result.finishReason],\n                        \"gen_ai.response.id\": responseData.id,\n                        \"gen_ai.response.model\": responseData.modelId,\n                        \"gen_ai.usage.input_tokens\": result.usage.inputTokens,\n                        \"gen_ai.usage.output_tokens\": result.usage.outputTokens\n                      }\n                    })\n                  );\n                  return { ...result, response: responseData };\n                }\n              });\n            }\n          );\n          const stepToolCalls = await Promise.all(\n            currentModelResponse.content.filter(\n              (part) => part.type === \"tool-call\"\n            ).map(\n              (toolCall) => parseToolCall({\n                toolCall,\n                tools,\n                repairToolCall,\n                system,\n                messages: stepInputMessages\n              })\n            )\n          );\n          for (const toolCall of stepToolCalls) {\n            if (toolCall.invalid) {\n              continue;\n            }\n            const tool3 = tools[toolCall.toolName];\n            if ((tool3 == null ? void 0 : tool3.onInputAvailable) != null) {\n              await tool3.onInputAvailable({\n                input: toolCall.input,\n                toolCallId: toolCall.toolCallId,\n                messages: stepInputMessages,\n                abortSignal,\n                experimental_context\n              });\n            }\n          }\n          const invalidToolCalls = stepToolCalls.filter(\n            (toolCall) => toolCall.invalid && toolCall.dynamic\n          );\n          clientToolOutputs = [];\n          for (const toolCall of invalidToolCalls) {\n            clientToolOutputs.push({\n              type: \"tool-error\",\n              toolCallId: toolCall.toolCallId,\n              toolName: toolCall.toolName,\n              input: toolCall.input,\n              error: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(toolCall.error),\n              dynamic: true\n            });\n          }\n          clientToolCalls = stepToolCalls.filter(\n            (toolCall) => !toolCall.providerExecuted\n          );\n          if (tools != null) {\n            clientToolOutputs.push(\n              ...await executeTools({\n                toolCalls: clientToolCalls.filter(\n                  (toolCall) => !toolCall.invalid\n                ),\n                tools,\n                tracer,\n                telemetry,\n                messages: stepInputMessages,\n                abortSignal,\n                experimental_context\n              })\n            );\n          }\n          const stepContent = asContent({\n            content: currentModelResponse.content,\n            toolCalls: stepToolCalls,\n            toolOutputs: clientToolOutputs\n          });\n          responseMessages.push(\n            ...toResponseMessages({\n              content: stepContent,\n              tools\n            })\n          );\n          const currentStepResult = new DefaultStepResult({\n            content: stepContent,\n            finishReason: currentModelResponse.finishReason,\n            usage: currentModelResponse.usage,\n            warnings: currentModelResponse.warnings,\n            providerMetadata: currentModelResponse.providerMetadata,\n            request: (_f = currentModelResponse.request) != null ? _f : {},\n            response: {\n              ...currentModelResponse.response,\n              // deep clone msgs to avoid mutating past messages in multi-step:\n              messages: structuredClone(responseMessages)\n            }\n          });\n          logWarnings((_g = currentModelResponse.warnings) != null ? _g : []);\n          steps.push(currentStepResult);\n          await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n        } while (\n          // there are tool calls:\n          clientToolCalls.length > 0 && // all current tool calls have outputs (incl. execution errors):\n          clientToolOutputs.length === clientToolCalls.length && // continue until a stop condition is met:\n          !await isStopConditionMet({ stopConditions, steps })\n        );\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.response.finishReason\": currentModelResponse.finishReason,\n              \"ai.response.text\": {\n                output: () => extractTextContent(currentModelResponse.content)\n              },\n              \"ai.response.toolCalls\": {\n                output: () => {\n                  const toolCalls = asToolCalls(currentModelResponse.content);\n                  return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n                }\n              },\n              \"ai.response.providerMetadata\": JSON.stringify(\n                currentModelResponse.providerMetadata\n              ),\n              // TODO rename telemetry attributes to inputTokens and outputTokens\n              \"ai.usage.promptTokens\": currentModelResponse.usage.inputTokens,\n              \"ai.usage.completionTokens\": currentModelResponse.usage.outputTokens\n            }\n          })\n        );\n        const lastStep = steps[steps.length - 1];\n        return new DefaultGenerateTextResult({\n          steps,\n          resolvedOutput: await (output == null ? void 0 : output.parseOutput(\n            { text: lastStep.text },\n            {\n              response: lastStep.response,\n              usage: lastStep.usage,\n              finishReason: lastStep.finishReason\n            }\n          ))\n        });\n      }\n    });\n  } catch (error) {\n    throw wrapGatewayError(error);\n  }\n}\nasync function executeTools({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry,\n  messages,\n  abortSignal,\n  experimental_context\n}) {\n  const toolOutputs = await Promise.all(\n    toolCalls.map(async ({ toolCallId, toolName, input }) => {\n      const tool3 = tools[toolName];\n      if ((tool3 == null ? void 0 : tool3.execute) == null) {\n        return void 0;\n      }\n      return recordSpan({\n        name: \"ai.toolCall\",\n        attributes: selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            ...assembleOperationName({\n              operationId: \"ai.toolCall\",\n              telemetry\n            }),\n            \"ai.toolCall.name\": toolName,\n            \"ai.toolCall.id\": toolCallId,\n            \"ai.toolCall.args\": {\n              output: () => JSON.stringify(input)\n            }\n          }\n        }),\n        tracer,\n        fn: async (span) => {\n          try {\n            const stream = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.executeTool)({\n              execute: tool3.execute.bind(tool3),\n              input,\n              options: {\n                toolCallId,\n                messages,\n                abortSignal,\n                experimental_context\n              }\n            });\n            let output;\n            for await (const part of stream) {\n              if (part.type === \"final\") {\n                output = part.output;\n              }\n            }\n            try {\n              span.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.toolCall.result\": {\n                      output: () => JSON.stringify(output)\n                    }\n                  }\n                })\n              );\n            } catch (ignored) {\n            }\n            return {\n              type: \"tool-result\",\n              toolCallId,\n              toolName,\n              input,\n              output,\n              dynamic: tool3.type === \"dynamic\"\n            };\n          } catch (error) {\n            recordErrorOnSpan(span, error);\n            return {\n              type: \"tool-error\",\n              toolCallId,\n              toolName,\n              input,\n              error,\n              dynamic: tool3.type === \"dynamic\"\n            };\n          }\n        }\n      });\n    })\n  );\n  return toolOutputs.filter(\n    (output) => output != null\n  );\n}\nvar DefaultGenerateTextResult = class {\n  constructor(options) {\n    this.steps = options.steps;\n    this.resolvedOutput = options.resolvedOutput;\n  }\n  get finalStep() {\n    return this.steps[this.steps.length - 1];\n  }\n  get content() {\n    return this.finalStep.content;\n  }\n  get text() {\n    return this.finalStep.text;\n  }\n  get files() {\n    return this.finalStep.files;\n  }\n  get reasoningText() {\n    return this.finalStep.reasoningText;\n  }\n  get reasoning() {\n    return this.finalStep.reasoning;\n  }\n  get toolCalls() {\n    return this.finalStep.toolCalls;\n  }\n  get staticToolCalls() {\n    return this.finalStep.staticToolCalls;\n  }\n  get dynamicToolCalls() {\n    return this.finalStep.dynamicToolCalls;\n  }\n  get toolResults() {\n    return this.finalStep.toolResults;\n  }\n  get staticToolResults() {\n    return this.finalStep.staticToolResults;\n  }\n  get dynamicToolResults() {\n    return this.finalStep.dynamicToolResults;\n  }\n  get sources() {\n    return this.finalStep.sources;\n  }\n  get finishReason() {\n    return this.finalStep.finishReason;\n  }\n  get warnings() {\n    return this.finalStep.warnings;\n  }\n  get providerMetadata() {\n    return this.finalStep.providerMetadata;\n  }\n  get response() {\n    return this.finalStep.response;\n  }\n  get request() {\n    return this.finalStep.request;\n  }\n  get usage() {\n    return this.finalStep.usage;\n  }\n  get totalUsage() {\n    return this.steps.reduce(\n      (totalUsage, step) => {\n        return addLanguageModelUsage(totalUsage, step.usage);\n      },\n      {\n        inputTokens: void 0,\n        outputTokens: void 0,\n        totalTokens: void 0,\n        reasoningTokens: void 0,\n        cachedInputTokens: void 0\n      }\n    );\n  }\n  get experimental_output() {\n    if (this.resolvedOutput == null) {\n      throw new NoOutputSpecifiedError();\n    }\n    return this.resolvedOutput;\n  }\n};\nfunction asToolCalls(content) {\n  const parts = content.filter(\n    (part) => part.type === \"tool-call\"\n  );\n  if (parts.length === 0) {\n    return void 0;\n  }\n  return parts.map((toolCall) => ({\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    input: toolCall.input\n  }));\n}\nfunction asContent({\n  content,\n  toolCalls,\n  toolOutputs\n}) {\n  return [\n    ...content.map((part) => {\n      switch (part.type) {\n        case \"text\":\n        case \"reasoning\":\n        case \"source\":\n          return part;\n        case \"file\": {\n          return {\n            type: \"file\",\n            file: new DefaultGeneratedFile(part)\n          };\n        }\n        case \"tool-call\": {\n          return toolCalls.find(\n            (toolCall) => toolCall.toolCallId === part.toolCallId\n          );\n        }\n        case \"tool-result\": {\n          const toolCall = toolCalls.find(\n            (toolCall2) => toolCall2.toolCallId === part.toolCallId\n          );\n          if (toolCall == null) {\n            throw new Error(`Tool call ${part.toolCallId} not found.`);\n          }\n          if (part.isError) {\n            return {\n              type: \"tool-error\",\n              toolCallId: part.toolCallId,\n              toolName: part.toolName,\n              input: toolCall.input,\n              error: part.result,\n              providerExecuted: true,\n              dynamic: toolCall.dynamic\n            };\n          }\n          return {\n            type: \"tool-result\",\n            toolCallId: part.toolCallId,\n            toolName: part.toolName,\n            input: toolCall.input,\n            output: part.result,\n            providerExecuted: true,\n            dynamic: toolCall.dynamic\n          };\n        }\n      }\n    }),\n    ...toolOutputs\n  ];\n}\n\n// src/generate-text/stream-text.ts\n\n\n\n// src/util/prepare-headers.ts\nfunction prepareHeaders(headers, defaultHeaders) {\n  const responseHeaders = new Headers(headers != null ? headers : {});\n  for (const [key, value] of Object.entries(defaultHeaders)) {\n    if (!responseHeaders.has(key)) {\n      responseHeaders.set(key, value);\n    }\n  }\n  return responseHeaders;\n}\n\n// src/text-stream/create-text-stream-response.ts\nfunction createTextStreamResponse({\n  status,\n  statusText,\n  headers,\n  textStream\n}) {\n  return new Response(textStream.pipeThrough(new TextEncoderStream()), {\n    status: status != null ? status : 200,\n    statusText,\n    headers: prepareHeaders(headers, {\n      \"content-type\": \"text/plain; charset=utf-8\"\n    })\n  });\n}\n\n// src/util/write-to-server-response.ts\nfunction writeToServerResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream\n}) {\n  response.writeHead(status != null ? status : 200, statusText, headers);\n  const reader = stream.getReader();\n  const read = async () => {\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done)\n          break;\n        response.write(value);\n      }\n    } catch (error) {\n      throw error;\n    } finally {\n      response.end();\n    }\n  };\n  read();\n}\n\n// src/text-stream/pipe-text-stream-to-response.ts\nfunction pipeTextStreamToResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  textStream\n}) {\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: Object.fromEntries(\n      prepareHeaders(headers, {\n        \"content-type\": \"text/plain; charset=utf-8\"\n      }).entries()\n    ),\n    stream: textStream.pipeThrough(new TextEncoderStream())\n  });\n}\n\n// src/ui-message-stream/json-to-sse-transform-stream.ts\nvar JsonToSseTransformStream = class extends TransformStream {\n  constructor() {\n    super({\n      transform(part, controller) {\n        controller.enqueue(`data: ${JSON.stringify(part)}\n\n`);\n      },\n      flush(controller) {\n        controller.enqueue(\"data: [DONE]\\n\\n\");\n      }\n    });\n  }\n};\n\n// src/ui-message-stream/ui-message-stream-headers.ts\nvar UI_MESSAGE_STREAM_HEADERS = {\n  \"content-type\": \"text/event-stream\",\n  \"cache-control\": \"no-cache\",\n  connection: \"keep-alive\",\n  \"x-vercel-ai-ui-message-stream\": \"v1\",\n  \"x-accel-buffering\": \"no\"\n  // disable nginx buffering\n};\n\n// src/ui-message-stream/create-ui-message-stream-response.ts\nfunction createUIMessageStreamResponse({\n  status,\n  statusText,\n  headers,\n  stream,\n  consumeSseStream\n}) {\n  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n  if (consumeSseStream) {\n    const [stream1, stream2] = sseStream.tee();\n    sseStream = stream1;\n    consumeSseStream({ stream: stream2 });\n  }\n  return new Response(sseStream.pipeThrough(new TextEncoderStream()), {\n    status,\n    statusText,\n    headers: prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS)\n  });\n}\n\n// src/ui-message-stream/get-response-ui-message-id.ts\nfunction getResponseUIMessageId({\n  originalMessages,\n  responseMessageId\n}) {\n  if (originalMessages == null) {\n    return void 0;\n  }\n  const lastMessage = originalMessages[originalMessages.length - 1];\n  return (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\" ? lastMessage.id : typeof responseMessageId === \"function\" ? responseMessageId() : responseMessageId;\n}\n\n// src/ui/process-ui-message-stream.ts\n\n\n// src/ui-message-stream/ui-message-chunks.ts\n\nvar uiMessageChunkSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text-start\"),\n    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text-delta\"),\n    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    delta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text-end\"),\n    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"error\"),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-input-start\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n    dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-input-delta\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    inputTextDelta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-input-available\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n    providerMetadata: providerMetadataSchema.optional(),\n    dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-input-error\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n    providerMetadata: providerMetadataSchema.optional(),\n    dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-output-available\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n    dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n    preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-output-error\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n    dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning\"),\n    text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning-start\"),\n    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning-delta\"),\n    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    delta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning-end\"),\n    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning-part-finish\")\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"source-url\"),\n    sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"source-document\"),\n    sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file\"),\n    url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"data-\"),\n    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n    data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    transient: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"start-step\")\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"finish-step\")\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"start\"),\n    messageId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n    messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"finish\"),\n    messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"abort\")\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"message-metadata\"),\n    messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown()\n  })\n]);\nfunction isDataUIMessageChunk(chunk) {\n  return chunk.type.startsWith(\"data-\");\n}\n\n// src/util/merge-objects.ts\nfunction mergeObjects(base, overrides) {\n  if (base === void 0 && overrides === void 0) {\n    return void 0;\n  }\n  if (base === void 0) {\n    return overrides;\n  }\n  if (overrides === void 0) {\n    return base;\n  }\n  const result = { ...base };\n  for (const key in overrides) {\n    if (Object.prototype.hasOwnProperty.call(overrides, key)) {\n      const overridesValue = overrides[key];\n      if (overridesValue === void 0)\n        continue;\n      const baseValue = key in base ? base[key] : void 0;\n      const isSourceObject = overridesValue !== null && typeof overridesValue === \"object\" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);\n      const isTargetObject = baseValue !== null && baseValue !== void 0 && typeof baseValue === \"object\" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);\n      if (isSourceObject && isTargetObject) {\n        result[key] = mergeObjects(\n          baseValue,\n          overridesValue\n        );\n      } else {\n        result[key] = overridesValue;\n      }\n    }\n  }\n  return result;\n}\n\n// src/util/parse-partial-json.ts\n\n\n// src/util/fix-json.ts\nfunction fixJson(input) {\n  const stack = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i, swapState) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_STRING\");\n          break;\n        }\n        case \"f\":\n        case \"t\":\n        case \"n\": {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_LITERAL\");\n          break;\n        }\n        case \"-\": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"{\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_OBJECT_START\");\n          break;\n        }\n        case \"[\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_ARRAY_START\");\n          break;\n        }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n        break;\n      }\n      case \"}\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  function processAfterArrayValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n        break;\n      }\n      case \"]\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n      case \"INSIDE_OBJECT_START\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n          case \"}\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_COMMA\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_KEY\": {\n        switch (char) {\n          case \":\": {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_BEFORE_VALUE\": {\n        processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        processAfterObjectValue(char, i);\n        break;\n      }\n      case \"INSIDE_STRING\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n          case \"\\\\\": {\n            stack.push(\"INSIDE_STRING_ESCAPE\");\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_START\": {\n        switch (char) {\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        switch (char) {\n          case \",\": {\n            stack.pop();\n            stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n            break;\n          }\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_COMMA\": {\n        processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_STRING_ESCAPE\": {\n        stack.pop();\n        lastValidIndex = i;\n        break;\n      }\n      case \"INSIDE_NUMBER\": {\n        switch (char) {\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\": {\n            lastValidIndex = i;\n            break;\n          }\n          case \"e\":\n          case \"E\":\n          case \"-\":\n          case \".\": {\n            break;\n          }\n          case \",\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"}\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"]\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            break;\n          }\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, i + 1);\n        if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n          stack.pop();\n          if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n        break;\n      }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n    switch (state) {\n      case \"INSIDE_STRING\": {\n        result += '\"';\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        result += \"}\";\n        break;\n      }\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        result += \"]\";\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, input.length);\n        if (\"true\".startsWith(partialLiteral)) {\n          result += \"true\".slice(partialLiteral.length);\n        } else if (\"false\".startsWith(partialLiteral)) {\n          result += \"false\".slice(partialLiteral.length);\n        } else if (\"null\".startsWith(partialLiteral)) {\n          result += \"null\".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// src/util/parse-partial-json.ts\nasync function parsePartialJson(jsonText) {\n  if (jsonText === void 0) {\n    return { value: void 0, state: \"undefined-input\" };\n  }\n  let result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: jsonText });\n  if (result.success) {\n    return { value: result.value, state: \"successful-parse\" };\n  }\n  result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: fixJson(jsonText) });\n  if (result.success) {\n    return { value: result.value, state: \"repaired-parse\" };\n  }\n  return { value: void 0, state: \"failed-parse\" };\n}\n\n// src/ui/ui-messages.ts\nfunction isToolUIPart(part) {\n  return part.type.startsWith(\"tool-\");\n}\nfunction isDynamicToolUIPart(part) {\n  return part.type === \"dynamic-tool\";\n}\nfunction isToolOrDynamicToolUIPart(part) {\n  return isToolUIPart(part) || isDynamicToolUIPart(part);\n}\nfunction getToolName(part) {\n  return part.type.split(\"-\").slice(1).join(\"-\");\n}\nfunction getToolOrDynamicToolName(part) {\n  return isDynamicToolUIPart(part) ? part.toolName : getToolName(part);\n}\n\n// src/ui/process-ui-message-stream.ts\nfunction createStreamingUIMessageState({\n  lastMessage,\n  messageId\n}) {\n  return {\n    message: (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\" ? lastMessage : {\n      id: messageId,\n      metadata: void 0,\n      role: \"assistant\",\n      parts: []\n    },\n    activeTextParts: {},\n    activeReasoningParts: {},\n    partialToolCalls: {}\n  };\n}\nfunction processUIMessageStream({\n  stream,\n  messageMetadataSchema,\n  dataPartSchemas,\n  runUpdateMessageJob,\n  onError,\n  onToolCall,\n  onData\n}) {\n  return stream.pipeThrough(\n    new TransformStream({\n      async transform(chunk, controller) {\n        await runUpdateMessageJob(async ({ state, write }) => {\n          var _a17, _b, _c, _d;\n          function getToolInvocation(toolCallId) {\n            const toolInvocations = state.message.parts.filter(isToolUIPart);\n            const toolInvocation = toolInvocations.find(\n              (invocation) => invocation.toolCallId === toolCallId\n            );\n            if (toolInvocation == null) {\n              throw new Error(\n                \"tool-output-error must be preceded by a tool-input-available\"\n              );\n            }\n            return toolInvocation;\n          }\n          function getDynamicToolInvocation(toolCallId) {\n            const toolInvocations = state.message.parts.filter(\n              (part) => part.type === \"dynamic-tool\"\n            );\n            const toolInvocation = toolInvocations.find(\n              (invocation) => invocation.toolCallId === toolCallId\n            );\n            if (toolInvocation == null) {\n              throw new Error(\n                \"tool-output-error must be preceded by a tool-input-available\"\n              );\n            }\n            return toolInvocation;\n          }\n          function updateToolPart(options) {\n            var _a18;\n            const part = state.message.parts.find(\n              (part2) => isToolUIPart(part2) && part2.toolCallId === options.toolCallId\n            );\n            const anyOptions = options;\n            const anyPart = part;\n            if (part != null) {\n              part.state = options.state;\n              anyPart.input = anyOptions.input;\n              anyPart.output = anyOptions.output;\n              anyPart.errorText = anyOptions.errorText;\n              anyPart.rawInput = anyOptions.rawInput;\n              anyPart.preliminary = anyOptions.preliminary;\n              anyPart.providerExecuted = (_a18 = anyOptions.providerExecuted) != null ? _a18 : part.providerExecuted;\n              if (anyOptions.providerMetadata != null && part.state === \"input-available\") {\n                part.callProviderMetadata = anyOptions.providerMetadata;\n              }\n            } else {\n              state.message.parts.push({\n                type: `tool-${options.toolName}`,\n                toolCallId: options.toolCallId,\n                state: options.state,\n                input: anyOptions.input,\n                output: anyOptions.output,\n                rawInput: anyOptions.rawInput,\n                errorText: anyOptions.errorText,\n                providerExecuted: anyOptions.providerExecuted,\n                preliminary: anyOptions.preliminary,\n                ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}\n              });\n            }\n          }\n          function updateDynamicToolPart(options) {\n            var _a18;\n            const part = state.message.parts.find(\n              (part2) => part2.type === \"dynamic-tool\" && part2.toolCallId === options.toolCallId\n            );\n            const anyOptions = options;\n            const anyPart = part;\n            if (part != null) {\n              part.state = options.state;\n              anyPart.toolName = options.toolName;\n              anyPart.input = anyOptions.input;\n              anyPart.output = anyOptions.output;\n              anyPart.errorText = anyOptions.errorText;\n              anyPart.rawInput = (_a18 = anyOptions.rawInput) != null ? _a18 : anyPart.rawInput;\n              anyPart.preliminary = anyOptions.preliminary;\n              if (anyOptions.providerMetadata != null && part.state === \"input-available\") {\n                part.callProviderMetadata = anyOptions.providerMetadata;\n              }\n            } else {\n              state.message.parts.push({\n                type: \"dynamic-tool\",\n                toolName: options.toolName,\n                toolCallId: options.toolCallId,\n                state: options.state,\n                input: anyOptions.input,\n                output: anyOptions.output,\n                errorText: anyOptions.errorText,\n                preliminary: anyOptions.preliminary,\n                ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}\n              });\n            }\n          }\n          async function updateMessageMetadata(metadata) {\n            if (metadata != null) {\n              const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;\n              if (messageMetadataSchema != null) {\n                await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                  value: mergedMetadata,\n                  schema: messageMetadataSchema\n                });\n              }\n              state.message.metadata = mergedMetadata;\n            }\n          }\n          switch (chunk.type) {\n            case \"text-start\": {\n              const textPart = {\n                type: \"text\",\n                text: \"\",\n                providerMetadata: chunk.providerMetadata,\n                state: \"streaming\"\n              };\n              state.activeTextParts[chunk.id] = textPart;\n              state.message.parts.push(textPart);\n              write();\n              break;\n            }\n            case \"text-delta\": {\n              const textPart = state.activeTextParts[chunk.id];\n              textPart.text += chunk.delta;\n              textPart.providerMetadata = (_a17 = chunk.providerMetadata) != null ? _a17 : textPart.providerMetadata;\n              write();\n              break;\n            }\n            case \"text-end\": {\n              const textPart = state.activeTextParts[chunk.id];\n              textPart.state = \"done\";\n              textPart.providerMetadata = (_b = chunk.providerMetadata) != null ? _b : textPart.providerMetadata;\n              delete state.activeTextParts[chunk.id];\n              write();\n              break;\n            }\n            case \"reasoning-start\": {\n              const reasoningPart = {\n                type: \"reasoning\",\n                text: \"\",\n                providerMetadata: chunk.providerMetadata,\n                state: \"streaming\"\n              };\n              state.activeReasoningParts[chunk.id] = reasoningPart;\n              state.message.parts.push(reasoningPart);\n              write();\n              break;\n            }\n            case \"reasoning-delta\": {\n              const reasoningPart = state.activeReasoningParts[chunk.id];\n              reasoningPart.text += chunk.delta;\n              reasoningPart.providerMetadata = (_c = chunk.providerMetadata) != null ? _c : reasoningPart.providerMetadata;\n              write();\n              break;\n            }\n            case \"reasoning-end\": {\n              const reasoningPart = state.activeReasoningParts[chunk.id];\n              reasoningPart.providerMetadata = (_d = chunk.providerMetadata) != null ? _d : reasoningPart.providerMetadata;\n              reasoningPart.state = \"done\";\n              delete state.activeReasoningParts[chunk.id];\n              write();\n              break;\n            }\n            case \"file\": {\n              state.message.parts.push({\n                type: \"file\",\n                mediaType: chunk.mediaType,\n                url: chunk.url\n              });\n              write();\n              break;\n            }\n            case \"source-url\": {\n              state.message.parts.push({\n                type: \"source-url\",\n                sourceId: chunk.sourceId,\n                url: chunk.url,\n                title: chunk.title,\n                providerMetadata: chunk.providerMetadata\n              });\n              write();\n              break;\n            }\n            case \"source-document\": {\n              state.message.parts.push({\n                type: \"source-document\",\n                sourceId: chunk.sourceId,\n                mediaType: chunk.mediaType,\n                title: chunk.title,\n                filename: chunk.filename,\n                providerMetadata: chunk.providerMetadata\n              });\n              write();\n              break;\n            }\n            case \"tool-input-start\": {\n              const toolInvocations = state.message.parts.filter(isToolUIPart);\n              state.partialToolCalls[chunk.toolCallId] = {\n                text: \"\",\n                toolName: chunk.toolName,\n                index: toolInvocations.length,\n                dynamic: chunk.dynamic\n              };\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-streaming\",\n                  input: void 0\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-streaming\",\n                  input: void 0,\n                  providerExecuted: chunk.providerExecuted\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-input-delta\": {\n              const partialToolCall = state.partialToolCalls[chunk.toolCallId];\n              partialToolCall.text += chunk.inputTextDelta;\n              const { value: partialArgs } = await parsePartialJson(\n                partialToolCall.text\n              );\n              if (partialToolCall.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: partialToolCall.toolName,\n                  state: \"input-streaming\",\n                  input: partialArgs\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: partialToolCall.toolName,\n                  state: \"input-streaming\",\n                  input: partialArgs\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-input-available\": {\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-available\",\n                  input: chunk.input,\n                  providerMetadata: chunk.providerMetadata\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-available\",\n                  input: chunk.input,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata\n                });\n              }\n              write();\n              if (onToolCall && !chunk.providerExecuted) {\n                await onToolCall({\n                  toolCall: chunk\n                });\n              }\n              break;\n            }\n            case \"tool-input-error\": {\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"output-error\",\n                  input: chunk.input,\n                  errorText: chunk.errorText,\n                  providerMetadata: chunk.providerMetadata\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"output-error\",\n                  input: void 0,\n                  rawInput: chunk.input,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-output-available\": {\n              if (chunk.dynamic) {\n                const toolInvocation = getDynamicToolInvocation(\n                  chunk.toolCallId\n                );\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: toolInvocation.toolName,\n                  state: \"output-available\",\n                  input: toolInvocation.input,\n                  output: chunk.output,\n                  preliminary: chunk.preliminary\n                });\n              } else {\n                const toolInvocation = getToolInvocation(chunk.toolCallId);\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: getToolName(toolInvocation),\n                  state: \"output-available\",\n                  input: toolInvocation.input,\n                  output: chunk.output,\n                  providerExecuted: chunk.providerExecuted,\n                  preliminary: chunk.preliminary\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-output-error\": {\n              if (chunk.dynamic) {\n                const toolInvocation = getDynamicToolInvocation(\n                  chunk.toolCallId\n                );\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: toolInvocation.toolName,\n                  state: \"output-error\",\n                  input: toolInvocation.input,\n                  errorText: chunk.errorText\n                });\n              } else {\n                const toolInvocation = getToolInvocation(chunk.toolCallId);\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: getToolName(toolInvocation),\n                  state: \"output-error\",\n                  input: toolInvocation.input,\n                  rawInput: toolInvocation.rawInput,\n                  errorText: chunk.errorText\n                });\n              }\n              write();\n              break;\n            }\n            case \"start-step\": {\n              state.message.parts.push({ type: \"step-start\" });\n              break;\n            }\n            case \"finish-step\": {\n              state.activeTextParts = {};\n              state.activeReasoningParts = {};\n              break;\n            }\n            case \"start\": {\n              if (chunk.messageId != null) {\n                state.message.id = chunk.messageId;\n              }\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageId != null || chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"finish\": {\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"message-metadata\": {\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"error\": {\n              onError == null ? void 0 : onError(new Error(chunk.errorText));\n              break;\n            }\n            default: {\n              if (isDataUIMessageChunk(chunk)) {\n                if ((dataPartSchemas == null ? void 0 : dataPartSchemas[chunk.type]) != null) {\n                  await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                    value: chunk.data,\n                    schema: dataPartSchemas[chunk.type]\n                  });\n                }\n                const dataChunk = chunk;\n                if (dataChunk.transient) {\n                  onData == null ? void 0 : onData(dataChunk);\n                  break;\n                }\n                const existingUIPart = dataChunk.id != null ? state.message.parts.find(\n                  (chunkArg) => dataChunk.type === chunkArg.type && dataChunk.id === chunkArg.id\n                ) : void 0;\n                if (existingUIPart != null) {\n                  existingUIPart.data = dataChunk.data;\n                } else {\n                  state.message.parts.push(dataChunk);\n                }\n                onData == null ? void 0 : onData(dataChunk);\n                write();\n              }\n            }\n          }\n          controller.enqueue(chunk);\n        });\n      }\n    })\n  );\n}\n\n// src/ui-message-stream/handle-ui-message-stream-finish.ts\nfunction handleUIMessageStreamFinish({\n  messageId,\n  originalMessages = [],\n  onFinish,\n  onError,\n  stream\n}) {\n  let lastMessage = originalMessages == null ? void 0 : originalMessages[originalMessages.length - 1];\n  if ((lastMessage == null ? void 0 : lastMessage.role) !== \"assistant\") {\n    lastMessage = void 0;\n  } else {\n    messageId = lastMessage.id;\n  }\n  let isAborted = false;\n  const idInjectedStream = stream.pipeThrough(\n    new TransformStream({\n      transform(chunk, controller) {\n        if (chunk.type === \"start\") {\n          const startChunk = chunk;\n          if (startChunk.messageId == null && messageId != null) {\n            startChunk.messageId = messageId;\n          }\n        }\n        if (chunk.type === \"abort\") {\n          isAborted = true;\n        }\n        controller.enqueue(chunk);\n      }\n    })\n  );\n  if (onFinish == null) {\n    return idInjectedStream;\n  }\n  const state = createStreamingUIMessageState({\n    lastMessage: lastMessage ? structuredClone(lastMessage) : void 0,\n    messageId: messageId != null ? messageId : \"\"\n    // will be overridden by the stream\n  });\n  const runUpdateMessageJob = async (job) => {\n    await job({ state, write: () => {\n    } });\n  };\n  let finishCalled = false;\n  const callOnFinish = async () => {\n    if (finishCalled || !onFinish) {\n      return;\n    }\n    finishCalled = true;\n    const isContinuation = state.message.id === (lastMessage == null ? void 0 : lastMessage.id);\n    await onFinish({\n      isAborted,\n      isContinuation,\n      responseMessage: state.message,\n      messages: [\n        ...isContinuation ? originalMessages.slice(0, -1) : originalMessages,\n        state.message\n      ]\n    });\n  };\n  return processUIMessageStream({\n    stream: idInjectedStream,\n    runUpdateMessageJob,\n    onError\n  }).pipeThrough(\n    new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      },\n      // @ts-expect-error cancel is still new and missing from types https://developer.mozilla.org/en-US/docs/Web/API/TransformStream#browser_compatibility\n      async cancel() {\n        await callOnFinish();\n      },\n      async flush() {\n        await callOnFinish();\n      }\n    })\n  );\n}\n\n// src/ui-message-stream/pipe-ui-message-stream-to-response.ts\nfunction pipeUIMessageStreamToResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream,\n  consumeSseStream\n}) {\n  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n  if (consumeSseStream) {\n    const [stream1, stream2] = sseStream.tee();\n    sseStream = stream1;\n    consumeSseStream({ stream: stream2 });\n  }\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: Object.fromEntries(\n      prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS).entries()\n    ),\n    stream: sseStream.pipeThrough(new TextEncoderStream())\n  });\n}\n\n// src/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source) {\n  const stream = source.pipeThrough(new TransformStream());\n  stream[Symbol.asyncIterator] = function() {\n    const reader = this.getReader();\n    let finished = false;\n    async function cleanup(cancelStream) {\n      var _a17;\n      finished = true;\n      try {\n        if (cancelStream) {\n          await ((_a17 = reader.cancel) == null ? void 0 : _a17.call(reader));\n        }\n      } finally {\n        try {\n          reader.releaseLock();\n        } catch (e) {\n        }\n      }\n    }\n    return {\n      /**\n       * Reads the next chunk from the stream.\n       * @returns A promise resolving to the next IteratorResult.\n       */\n      async next() {\n        if (finished) {\n          return { done: true, value: void 0 };\n        }\n        const { done, value } = await reader.read();\n        if (done) {\n          await cleanup(true);\n          return { done: true, value: void 0 };\n        }\n        return { done: false, value };\n      },\n      /**\n       * Called on early exit (e.g., break from for-await).\n       * Ensures the stream is cancelled and resources are released.\n       * @returns A promise resolving to a completed IteratorResult.\n       */\n      async return() {\n        await cleanup(true);\n        return { done: true, value: void 0 };\n      },\n      /**\n       * Called on early exit with error.\n       * Ensures the stream is cancelled and resources are released, then rethrows the error.\n       * @param err The error to throw.\n       * @returns A promise that rejects with the provided error.\n       */\n      async throw(err) {\n        await cleanup(true);\n        throw err;\n      }\n    };\n  };\n  return stream;\n}\n\n// src/util/consume-stream.ts\nasync function consumeStream({\n  stream,\n  onError\n}) {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { done } = await reader.read();\n      if (done)\n        break;\n    }\n  } catch (error) {\n    onError == null ? void 0 : onError(error);\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// src/util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n  let resolve2;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve2 = res;\n    reject = rej;\n  });\n  return {\n    promise,\n    resolve: resolve2,\n    reject\n  };\n}\n\n// src/util/create-stitchable-stream.ts\nfunction createStitchableStream() {\n  let innerStreamReaders = [];\n  let controller = null;\n  let isClosed = false;\n  let waitForNewStream = createResolvablePromise();\n  const terminate = () => {\n    isClosed = true;\n    waitForNewStream.resolve();\n    innerStreamReaders.forEach((reader) => reader.cancel());\n    innerStreamReaders = [];\n    controller == null ? void 0 : controller.close();\n  };\n  const processPull = async () => {\n    if (isClosed && innerStreamReaders.length === 0) {\n      controller == null ? void 0 : controller.close();\n      return;\n    }\n    if (innerStreamReaders.length === 0) {\n      waitForNewStream = createResolvablePromise();\n      await waitForNewStream.promise;\n      return processPull();\n    }\n    try {\n      const { value, done } = await innerStreamReaders[0].read();\n      if (done) {\n        innerStreamReaders.shift();\n        if (innerStreamReaders.length > 0) {\n          await processPull();\n        } else if (isClosed) {\n          controller == null ? void 0 : controller.close();\n        }\n      } else {\n        controller == null ? void 0 : controller.enqueue(value);\n      }\n    } catch (error) {\n      controller == null ? void 0 : controller.error(error);\n      innerStreamReaders.shift();\n      terminate();\n    }\n  };\n  return {\n    stream: new ReadableStream({\n      start(controllerParam) {\n        controller = controllerParam;\n      },\n      pull: processPull,\n      async cancel() {\n        for (const reader of innerStreamReaders) {\n          await reader.cancel();\n        }\n        innerStreamReaders = [];\n        isClosed = true;\n      }\n    }),\n    addStream: (innerStream) => {\n      if (isClosed) {\n        throw new Error(\"Cannot add inner stream: outer stream is closed\");\n      }\n      innerStreamReaders.push(innerStream.getReader());\n      waitForNewStream.resolve();\n    },\n    /**\n     * Gracefully close the outer stream. This will let the inner streams\n     * finish processing and then close the outer stream.\n     */\n    close: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n      if (innerStreamReaders.length === 0) {\n        controller == null ? void 0 : controller.close();\n      }\n    },\n    /**\n     * Immediately close the outer stream. This will cancel all inner streams\n     * and close the outer stream.\n     */\n    terminate\n  };\n}\n\n// src/util/delayed-promise.ts\nvar DelayedPromise = class {\n  constructor() {\n    this.status = { type: \"pending\" };\n    this._resolve = void 0;\n    this._reject = void 0;\n  }\n  get promise() {\n    if (this._promise) {\n      return this._promise;\n    }\n    this._promise = new Promise((resolve2, reject) => {\n      if (this.status.type === \"resolved\") {\n        resolve2(this.status.value);\n      } else if (this.status.type === \"rejected\") {\n        reject(this.status.error);\n      }\n      this._resolve = resolve2;\n      this._reject = reject;\n    });\n    return this._promise;\n  }\n  resolve(value) {\n    var _a17;\n    this.status = { type: \"resolved\", value };\n    if (this._promise) {\n      (_a17 = this._resolve) == null ? void 0 : _a17.call(this, value);\n    }\n  }\n  reject(error) {\n    var _a17;\n    this.status = { type: \"rejected\", error };\n    if (this._promise) {\n      (_a17 = this._reject) == null ? void 0 : _a17.call(this, error);\n    }\n  }\n};\n\n// src/util/now.ts\nfunction now() {\n  var _a17, _b;\n  return (_b = (_a17 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a17.now()) != null ? _b : Date.now();\n}\n\n// src/generate-text/run-tools-transformation.ts\n\nfunction runToolsTransformation({\n  tools,\n  generatorStream,\n  tracer,\n  telemetry,\n  system,\n  messages,\n  abortSignal,\n  repairToolCall,\n  experimental_context\n}) {\n  let toolResultsStreamController = null;\n  const toolResultsStream = new ReadableStream({\n    start(controller) {\n      toolResultsStreamController = controller;\n    }\n  });\n  const outstandingToolResults = /* @__PURE__ */ new Set();\n  const toolInputs = /* @__PURE__ */ new Map();\n  let canClose = false;\n  let finishChunk = void 0;\n  function attemptClose() {\n    if (canClose && outstandingToolResults.size === 0) {\n      if (finishChunk != null) {\n        toolResultsStreamController.enqueue(finishChunk);\n      }\n      toolResultsStreamController.close();\n    }\n  }\n  const forwardStream = new TransformStream({\n    async transform(chunk, controller) {\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"stream-start\":\n        case \"text-start\":\n        case \"text-delta\":\n        case \"text-end\":\n        case \"reasoning-start\":\n        case \"reasoning-delta\":\n        case \"reasoning-end\":\n        case \"tool-input-start\":\n        case \"tool-input-delta\":\n        case \"tool-input-end\":\n        case \"source\":\n        case \"response-metadata\":\n        case \"error\":\n        case \"raw\": {\n          controller.enqueue(chunk);\n          break;\n        }\n        case \"file\": {\n          controller.enqueue({\n            type: \"file\",\n            file: new DefaultGeneratedFileWithType({\n              data: chunk.data,\n              mediaType: chunk.mediaType\n            })\n          });\n          break;\n        }\n        case \"finish\": {\n          finishChunk = {\n            type: \"finish\",\n            finishReason: chunk.finishReason,\n            usage: chunk.usage,\n            providerMetadata: chunk.providerMetadata\n          };\n          break;\n        }\n        case \"tool-call\": {\n          try {\n            const toolCall = await parseToolCall({\n              toolCall: chunk,\n              tools,\n              repairToolCall,\n              system,\n              messages\n            });\n            controller.enqueue(toolCall);\n            if (toolCall.invalid) {\n              toolResultsStreamController.enqueue({\n                type: \"tool-error\",\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                input: toolCall.input,\n                error: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(toolCall.error),\n                dynamic: true\n              });\n              break;\n            }\n            const tool3 = tools[toolCall.toolName];\n            toolInputs.set(toolCall.toolCallId, toolCall.input);\n            if (tool3.onInputAvailable != null) {\n              await tool3.onInputAvailable({\n                input: toolCall.input,\n                toolCallId: toolCall.toolCallId,\n                messages,\n                abortSignal,\n                experimental_context\n              });\n            }\n            if (tool3.execute != null && toolCall.providerExecuted !== true) {\n              const toolExecutionId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId)();\n              outstandingToolResults.add(toolExecutionId);\n              recordSpan({\n                name: \"ai.toolCall\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.toolCall\",\n                      telemetry\n                    }),\n                    \"ai.toolCall.name\": toolCall.toolName,\n                    \"ai.toolCall.id\": toolCall.toolCallId,\n                    \"ai.toolCall.args\": {\n                      output: () => JSON.stringify(toolCall.input)\n                    }\n                  }\n                }),\n                tracer,\n                fn: async (span) => {\n                  let output;\n                  try {\n                    const stream = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.executeTool)({\n                      execute: tool3.execute.bind(tool3),\n                      input: toolCall.input,\n                      options: {\n                        toolCallId: toolCall.toolCallId,\n                        messages,\n                        abortSignal,\n                        experimental_context\n                      }\n                    });\n                    for await (const part of stream) {\n                      toolResultsStreamController.enqueue({\n                        ...toolCall,\n                        type: \"tool-result\",\n                        output: part.output,\n                        ...part.type === \"preliminary\" && {\n                          preliminary: true\n                        }\n                      });\n                      if (part.type === \"final\") {\n                        output = part.output;\n                      }\n                    }\n                  } catch (error) {\n                    recordErrorOnSpan(span, error);\n                    toolResultsStreamController.enqueue({\n                      ...toolCall,\n                      type: \"tool-error\",\n                      error\n                    });\n                    outstandingToolResults.delete(toolExecutionId);\n                    attemptClose();\n                    return;\n                  }\n                  outstandingToolResults.delete(toolExecutionId);\n                  attemptClose();\n                  try {\n                    span.setAttributes(\n                      selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                          \"ai.toolCall.result\": {\n                            output: () => JSON.stringify(output)\n                          }\n                        }\n                      })\n                    );\n                  } catch (ignored) {\n                  }\n                }\n              });\n            }\n          } catch (error) {\n            toolResultsStreamController.enqueue({ type: \"error\", error });\n          }\n          break;\n        }\n        case \"tool-result\": {\n          const toolName = chunk.toolName;\n          if (chunk.isError) {\n            toolResultsStreamController.enqueue({\n              type: \"tool-error\",\n              toolCallId: chunk.toolCallId,\n              toolName,\n              input: toolInputs.get(chunk.toolCallId),\n              providerExecuted: chunk.providerExecuted,\n              error: chunk.result\n            });\n          } else {\n            controller.enqueue({\n              type: \"tool-result\",\n              toolCallId: chunk.toolCallId,\n              toolName,\n              input: toolInputs.get(chunk.toolCallId),\n              output: chunk.result,\n              providerExecuted: chunk.providerExecuted\n            });\n          }\n          break;\n        }\n        default: {\n          const _exhaustiveCheck = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    flush() {\n      canClose = true;\n      attemptClose();\n    }\n  });\n  return new ReadableStream({\n    async start(controller) {\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n            }\n          })\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            }\n          })\n        )\n      ]);\n    }\n  });\n}\n\n// src/generate-text/stream-text.ts\nvar originalGenerateId2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n  prefix: \"aitxt\",\n  size: 24\n});\nfunction streamText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  stopWhen = stepCountIs(1),\n  experimental_output: output,\n  experimental_telemetry: telemetry,\n  prepareStep,\n  providerOptions,\n  experimental_activeTools,\n  activeTools = experimental_activeTools,\n  experimental_repairToolCall: repairToolCall,\n  experimental_transform: transform,\n  experimental_download: download2,\n  includeRawChunks = false,\n  onChunk,\n  onError = ({ error }) => {\n    console.error(error);\n  },\n  onFinish,\n  onAbort,\n  onStepFinish,\n  experimental_context,\n  _internal: {\n    now: now2 = now,\n    generateId: generateId3 = originalGenerateId2,\n    currentDate = () => /* @__PURE__ */ new Date()\n  } = {},\n  ...settings\n}) {\n  return new DefaultStreamTextResult({\n    model: resolveLanguageModel(model),\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    transforms: asArray(transform),\n    activeTools,\n    repairToolCall,\n    stopConditions: asArray(stopWhen),\n    output,\n    providerOptions,\n    prepareStep,\n    includeRawChunks,\n    onChunk,\n    onError,\n    onFinish,\n    onAbort,\n    onStepFinish,\n    now: now2,\n    currentDate,\n    generateId: generateId3,\n    experimental_context,\n    download: download2\n  });\n}\nfunction createOutputTransformStream(output) {\n  if (!output) {\n    return new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n      }\n    });\n  }\n  let firstTextChunkId = void 0;\n  let text2 = \"\";\n  let textChunk = \"\";\n  let lastPublishedJson = \"\";\n  function publishTextChunk({\n    controller,\n    partialOutput = void 0\n  }) {\n    controller.enqueue({\n      part: {\n        type: \"text-delta\",\n        id: firstTextChunkId,\n        text: textChunk\n      },\n      partialOutput\n    });\n    textChunk = \"\";\n  }\n  return new TransformStream({\n    async transform(chunk, controller) {\n      if (chunk.type === \"finish-step\" && textChunk.length > 0) {\n        publishTextChunk({ controller });\n      }\n      if (chunk.type !== \"text-delta\" && chunk.type !== \"text-start\" && chunk.type !== \"text-end\") {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      if (firstTextChunkId == null) {\n        firstTextChunkId = chunk.id;\n      } else if (chunk.id !== firstTextChunkId) {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      if (chunk.type === \"text-start\") {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      if (chunk.type === \"text-end\") {\n        if (textChunk.length > 0) {\n          publishTextChunk({ controller });\n        }\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      text2 += chunk.text;\n      textChunk += chunk.text;\n      const result = await output.parsePartial({ text: text2 });\n      if (result != null) {\n        const currentJson = JSON.stringify(result.partial);\n        if (currentJson !== lastPublishedJson) {\n          publishTextChunk({ controller, partialOutput: result.partial });\n          lastPublishedJson = currentJson;\n        }\n      }\n    }\n  });\n}\nvar DefaultStreamTextResult = class {\n  constructor({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    transforms,\n    activeTools,\n    repairToolCall,\n    stopConditions,\n    output,\n    providerOptions,\n    prepareStep,\n    includeRawChunks,\n    now: now2,\n    currentDate,\n    generateId: generateId3,\n    onChunk,\n    onError,\n    onFinish,\n    onAbort,\n    onStepFinish,\n    experimental_context,\n    download: download2\n  }) {\n    this._totalUsage = new DelayedPromise();\n    this._finishReason = new DelayedPromise();\n    this._steps = new DelayedPromise();\n    this.output = output;\n    this.includeRawChunks = includeRawChunks;\n    this.tools = tools;\n    let stepFinish;\n    let recordedContent = [];\n    const recordedResponseMessages = [];\n    let recordedFinishReason = void 0;\n    let recordedTotalUsage = void 0;\n    let recordedRequest = {};\n    let recordedWarnings = [];\n    const recordedSteps = [];\n    let rootSpan;\n    let activeTextContent = {};\n    let activeReasoningContent = {};\n    const eventProcessor = new TransformStream({\n      async transform(chunk, controller) {\n        var _a17, _b, _c;\n        controller.enqueue(chunk);\n        const { part } = chunk;\n        if (part.type === \"text-delta\" || part.type === \"reasoning-delta\" || part.type === \"source\" || part.type === \"tool-call\" || part.type === \"tool-result\" || part.type === \"tool-input-start\" || part.type === \"tool-input-delta\" || part.type === \"raw\") {\n          await (onChunk == null ? void 0 : onChunk({ chunk: part }));\n        }\n        if (part.type === \"error\") {\n          await onError({ error: wrapGatewayError(part.error) });\n        }\n        if (part.type === \"text-start\") {\n          activeTextContent[part.id] = {\n            type: \"text\",\n            text: \"\",\n            providerMetadata: part.providerMetadata\n          };\n          recordedContent.push(activeTextContent[part.id]);\n        }\n        if (part.type === \"text-delta\") {\n          const activeText = activeTextContent[part.id];\n          if (activeText == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `text part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeText.text += part.text;\n          activeText.providerMetadata = (_a17 = part.providerMetadata) != null ? _a17 : activeText.providerMetadata;\n        }\n        if (part.type === \"text-end\") {\n          delete activeTextContent[part.id];\n        }\n        if (part.type === \"reasoning-start\") {\n          activeReasoningContent[part.id] = {\n            type: \"reasoning\",\n            text: \"\",\n            providerMetadata: part.providerMetadata\n          };\n          recordedContent.push(activeReasoningContent[part.id]);\n        }\n        if (part.type === \"reasoning-delta\") {\n          const activeReasoning = activeReasoningContent[part.id];\n          if (activeReasoning == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `reasoning part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeReasoning.text += part.text;\n          activeReasoning.providerMetadata = (_b = part.providerMetadata) != null ? _b : activeReasoning.providerMetadata;\n        }\n        if (part.type === \"reasoning-end\") {\n          const activeReasoning = activeReasoningContent[part.id];\n          if (activeReasoning == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `reasoning part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeReasoning.providerMetadata = (_c = part.providerMetadata) != null ? _c : activeReasoning.providerMetadata;\n          delete activeReasoningContent[part.id];\n        }\n        if (part.type === \"file\") {\n          recordedContent.push({ type: \"file\", file: part.file });\n        }\n        if (part.type === \"source\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-call\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-result\" && !part.preliminary) {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-error\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"start-step\") {\n          recordedRequest = part.request;\n          recordedWarnings = part.warnings;\n        }\n        if (part.type === \"finish-step\") {\n          const stepMessages = toResponseMessages({\n            content: recordedContent,\n            tools\n          });\n          const currentStepResult = new DefaultStepResult({\n            content: recordedContent,\n            finishReason: part.finishReason,\n            usage: part.usage,\n            warnings: recordedWarnings,\n            request: recordedRequest,\n            response: {\n              ...part.response,\n              messages: [...recordedResponseMessages, ...stepMessages]\n            },\n            providerMetadata: part.providerMetadata\n          });\n          await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n          logWarnings(recordedWarnings);\n          recordedSteps.push(currentStepResult);\n          recordedContent = [];\n          activeReasoningContent = {};\n          activeTextContent = {};\n          recordedResponseMessages.push(...stepMessages);\n          stepFinish.resolve();\n        }\n        if (part.type === \"finish\") {\n          recordedTotalUsage = part.totalUsage;\n          recordedFinishReason = part.finishReason;\n        }\n      },\n      async flush(controller) {\n        try {\n          if (recordedSteps.length === 0) {\n            const error = new NoOutputGeneratedError({\n              message: \"No output generated. Check the stream for errors.\"\n            });\n            self._finishReason.reject(error);\n            self._totalUsage.reject(error);\n            self._steps.reject(error);\n            return;\n          }\n          const finishReason = recordedFinishReason != null ? recordedFinishReason : \"unknown\";\n          const totalUsage = recordedTotalUsage != null ? recordedTotalUsage : {\n            inputTokens: void 0,\n            outputTokens: void 0,\n            totalTokens: void 0\n          };\n          self._finishReason.resolve(finishReason);\n          self._totalUsage.resolve(totalUsage);\n          self._steps.resolve(recordedSteps);\n          const finalStep = recordedSteps[recordedSteps.length - 1];\n          await (onFinish == null ? void 0 : onFinish({\n            finishReason,\n            totalUsage,\n            usage: finalStep.usage,\n            content: finalStep.content,\n            text: finalStep.text,\n            reasoningText: finalStep.reasoningText,\n            reasoning: finalStep.reasoning,\n            files: finalStep.files,\n            sources: finalStep.sources,\n            toolCalls: finalStep.toolCalls,\n            staticToolCalls: finalStep.staticToolCalls,\n            dynamicToolCalls: finalStep.dynamicToolCalls,\n            toolResults: finalStep.toolResults,\n            staticToolResults: finalStep.staticToolResults,\n            dynamicToolResults: finalStep.dynamicToolResults,\n            request: finalStep.request,\n            response: finalStep.response,\n            warnings: finalStep.warnings,\n            providerMetadata: finalStep.providerMetadata,\n            steps: recordedSteps\n          }));\n          rootSpan.setAttributes(\n            selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                \"ai.response.finishReason\": finishReason,\n                \"ai.response.text\": { output: () => finalStep.text },\n                \"ai.response.toolCalls\": {\n                  output: () => {\n                    var _a17;\n                    return ((_a17 = finalStep.toolCalls) == null ? void 0 : _a17.length) ? JSON.stringify(finalStep.toolCalls) : void 0;\n                  }\n                },\n                \"ai.response.providerMetadata\": JSON.stringify(\n                  finalStep.providerMetadata\n                ),\n                \"ai.usage.inputTokens\": totalUsage.inputTokens,\n                \"ai.usage.outputTokens\": totalUsage.outputTokens,\n                \"ai.usage.totalTokens\": totalUsage.totalTokens,\n                \"ai.usage.reasoningTokens\": totalUsage.reasoningTokens,\n                \"ai.usage.cachedInputTokens\": totalUsage.cachedInputTokens\n              }\n            })\n          );\n        } catch (error) {\n          controller.error(error);\n        } finally {\n          rootSpan.end();\n        }\n      }\n    });\n    const stitchableStream = createStitchableStream();\n    this.addStream = stitchableStream.addStream;\n    this.closeStream = stitchableStream.close;\n    const reader = stitchableStream.stream.getReader();\n    let stream = new ReadableStream({\n      async start(controller) {\n        controller.enqueue({ type: \"start\" });\n      },\n      async pull(controller) {\n        function abort() {\n          onAbort == null ? void 0 : onAbort({ steps: recordedSteps });\n          controller.enqueue({ type: \"abort\" });\n          controller.close();\n        }\n        try {\n          const { done, value } = await reader.read();\n          if (done) {\n            controller.close();\n            return;\n          }\n          if (abortSignal == null ? void 0 : abortSignal.aborted) {\n            abort();\n            return;\n          }\n          controller.enqueue(value);\n        } catch (error) {\n          if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isAbortError)(error) && (abortSignal == null ? void 0 : abortSignal.aborted)) {\n            abort();\n          } else {\n            controller.error(error);\n          }\n        }\n      },\n      cancel(reason) {\n        return stitchableStream.stream.cancel(reason);\n      }\n    });\n    for (const transform of transforms) {\n      stream = stream.pipeThrough(\n        transform({\n          tools,\n          stopStream() {\n            stitchableStream.terminate();\n          }\n        })\n      );\n    }\n    this.baseStream = stream.pipeThrough(createOutputTransformStream(output)).pipeThrough(eventProcessor);\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n      abortSignal\n    });\n    const tracer = getTracer(telemetry);\n    const callSettings = prepareCallSettings(settings);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...callSettings, maxRetries }\n    });\n    const self = this;\n    recordSpan({\n      name: \"ai.streamText\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({ operationId: \"ai.streamText\", telemetry }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          }\n        }\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async (rootSpanArg) => {\n        rootSpan = rootSpanArg;\n        async function streamStep({\n          currentStep,\n          responseMessages,\n          usage\n        }) {\n          var _a17, _b, _c, _d, _e;\n          const includeRawChunks2 = self.includeRawChunks;\n          stepFinish = new DelayedPromise();\n          const initialPrompt = await standardizePrompt({\n            system,\n            prompt,\n            messages\n          });\n          const stepInputMessages = [\n            ...initialPrompt.messages,\n            ...responseMessages\n          ];\n          const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n            model,\n            steps: recordedSteps,\n            stepNumber: recordedSteps.length,\n            messages: stepInputMessages\n          }));\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: {\n              system: (_a17 = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _a17 : initialPrompt.system,\n              messages: (_b = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _b : stepInputMessages\n            },\n            supportedUrls: await model.supportedUrls,\n            download: download2\n          });\n          const stepModel = resolveLanguageModel(\n            (_c = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _c : model\n          );\n          const { toolChoice: stepToolChoice, tools: stepTools } = prepareToolsAndToolChoice({\n            tools,\n            toolChoice: (_d = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _d : toolChoice,\n            activeTools: (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools\n          });\n          const {\n            result: { stream: stream2, response, request },\n            doStreamSpan,\n            startTimestampMs\n          } = await retry(\n            () => recordSpan({\n              name: \"ai.streamText.doStream\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: \"ai.streamText.doStream\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  // model:\n                  \"ai.model.provider\": stepModel.provider,\n                  \"ai.model.id\": stepModel.modelId,\n                  // prompt:\n                  \"ai.prompt.messages\": {\n                    input: () => stringifyForTelemetry(promptMessages)\n                  },\n                  \"ai.prompt.tools\": {\n                    // convert the language model level tools:\n                    input: () => stepTools == null ? void 0 : stepTools.map((tool3) => JSON.stringify(tool3))\n                  },\n                  \"ai.prompt.toolChoice\": {\n                    input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0\n                  },\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.system\": stepModel.provider,\n                  \"gen_ai.request.model\": stepModel.modelId,\n                  \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                  \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                  \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                  \"gen_ai.request.stop_sequences\": callSettings.stopSequences,\n                  \"gen_ai.request.temperature\": callSettings.temperature,\n                  \"gen_ai.request.top_k\": callSettings.topK,\n                  \"gen_ai.request.top_p\": callSettings.topP\n                }\n              }),\n              tracer,\n              endWhenDone: false,\n              fn: async (doStreamSpan2) => {\n                return {\n                  startTimestampMs: now2(),\n                  // get before the call\n                  doStreamSpan: doStreamSpan2,\n                  result: await stepModel.doStream({\n                    ...callSettings,\n                    tools: stepTools,\n                    toolChoice: stepToolChoice,\n                    responseFormat: output == null ? void 0 : output.responseFormat,\n                    prompt: promptMessages,\n                    providerOptions,\n                    abortSignal,\n                    headers,\n                    includeRawChunks: includeRawChunks2\n                  })\n                };\n              }\n            })\n          );\n          const streamWithToolResults = runToolsTransformation({\n            tools,\n            generatorStream: stream2,\n            tracer,\n            telemetry,\n            system,\n            messages: stepInputMessages,\n            repairToolCall,\n            abortSignal,\n            experimental_context\n          });\n          const stepRequest = request != null ? request : {};\n          const stepToolCalls = [];\n          const stepToolOutputs = [];\n          let warnings;\n          const activeToolCallToolNames = {};\n          let stepFinishReason = \"unknown\";\n          let stepUsage = {\n            inputTokens: void 0,\n            outputTokens: void 0,\n            totalTokens: void 0\n          };\n          let stepProviderMetadata;\n          let stepFirstChunk = true;\n          let stepResponse = {\n            id: generateId3(),\n            timestamp: currentDate(),\n            modelId: model.modelId\n          };\n          let activeText = \"\";\n          self.addStream(\n            streamWithToolResults.pipeThrough(\n              new TransformStream({\n                async transform(chunk, controller) {\n                  var _a18, _b2, _c2, _d2;\n                  if (chunk.type === \"stream-start\") {\n                    warnings = chunk.warnings;\n                    return;\n                  }\n                  if (stepFirstChunk) {\n                    const msToFirstChunk = now2() - startTimestampMs;\n                    stepFirstChunk = false;\n                    doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                      \"ai.response.msToFirstChunk\": msToFirstChunk\n                    });\n                    doStreamSpan.setAttributes({\n                      \"ai.response.msToFirstChunk\": msToFirstChunk\n                    });\n                    controller.enqueue({\n                      type: \"start-step\",\n                      request: stepRequest,\n                      warnings: warnings != null ? warnings : []\n                    });\n                  }\n                  const chunkType = chunk.type;\n                  switch (chunkType) {\n                    case \"text-start\":\n                    case \"text-end\": {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"text-delta\": {\n                      if (chunk.delta.length > 0) {\n                        controller.enqueue({\n                          type: \"text-delta\",\n                          id: chunk.id,\n                          text: chunk.delta,\n                          providerMetadata: chunk.providerMetadata\n                        });\n                        activeText += chunk.delta;\n                      }\n                      break;\n                    }\n                    case \"reasoning-start\":\n                    case \"reasoning-end\": {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"reasoning-delta\": {\n                      controller.enqueue({\n                        type: \"reasoning-delta\",\n                        id: chunk.id,\n                        text: chunk.delta,\n                        providerMetadata: chunk.providerMetadata\n                      });\n                      break;\n                    }\n                    case \"tool-call\": {\n                      controller.enqueue(chunk);\n                      stepToolCalls.push(chunk);\n                      break;\n                    }\n                    case \"tool-result\": {\n                      controller.enqueue(chunk);\n                      if (!chunk.preliminary) {\n                        stepToolOutputs.push(chunk);\n                      }\n                      break;\n                    }\n                    case \"tool-error\": {\n                      controller.enqueue(chunk);\n                      stepToolOutputs.push(chunk);\n                      break;\n                    }\n                    case \"response-metadata\": {\n                      stepResponse = {\n                        id: (_a18 = chunk.id) != null ? _a18 : stepResponse.id,\n                        timestamp: (_b2 = chunk.timestamp) != null ? _b2 : stepResponse.timestamp,\n                        modelId: (_c2 = chunk.modelId) != null ? _c2 : stepResponse.modelId\n                      };\n                      break;\n                    }\n                    case \"finish\": {\n                      stepUsage = chunk.usage;\n                      stepFinishReason = chunk.finishReason;\n                      stepProviderMetadata = chunk.providerMetadata;\n                      const msToFinish = now2() - startTimestampMs;\n                      doStreamSpan.addEvent(\"ai.stream.finish\");\n                      doStreamSpan.setAttributes({\n                        \"ai.response.msToFinish\": msToFinish,\n                        \"ai.response.avgOutputTokensPerSecond\": 1e3 * ((_d2 = stepUsage.outputTokens) != null ? _d2 : 0) / msToFinish\n                      });\n                      break;\n                    }\n                    case \"file\": {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"source\": {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"tool-input-start\": {\n                      activeToolCallToolNames[chunk.id] = chunk.toolName;\n                      const tool3 = tools == null ? void 0 : tools[chunk.toolName];\n                      if ((tool3 == null ? void 0 : tool3.onInputStart) != null) {\n                        await tool3.onInputStart({\n                          toolCallId: chunk.id,\n                          messages: stepInputMessages,\n                          abortSignal,\n                          experimental_context\n                        });\n                      }\n                      controller.enqueue({\n                        ...chunk,\n                        dynamic: (tool3 == null ? void 0 : tool3.type) === \"dynamic\"\n                      });\n                      break;\n                    }\n                    case \"tool-input-end\": {\n                      delete activeToolCallToolNames[chunk.id];\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"tool-input-delta\": {\n                      const toolName = activeToolCallToolNames[chunk.id];\n                      const tool3 = tools == null ? void 0 : tools[toolName];\n                      if ((tool3 == null ? void 0 : tool3.onInputDelta) != null) {\n                        await tool3.onInputDelta({\n                          inputTextDelta: chunk.delta,\n                          toolCallId: chunk.id,\n                          messages: stepInputMessages,\n                          abortSignal,\n                          experimental_context\n                        });\n                      }\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"error\": {\n                      controller.enqueue(chunk);\n                      stepFinishReason = \"error\";\n                      break;\n                    }\n                    case \"raw\": {\n                      if (includeRawChunks2) {\n                        controller.enqueue(chunk);\n                      }\n                      break;\n                    }\n                    default: {\n                      const exhaustiveCheck = chunkType;\n                      throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                    }\n                  }\n                },\n                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                async flush(controller) {\n                  const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;\n                  try {\n                    doStreamSpan.setAttributes(\n                      selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                          \"ai.response.finishReason\": stepFinishReason,\n                          \"ai.response.text\": {\n                            output: () => activeText\n                          },\n                          \"ai.response.toolCalls\": {\n                            output: () => stepToolCallsJson\n                          },\n                          \"ai.response.id\": stepResponse.id,\n                          \"ai.response.model\": stepResponse.modelId,\n                          \"ai.response.timestamp\": stepResponse.timestamp.toISOString(),\n                          \"ai.response.providerMetadata\": JSON.stringify(stepProviderMetadata),\n                          \"ai.usage.inputTokens\": stepUsage.inputTokens,\n                          \"ai.usage.outputTokens\": stepUsage.outputTokens,\n                          \"ai.usage.totalTokens\": stepUsage.totalTokens,\n                          \"ai.usage.reasoningTokens\": stepUsage.reasoningTokens,\n                          \"ai.usage.cachedInputTokens\": stepUsage.cachedInputTokens,\n                          // standardized gen-ai llm span attributes:\n                          \"gen_ai.response.finish_reasons\": [stepFinishReason],\n                          \"gen_ai.response.id\": stepResponse.id,\n                          \"gen_ai.response.model\": stepResponse.modelId,\n                          \"gen_ai.usage.input_tokens\": stepUsage.inputTokens,\n                          \"gen_ai.usage.output_tokens\": stepUsage.outputTokens\n                        }\n                      })\n                    );\n                  } catch (error) {\n                  } finally {\n                    doStreamSpan.end();\n                  }\n                  controller.enqueue({\n                    type: \"finish-step\",\n                    finishReason: stepFinishReason,\n                    usage: stepUsage,\n                    providerMetadata: stepProviderMetadata,\n                    response: {\n                      ...stepResponse,\n                      headers: response == null ? void 0 : response.headers\n                    }\n                  });\n                  const combinedUsage = addLanguageModelUsage(usage, stepUsage);\n                  await stepFinish.promise;\n                  const clientToolCalls = stepToolCalls.filter(\n                    (toolCall) => toolCall.providerExecuted !== true\n                  );\n                  const clientToolOutputs = stepToolOutputs.filter(\n                    (toolOutput) => toolOutput.providerExecuted !== true\n                  );\n                  if (clientToolCalls.length > 0 && // all current tool calls have outputs (incl. execution errors):\n                  clientToolOutputs.length === clientToolCalls.length && // continue until a stop condition is met:\n                  !await isStopConditionMet({\n                    stopConditions,\n                    steps: recordedSteps\n                  })) {\n                    responseMessages.push(\n                      ...toResponseMessages({\n                        content: (\n                          // use transformed content to create the messages for the next step:\n                          recordedSteps[recordedSteps.length - 1].content\n                        ),\n                        tools\n                      })\n                    );\n                    try {\n                      await streamStep({\n                        currentStep: currentStep + 1,\n                        responseMessages,\n                        usage: combinedUsage\n                      });\n                    } catch (error) {\n                      controller.enqueue({\n                        type: \"error\",\n                        error\n                      });\n                      self.closeStream();\n                    }\n                  } else {\n                    controller.enqueue({\n                      type: \"finish\",\n                      finishReason: stepFinishReason,\n                      totalUsage: combinedUsage\n                    });\n                    self.closeStream();\n                  }\n                }\n              })\n            )\n          );\n        }\n        await streamStep({\n          currentStep: 0,\n          responseMessages: [],\n          usage: {\n            inputTokens: void 0,\n            outputTokens: void 0,\n            totalTokens: void 0\n          }\n        });\n      }\n    }).catch((error) => {\n      self.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: \"error\", error });\n            controller.close();\n          }\n        })\n      );\n      self.closeStream();\n    });\n  }\n  get steps() {\n    this.consumeStream();\n    return this._steps.promise;\n  }\n  get finalStep() {\n    return this.steps.then((steps) => steps[steps.length - 1]);\n  }\n  get content() {\n    return this.finalStep.then((step) => step.content);\n  }\n  get warnings() {\n    return this.finalStep.then((step) => step.warnings);\n  }\n  get providerMetadata() {\n    return this.finalStep.then((step) => step.providerMetadata);\n  }\n  get text() {\n    return this.finalStep.then((step) => step.text);\n  }\n  get reasoningText() {\n    return this.finalStep.then((step) => step.reasoningText);\n  }\n  get reasoning() {\n    return this.finalStep.then((step) => step.reasoning);\n  }\n  get sources() {\n    return this.finalStep.then((step) => step.sources);\n  }\n  get files() {\n    return this.finalStep.then((step) => step.files);\n  }\n  get toolCalls() {\n    return this.finalStep.then((step) => step.toolCalls);\n  }\n  get staticToolCalls() {\n    return this.finalStep.then((step) => step.staticToolCalls);\n  }\n  get dynamicToolCalls() {\n    return this.finalStep.then((step) => step.dynamicToolCalls);\n  }\n  get toolResults() {\n    return this.finalStep.then((step) => step.toolResults);\n  }\n  get staticToolResults() {\n    return this.finalStep.then((step) => step.staticToolResults);\n  }\n  get dynamicToolResults() {\n    return this.finalStep.then((step) => step.dynamicToolResults);\n  }\n  get usage() {\n    return this.finalStep.then((step) => step.usage);\n  }\n  get request() {\n    return this.finalStep.then((step) => step.request);\n  }\n  get response() {\n    return this.finalStep.then((step) => step.response);\n  }\n  get totalUsage() {\n    this.consumeStream();\n    return this._totalUsage.promise;\n  }\n  get finishReason() {\n    this.consumeStream();\n    return this._finishReason.promise;\n  }\n  /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */\n  teeStream() {\n    const [stream1, stream2] = this.baseStream.tee();\n    this.baseStream = stream2;\n    return stream1;\n  }\n  get textStream() {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ part }, controller) {\n            if (part.type === \"text-delta\") {\n              controller.enqueue(part.text);\n            }\n          }\n        })\n      )\n    );\n  }\n  get fullStream() {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ part }, controller) {\n            controller.enqueue(part);\n          }\n        })\n      )\n    );\n  }\n  async consumeStream(options) {\n    var _a17;\n    try {\n      await consumeStream({\n        stream: this.fullStream,\n        onError: options == null ? void 0 : options.onError\n      });\n    } catch (error) {\n      (_a17 = options == null ? void 0 : options.onError) == null ? void 0 : _a17.call(options, error);\n    }\n  }\n  get experimental_partialOutputStream() {\n    if (this.output == null) {\n      throw new NoOutputSpecifiedError();\n    }\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ partialOutput }, controller) {\n            if (partialOutput != null) {\n              controller.enqueue(partialOutput);\n            }\n          }\n        })\n      )\n    );\n  }\n  toUIMessageStream({\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning = true,\n    sendSources = false,\n    sendStart = true,\n    sendFinish = true,\n    onError = _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage\n  } = {}) {\n    const responseMessageId = generateMessageId != null ? getResponseUIMessageId({\n      originalMessages,\n      responseMessageId: generateMessageId\n    }) : void 0;\n    const toolNamesByCallId = {};\n    const isDynamic = (toolCallId) => {\n      var _a17, _b;\n      const toolName = toolNamesByCallId[toolCallId];\n      const dynamic = ((_b = (_a17 = this.tools) == null ? void 0 : _a17[toolName]) == null ? void 0 : _b.type) === \"dynamic\";\n      return dynamic ? true : void 0;\n    };\n    const baseStream = this.fullStream.pipeThrough(\n      new TransformStream({\n        transform: async (part, controller) => {\n          const messageMetadataValue = messageMetadata == null ? void 0 : messageMetadata({ part });\n          const partType = part.type;\n          switch (partType) {\n            case \"text-start\": {\n              controller.enqueue({\n                type: \"text-start\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"text-delta\": {\n              controller.enqueue({\n                type: \"text-delta\",\n                id: part.id,\n                delta: part.text,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"text-end\": {\n              controller.enqueue({\n                type: \"text-end\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"reasoning-start\": {\n              controller.enqueue({\n                type: \"reasoning-start\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"reasoning-delta\": {\n              if (sendReasoning) {\n                controller.enqueue({\n                  type: \"reasoning-delta\",\n                  id: part.id,\n                  delta: part.text,\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n                });\n              }\n              break;\n            }\n            case \"reasoning-end\": {\n              controller.enqueue({\n                type: \"reasoning-end\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"file\": {\n              controller.enqueue({\n                type: \"file\",\n                mediaType: part.file.mediaType,\n                url: `data:${part.file.mediaType};base64,${part.file.base64}`\n              });\n              break;\n            }\n            case \"source\": {\n              if (sendSources && part.sourceType === \"url\") {\n                controller.enqueue({\n                  type: \"source-url\",\n                  sourceId: part.id,\n                  url: part.url,\n                  title: part.title,\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n                });\n              }\n              if (sendSources && part.sourceType === \"document\") {\n                controller.enqueue({\n                  type: \"source-document\",\n                  sourceId: part.id,\n                  mediaType: part.mediaType,\n                  title: part.title,\n                  filename: part.filename,\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n                });\n              }\n              break;\n            }\n            case \"tool-input-start\": {\n              toolNamesByCallId[part.id] = part.toolName;\n              const dynamic = isDynamic(part.id);\n              controller.enqueue({\n                type: \"tool-input-start\",\n                toolCallId: part.id,\n                toolName: part.toolName,\n                ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                ...dynamic != null ? { dynamic } : {}\n              });\n              break;\n            }\n            case \"tool-input-delta\": {\n              controller.enqueue({\n                type: \"tool-input-delta\",\n                toolCallId: part.id,\n                inputTextDelta: part.delta\n              });\n              break;\n            }\n            case \"tool-call\": {\n              toolNamesByCallId[part.toolCallId] = part.toolName;\n              const dynamic = isDynamic(part.toolCallId);\n              if (part.invalid) {\n                controller.enqueue({\n                  type: \"tool-input-error\",\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  input: part.input,\n                  ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},\n                  ...dynamic != null ? { dynamic } : {},\n                  errorText: onError(part.error)\n                });\n              } else {\n                controller.enqueue({\n                  type: \"tool-input-available\",\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  input: part.input,\n                  ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},\n                  ...dynamic != null ? { dynamic } : {}\n                });\n              }\n              break;\n            }\n            case \"tool-result\": {\n              const dynamic = isDynamic(part.toolCallId);\n              controller.enqueue({\n                type: \"tool-output-available\",\n                toolCallId: part.toolCallId,\n                output: part.output,\n                ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                ...part.preliminary != null ? { preliminary: part.preliminary } : {},\n                ...dynamic != null ? { dynamic } : {}\n              });\n              break;\n            }\n            case \"tool-error\": {\n              const dynamic = isDynamic(part.toolCallId);\n              controller.enqueue({\n                type: \"tool-output-error\",\n                toolCallId: part.toolCallId,\n                errorText: onError(part.error),\n                ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                ...dynamic != null ? { dynamic } : {}\n              });\n              break;\n            }\n            case \"error\": {\n              controller.enqueue({\n                type: \"error\",\n                errorText: onError(part.error)\n              });\n              break;\n            }\n            case \"start-step\": {\n              controller.enqueue({ type: \"start-step\" });\n              break;\n            }\n            case \"finish-step\": {\n              controller.enqueue({ type: \"finish-step\" });\n              break;\n            }\n            case \"start\": {\n              if (sendStart) {\n                controller.enqueue({\n                  type: \"start\",\n                  ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {},\n                  ...responseMessageId != null ? { messageId: responseMessageId } : {}\n                });\n              }\n              break;\n            }\n            case \"finish\": {\n              if (sendFinish) {\n                controller.enqueue({\n                  type: \"finish\",\n                  ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {}\n                });\n              }\n              break;\n            }\n            case \"abort\": {\n              controller.enqueue(part);\n              break;\n            }\n            case \"tool-input-end\": {\n              break;\n            }\n            case \"raw\": {\n              break;\n            }\n            default: {\n              const exhaustiveCheck = partType;\n              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n            }\n          }\n          if (messageMetadataValue != null && partType !== \"start\" && partType !== \"finish\") {\n            controller.enqueue({\n              type: \"message-metadata\",\n              messageMetadata: messageMetadataValue\n            });\n          }\n        }\n      })\n    );\n    return createAsyncIterableStream(\n      handleUIMessageStreamFinish({\n        stream: baseStream,\n        messageId: responseMessageId != null ? responseMessageId : generateMessageId == null ? void 0 : generateMessageId(),\n        originalMessages,\n        onFinish,\n        onError\n      })\n    );\n  }\n  pipeUIMessageStreamToResponse(response, {\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning,\n    sendSources,\n    sendFinish,\n    sendStart,\n    onError,\n    ...init\n  } = {}) {\n    pipeUIMessageStreamToResponse({\n      response,\n      stream: this.toUIMessageStream({\n        originalMessages,\n        generateMessageId,\n        onFinish,\n        messageMetadata,\n        sendReasoning,\n        sendSources,\n        sendFinish,\n        sendStart,\n        onError\n      }),\n      ...init\n    });\n  }\n  pipeTextStreamToResponse(response, init) {\n    pipeTextStreamToResponse({\n      response,\n      textStream: this.textStream,\n      ...init\n    });\n  }\n  toUIMessageStreamResponse({\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning,\n    sendSources,\n    sendFinish,\n    sendStart,\n    onError,\n    ...init\n  } = {}) {\n    return createUIMessageStreamResponse({\n      stream: this.toUIMessageStream({\n        originalMessages,\n        generateMessageId,\n        onFinish,\n        messageMetadata,\n        sendReasoning,\n        sendSources,\n        sendFinish,\n        sendStart,\n        onError\n      }),\n      ...init\n    });\n  }\n  toTextStreamResponse(init) {\n    return createTextStreamResponse({\n      textStream: this.textStream,\n      ...init\n    });\n  }\n};\n\n// src/ui/convert-to-model-messages.ts\nfunction convertToModelMessages(messages, options) {\n  const modelMessages = [];\n  if (options == null ? void 0 : options.ignoreIncompleteToolCalls) {\n    messages = messages.map((message) => ({\n      ...message,\n      parts: message.parts.filter(\n        (part) => !isToolOrDynamicToolUIPart(part) || part.state !== \"input-streaming\" && part.state !== \"input-available\"\n      )\n    }));\n  }\n  for (const message of messages) {\n    switch (message.role) {\n      case \"system\": {\n        const textParts = message.parts.filter((part) => part.type === \"text\");\n        const providerMetadata = textParts.reduce((acc, part) => {\n          if (part.providerMetadata != null) {\n            return { ...acc, ...part.providerMetadata };\n          }\n          return acc;\n        }, {});\n        modelMessages.push({\n          role: \"system\",\n          content: textParts.map((part) => part.text).join(\"\"),\n          ...Object.keys(providerMetadata).length > 0 ? { providerOptions: providerMetadata } : {}\n        });\n        break;\n      }\n      case \"user\": {\n        modelMessages.push({\n          role: \"user\",\n          content: message.parts.filter(\n            (part) => part.type === \"text\" || part.type === \"file\"\n          ).map((part) => {\n            switch (part.type) {\n              case \"text\":\n                return {\n                  type: \"text\",\n                  text: part.text,\n                  ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n                };\n              case \"file\":\n                return {\n                  type: \"file\",\n                  mediaType: part.mediaType,\n                  filename: part.filename,\n                  data: part.url,\n                  ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n                };\n              default:\n                return part;\n            }\n          })\n        });\n        break;\n      }\n      case \"assistant\": {\n        if (message.parts != null) {\n          let processBlock2 = function() {\n            var _a17, _b;\n            if (block.length === 0) {\n              return;\n            }\n            const content = [];\n            for (const part of block) {\n              if (part.type === \"text\") {\n                content.push({\n                  type: \"text\",\n                  text: part.text,\n                  ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n                });\n              } else if (part.type === \"file\") {\n                content.push({\n                  type: \"file\",\n                  mediaType: part.mediaType,\n                  filename: part.filename,\n                  data: part.url\n                });\n              } else if (part.type === \"reasoning\") {\n                content.push({\n                  type: \"reasoning\",\n                  text: part.text,\n                  providerOptions: part.providerMetadata\n                });\n              } else if (part.type === \"dynamic-tool\") {\n                const toolName = part.toolName;\n                if (part.state !== \"input-streaming\") {\n                  content.push({\n                    type: \"tool-call\",\n                    toolCallId: part.toolCallId,\n                    toolName,\n                    input: part.input,\n                    ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}\n                  });\n                }\n              } else if (isToolUIPart(part)) {\n                const toolName = getToolName(part);\n                if (part.state !== \"input-streaming\") {\n                  content.push({\n                    type: \"tool-call\",\n                    toolCallId: part.toolCallId,\n                    toolName,\n                    input: part.state === \"output-error\" ? (_a17 = part.input) != null ? _a17 : part.rawInput : part.input,\n                    providerExecuted: part.providerExecuted,\n                    ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}\n                  });\n                  if (part.providerExecuted === true && (part.state === \"output-available\" || part.state === \"output-error\")) {\n                    content.push({\n                      type: \"tool-result\",\n                      toolCallId: part.toolCallId,\n                      toolName,\n                      output: createToolModelOutput({\n                        output: part.state === \"output-error\" ? part.errorText : part.output,\n                        tool: (_b = options == null ? void 0 : options.tools) == null ? void 0 : _b[toolName],\n                        errorMode: part.state === \"output-error\" ? \"json\" : \"none\"\n                      })\n                    });\n                  }\n                }\n              } else {\n                const _exhaustiveCheck = part;\n                throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n              }\n            }\n            modelMessages.push({\n              role: \"assistant\",\n              content\n            });\n            const toolParts = block.filter(\n              (part) => isToolUIPart(part) && part.providerExecuted !== true || part.type === \"dynamic-tool\"\n            );\n            if (toolParts.length > 0) {\n              modelMessages.push({\n                role: \"tool\",\n                content: toolParts.map((toolPart) => {\n                  var _a18;\n                  switch (toolPart.state) {\n                    case \"output-error\":\n                    case \"output-available\": {\n                      const toolName = toolPart.type === \"dynamic-tool\" ? toolPart.toolName : getToolName(toolPart);\n                      return {\n                        type: \"tool-result\",\n                        toolCallId: toolPart.toolCallId,\n                        toolName,\n                        output: createToolModelOutput({\n                          output: toolPart.state === \"output-error\" ? toolPart.errorText : toolPart.output,\n                          tool: (_a18 = options == null ? void 0 : options.tools) == null ? void 0 : _a18[toolName],\n                          errorMode: toolPart.state === \"output-error\" ? \"text\" : \"none\"\n                        })\n                      };\n                    }\n                    default: {\n                      return null;\n                    }\n                  }\n                }).filter(\n                  (output) => output != null\n                )\n              });\n            }\n            block = [];\n          };\n          var processBlock = processBlock2;\n          let block = [];\n          for (const part of message.parts) {\n            if (part.type === \"text\" || part.type === \"reasoning\" || part.type === \"file\" || part.type === \"dynamic-tool\" || isToolUIPart(part)) {\n              block.push(part);\n            } else if (part.type === \"step-start\") {\n              processBlock2();\n            }\n          }\n          processBlock2();\n          break;\n        }\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = message.role;\n        throw new MessageConversionError({\n          originalMessage: message,\n          message: `Unsupported role: ${_exhaustiveCheck}`\n        });\n      }\n    }\n  }\n  return modelMessages;\n}\nvar convertToCoreMessages = convertToModelMessages;\n\n// src/agent/agent.ts\nvar Agent = class {\n  constructor(settings) {\n    this.settings = settings;\n  }\n  get tools() {\n    return this.settings.tools;\n  }\n  async generate(options) {\n    return generateText({ ...this.settings, ...options });\n  }\n  stream(options) {\n    return streamText({ ...this.settings, ...options });\n  }\n  /**\n   * Creates a response object that streams UI messages to the client.\n   */\n  respond(options) {\n    return this.stream({\n      prompt: convertToModelMessages(options.messages)\n    }).toUIMessageStreamResponse();\n  }\n};\n\n// src/embed/embed.ts\nasync function embed({\n  model: modelArg,\n  value,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry\n}) {\n  const model = resolveEmbeddingModel(modelArg);\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.embed\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embed\", telemetry }),\n        ...baseTelemetryAttributes,\n        \"ai.value\": { input: () => JSON.stringify(value) }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const { embedding, usage, response, providerMetadata } = await retry(\n        () => (\n          // nested spans to align with the embedMany telemetry data:\n          recordSpan({\n            name: \"ai.embed.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embed.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": { input: () => [JSON.stringify(value)] }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a17;\n              const modelResponse = await model.doEmbed({\n                values: [value],\n                abortSignal,\n                headers,\n                providerOptions\n              });\n              const embedding2 = modelResponse.embeddings[0];\n              const usage2 = (_a17 = modelResponse.usage) != null ? _a17 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => modelResponse.embeddings.map(\n                        (embedding3) => JSON.stringify(embedding3)\n                      )\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return {\n                embedding: embedding2,\n                usage: usage2,\n                providerMetadata: modelResponse.providerMetadata,\n                response: modelResponse.response\n              };\n            }\n          })\n        )\n      );\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embedding\": { output: () => JSON.stringify(embedding) },\n            \"ai.usage.tokens\": usage.tokens\n          }\n        })\n      );\n      return new DefaultEmbedResult({\n        value,\n        embedding,\n        usage,\n        providerMetadata,\n        response\n      });\n    }\n  });\n}\nvar DefaultEmbedResult = class {\n  constructor(options) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.usage = options.usage;\n    this.providerMetadata = options.providerMetadata;\n    this.response = options.response;\n  }\n};\n\n// src/util/split-array.ts\nfunction splitArray(array, chunkSize) {\n  if (chunkSize <= 0) {\n    throw new Error(\"chunkSize must be greater than 0\");\n  }\n  const result = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n  return result;\n}\n\n// src/embed/embed-many.ts\nasync function embedMany({\n  model: modelArg,\n  values,\n  maxParallelCalls = Infinity,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  providerOptions,\n  experimental_telemetry: telemetry\n}) {\n  const model = resolveEmbeddingModel(modelArg);\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.embedMany\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embedMany\", telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.values\": {\n          input: () => values.map((value) => JSON.stringify(value))\n        }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      var _a17;\n      const [maxEmbeddingsPerCall, supportsParallelCalls] = await Promise.all([\n        model.maxEmbeddingsPerCall,\n        model.supportsParallelCalls\n      ]);\n      if (maxEmbeddingsPerCall == null || maxEmbeddingsPerCall === Infinity) {\n        const { embeddings: embeddings2, usage, response, providerMetadata: providerMetadata2 } = await retry(\n          () => {\n            return recordSpan({\n              name: \"ai.embedMany.doEmbed\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: \"ai.embedMany.doEmbed\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  // specific settings that only make sense on the outer level:\n                  \"ai.values\": {\n                    input: () => values.map((value) => JSON.stringify(value))\n                  }\n                }\n              }),\n              tracer,\n              fn: async (doEmbedSpan) => {\n                var _a18;\n                const modelResponse = await model.doEmbed({\n                  values,\n                  abortSignal,\n                  headers,\n                  providerOptions\n                });\n                const embeddings3 = modelResponse.embeddings;\n                const usage2 = (_a18 = modelResponse.usage) != null ? _a18 : { tokens: NaN };\n                doEmbedSpan.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.embeddings\": {\n                        output: () => embeddings3.map(\n                          (embedding) => JSON.stringify(embedding)\n                        )\n                      },\n                      \"ai.usage.tokens\": usage2.tokens\n                    }\n                  })\n                );\n                return {\n                  embeddings: embeddings3,\n                  usage: usage2,\n                  providerMetadata: modelResponse.providerMetadata,\n                  response: modelResponse.response\n                };\n              }\n            });\n          }\n        );\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.embeddings\": {\n                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))\n              },\n              \"ai.usage.tokens\": usage.tokens\n            }\n          })\n        );\n        return new DefaultEmbedManyResult({\n          values,\n          embeddings: embeddings2,\n          usage,\n          providerMetadata: providerMetadata2,\n          responses: [response]\n        });\n      }\n      const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n      const embeddings = [];\n      const responses = [];\n      let tokens = 0;\n      let providerMetadata;\n      const parallelChunks = splitArray(\n        valueChunks,\n        supportsParallelCalls ? maxParallelCalls : 1\n      );\n      for (const parallelChunk of parallelChunks) {\n        const results = await Promise.all(\n          parallelChunk.map((chunk) => {\n            return retry(() => {\n              return recordSpan({\n                name: \"ai.embedMany.doEmbed\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.embedMany.doEmbed\",\n                      telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.values\": {\n                      input: () => chunk.map((value) => JSON.stringify(value))\n                    }\n                  }\n                }),\n                tracer,\n                fn: async (doEmbedSpan) => {\n                  var _a18;\n                  const modelResponse = await model.doEmbed({\n                    values: chunk,\n                    abortSignal,\n                    headers,\n                    providerOptions\n                  });\n                  const embeddings2 = modelResponse.embeddings;\n                  const usage = (_a18 = modelResponse.usage) != null ? _a18 : { tokens: NaN };\n                  doEmbedSpan.setAttributes(\n                    selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        \"ai.embeddings\": {\n                          output: () => embeddings2.map(\n                            (embedding) => JSON.stringify(embedding)\n                          )\n                        },\n                        \"ai.usage.tokens\": usage.tokens\n                      }\n                    })\n                  );\n                  return {\n                    embeddings: embeddings2,\n                    usage,\n                    providerMetadata: modelResponse.providerMetadata,\n                    response: modelResponse.response\n                  };\n                }\n              });\n            });\n          })\n        );\n        for (const result of results) {\n          embeddings.push(...result.embeddings);\n          responses.push(result.response);\n          tokens += result.usage.tokens;\n          if (result.providerMetadata) {\n            if (!providerMetadata) {\n              providerMetadata = { ...result.providerMetadata };\n            } else {\n              for (const [providerName, metadata] of Object.entries(\n                result.providerMetadata\n              )) {\n                providerMetadata[providerName] = {\n                  ...(_a17 = providerMetadata[providerName]) != null ? _a17 : {},\n                  ...metadata\n                };\n              }\n            }\n          }\n        }\n      }\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embeddings\": {\n              output: () => embeddings.map((embedding) => JSON.stringify(embedding))\n            },\n            \"ai.usage.tokens\": tokens\n          }\n        })\n      );\n      return new DefaultEmbedManyResult({\n        values,\n        embeddings,\n        usage: { tokens },\n        providerMetadata,\n        responses\n      });\n    }\n  });\n}\nvar DefaultEmbedManyResult = class {\n  constructor(options) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n    this.usage = options.usage;\n    this.providerMetadata = options.providerMetadata;\n    this.responses = options.responses;\n  }\n};\n\n// src/generate-image/generate-image.ts\nasync function generateImage({\n  model,\n  prompt,\n  n = 1,\n  maxImagesPerCall,\n  size,\n  aspectRatio,\n  seed,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  var _a17, _b;\n  if (model.specificationVersion !== \"v2\") {\n    throw new UnsupportedModelVersionError({\n      version: model.specificationVersion,\n      provider: model.provider,\n      modelId: model.modelId\n    });\n  }\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const maxImagesPerCallWithDefault = (_a17 = maxImagesPerCall != null ? maxImagesPerCall : await invokeModelMaxImagesPerCall(model)) != null ? _a17 : 1;\n  const callCount = Math.ceil(n / maxImagesPerCallWithDefault);\n  const callImageCounts = Array.from({ length: callCount }, (_, i) => {\n    if (i < callCount - 1) {\n      return maxImagesPerCallWithDefault;\n    }\n    const remainder = n % maxImagesPerCallWithDefault;\n    return remainder === 0 ? maxImagesPerCallWithDefault : remainder;\n  });\n  const results = await Promise.all(\n    callImageCounts.map(\n      async (callImageCount) => retry(\n        () => model.doGenerate({\n          prompt,\n          n: callImageCount,\n          abortSignal,\n          headers,\n          size,\n          aspectRatio,\n          seed,\n          providerOptions: providerOptions != null ? providerOptions : {}\n        })\n      )\n    )\n  );\n  const images = [];\n  const warnings = [];\n  const responses = [];\n  const providerMetadata = {};\n  for (const result of results) {\n    images.push(\n      ...result.images.map(\n        (image) => {\n          var _a18;\n          return new DefaultGeneratedFile({\n            data: image,\n            mediaType: (_a18 = detectMediaType({\n              data: image,\n              signatures: imageMediaTypeSignatures\n            })) != null ? _a18 : \"image/png\"\n          });\n        }\n      )\n    );\n    warnings.push(...result.warnings);\n    if (result.providerMetadata) {\n      for (const [providerName, metadata] of Object.entries(result.providerMetadata)) {\n        (_b = providerMetadata[providerName]) != null ? _b : providerMetadata[providerName] = { images: [] };\n        providerMetadata[providerName].images.push(\n          ...result.providerMetadata[providerName].images\n        );\n      }\n    }\n    responses.push(result.response);\n  }\n  logWarnings(warnings);\n  if (!images.length) {\n    throw new NoImageGeneratedError({ responses });\n  }\n  return new DefaultGenerateImageResult({\n    images,\n    warnings,\n    responses,\n    providerMetadata\n  });\n}\nvar DefaultGenerateImageResult = class {\n  constructor(options) {\n    this.images = options.images;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = options.providerMetadata;\n  }\n  get image() {\n    return this.images[0];\n  }\n};\nasync function invokeModelMaxImagesPerCall(model) {\n  const isFunction = model.maxImagesPerCall instanceof Function;\n  if (!isFunction) {\n    return model.maxImagesPerCall;\n  }\n  return model.maxImagesPerCall({\n    modelId: model.modelId\n  });\n}\n\n// src/generate-object/generate-object.ts\n\n\n// src/generate-text/extract-reasoning-content.ts\nfunction extractReasoningContent(content) {\n  const parts = content.filter(\n    (content2) => content2.type === \"reasoning\"\n  );\n  return parts.length === 0 ? void 0 : parts.map((content2) => content2.text).join(\"\\n\");\n}\n\n// src/generate-object/output-strategy.ts\n\n\nvar noSchemaOutputStrategy = {\n  type: \"no-schema\",\n  jsonSchema: void 0,\n  async validatePartialResult({ value, textDelta }) {\n    return { success: true, value: { partial: value, textDelta } };\n  },\n  async validateFinalResult(value, context) {\n    return value === void 0 ? {\n      success: false,\n      error: new NoObjectGeneratedError({\n        message: \"No object generated: response did not match schema.\",\n        text: context.text,\n        response: context.response,\n        usage: context.usage,\n        finishReason: context.finishReason\n      })\n    } : { success: true, value };\n  },\n  createElementStream() {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n      functionality: \"element streams in no-schema mode\"\n    });\n  }\n};\nvar objectOutputStrategy = (schema) => ({\n  type: \"object\",\n  jsonSchema: schema.jsonSchema,\n  async validatePartialResult({ value, textDelta }) {\n    return {\n      success: true,\n      value: {\n        // Note: currently no validation of partial results:\n        partial: value,\n        textDelta\n      }\n    };\n  },\n  async validateFinalResult(value) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value, schema });\n  },\n  createElementStream() {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n      functionality: \"element streams in object mode\"\n    });\n  }\n});\nvar arrayOutputStrategy = (schema) => {\n  const { $schema, ...itemSchema } = schema.jsonSchema;\n  return {\n    type: \"enum\",\n    // wrap in object that contains array of elements, since most LLMs will not\n    // be able to generate an array directly:\n    // possible future optimization: use arrays directly when model supports grammar-guided generation\n    jsonSchema: {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        elements: { type: \"array\", items: itemSchema }\n      },\n      required: [\"elements\"],\n      additionalProperties: false\n    },\n    async validatePartialResult({\n      value,\n      latestObject,\n      isFirstDelta,\n      isFinalDelta\n    }) {\n      var _a17;\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      const resultArray = [];\n      for (let i = 0; i < inputArray.length; i++) {\n        const element = inputArray[i];\n        const result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: element, schema });\n        if (i === inputArray.length - 1 && !isFinalDelta) {\n          continue;\n        }\n        if (!result.success) {\n          return result;\n        }\n        resultArray.push(result.value);\n      }\n      const publishedElementCount = (_a17 = latestObject == null ? void 0 : latestObject.length) != null ? _a17 : 0;\n      let textDelta = \"\";\n      if (isFirstDelta) {\n        textDelta += \"[\";\n      }\n      if (publishedElementCount > 0) {\n        textDelta += \",\";\n      }\n      textDelta += resultArray.slice(publishedElementCount).map((element) => JSON.stringify(element)).join(\",\");\n      if (isFinalDelta) {\n        textDelta += \"]\";\n      }\n      return {\n        success: true,\n        value: {\n          partial: resultArray,\n          textDelta\n        }\n      };\n    },\n    async validateFinalResult(value) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      for (const element of inputArray) {\n        const result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: element, schema });\n        if (!result.success) {\n          return result;\n        }\n      }\n      return { success: true, value: inputArray };\n    },\n    createElementStream(originalStream) {\n      let publishedElements = 0;\n      return createAsyncIterableStream(\n        originalStream.pipeThrough(\n          new TransformStream({\n            transform(chunk, controller) {\n              switch (chunk.type) {\n                case \"object\": {\n                  const array = chunk.object;\n                  for (; publishedElements < array.length; publishedElements++) {\n                    controller.enqueue(array[publishedElements]);\n                  }\n                  break;\n                }\n                case \"text-delta\":\n                case \"finish\":\n                case \"error\":\n                  break;\n                default: {\n                  const _exhaustiveCheck = chunk;\n                  throw new Error(\n                    `Unsupported chunk type: ${_exhaustiveCheck}`\n                  );\n                }\n              }\n            }\n          })\n        )\n      );\n    }\n  };\n};\nvar enumOutputStrategy = (enumValues) => {\n  return {\n    type: \"enum\",\n    // wrap in object that contains result, since most LLMs will not\n    // be able to generate an enum value directly:\n    // possible future optimization: use enums directly when model supports top-level enums\n    jsonSchema: {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        result: { type: \"string\", enum: enumValues }\n      },\n      required: [\"result\"],\n      additionalProperties: false\n    },\n    async validateFinalResult(value) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: 'value must be an object that contains a string in the \"result\" property.'\n          })\n        };\n      }\n      const result = value.result;\n      return enumValues.includes(result) ? { success: true, value: result } : {\n        success: false,\n        error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n          value,\n          cause: \"value must be a string in the enum\"\n        })\n      };\n    },\n    async validatePartialResult({ value, textDelta }) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: 'value must be an object that contains a string in the \"result\" property.'\n          })\n        };\n      }\n      const result = value.result;\n      const possibleEnumValues = enumValues.filter(\n        (enumValue) => enumValue.startsWith(result)\n      );\n      if (value.result.length === 0 || possibleEnumValues.length === 0) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be a string in the enum\"\n          })\n        };\n      }\n      return {\n        success: true,\n        value: {\n          partial: possibleEnumValues.length > 1 ? result : possibleEnumValues[0],\n          textDelta\n        }\n      };\n    },\n    createElementStream() {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n        functionality: \"element streams in enum mode\"\n      });\n    }\n  };\n};\nfunction getOutputStrategy({\n  output,\n  schema,\n  enumValues\n}) {\n  switch (output) {\n    case \"object\":\n      return objectOutputStrategy((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(schema));\n    case \"array\":\n      return arrayOutputStrategy((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(schema));\n    case \"enum\":\n      return enumOutputStrategy(enumValues);\n    case \"no-schema\":\n      return noSchemaOutputStrategy;\n    default: {\n      const _exhaustiveCheck = output;\n      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n    }\n  }\n}\n\n// src/generate-object/parse-and-validate-object-result.ts\n\n\nasync function parseAndValidateObjectResult(result, outputStrategy, context) {\n  const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: result });\n  if (!parseResult.success) {\n    throw new NoObjectGeneratedError({\n      message: \"No object generated: could not parse the response.\",\n      cause: parseResult.error,\n      text: result,\n      response: context.response,\n      usage: context.usage,\n      finishReason: context.finishReason\n    });\n  }\n  const validationResult = await outputStrategy.validateFinalResult(\n    parseResult.value,\n    {\n      text: result,\n      response: context.response,\n      usage: context.usage\n    }\n  );\n  if (!validationResult.success) {\n    throw new NoObjectGeneratedError({\n      message: \"No object generated: response did not match schema.\",\n      cause: validationResult.error,\n      text: result,\n      response: context.response,\n      usage: context.usage,\n      finishReason: context.finishReason\n    });\n  }\n  return validationResult.value;\n}\nasync function parseAndValidateObjectResultWithRepair(result, outputStrategy, repairText, context) {\n  try {\n    return await parseAndValidateObjectResult(result, outputStrategy, context);\n  } catch (error) {\n    if (repairText != null && NoObjectGeneratedError.isInstance(error) && (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError.isInstance(error.cause) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.isInstance(error.cause))) {\n      const repairedText = await repairText({\n        text: result,\n        error: error.cause\n      });\n      if (repairedText === null) {\n        throw error;\n      }\n      return await parseAndValidateObjectResult(\n        repairedText,\n        outputStrategy,\n        context\n      );\n    }\n    throw error;\n  }\n}\n\n// src/generate-object/validate-object-generation-input.ts\nfunction validateObjectGenerationInput({\n  output,\n  schema,\n  schemaName,\n  schemaDescription,\n  enumValues\n}) {\n  if (output != null && output !== \"object\" && output !== \"array\" && output !== \"enum\" && output !== \"no-schema\") {\n    throw new InvalidArgumentError({\n      parameter: \"output\",\n      value: output,\n      message: \"Invalid output type.\"\n    });\n  }\n  if (output === \"no-schema\") {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for no-schema output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for no-schema output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for no-schema output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for no-schema output.\"\n      });\n    }\n  }\n  if (output === \"object\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is required for object output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for object output.\"\n      });\n    }\n  }\n  if (output === \"array\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Element schema is required for array output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for array output.\"\n      });\n    }\n  }\n  if (output === \"enum\") {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for enum output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for enum output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for enum output.\"\n      });\n    }\n    if (enumValues == null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are required for enum output.\"\n      });\n    }\n    for (const value of enumValues) {\n      if (typeof value !== \"string\") {\n        throw new InvalidArgumentError({\n          parameter: \"enumValues\",\n          value,\n          message: \"Enum values must be strings.\"\n        });\n      }\n    }\n  }\n}\n\n// src/generate-object/generate-object.ts\nvar originalGenerateId3 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({ prefix: \"aiobj\", size: 24 });\nasync function generateObject(options) {\n  const {\n    model: modelArg,\n    output = \"object\",\n    system,\n    prompt,\n    messages,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    headers,\n    experimental_repairText: repairText,\n    experimental_telemetry: telemetry,\n    experimental_download: download2,\n    providerOptions,\n    _internal: {\n      generateId: generateId3 = originalGenerateId3,\n      currentDate = () => /* @__PURE__ */ new Date()\n    } = {},\n    ...settings\n  } = options;\n  const model = resolveLanguageModel(modelArg);\n  const enumValues = \"enum\" in options ? options.enum : void 0;\n  const {\n    schema: inputSchema,\n    schemaDescription,\n    schemaName\n  } = \"schema\" in options ? options : {};\n  validateObjectGenerationInput({\n    output,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues\n  });\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues\n  });\n  const callSettings = prepareCallSettings(settings);\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...callSettings, maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  try {\n    return await recordSpan({\n      name: \"ai.generateObject\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.generateObject\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          },\n          \"ai.schema\": outputStrategy.jsonSchema != null ? { input: () => JSON.stringify(outputStrategy.jsonSchema) } : void 0,\n          \"ai.schema.name\": schemaName,\n          \"ai.schema.description\": schemaDescription,\n          \"ai.settings.output\": outputStrategy.type\n        }\n      }),\n      tracer,\n      fn: async (span) => {\n        var _a17;\n        let result;\n        let finishReason;\n        let usage;\n        let warnings;\n        let response;\n        let request;\n        let resultProviderMetadata;\n        let reasoning;\n        const standardizedPrompt = await standardizePrompt({\n          system,\n          prompt,\n          messages\n        });\n        const promptMessages = await convertToLanguageModelPrompt({\n          prompt: standardizedPrompt,\n          supportedUrls: await model.supportedUrls,\n          download: download2\n        });\n        const generateResult = await retry(\n          () => recordSpan({\n            name: \"ai.generateObject.doGenerate\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.generateObject.doGenerate\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.messages\": {\n                  input: () => stringifyForTelemetry(promptMessages)\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                \"gen_ai.request.temperature\": callSettings.temperature,\n                \"gen_ai.request.top_k\": callSettings.topK,\n                \"gen_ai.request.top_p\": callSettings.topP\n              }\n            }),\n            tracer,\n            fn: async (span2) => {\n              var _a18, _b, _c, _d, _e, _f, _g, _h;\n              const result2 = await model.doGenerate({\n                responseFormat: {\n                  type: \"json\",\n                  schema: outputStrategy.jsonSchema,\n                  name: schemaName,\n                  description: schemaDescription\n                },\n                ...prepareCallSettings(settings),\n                prompt: promptMessages,\n                providerOptions,\n                abortSignal,\n                headers\n              });\n              const responseData = {\n                id: (_b = (_a18 = result2.response) == null ? void 0 : _a18.id) != null ? _b : generateId3(),\n                timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),\n                modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId,\n                headers: (_g = result2.response) == null ? void 0 : _g.headers,\n                body: (_h = result2.response) == null ? void 0 : _h.body\n              };\n              const text2 = extractTextContent(result2.content);\n              const reasoning2 = extractReasoningContent(result2.content);\n              if (text2 === void 0) {\n                throw new NoObjectGeneratedError({\n                  message: \"No object generated: the model did not return a response.\",\n                  response: responseData,\n                  usage: result2.usage,\n                  finishReason: result2.finishReason\n                });\n              }\n              span2.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.response.finishReason\": result2.finishReason,\n                    \"ai.response.object\": { output: () => text2 },\n                    \"ai.response.id\": responseData.id,\n                    \"ai.response.model\": responseData.modelId,\n                    \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                    \"ai.response.providerMetadata\": JSON.stringify(\n                      result2.providerMetadata\n                    ),\n                    // TODO rename telemetry attributes to inputTokens and outputTokens\n                    \"ai.usage.promptTokens\": result2.usage.inputTokens,\n                    \"ai.usage.completionTokens\": result2.usage.outputTokens,\n                    // standardized gen-ai llm span attributes:\n                    \"gen_ai.response.finish_reasons\": [result2.finishReason],\n                    \"gen_ai.response.id\": responseData.id,\n                    \"gen_ai.response.model\": responseData.modelId,\n                    \"gen_ai.usage.input_tokens\": result2.usage.inputTokens,\n                    \"gen_ai.usage.output_tokens\": result2.usage.outputTokens\n                  }\n                })\n              );\n              return {\n                ...result2,\n                objectText: text2,\n                reasoning: reasoning2,\n                responseData\n              };\n            }\n          })\n        );\n        result = generateResult.objectText;\n        finishReason = generateResult.finishReason;\n        usage = generateResult.usage;\n        warnings = generateResult.warnings;\n        resultProviderMetadata = generateResult.providerMetadata;\n        request = (_a17 = generateResult.request) != null ? _a17 : {};\n        response = generateResult.responseData;\n        reasoning = generateResult.reasoning;\n        logWarnings(warnings);\n        const object2 = await parseAndValidateObjectResultWithRepair(\n          result,\n          outputStrategy,\n          repairText,\n          {\n            response,\n            usage,\n            finishReason\n          }\n        );\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.response.finishReason\": finishReason,\n              \"ai.response.object\": {\n                output: () => JSON.stringify(object2)\n              },\n              \"ai.response.providerMetadata\": JSON.stringify(\n                resultProviderMetadata\n              ),\n              // TODO rename telemetry attributes to inputTokens and outputTokens\n              \"ai.usage.promptTokens\": usage.inputTokens,\n              \"ai.usage.completionTokens\": usage.outputTokens\n            }\n          })\n        );\n        return new DefaultGenerateObjectResult({\n          object: object2,\n          reasoning,\n          finishReason,\n          usage,\n          warnings,\n          request,\n          response,\n          providerMetadata: resultProviderMetadata\n        });\n      }\n    });\n  } catch (error) {\n    throw wrapGatewayError(error);\n  }\n}\nvar DefaultGenerateObjectResult = class {\n  constructor(options) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.response = options.response;\n    this.request = options.request;\n    this.reasoning = options.reasoning;\n  }\n  toJsonResponse(init) {\n    var _a17;\n    return new Response(JSON.stringify(this.object), {\n      status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,\n      headers: prepareHeaders(init == null ? void 0 : init.headers, {\n        \"content-type\": \"application/json; charset=utf-8\"\n      })\n    });\n  }\n};\n\n// src/generate-object/stream-object.ts\n\n\n// src/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2) {\n  if (vector1.length !== vector2.length) {\n    throw new InvalidArgumentError({\n      parameter: \"vector1,vector2\",\n      value: { vector1Length: vector1.length, vector2Length: vector2.length },\n      message: `Vectors must have the same length`\n    });\n  }\n  const n = vector1.length;\n  if (n === 0) {\n    return 0;\n  }\n  let magnitudeSquared1 = 0;\n  let magnitudeSquared2 = 0;\n  let dotProduct = 0;\n  for (let i = 0; i < n; i++) {\n    const value1 = vector1[i];\n    const value2 = vector2[i];\n    magnitudeSquared1 += value1 * value1;\n    magnitudeSquared2 += value2 * value2;\n    dotProduct += value1 * value2;\n  }\n  return magnitudeSquared1 === 0 || magnitudeSquared2 === 0 ? 0 : dotProduct / (Math.sqrt(magnitudeSquared1) * Math.sqrt(magnitudeSquared2));\n}\n\n// src/util/data-url.ts\nfunction getTextFromDataUrl(dataUrl) {\n  const [header, base64Content] = dataUrl.split(\",\");\n  const mediaType = header.split(\";\")[0].split(\":\")[1];\n  if (mediaType == null || base64Content == null) {\n    throw new Error(\"Invalid data URL format\");\n  }\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n\n// src/util/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n  if (obj1 === obj2)\n    return true;\n  if (obj1 == null || obj2 == null)\n    return false;\n  if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\")\n    return obj1 === obj2;\n  if (obj1.constructor !== obj2.constructor)\n    return false;\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length)\n      return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i]))\n        return false;\n    }\n    return true;\n  }\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length)\n    return false;\n  for (const key of keys1) {\n    if (!keys2.includes(key))\n      return false;\n    if (!isDeepEqualData(obj1[key], obj2[key]))\n      return false;\n  }\n  return true;\n}\n\n// src/util/serial-job-executor.ts\nvar SerialJobExecutor = class {\n  constructor() {\n    this.queue = [];\n    this.isProcessing = false;\n  }\n  async processQueue() {\n    if (this.isProcessing) {\n      return;\n    }\n    this.isProcessing = true;\n    while (this.queue.length > 0) {\n      await this.queue[0]();\n      this.queue.shift();\n    }\n    this.isProcessing = false;\n  }\n  async run(job) {\n    return new Promise((resolve2, reject) => {\n      this.queue.push(async () => {\n        try {\n          await job();\n          resolve2();\n        } catch (error) {\n          reject(error);\n        }\n      });\n      void this.processQueue();\n    });\n  }\n};\n\n// src/util/simulate-readable-stream.ts\n\nfunction simulateReadableStream({\n  chunks,\n  initialDelayInMs = 0,\n  chunkDelayInMs = 0,\n  _internal\n}) {\n  var _a17;\n  const delay2 = (_a17 = _internal == null ? void 0 : _internal.delay) != null ? _a17 : _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay;\n  let index = 0;\n  return new ReadableStream({\n    async pull(controller) {\n      if (index < chunks.length) {\n        await delay2(index === 0 ? initialDelayInMs : chunkDelayInMs);\n        controller.enqueue(chunks[index++]);\n      } else {\n        controller.close();\n      }\n    }\n  });\n}\n\n// src/generate-object/stream-object.ts\nvar originalGenerateId4 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({ prefix: \"aiobj\", size: 24 });\nfunction streamObject(options) {\n  const {\n    model,\n    output = \"object\",\n    system,\n    prompt,\n    messages,\n    maxRetries,\n    abortSignal,\n    headers,\n    experimental_repairText: repairText,\n    experimental_telemetry: telemetry,\n    experimental_download: download2,\n    providerOptions,\n    onError = ({ error }) => {\n      console.error(error);\n    },\n    onFinish,\n    _internal: {\n      generateId: generateId3 = originalGenerateId4,\n      currentDate = () => /* @__PURE__ */ new Date(),\n      now: now2 = now\n    } = {},\n    ...settings\n  } = options;\n  const enumValues = \"enum\" in options && options.enum ? options.enum : void 0;\n  const {\n    schema: inputSchema,\n    schemaDescription,\n    schemaName\n  } = \"schema\" in options ? options : {};\n  validateObjectGenerationInput({\n    output,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues\n  });\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues\n  });\n  return new DefaultStreamObjectResult({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    repairText,\n    onError,\n    onFinish,\n    download: download2,\n    generateId: generateId3,\n    currentDate,\n    now: now2\n  });\n}\nvar DefaultStreamObjectResult = class {\n  constructor({\n    model: modelArg,\n    headers,\n    telemetry,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    repairText,\n    onError,\n    onFinish,\n    download: download2,\n    generateId: generateId3,\n    currentDate,\n    now: now2\n  }) {\n    this._object = new DelayedPromise();\n    this._usage = new DelayedPromise();\n    this._providerMetadata = new DelayedPromise();\n    this._warnings = new DelayedPromise();\n    this._request = new DelayedPromise();\n    this._response = new DelayedPromise();\n    this._finishReason = new DelayedPromise();\n    const model = resolveLanguageModel(modelArg);\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n      abortSignal\n    });\n    const callSettings = prepareCallSettings(settings);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...callSettings, maxRetries }\n    });\n    const tracer = getTracer(telemetry);\n    const self = this;\n    const stitchableStream = createStitchableStream();\n    const eventProcessor = new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n        if (chunk.type === \"error\") {\n          onError({ error: wrapGatewayError(chunk.error) });\n        }\n      }\n    });\n    this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);\n    recordSpan({\n      name: \"ai.streamObject\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.streamObject\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          },\n          \"ai.schema\": outputStrategy.jsonSchema != null ? { input: () => JSON.stringify(outputStrategy.jsonSchema) } : void 0,\n          \"ai.schema.name\": schemaName,\n          \"ai.schema.description\": schemaDescription,\n          \"ai.settings.output\": outputStrategy.type\n        }\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async (rootSpan) => {\n        const standardizedPrompt = await standardizePrompt({\n          system,\n          prompt,\n          messages\n        });\n        const callOptions = {\n          responseFormat: {\n            type: \"json\",\n            schema: outputStrategy.jsonSchema,\n            name: schemaName,\n            description: schemaDescription\n          },\n          ...prepareCallSettings(settings),\n          prompt: await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            supportedUrls: await model.supportedUrls,\n            download: download2\n          }),\n          providerOptions,\n          abortSignal,\n          headers,\n          includeRawChunks: false\n        };\n        const transformer = {\n          transform: (chunk, controller) => {\n            switch (chunk.type) {\n              case \"text-delta\":\n                controller.enqueue(chunk.delta);\n                break;\n              case \"response-metadata\":\n              case \"finish\":\n              case \"error\":\n              case \"stream-start\":\n                controller.enqueue(chunk);\n                break;\n            }\n          }\n        };\n        const {\n          result: { stream, response, request },\n          doStreamSpan,\n          startTimestampMs\n        } = await retry(\n          () => recordSpan({\n            name: \"ai.streamObject.doStream\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.streamObject.doStream\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.messages\": {\n                  input: () => stringifyForTelemetry(callOptions.prompt)\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                \"gen_ai.request.temperature\": callSettings.temperature,\n                \"gen_ai.request.top_k\": callSettings.topK,\n                \"gen_ai.request.top_p\": callSettings.topP\n              }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async (doStreamSpan2) => ({\n              startTimestampMs: now2(),\n              doStreamSpan: doStreamSpan2,\n              result: await model.doStream(callOptions)\n            })\n          })\n        );\n        self._request.resolve(request != null ? request : {});\n        let warnings;\n        let usage = {\n          inputTokens: void 0,\n          outputTokens: void 0,\n          totalTokens: void 0\n        };\n        let finishReason;\n        let providerMetadata;\n        let object2;\n        let error;\n        let accumulatedText = \"\";\n        let textDelta = \"\";\n        let fullResponse = {\n          id: generateId3(),\n          timestamp: currentDate(),\n          modelId: model.modelId\n        };\n        let latestObjectJson = void 0;\n        let latestObject = void 0;\n        let isFirstChunk = true;\n        let isFirstDelta = true;\n        const transformedStream = stream.pipeThrough(new TransformStream(transformer)).pipeThrough(\n          new TransformStream({\n            async transform(chunk, controller) {\n              var _a17, _b, _c;\n              if (typeof chunk === \"object\" && chunk.type === \"stream-start\") {\n                warnings = chunk.warnings;\n                return;\n              }\n              if (isFirstChunk) {\n                const msToFirstChunk = now2() - startTimestampMs;\n                isFirstChunk = false;\n                doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n                doStreamSpan.setAttributes({\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n              }\n              if (typeof chunk === \"string\") {\n                accumulatedText += chunk;\n                textDelta += chunk;\n                const { value: currentObjectJson, state: parseState } = await parsePartialJson(accumulatedText);\n                if (currentObjectJson !== void 0 && !isDeepEqualData(latestObjectJson, currentObjectJson)) {\n                  const validationResult = await outputStrategy.validatePartialResult({\n                    value: currentObjectJson,\n                    textDelta,\n                    latestObject,\n                    isFirstDelta,\n                    isFinalDelta: parseState === \"successful-parse\"\n                  });\n                  if (validationResult.success && !isDeepEqualData(\n                    latestObject,\n                    validationResult.value.partial\n                  )) {\n                    latestObjectJson = currentObjectJson;\n                    latestObject = validationResult.value.partial;\n                    controller.enqueue({\n                      type: \"object\",\n                      object: latestObject\n                    });\n                    controller.enqueue({\n                      type: \"text-delta\",\n                      textDelta: validationResult.value.textDelta\n                    });\n                    textDelta = \"\";\n                    isFirstDelta = false;\n                  }\n                }\n                return;\n              }\n              switch (chunk.type) {\n                case \"response-metadata\": {\n                  fullResponse = {\n                    id: (_a17 = chunk.id) != null ? _a17 : fullResponse.id,\n                    timestamp: (_b = chunk.timestamp) != null ? _b : fullResponse.timestamp,\n                    modelId: (_c = chunk.modelId) != null ? _c : fullResponse.modelId\n                  };\n                  break;\n                }\n                case \"finish\": {\n                  if (textDelta !== \"\") {\n                    controller.enqueue({ type: \"text-delta\", textDelta });\n                  }\n                  finishReason = chunk.finishReason;\n                  usage = chunk.usage;\n                  providerMetadata = chunk.providerMetadata;\n                  controller.enqueue({\n                    ...chunk,\n                    usage,\n                    response: fullResponse\n                  });\n                  logWarnings(warnings != null ? warnings : []);\n                  self._usage.resolve(usage);\n                  self._providerMetadata.resolve(providerMetadata);\n                  self._warnings.resolve(warnings);\n                  self._response.resolve({\n                    ...fullResponse,\n                    headers: response == null ? void 0 : response.headers\n                  });\n                  self._finishReason.resolve(finishReason != null ? finishReason : \"unknown\");\n                  try {\n                    object2 = await parseAndValidateObjectResultWithRepair(\n                      accumulatedText,\n                      outputStrategy,\n                      repairText,\n                      {\n                        response: fullResponse,\n                        usage,\n                        finishReason\n                      }\n                    );\n                    self._object.resolve(object2);\n                  } catch (e) {\n                    error = e;\n                    self._object.reject(e);\n                  }\n                  break;\n                }\n                default: {\n                  controller.enqueue(chunk);\n                  break;\n                }\n              }\n            },\n            // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n            async flush(controller) {\n              try {\n                const finalUsage = usage != null ? usage : {\n                  promptTokens: NaN,\n                  completionTokens: NaN,\n                  totalTokens: NaN\n                };\n                doStreamSpan.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": finishReason,\n                      \"ai.response.object\": {\n                        output: () => JSON.stringify(object2)\n                      },\n                      \"ai.response.id\": fullResponse.id,\n                      \"ai.response.model\": fullResponse.modelId,\n                      \"ai.response.timestamp\": fullResponse.timestamp.toISOString(),\n                      \"ai.response.providerMetadata\": JSON.stringify(providerMetadata),\n                      \"ai.usage.inputTokens\": finalUsage.inputTokens,\n                      \"ai.usage.outputTokens\": finalUsage.outputTokens,\n                      \"ai.usage.totalTokens\": finalUsage.totalTokens,\n                      \"ai.usage.reasoningTokens\": finalUsage.reasoningTokens,\n                      \"ai.usage.cachedInputTokens\": finalUsage.cachedInputTokens,\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [finishReason],\n                      \"gen_ai.response.id\": fullResponse.id,\n                      \"gen_ai.response.model\": fullResponse.modelId,\n                      \"gen_ai.usage.input_tokens\": finalUsage.inputTokens,\n                      \"gen_ai.usage.output_tokens\": finalUsage.outputTokens\n                    }\n                  })\n                );\n                doStreamSpan.end();\n                rootSpan.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.usage.inputTokens\": finalUsage.inputTokens,\n                      \"ai.usage.outputTokens\": finalUsage.outputTokens,\n                      \"ai.usage.totalTokens\": finalUsage.totalTokens,\n                      \"ai.usage.reasoningTokens\": finalUsage.reasoningTokens,\n                      \"ai.usage.cachedInputTokens\": finalUsage.cachedInputTokens,\n                      \"ai.response.object\": {\n                        output: () => JSON.stringify(object2)\n                      },\n                      \"ai.response.providerMetadata\": JSON.stringify(providerMetadata)\n                    }\n                  })\n                );\n                await (onFinish == null ? void 0 : onFinish({\n                  usage: finalUsage,\n                  object: object2,\n                  error,\n                  response: {\n                    ...fullResponse,\n                    headers: response == null ? void 0 : response.headers\n                  },\n                  warnings,\n                  providerMetadata\n                }));\n              } catch (error2) {\n                controller.enqueue({ type: \"error\", error: error2 });\n              } finally {\n                rootSpan.end();\n              }\n            }\n          })\n        );\n        stitchableStream.addStream(transformedStream);\n      }\n    }).catch((error) => {\n      stitchableStream.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: \"error\", error });\n            controller.close();\n          }\n        })\n      );\n    }).finally(() => {\n      stitchableStream.close();\n    });\n    this.outputStrategy = outputStrategy;\n  }\n  get object() {\n    return this._object.promise;\n  }\n  get usage() {\n    return this._usage.promise;\n  }\n  get providerMetadata() {\n    return this._providerMetadata.promise;\n  }\n  get warnings() {\n    return this._warnings.promise;\n  }\n  get request() {\n    return this._request.promise;\n  }\n  get response() {\n    return this._response.promise;\n  }\n  get finishReason() {\n    return this._finishReason.promise;\n  }\n  get partialObjectStream() {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case \"object\":\n                controller.enqueue(chunk.object);\n                break;\n              case \"text-delta\":\n              case \"finish\":\n              case \"error\":\n                break;\n              default: {\n                const _exhaustiveCheck = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          }\n        })\n      )\n    );\n  }\n  get elementStream() {\n    return this.outputStrategy.createElementStream(this.baseStream);\n  }\n  get textStream() {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case \"text-delta\":\n                controller.enqueue(chunk.textDelta);\n                break;\n              case \"object\":\n              case \"finish\":\n              case \"error\":\n                break;\n              default: {\n                const _exhaustiveCheck = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          }\n        })\n      )\n    );\n  }\n  get fullStream() {\n    return createAsyncIterableStream(this.baseStream);\n  }\n  pipeTextStreamToResponse(response, init) {\n    pipeTextStreamToResponse({\n      response,\n      textStream: this.textStream,\n      ...init\n    });\n  }\n  toTextStreamResponse(init) {\n    return createTextStreamResponse({\n      textStream: this.textStream,\n      ...init\n    });\n  }\n};\n\n// src/error/no-speech-generated-error.ts\n\nvar NoSpeechGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor(options) {\n    super({\n      name: \"AI_NoSpeechGeneratedError\",\n      message: \"No speech audio generated.\"\n    });\n    this.responses = options.responses;\n  }\n};\n\n// src/generate-speech/generated-audio-file.ts\nvar DefaultGeneratedAudioFile = class extends DefaultGeneratedFile {\n  constructor({\n    data,\n    mediaType\n  }) {\n    super({ data, mediaType });\n    let format = \"mp3\";\n    if (mediaType) {\n      const mediaTypeParts = mediaType.split(\"/\");\n      if (mediaTypeParts.length === 2) {\n        if (mediaType !== \"audio/mpeg\") {\n          format = mediaTypeParts[1];\n        }\n      }\n    }\n    if (!format) {\n      throw new Error(\n        \"Audio format must be provided or determinable from media type\"\n      );\n    }\n    this.format = format;\n  }\n};\n\n// src/generate-speech/generate-speech.ts\nasync function generateSpeech({\n  model,\n  text: text2,\n  voice,\n  outputFormat,\n  instructions,\n  speed,\n  language,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  var _a17;\n  if (model.specificationVersion !== \"v2\") {\n    throw new UnsupportedModelVersionError({\n      version: model.specificationVersion,\n      provider: model.provider,\n      modelId: model.modelId\n    });\n  }\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const result = await retry(\n    () => model.doGenerate({\n      text: text2,\n      voice,\n      outputFormat,\n      instructions,\n      speed,\n      language,\n      abortSignal,\n      headers,\n      providerOptions\n    })\n  );\n  if (!result.audio || result.audio.length === 0) {\n    throw new NoSpeechGeneratedError({ responses: [result.response] });\n  }\n  logWarnings(result.warnings);\n  return new DefaultSpeechResult({\n    audio: new DefaultGeneratedAudioFile({\n      data: result.audio,\n      mediaType: (_a17 = detectMediaType({\n        data: result.audio,\n        signatures: audioMediaTypeSignatures\n      })) != null ? _a17 : \"audio/mp3\"\n    }),\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata\n  });\n}\nvar DefaultSpeechResult = class {\n  constructor(options) {\n    var _a17;\n    this.audio = options.audio;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = (_a17 = options.providerMetadata) != null ? _a17 : {};\n  }\n};\n\n// src/generate-text/output.ts\nvar output_exports = {};\n__export(output_exports, {\n  object: () => object,\n  text: () => text\n});\n\nvar text = () => ({\n  type: \"text\",\n  responseFormat: { type: \"text\" },\n  async parsePartial({ text: text2 }) {\n    return { partial: text2 };\n  },\n  async parseOutput({ text: text2 }) {\n    return text2;\n  }\n});\nvar object = ({\n  schema: inputSchema\n}) => {\n  const schema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(inputSchema);\n  return {\n    type: \"object\",\n    responseFormat: {\n      type: \"json\",\n      schema: schema.jsonSchema\n    },\n    async parsePartial({ text: text2 }) {\n      const result = await parsePartialJson(text2);\n      switch (result.state) {\n        case \"failed-parse\":\n        case \"undefined-input\":\n          return void 0;\n        case \"repaired-parse\":\n        case \"successful-parse\":\n          return {\n            // Note: currently no validation of partial results:\n            partial: result.value\n          };\n        default: {\n          const _exhaustiveCheck = result.state;\n          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    async parseOutput({ text: text2 }, context) {\n      const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: text2 });\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: could not parse the response.\",\n          cause: parseResult.error,\n          text: text2,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason\n        });\n      }\n      const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n        value: parseResult.value,\n        schema\n      });\n      if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: response did not match schema.\",\n          cause: validationResult.error,\n          text: text2,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason\n        });\n      }\n      return validationResult.value;\n    }\n  };\n};\n\n// src/generate-text/smooth-stream.ts\n\n\nvar CHUNKING_REGEXPS = {\n  word: /\\S+\\s+/m,\n  line: /\\n+/m\n};\nfunction smoothStream({\n  delayInMs = 10,\n  chunking = \"word\",\n  _internal: { delay: delay2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay } = {}\n} = {}) {\n  let detectChunk;\n  if (typeof chunking === \"function\") {\n    detectChunk = (buffer) => {\n      const match = chunking(buffer);\n      if (match == null) {\n        return null;\n      }\n      if (!match.length) {\n        throw new Error(`Chunking function must return a non-empty string.`);\n      }\n      if (!buffer.startsWith(match)) {\n        throw new Error(\n          `Chunking function must return a match that is a prefix of the buffer. Received: \"${match}\" expected to start with \"${buffer}\"`\n        );\n      }\n      return match;\n    };\n  } else {\n    const chunkingRegex = typeof chunking === \"string\" ? CHUNKING_REGEXPS[chunking] : chunking;\n    if (chunkingRegex == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError({\n        argument: \"chunking\",\n        message: `Chunking must be \"word\" or \"line\" or a RegExp. Received: ${chunking}`\n      });\n    }\n    detectChunk = (buffer) => {\n      const match = chunkingRegex.exec(buffer);\n      if (!match) {\n        return null;\n      }\n      return buffer.slice(0, match.index) + (match == null ? void 0 : match[0]);\n    };\n  }\n  return () => {\n    let buffer = \"\";\n    let id = \"\";\n    return new TransformStream({\n      async transform(chunk, controller) {\n        if (chunk.type !== \"text-delta\") {\n          if (buffer.length > 0) {\n            controller.enqueue({ type: \"text-delta\", text: buffer, id });\n            buffer = \"\";\n          }\n          controller.enqueue(chunk);\n          return;\n        }\n        if (chunk.id !== id && buffer.length > 0) {\n          controller.enqueue({ type: \"text-delta\", text: buffer, id });\n          buffer = \"\";\n        }\n        buffer += chunk.text;\n        id = chunk.id;\n        let match;\n        while ((match = detectChunk(buffer)) != null) {\n          controller.enqueue({ type: \"text-delta\", text: match, id });\n          buffer = buffer.slice(match.length);\n          await delay2(delayInMs);\n        }\n      }\n    });\n  };\n}\n\n// src/middleware/default-settings-middleware.ts\nfunction defaultSettingsMiddleware({\n  settings\n}) {\n  return {\n    middlewareVersion: \"v2\",\n    transformParams: async ({ params }) => {\n      return mergeObjects(settings, params);\n    }\n  };\n}\n\n// src/util/get-potential-start-index.ts\nfunction getPotentialStartIndex(text2, searchedText) {\n  if (searchedText.length === 0) {\n    return null;\n  }\n  const directIndex = text2.indexOf(searchedText);\n  if (directIndex !== -1) {\n    return directIndex;\n  }\n  for (let i = text2.length - 1; i >= 0; i--) {\n    const suffix = text2.substring(i);\n    if (searchedText.startsWith(suffix)) {\n      return i;\n    }\n  }\n  return null;\n}\n\n// src/middleware/extract-reasoning-middleware.ts\nfunction extractReasoningMiddleware({\n  tagName,\n  separator = \"\\n\",\n  startWithReasoning = false\n}) {\n  const openingTag = `<${tagName}>`;\n  const closingTag = `</${tagName}>`;\n  return {\n    middlewareVersion: \"v2\",\n    wrapGenerate: async ({ doGenerate }) => {\n      const { content, ...rest } = await doGenerate();\n      const transformedContent = [];\n      for (const part of content) {\n        if (part.type !== \"text\") {\n          transformedContent.push(part);\n          continue;\n        }\n        const text2 = startWithReasoning ? openingTag + part.text : part.text;\n        const regexp = new RegExp(`${openingTag}(.*?)${closingTag}`, \"gs\");\n        const matches = Array.from(text2.matchAll(regexp));\n        if (!matches.length) {\n          transformedContent.push(part);\n          continue;\n        }\n        const reasoningText = matches.map((match) => match[1]).join(separator);\n        let textWithoutReasoning = text2;\n        for (let i = matches.length - 1; i >= 0; i--) {\n          const match = matches[i];\n          const beforeMatch = textWithoutReasoning.slice(0, match.index);\n          const afterMatch = textWithoutReasoning.slice(\n            match.index + match[0].length\n          );\n          textWithoutReasoning = beforeMatch + (beforeMatch.length > 0 && afterMatch.length > 0 ? separator : \"\") + afterMatch;\n        }\n        transformedContent.push({\n          type: \"reasoning\",\n          text: reasoningText\n        });\n        transformedContent.push({\n          type: \"text\",\n          text: textWithoutReasoning\n        });\n      }\n      return { content: transformedContent, ...rest };\n    },\n    wrapStream: async ({ doStream }) => {\n      const { stream, ...rest } = await doStream();\n      const reasoningExtractions = {};\n      let delayedTextStart;\n      return {\n        stream: stream.pipeThrough(\n          new TransformStream({\n            transform: (chunk, controller) => {\n              if (chunk.type === \"text-start\") {\n                delayedTextStart = chunk;\n                return;\n              }\n              if (chunk.type === \"text-end\" && delayedTextStart) {\n                controller.enqueue(delayedTextStart);\n                delayedTextStart = void 0;\n              }\n              if (chunk.type !== \"text-delta\") {\n                controller.enqueue(chunk);\n                return;\n              }\n              if (reasoningExtractions[chunk.id] == null) {\n                reasoningExtractions[chunk.id] = {\n                  isFirstReasoning: true,\n                  isFirstText: true,\n                  afterSwitch: false,\n                  isReasoning: startWithReasoning,\n                  buffer: \"\",\n                  idCounter: 0,\n                  textId: chunk.id\n                };\n              }\n              const activeExtraction = reasoningExtractions[chunk.id];\n              activeExtraction.buffer += chunk.delta;\n              function publish(text2) {\n                if (text2.length > 0) {\n                  const prefix = activeExtraction.afterSwitch && (activeExtraction.isReasoning ? !activeExtraction.isFirstReasoning : !activeExtraction.isFirstText) ? separator : \"\";\n                  if (activeExtraction.isReasoning && (activeExtraction.afterSwitch || activeExtraction.isFirstReasoning)) {\n                    controller.enqueue({\n                      type: \"reasoning-start\",\n                      id: `reasoning-${activeExtraction.idCounter}`\n                    });\n                  }\n                  if (activeExtraction.isReasoning) {\n                    controller.enqueue({\n                      type: \"reasoning-delta\",\n                      delta: prefix + text2,\n                      id: `reasoning-${activeExtraction.idCounter}`\n                    });\n                  } else {\n                    if (delayedTextStart) {\n                      controller.enqueue(delayedTextStart);\n                      delayedTextStart = void 0;\n                    }\n                    controller.enqueue({\n                      type: \"text-delta\",\n                      delta: prefix + text2,\n                      id: activeExtraction.textId\n                    });\n                  }\n                  activeExtraction.afterSwitch = false;\n                  if (activeExtraction.isReasoning) {\n                    activeExtraction.isFirstReasoning = false;\n                  } else {\n                    activeExtraction.isFirstText = false;\n                  }\n                }\n              }\n              do {\n                const nextTag = activeExtraction.isReasoning ? closingTag : openingTag;\n                const startIndex = getPotentialStartIndex(\n                  activeExtraction.buffer,\n                  nextTag\n                );\n                if (startIndex == null) {\n                  publish(activeExtraction.buffer);\n                  activeExtraction.buffer = \"\";\n                  break;\n                }\n                publish(activeExtraction.buffer.slice(0, startIndex));\n                const foundFullMatch = startIndex + nextTag.length <= activeExtraction.buffer.length;\n                if (foundFullMatch) {\n                  activeExtraction.buffer = activeExtraction.buffer.slice(\n                    startIndex + nextTag.length\n                  );\n                  if (activeExtraction.isReasoning) {\n                    controller.enqueue({\n                      type: \"reasoning-end\",\n                      id: `reasoning-${activeExtraction.idCounter++}`\n                    });\n                  }\n                  activeExtraction.isReasoning = !activeExtraction.isReasoning;\n                  activeExtraction.afterSwitch = true;\n                } else {\n                  activeExtraction.buffer = activeExtraction.buffer.slice(startIndex);\n                  break;\n                }\n              } while (true);\n            }\n          })\n        ),\n        ...rest\n      };\n    }\n  };\n}\n\n// src/middleware/simulate-streaming-middleware.ts\nfunction simulateStreamingMiddleware() {\n  return {\n    middlewareVersion: \"v2\",\n    wrapStream: async ({ doGenerate }) => {\n      const result = await doGenerate();\n      let id = 0;\n      const simulatedStream = new ReadableStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"stream-start\",\n            warnings: result.warnings\n          });\n          controller.enqueue({ type: \"response-metadata\", ...result.response });\n          for (const part of result.content) {\n            switch (part.type) {\n              case \"text\": {\n                if (part.text.length > 0) {\n                  controller.enqueue({ type: \"text-start\", id: String(id) });\n                  controller.enqueue({\n                    type: \"text-delta\",\n                    id: String(id),\n                    delta: part.text\n                  });\n                  controller.enqueue({ type: \"text-end\", id: String(id) });\n                  id++;\n                }\n                break;\n              }\n              case \"reasoning\": {\n                controller.enqueue({\n                  type: \"reasoning-start\",\n                  id: String(id),\n                  providerMetadata: part.providerMetadata\n                });\n                controller.enqueue({\n                  type: \"reasoning-delta\",\n                  id: String(id),\n                  delta: part.text\n                });\n                controller.enqueue({ type: \"reasoning-end\", id: String(id) });\n                id++;\n                break;\n              }\n              default: {\n                controller.enqueue(part);\n                break;\n              }\n            }\n          }\n          controller.enqueue({\n            type: \"finish\",\n            finishReason: result.finishReason,\n            usage: result.usage,\n            providerMetadata: result.providerMetadata\n          });\n          controller.close();\n        }\n      });\n      return {\n        stream: simulatedStream,\n        request: result.request,\n        response: result.response\n      };\n    }\n  };\n}\n\n// src/middleware/wrap-language-model.ts\nvar wrapLanguageModel = ({\n  model,\n  middleware: middlewareArg,\n  modelId,\n  providerId\n}) => {\n  return asArray(middlewareArg).reverse().reduce((wrappedModel, middleware) => {\n    return doWrap({ model: wrappedModel, middleware, modelId, providerId });\n  }, model);\n};\nvar doWrap = ({\n  model,\n  middleware: {\n    transformParams,\n    wrapGenerate,\n    wrapStream,\n    overrideProvider,\n    overrideModelId,\n    overrideSupportedUrls\n  },\n  modelId,\n  providerId\n}) => {\n  var _a17, _b, _c;\n  async function doTransform({\n    params,\n    type\n  }) {\n    return transformParams ? await transformParams({ params, type, model }) : params;\n  }\n  return {\n    specificationVersion: \"v2\",\n    provider: (_a17 = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({ model })) != null ? _a17 : model.provider,\n    modelId: (_b = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({ model })) != null ? _b : model.modelId,\n    supportedUrls: (_c = overrideSupportedUrls == null ? void 0 : overrideSupportedUrls({ model })) != null ? _c : model.supportedUrls,\n    async doGenerate(params) {\n      const transformedParams = await doTransform({ params, type: \"generate\" });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapGenerate ? wrapGenerate({\n        doGenerate,\n        doStream,\n        params: transformedParams,\n        model\n      }) : doGenerate();\n    },\n    async doStream(params) {\n      const transformedParams = await doTransform({ params, type: \"stream\" });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapStream ? wrapStream({ doGenerate, doStream, params: transformedParams, model }) : doStream();\n    }\n  };\n};\n\n// src/middleware/wrap-provider.ts\nfunction wrapProvider({\n  provider,\n  languageModelMiddleware\n}) {\n  const wrappedProvider = {\n    languageModel(modelId) {\n      let model = provider.languageModel(modelId);\n      model = wrapLanguageModel({\n        model,\n        middleware: languageModelMiddleware\n      });\n      return model;\n    },\n    textEmbeddingModel: provider.textEmbeddingModel,\n    imageModel: provider.imageModel,\n    transcriptionModel: provider.transcriptionModel,\n    speechModel: provider.speechModel\n  };\n  return wrappedProvider;\n}\n\n// src/registry/custom-provider.ts\n\nfunction customProvider({\n  languageModels,\n  textEmbeddingModels,\n  imageModels,\n  transcriptionModels,\n  speechModels,\n  fallbackProvider\n}) {\n  return {\n    languageModel(modelId) {\n      if (languageModels != null && modelId in languageModels) {\n        return languageModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.languageModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"languageModel\" });\n    },\n    textEmbeddingModel(modelId) {\n      if (textEmbeddingModels != null && modelId in textEmbeddingModels) {\n        return textEmbeddingModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.textEmbeddingModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"textEmbeddingModel\" });\n    },\n    imageModel(modelId) {\n      if (imageModels != null && modelId in imageModels) {\n        return imageModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.imageModel) {\n        return fallbackProvider.imageModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"imageModel\" });\n    },\n    transcriptionModel(modelId) {\n      if (transcriptionModels != null && modelId in transcriptionModels) {\n        return transcriptionModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.transcriptionModel) {\n        return fallbackProvider.transcriptionModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"transcriptionModel\" });\n    },\n    speechModel(modelId) {\n      if (speechModels != null && modelId in speechModels) {\n        return speechModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.speechModel) {\n        return fallbackProvider.speechModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"speechModel\" });\n    }\n  };\n}\nvar experimental_customProvider = customProvider;\n\n// src/registry/no-such-provider-error.ts\n\nvar name16 = \"AI_NoSuchProviderError\";\nvar marker16 = `vercel.ai.error.${name16}`;\nvar symbol16 = Symbol.for(marker16);\nvar _a16;\nvar NoSuchProviderError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError {\n  constructor({\n    modelId,\n    modelType,\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`\n  }) {\n    super({ errorName: name16, modelId, modelType, message });\n    this[_a16] = true;\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker16);\n  }\n};\n_a16 = symbol16;\n\n// src/registry/provider-registry.ts\n\nfunction createProviderRegistry(providers, {\n  separator = \":\",\n  languageModelMiddleware\n} = {}) {\n  const registry = new DefaultProviderRegistry({\n    separator,\n    languageModelMiddleware\n  });\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider });\n  }\n  return registry;\n}\nvar experimental_createProviderRegistry = createProviderRegistry;\nvar DefaultProviderRegistry = class {\n  constructor({\n    separator,\n    languageModelMiddleware\n  }) {\n    this.providers = {};\n    this.separator = separator;\n    this.languageModelMiddleware = languageModelMiddleware;\n  }\n  registerProvider({\n    id,\n    provider\n  }) {\n    this.providers[id] = provider;\n  }\n  getProvider(id, modelType) {\n    const provider = this.providers[id];\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        modelId: id,\n        modelType,\n        providerId: id,\n        availableProviders: Object.keys(this.providers)\n      });\n    }\n    return provider;\n  }\n  splitId(id, modelType) {\n    const index = id.indexOf(this.separator);\n    if (index === -1) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType,\n        message: `Invalid ${modelType} id for registry: ${id} (must be in the format \"providerId${this.separator}modelId\")`\n      });\n    }\n    return [id.slice(0, index), id.slice(index + this.separator.length)];\n  }\n  languageModel(id) {\n    var _a17, _b;\n    const [providerId, modelId] = this.splitId(id, \"languageModel\");\n    let model = (_b = (_a17 = this.getProvider(providerId, \"languageModel\")).languageModel) == null ? void 0 : _b.call(\n      _a17,\n      modelId\n    );\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"languageModel\" });\n    }\n    if (this.languageModelMiddleware != null) {\n      model = wrapLanguageModel({\n        model,\n        middleware: this.languageModelMiddleware\n      });\n    }\n    return model;\n  }\n  textEmbeddingModel(id) {\n    var _a17;\n    const [providerId, modelId] = this.splitId(id, \"textEmbeddingModel\");\n    const provider = this.getProvider(providerId, \"textEmbeddingModel\");\n    const model = (_a17 = provider.textEmbeddingModel) == null ? void 0 : _a17.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType: \"textEmbeddingModel\"\n      });\n    }\n    return model;\n  }\n  imageModel(id) {\n    var _a17;\n    const [providerId, modelId] = this.splitId(id, \"imageModel\");\n    const provider = this.getProvider(providerId, \"imageModel\");\n    const model = (_a17 = provider.imageModel) == null ? void 0 : _a17.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"imageModel\" });\n    }\n    return model;\n  }\n  transcriptionModel(id) {\n    var _a17;\n    const [providerId, modelId] = this.splitId(id, \"transcriptionModel\");\n    const provider = this.getProvider(providerId, \"transcriptionModel\");\n    const model = (_a17 = provider.transcriptionModel) == null ? void 0 : _a17.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType: \"transcriptionModel\"\n      });\n    }\n    return model;\n  }\n  speechModel(id) {\n    var _a17;\n    const [providerId, modelId] = this.splitId(id, \"speechModel\");\n    const provider = this.getProvider(providerId, \"speechModel\");\n    const model = (_a17 = provider.speechModel) == null ? void 0 : _a17.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"speechModel\" });\n    }\n    return model;\n  }\n};\n\n// src/tool/mcp/mcp-client.ts\n\n\n// src/tool/mcp/mcp-sse-transport.ts\n\n\n// src/tool/mcp/json-rpc-message.ts\n\n\n// src/tool/mcp/types.ts\n\nvar LATEST_PROTOCOL_VERSION = \"2025-06-18\";\nvar SUPPORTED_PROTOCOL_VERSIONS = [\n  LATEST_PROTOCOL_VERSION,\n  \"2025-03-26\",\n  \"2024-11-05\"\n];\nvar ClientOrServerImplementationSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.looseObject({\n  name: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  version: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n});\nvar BaseParamsSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.looseObject({\n  _meta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({}).loose())\n});\nvar ResultSchema = BaseParamsSchema;\nvar RequestSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  method: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  params: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(BaseParamsSchema)\n});\nvar ServerCapabilitiesSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.looseObject({\n  experimental: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({}).loose()),\n  logging: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({}).loose()),\n  prompts: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.looseObject({\n      listChanged: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean())\n    })\n  ),\n  resources: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.looseObject({\n      subscribe: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean()),\n      listChanged: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean())\n    })\n  ),\n  tools: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.looseObject({\n      listChanged: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean())\n    })\n  )\n});\nvar InitializeResultSchema = ResultSchema.extend({\n  protocolVersion: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  capabilities: ServerCapabilitiesSchema,\n  serverInfo: ClientOrServerImplementationSchema,\n  instructions: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string())\n});\nvar PaginatedResultSchema = ResultSchema.extend({\n  nextCursor: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string())\n});\nvar ToolSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  name: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  description: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()),\n  inputSchema: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"object\"),\n    properties: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({}).loose())\n  }).loose()\n}).loose();\nvar ListToolsResultSchema = PaginatedResultSchema.extend({\n  tools: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(ToolSchema)\n});\nvar TextContentSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n}).loose();\nvar ImageContentSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"image\"),\n  data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.base64(),\n  mimeType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n}).loose();\nvar ResourceContentsSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  /**\n   * The URI of this resource.\n   */\n  uri: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  /**\n   * The MIME type of this resource, if known.\n   */\n  mimeType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string())\n}).loose();\nvar TextResourceContentsSchema = ResourceContentsSchema.extend({\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n});\nvar BlobResourceContentsSchema = ResourceContentsSchema.extend({\n  blob: zod_v4__WEBPACK_IMPORTED_MODULE_3__.base64()\n});\nvar EmbeddedResourceSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"resource\"),\n  resource: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([TextResourceContentsSchema, BlobResourceContentsSchema])\n}).loose();\nvar CallToolResultSchema = ResultSchema.extend({\n  content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema])\n  ),\n  isError: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().default(false).optional()\n}).or(\n  ResultSchema.extend({\n    toolResult: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown()\n  })\n);\n\n// src/tool/mcp/json-rpc-message.ts\nvar JSONRPC_VERSION = \"2.0\";\nvar JSONRPCRequestSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  jsonrpc: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(JSONRPC_VERSION),\n  id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.number().int()])\n}).merge(RequestSchema).strict();\nvar JSONRPCResponseSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  jsonrpc: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(JSONRPC_VERSION),\n  id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.number().int()]),\n  result: ResultSchema\n}).strict();\nvar JSONRPCErrorSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  jsonrpc: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(JSONRPC_VERSION),\n  id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.number().int()]),\n  error: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    code: zod_v4__WEBPACK_IMPORTED_MODULE_3__.number().int(),\n    message: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown())\n  })\n}).strict();\nvar JSONRPCNotificationSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  jsonrpc: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(JSONRPC_VERSION)\n}).merge(\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    method: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    params: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(BaseParamsSchema)\n  })\n).strict();\nvar JSONRPCMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n  JSONRPCRequestSchema,\n  JSONRPCNotificationSchema,\n  JSONRPCResponseSchema,\n  JSONRPCErrorSchema\n]);\n\n// src/tool/mcp/mcp-sse-transport.ts\nvar SseMCPTransport = class {\n  constructor({\n    url,\n    headers\n  }) {\n    this.connected = false;\n    this.url = new URL(url);\n    this.headers = headers;\n  }\n  async start() {\n    return new Promise((resolve2, reject) => {\n      if (this.connected) {\n        return resolve2();\n      }\n      this.abortController = new AbortController();\n      const establishConnection = async () => {\n        var _a17, _b, _c;\n        try {\n          const headers = new Headers(this.headers);\n          headers.set(\"Accept\", \"text/event-stream\");\n          const response = await fetch(this.url.href, {\n            headers,\n            signal: (_a17 = this.abortController) == null ? void 0 : _a17.signal\n          });\n          if (!response.ok || !response.body) {\n            const error = new MCPClientError({\n              message: `MCP SSE Transport Error: ${response.status} ${response.statusText}`\n            });\n            (_b = this.onerror) == null ? void 0 : _b.call(this, error);\n            return reject(error);\n          }\n          const stream = response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_6__.EventSourceParserStream());\n          const reader = stream.getReader();\n          const processEvents = async () => {\n            var _a18, _b2, _c2;\n            try {\n              while (true) {\n                const { done, value } = await reader.read();\n                if (done) {\n                  if (this.connected) {\n                    this.connected = false;\n                    throw new MCPClientError({\n                      message: \"MCP SSE Transport Error: Connection closed unexpectedly\"\n                    });\n                  }\n                  return;\n                }\n                const { event, data } = value;\n                if (event === \"endpoint\") {\n                  this.endpoint = new URL(data, this.url);\n                  if (this.endpoint.origin !== this.url.origin) {\n                    throw new MCPClientError({\n                      message: `MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`\n                    });\n                  }\n                  this.connected = true;\n                  resolve2();\n                } else if (event === \"message\") {\n                  try {\n                    const message = JSONRPCMessageSchema.parse(\n                      JSON.parse(data)\n                    );\n                    (_a18 = this.onmessage) == null ? void 0 : _a18.call(this, message);\n                  } catch (error) {\n                    const e = new MCPClientError({\n                      message: \"MCP SSE Transport Error: Failed to parse message\",\n                      cause: error\n                    });\n                    (_b2 = this.onerror) == null ? void 0 : _b2.call(this, e);\n                  }\n                }\n              }\n            } catch (error) {\n              if (error instanceof Error && error.name === \"AbortError\") {\n                return;\n              }\n              (_c2 = this.onerror) == null ? void 0 : _c2.call(this, error);\n              reject(error);\n            }\n          };\n          this.sseConnection = {\n            close: () => reader.cancel()\n          };\n          processEvents();\n        } catch (error) {\n          if (error instanceof Error && error.name === \"AbortError\") {\n            return;\n          }\n          (_c = this.onerror) == null ? void 0 : _c.call(this, error);\n          reject(error);\n        }\n      };\n      establishConnection();\n    });\n  }\n  async close() {\n    var _a17, _b, _c;\n    this.connected = false;\n    (_a17 = this.sseConnection) == null ? void 0 : _a17.close();\n    (_b = this.abortController) == null ? void 0 : _b.abort();\n    (_c = this.onclose) == null ? void 0 : _c.call(this);\n  }\n  async send(message) {\n    var _a17, _b, _c;\n    if (!this.endpoint || !this.connected) {\n      throw new MCPClientError({\n        message: \"MCP SSE Transport Error: Not connected\"\n      });\n    }\n    try {\n      const headers = new Headers(this.headers);\n      headers.set(\"Content-Type\", \"application/json\");\n      const init = {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(message),\n        signal: (_a17 = this.abortController) == null ? void 0 : _a17.signal\n      };\n      const response = await fetch(this.endpoint, init);\n      if (!response.ok) {\n        const text2 = await response.text().catch(() => null);\n        const error = new MCPClientError({\n          message: `MCP SSE Transport Error: POSTing to endpoint (HTTP ${response.status}): ${text2}`\n        });\n        (_b = this.onerror) == null ? void 0 : _b.call(this, error);\n        return;\n      }\n    } catch (error) {\n      (_c = this.onerror) == null ? void 0 : _c.call(this, error);\n      return;\n    }\n  }\n};\n\n// src/tool/mcp/mcp-transport.ts\nfunction createMcpTransport(config) {\n  if (config.type !== \"sse\") {\n    throw new MCPClientError({\n      message: \"Unsupported or invalid transport configuration. If you are using a custom transport, make sure it implements the MCPTransport interface.\"\n    });\n  }\n  return new SseMCPTransport(config);\n}\nfunction isCustomMcpTransport(transport) {\n  return \"start\" in transport && typeof transport.start === \"function\" && \"send\" in transport && typeof transport.send === \"function\" && \"close\" in transport && typeof transport.close === \"function\";\n}\n\n// src/tool/mcp/mcp-client.ts\nvar CLIENT_VERSION = \"1.0.0\";\nasync function createMCPClient(config) {\n  const client = new DefaultMCPClient(config);\n  await client.init();\n  return client;\n}\nvar DefaultMCPClient = class {\n  constructor({\n    transport: transportConfig,\n    name: name17 = \"ai-sdk-mcp-client\",\n    onUncaughtError\n  }) {\n    this.requestMessageId = 0;\n    this.responseHandlers = /* @__PURE__ */ new Map();\n    this.serverCapabilities = {};\n    this.isClosed = true;\n    this.onUncaughtError = onUncaughtError;\n    if (isCustomMcpTransport(transportConfig)) {\n      this.transport = transportConfig;\n    } else {\n      this.transport = createMcpTransport(transportConfig);\n    }\n    this.transport.onclose = () => this.onClose();\n    this.transport.onerror = (error) => this.onError(error);\n    this.transport.onmessage = (message) => {\n      if (\"method\" in message) {\n        this.onError(\n          new MCPClientError({\n            message: \"Unsupported message type\"\n          })\n        );\n        return;\n      }\n      this.onResponse(message);\n    };\n    this.clientInfo = {\n      name: name17,\n      version: CLIENT_VERSION\n    };\n  }\n  async init() {\n    try {\n      await this.transport.start();\n      this.isClosed = false;\n      const result = await this.request({\n        request: {\n          method: \"initialize\",\n          params: {\n            protocolVersion: LATEST_PROTOCOL_VERSION,\n            capabilities: {},\n            clientInfo: this.clientInfo\n          }\n        },\n        resultSchema: InitializeResultSchema\n      });\n      if (result === void 0) {\n        throw new MCPClientError({\n          message: \"Server sent invalid initialize result\"\n        });\n      }\n      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {\n        throw new MCPClientError({\n          message: `Server's protocol version is not supported: ${result.protocolVersion}`\n        });\n      }\n      this.serverCapabilities = result.capabilities;\n      await this.notification({\n        method: \"notifications/initialized\"\n      });\n      return this;\n    } catch (error) {\n      await this.close();\n      throw error;\n    }\n  }\n  async close() {\n    var _a17;\n    if (this.isClosed)\n      return;\n    await ((_a17 = this.transport) == null ? void 0 : _a17.close());\n    this.onClose();\n  }\n  assertCapability(method) {\n    switch (method) {\n      case \"initialize\":\n        break;\n      case \"tools/list\":\n      case \"tools/call\":\n        if (!this.serverCapabilities.tools) {\n          throw new MCPClientError({\n            message: `Server does not support tools`\n          });\n        }\n        break;\n      default:\n        throw new MCPClientError({\n          message: `Unsupported method: ${method}`\n        });\n    }\n  }\n  async request({\n    request,\n    resultSchema,\n    options\n  }) {\n    return new Promise((resolve2, reject) => {\n      if (this.isClosed) {\n        return reject(\n          new MCPClientError({\n            message: \"Attempted to send a request from a closed client\"\n          })\n        );\n      }\n      this.assertCapability(request.method);\n      const signal = options == null ? void 0 : options.signal;\n      signal == null ? void 0 : signal.throwIfAborted();\n      const messageId = this.requestMessageId++;\n      const jsonrpcRequest = {\n        ...request,\n        jsonrpc: \"2.0\",\n        id: messageId\n      };\n      const cleanup = () => {\n        this.responseHandlers.delete(messageId);\n      };\n      this.responseHandlers.set(messageId, (response) => {\n        if (signal == null ? void 0 : signal.aborted) {\n          return reject(\n            new MCPClientError({\n              message: \"Request was aborted\",\n              cause: signal.reason\n            })\n          );\n        }\n        if (response instanceof Error) {\n          return reject(response);\n        }\n        try {\n          const result = resultSchema.parse(response.result);\n          resolve2(result);\n        } catch (error) {\n          const parseError = new MCPClientError({\n            message: \"Failed to parse server response\",\n            cause: error\n          });\n          reject(parseError);\n        }\n      });\n      this.transport.send(jsonrpcRequest).catch((error) => {\n        cleanup();\n        reject(error);\n      });\n    });\n  }\n  async listTools({\n    params,\n    options\n  } = {}) {\n    try {\n      return this.request({\n        request: { method: \"tools/list\", params },\n        resultSchema: ListToolsResultSchema,\n        options\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n  async callTool({\n    name: name17,\n    args,\n    options\n  }) {\n    try {\n      return this.request({\n        request: { method: \"tools/call\", params: { name: name17, arguments: args } },\n        resultSchema: CallToolResultSchema,\n        options: {\n          signal: options == null ? void 0 : options.abortSignal\n        }\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n  async notification(notification) {\n    const jsonrpcNotification = {\n      ...notification,\n      jsonrpc: \"2.0\"\n    };\n    await this.transport.send(jsonrpcNotification);\n  }\n  /**\n   * Returns a set of AI SDK tools from the MCP server\n   * @returns A record of tool names to their implementations\n   */\n  async tools({\n    schemas = \"automatic\"\n  } = {}) {\n    var _a17;\n    const tools = {};\n    try {\n      const listToolsResult = await this.listTools();\n      for (const { name: name17, description, inputSchema } of listToolsResult.tools) {\n        if (schemas !== \"automatic\" && !(name17 in schemas)) {\n          continue;\n        }\n        const self = this;\n        const execute = async (args, options) => {\n          var _a18;\n          (_a18 = options == null ? void 0 : options.abortSignal) == null ? void 0 : _a18.throwIfAborted();\n          return self.callTool({ name: name17, args, options });\n        };\n        const toolWithExecute = schemas === \"automatic\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.dynamicTool)({\n          description,\n          inputSchema: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.jsonSchema)({\n            ...inputSchema,\n            properties: (_a17 = inputSchema.properties) != null ? _a17 : {},\n            additionalProperties: false\n          }),\n          execute\n        }) : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.tool)({\n          description,\n          inputSchema: schemas[name17].inputSchema,\n          execute\n        });\n        tools[name17] = toolWithExecute;\n      }\n      return tools;\n    } catch (error) {\n      throw error;\n    }\n  }\n  onClose() {\n    if (this.isClosed)\n      return;\n    this.isClosed = true;\n    const error = new MCPClientError({\n      message: \"Connection closed\"\n    });\n    for (const handler of this.responseHandlers.values()) {\n      handler(error);\n    }\n    this.responseHandlers.clear();\n  }\n  onError(error) {\n    if (this.onUncaughtError) {\n      this.onUncaughtError(error);\n    }\n  }\n  onResponse(response) {\n    const messageId = Number(response.id);\n    const handler = this.responseHandlers.get(messageId);\n    if (handler === void 0) {\n      throw new MCPClientError({\n        message: `Protocol error: Received a response for an unknown message ID: ${JSON.stringify(\n          response\n        )}`\n      });\n    }\n    this.responseHandlers.delete(messageId);\n    handler(\n      \"result\" in response ? response : new MCPClientError({\n        message: response.error.message,\n        cause: response.error\n      })\n    );\n  }\n};\n\n// src/error/no-transcript-generated-error.ts\n\nvar NoTranscriptGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor(options) {\n    super({\n      name: \"AI_NoTranscriptGeneratedError\",\n      message: \"No transcript generated.\"\n    });\n    this.responses = options.responses;\n  }\n};\n\n// src/transcribe/transcribe.ts\nasync function transcribe({\n  model,\n  audio,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  if (model.specificationVersion !== \"v2\") {\n    throw new UnsupportedModelVersionError({\n      version: model.specificationVersion,\n      provider: model.provider,\n      modelId: model.modelId\n    });\n  }\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const audioData = audio instanceof URL ? (await download({ url: audio })).data : convertDataContentToUint8Array(audio);\n  const result = await retry(\n    () => {\n      var _a17;\n      return model.doGenerate({\n        audio: audioData,\n        abortSignal,\n        headers,\n        providerOptions,\n        mediaType: (_a17 = detectMediaType({\n          data: audioData,\n          signatures: audioMediaTypeSignatures\n        })) != null ? _a17 : \"audio/wav\"\n      });\n    }\n  );\n  logWarnings(result.warnings);\n  if (!result.text) {\n    throw new NoTranscriptGeneratedError({ responses: [result.response] });\n  }\n  return new DefaultTranscriptionResult({\n    text: result.text,\n    segments: result.segments,\n    language: result.language,\n    durationInSeconds: result.durationInSeconds,\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata\n  });\n}\nvar DefaultTranscriptionResult = class {\n  constructor(options) {\n    var _a17;\n    this.text = options.text;\n    this.segments = options.segments;\n    this.language = options.language;\n    this.durationInSeconds = options.durationInSeconds;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = (_a17 = options.providerMetadata) != null ? _a17 : {};\n  }\n};\n\n// src/ui/call-completion-api.ts\n\n\n// src/ui/process-text-stream.ts\nasync function processTextStream({\n  stream,\n  onTextPart\n}) {\n  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    await onTextPart(value);\n  }\n}\n\n// src/ui/call-completion-api.ts\nvar getOriginalFetch = () => fetch;\nasync function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = \"data\",\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onFinish,\n  onError,\n  fetch: fetch2 = getOriginalFetch()\n}) {\n  var _a17;\n  try {\n    setLoading(true);\n    setError(void 0);\n    const abortController = new AbortController();\n    setAbortController(abortController);\n    setCompletion(\"\");\n    const response = await fetch2(api, {\n      method: \"POST\",\n      body: JSON.stringify({\n        prompt,\n        ...body\n      }),\n      credentials,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      signal: abortController.signal\n    }).catch((err) => {\n      throw err;\n    });\n    if (!response.ok) {\n      throw new Error(\n        (_a17 = await response.text()) != null ? _a17 : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    let result = \"\";\n    switch (streamProtocol) {\n      case \"text\": {\n        await processTextStream({\n          stream: response.body,\n          onTextPart: (chunk) => {\n            result += chunk;\n            setCompletion(result);\n          }\n        });\n        break;\n      }\n      case \"data\": {\n        await consumeStream({\n          stream: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream)({\n            stream: response.body,\n            schema: uiMessageChunkSchema\n          }).pipeThrough(\n            new TransformStream({\n              async transform(part) {\n                if (!part.success) {\n                  throw part.error;\n                }\n                const streamPart = part.value;\n                if (streamPart.type === \"text-delta\") {\n                  result += streamPart.delta;\n                  setCompletion(result);\n                } else if (streamPart.type === \"error\") {\n                  throw new Error(streamPart.errorText);\n                }\n              }\n            })\n          ),\n          onError: (error) => {\n            throw error;\n          }\n        });\n        break;\n      }\n      default: {\n        const exhaustiveCheck = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n    }\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    if (err.name === \"AbortError\") {\n      setAbortController(null);\n      return null;\n    }\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n    setError(err);\n  } finally {\n    setLoading(false);\n  }\n}\n\n// src/ui/chat.ts\n\n\n// src/ui/convert-file-list-to-file-ui-parts.ts\nasync function convertFileListToFileUIParts(files) {\n  if (files == null) {\n    return [];\n  }\n  if (!globalThis.FileList || !(files instanceof globalThis.FileList)) {\n    throw new Error(\"FileList is not supported in the current environment\");\n  }\n  return Promise.all(\n    Array.from(files).map(async (file) => {\n      const { name: name17, type } = file;\n      const dataUrl = await new Promise((resolve2, reject) => {\n        const reader = new FileReader();\n        reader.onload = (readerEvent) => {\n          var _a17;\n          resolve2((_a17 = readerEvent.target) == null ? void 0 : _a17.result);\n        };\n        reader.onerror = (error) => reject(error);\n        reader.readAsDataURL(file);\n      });\n      return {\n        type: \"file\",\n        mediaType: type,\n        filename: name17,\n        url: dataUrl\n      };\n    })\n  );\n}\n\n// src/ui/default-chat-transport.ts\n\n\n// src/ui/http-chat-transport.ts\n\nvar HttpChatTransport = class {\n  constructor({\n    api = \"/api/chat\",\n    credentials,\n    headers,\n    body,\n    fetch: fetch2,\n    prepareSendMessagesRequest,\n    prepareReconnectToStreamRequest\n  }) {\n    this.api = api;\n    this.credentials = credentials;\n    this.headers = headers;\n    this.body = body;\n    this.fetch = fetch2;\n    this.prepareSendMessagesRequest = prepareSendMessagesRequest;\n    this.prepareReconnectToStreamRequest = prepareReconnectToStreamRequest;\n  }\n  async sendMessages({\n    abortSignal,\n    ...options\n  }) {\n    var _a17, _b, _c, _d, _e;\n    const resolvedBody = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.body);\n    const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.headers);\n    const resolvedCredentials = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.credentials);\n    const preparedRequest = await ((_a17 = this.prepareSendMessagesRequest) == null ? void 0 : _a17.call(this, {\n      api: this.api,\n      id: options.chatId,\n      messages: options.messages,\n      body: { ...resolvedBody, ...options.body },\n      headers: { ...resolvedHeaders, ...options.headers },\n      credentials: resolvedCredentials,\n      requestMetadata: options.metadata,\n      trigger: options.trigger,\n      messageId: options.messageId\n    }));\n    const api = (_b = preparedRequest == null ? void 0 : preparedRequest.api) != null ? _b : this.api;\n    const headers = (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? preparedRequest.headers : { ...resolvedHeaders, ...options.headers };\n    const body = (preparedRequest == null ? void 0 : preparedRequest.body) !== void 0 ? preparedRequest.body : {\n      ...resolvedBody,\n      ...options.body,\n      id: options.chatId,\n      messages: options.messages,\n      trigger: options.trigger,\n      messageId: options.messageId\n    };\n    const credentials = (_c = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _c : resolvedCredentials;\n    const fetch2 = (_d = this.fetch) != null ? _d : globalThis.fetch;\n    const response = await fetch2(api, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      body: JSON.stringify(body),\n      credentials,\n      signal: abortSignal\n    });\n    if (!response.ok) {\n      throw new Error(\n        (_e = await response.text()) != null ? _e : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    return this.processResponseStream(response.body);\n  }\n  async reconnectToStream(options) {\n    var _a17, _b, _c, _d, _e;\n    const resolvedBody = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.body);\n    const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.headers);\n    const resolvedCredentials = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.credentials);\n    const preparedRequest = await ((_a17 = this.prepareReconnectToStreamRequest) == null ? void 0 : _a17.call(this, {\n      api: this.api,\n      id: options.chatId,\n      body: { ...resolvedBody, ...options.body },\n      headers: { ...resolvedHeaders, ...options.headers },\n      credentials: resolvedCredentials,\n      requestMetadata: options.metadata\n    }));\n    const api = (_b = preparedRequest == null ? void 0 : preparedRequest.api) != null ? _b : `${this.api}/${options.chatId}/stream`;\n    const headers = (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? preparedRequest.headers : { ...resolvedHeaders, ...options.headers };\n    const credentials = (_c = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _c : resolvedCredentials;\n    const fetch2 = (_d = this.fetch) != null ? _d : globalThis.fetch;\n    const response = await fetch2(api, {\n      method: \"GET\",\n      headers,\n      credentials\n    });\n    if (response.status === 204) {\n      return null;\n    }\n    if (!response.ok) {\n      throw new Error(\n        (_e = await response.text()) != null ? _e : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    return this.processResponseStream(response.body);\n  }\n};\n\n// src/ui/default-chat-transport.ts\nvar DefaultChatTransport = class extends HttpChatTransport {\n  constructor(options = {}) {\n    super(options);\n  }\n  processResponseStream(stream) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream)({\n      stream,\n      schema: uiMessageChunkSchema\n    }).pipeThrough(\n      new TransformStream({\n        async transform(chunk, controller) {\n          if (!chunk.success) {\n            throw chunk.error;\n          }\n          controller.enqueue(chunk.value);\n        }\n      })\n    );\n  }\n};\n\n// src/ui/chat.ts\nvar AbstractChat = class {\n  constructor({\n    generateId: generateId3 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId,\n    id = generateId3(),\n    transport = new DefaultChatTransport(),\n    messageMetadataSchema,\n    dataPartSchemas,\n    state,\n    onError,\n    onToolCall,\n    onFinish,\n    onData,\n    sendAutomaticallyWhen\n  }) {\n    this.activeResponse = void 0;\n    this.jobExecutor = new SerialJobExecutor();\n    /**\n     * Appends or replaces a user message to the chat list. This triggers the API call to fetch\n     * the assistant's response.\n     *\n     * If a messageId is provided, the message will be replaced.\n     */\n    this.sendMessage = async (message, options) => {\n      var _a17, _b, _c, _d;\n      if (message == null) {\n        await this.makeRequest({\n          trigger: \"submit-message\",\n          messageId: (_a17 = this.lastMessage) == null ? void 0 : _a17.id,\n          ...options\n        });\n        return;\n      }\n      let uiMessage;\n      if (\"text\" in message || \"files\" in message) {\n        const fileParts = Array.isArray(message.files) ? message.files : await convertFileListToFileUIParts(message.files);\n        uiMessage = {\n          parts: [\n            ...fileParts,\n            ...\"text\" in message && message.text != null ? [{ type: \"text\", text: message.text }] : []\n          ]\n        };\n      } else {\n        uiMessage = message;\n      }\n      if (message.messageId != null) {\n        const messageIndex = this.state.messages.findIndex(\n          (m) => m.id === message.messageId\n        );\n        if (messageIndex === -1) {\n          throw new Error(`message with id ${message.messageId} not found`);\n        }\n        if (this.state.messages[messageIndex].role !== \"user\") {\n          throw new Error(\n            `message with id ${message.messageId} is not a user message`\n          );\n        }\n        this.state.messages = this.state.messages.slice(0, messageIndex + 1);\n        this.state.replaceMessage(messageIndex, {\n          ...uiMessage,\n          id: message.messageId,\n          role: (_b = uiMessage.role) != null ? _b : \"user\",\n          metadata: message.metadata\n        });\n      } else {\n        this.state.pushMessage({\n          ...uiMessage,\n          id: (_c = uiMessage.id) != null ? _c : this.generateId(),\n          role: (_d = uiMessage.role) != null ? _d : \"user\",\n          metadata: message.metadata\n        });\n      }\n      await this.makeRequest({\n        trigger: \"submit-message\",\n        messageId: message.messageId,\n        ...options\n      });\n    };\n    /**\n     * Regenerate the assistant message with the provided message id.\n     * If no message id is provided, the last assistant message will be regenerated.\n     */\n    this.regenerate = async ({\n      messageId,\n      ...options\n    } = {}) => {\n      const messageIndex = messageId == null ? this.state.messages.length - 1 : this.state.messages.findIndex((message) => message.id === messageId);\n      if (messageIndex === -1) {\n        throw new Error(`message ${messageId} not found`);\n      }\n      this.state.messages = this.state.messages.slice(\n        0,\n        // if the message is a user message, we need to include it in the request:\n        this.messages[messageIndex].role === \"assistant\" ? messageIndex : messageIndex + 1\n      );\n      await this.makeRequest({\n        trigger: \"regenerate-message\",\n        messageId,\n        ...options\n      });\n    };\n    /**\n     * Attempt to resume an ongoing streaming response.\n     */\n    this.resumeStream = async (options = {}) => {\n      await this.makeRequest({ trigger: \"resume-stream\", ...options });\n    };\n    /**\n     * Clear the error state and set the status to ready if the chat is in an error state.\n     */\n    this.clearError = () => {\n      if (this.status === \"error\") {\n        this.state.error = void 0;\n        this.setStatus({ status: \"ready\" });\n      }\n    };\n    this.addToolResult = async ({\n      tool: tool3,\n      toolCallId,\n      output\n    }) => this.jobExecutor.run(async () => {\n      var _a17, _b;\n      const messages = this.state.messages;\n      const lastMessage = messages[messages.length - 1];\n      this.state.replaceMessage(messages.length - 1, {\n        ...lastMessage,\n        parts: lastMessage.parts.map(\n          (part) => isToolOrDynamicToolUIPart(part) && part.toolCallId === toolCallId ? { ...part, state: \"output-available\", output } : part\n        )\n      });\n      if (this.activeResponse) {\n        this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(\n          (part) => isToolOrDynamicToolUIPart(part) && part.toolCallId === toolCallId ? {\n            ...part,\n            state: \"output-available\",\n            output,\n            errorText: void 0\n          } : part\n        );\n      }\n      if (this.status !== \"streaming\" && this.status !== \"submitted\" && ((_a17 = this.sendAutomaticallyWhen) == null ? void 0 : _a17.call(this, { messages: this.state.messages }))) {\n        this.makeRequest({\n          trigger: \"submit-message\",\n          messageId: (_b = this.lastMessage) == null ? void 0 : _b.id\n        });\n      }\n    });\n    /**\n     * Abort the current request immediately, keep the generated tokens if any.\n     */\n    this.stop = async () => {\n      var _a17;\n      if (this.status !== \"streaming\" && this.status !== \"submitted\")\n        return;\n      if ((_a17 = this.activeResponse) == null ? void 0 : _a17.abortController) {\n        this.activeResponse.abortController.abort();\n      }\n    };\n    this.id = id;\n    this.transport = transport;\n    this.generateId = generateId3;\n    this.messageMetadataSchema = messageMetadataSchema;\n    this.dataPartSchemas = dataPartSchemas;\n    this.state = state;\n    this.onError = onError;\n    this.onToolCall = onToolCall;\n    this.onFinish = onFinish;\n    this.onData = onData;\n    this.sendAutomaticallyWhen = sendAutomaticallyWhen;\n  }\n  /**\n   * Hook status:\n   *\n   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.\n   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.\n   * - `ready`: The full response has been received and processed; a new user message can be submitted.\n   * - `error`: An error occurred during the API request, preventing successful completion.\n   */\n  get status() {\n    return this.state.status;\n  }\n  setStatus({\n    status,\n    error\n  }) {\n    if (this.status === status)\n      return;\n    this.state.status = status;\n    this.state.error = error;\n  }\n  get error() {\n    return this.state.error;\n  }\n  get messages() {\n    return this.state.messages;\n  }\n  get lastMessage() {\n    return this.state.messages[this.state.messages.length - 1];\n  }\n  set messages(messages) {\n    this.state.messages = messages;\n  }\n  async makeRequest({\n    trigger,\n    metadata,\n    headers,\n    body,\n    messageId\n  }) {\n    var _a17, _b, _c;\n    this.setStatus({ status: \"submitted\", error: void 0 });\n    const lastMessage = this.lastMessage;\n    let isAbort = false;\n    let isDisconnect = false;\n    let isError = false;\n    try {\n      const activeResponse = {\n        state: createStreamingUIMessageState({\n          lastMessage: this.state.snapshot(lastMessage),\n          messageId: this.generateId()\n        }),\n        abortController: new AbortController()\n      };\n      activeResponse.abortController.signal.addEventListener(\"abort\", () => {\n        isAbort = true;\n      });\n      this.activeResponse = activeResponse;\n      let stream;\n      if (trigger === \"resume-stream\") {\n        const reconnect = await this.transport.reconnectToStream({\n          chatId: this.id,\n          metadata,\n          headers,\n          body\n        });\n        if (reconnect == null) {\n          this.setStatus({ status: \"ready\" });\n          return;\n        }\n        stream = reconnect;\n      } else {\n        stream = await this.transport.sendMessages({\n          chatId: this.id,\n          messages: this.state.messages,\n          abortSignal: activeResponse.abortController.signal,\n          metadata,\n          headers,\n          body,\n          trigger,\n          messageId\n        });\n      }\n      const runUpdateMessageJob = (job) => (\n        // serialize the job execution to avoid race conditions:\n        this.jobExecutor.run(\n          () => job({\n            state: activeResponse.state,\n            write: () => {\n              var _a18;\n              this.setStatus({ status: \"streaming\" });\n              const replaceLastMessage = activeResponse.state.message.id === ((_a18 = this.lastMessage) == null ? void 0 : _a18.id);\n              if (replaceLastMessage) {\n                this.state.replaceMessage(\n                  this.state.messages.length - 1,\n                  activeResponse.state.message\n                );\n              } else {\n                this.state.pushMessage(activeResponse.state.message);\n              }\n            }\n          })\n        )\n      );\n      await consumeStream({\n        stream: processUIMessageStream({\n          stream,\n          onToolCall: this.onToolCall,\n          onData: this.onData,\n          messageMetadataSchema: this.messageMetadataSchema,\n          dataPartSchemas: this.dataPartSchemas,\n          runUpdateMessageJob,\n          onError: (error) => {\n            throw error;\n          }\n        }),\n        onError: (error) => {\n          throw error;\n        }\n      });\n      this.setStatus({ status: \"ready\" });\n    } catch (err) {\n      if (isAbort || err.name === \"AbortError\") {\n        isAbort = true;\n        this.setStatus({ status: \"ready\" });\n        return null;\n      }\n      isError = true;\n      if (err instanceof TypeError && (err.message.toLowerCase().includes(\"fetch\") || err.message.toLowerCase().includes(\"network\"))) {\n        isDisconnect = true;\n      }\n      if (this.onError && err instanceof Error) {\n        this.onError(err);\n      }\n      this.setStatus({ status: \"error\", error: err });\n    } finally {\n      try {\n        (_a17 = this.onFinish) == null ? void 0 : _a17.call(this, {\n          message: this.activeResponse.state.message,\n          messages: this.state.messages,\n          isAbort,\n          isDisconnect,\n          isError\n        });\n      } catch (err) {\n        console.error(err);\n      }\n      this.activeResponse = void 0;\n    }\n    if ((_b = this.sendAutomaticallyWhen) == null ? void 0 : _b.call(this, { messages: this.state.messages })) {\n      await this.makeRequest({\n        trigger: \"submit-message\",\n        messageId: (_c = this.lastMessage) == null ? void 0 : _c.id,\n        metadata,\n        headers,\n        body\n      });\n    }\n  }\n};\n\n// src/ui/last-assistant-message-is-complete-with-tool-calls.ts\nfunction lastAssistantMessageIsCompleteWithToolCalls({\n  messages\n}) {\n  const message = messages[messages.length - 1];\n  if (!message) {\n    return false;\n  }\n  if (message.role !== \"assistant\") {\n    return false;\n  }\n  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {\n    return part.type === \"step-start\" ? index : lastIndex;\n  }, -1);\n  const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter(isToolOrDynamicToolUIPart);\n  return lastStepToolInvocations.length > 0 && lastStepToolInvocations.every((part) => part.state === \"output-available\");\n}\n\n// src/ui/transform-text-to-ui-message-stream.ts\nfunction transformTextToUiMessageStream({\n  stream\n}) {\n  return stream.pipeThrough(\n    new TransformStream({\n      start(controller) {\n        controller.enqueue({ type: \"start\" });\n        controller.enqueue({ type: \"start-step\" });\n        controller.enqueue({ type: \"text-start\", id: \"text-1\" });\n      },\n      async transform(part, controller) {\n        controller.enqueue({ type: \"text-delta\", id: \"text-1\", delta: part });\n      },\n      async flush(controller) {\n        controller.enqueue({ type: \"text-end\", id: \"text-1\" });\n        controller.enqueue({ type: \"finish-step\" });\n        controller.enqueue({ type: \"finish\" });\n      }\n    })\n  );\n}\n\n// src/ui/text-stream-chat-transport.ts\nvar TextStreamChatTransport = class extends HttpChatTransport {\n  constructor(options = {}) {\n    super(options);\n  }\n  processResponseStream(stream) {\n    return transformTextToUiMessageStream({\n      stream: stream.pipeThrough(new TextDecoderStream())\n    });\n  }\n};\n\n// src/ui/validate-ui-messages.ts\n\n\n\nvar textUIPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  state: zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\"streaming\", \"done\"]).optional(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar reasoningUIPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning\"),\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  state: zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\"streaming\", \"done\"]).optional(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar sourceUrlUIPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"source-url\"),\n  sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar sourceDocumentUIPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"source-document\"),\n  sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar fileUIPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file\"),\n  mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n  url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar stepStartUIPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"step-start\")\n});\nvar dataUIPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"data-\"),\n  id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n  data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown()\n});\nvar dynamicToolUIPartSchemas = [\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"input-streaming\"),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"input-available\"),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    callProviderMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-available\"),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    callProviderMetadata: providerMetadataSchema.optional(),\n    preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-error\"),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    callProviderMetadata: providerMetadataSchema.optional()\n  })\n];\nvar toolUIPartSchemas = [\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"input-streaming\"),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"input-available\"),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    callProviderMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-available\"),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    callProviderMetadata: providerMetadataSchema.optional(),\n    preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-error\"),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    callProviderMetadata: providerMetadataSchema.optional()\n  })\n];\nvar uiMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  role: zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\"system\", \"user\", \"assistant\"]),\n  metadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional(),\n  parts: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n      textUIPartSchema,\n      reasoningUIPartSchema,\n      sourceUrlUIPartSchema,\n      sourceDocumentUIPartSchema,\n      fileUIPartSchema,\n      stepStartUIPartSchema,\n      dataUIPartSchema,\n      ...dynamicToolUIPartSchemas,\n      ...toolUIPartSchemas\n    ])\n  )\n});\nasync function validateUIMessages({\n  messages,\n  metadataSchema,\n  dataSchemas,\n  tools\n}) {\n  if (messages == null) {\n    throw new InvalidArgumentError({\n      parameter: \"messages\",\n      value: messages,\n      message: \"messages parameter must be provided\"\n    });\n  }\n  const validatedMessages = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n    value: messages,\n    schema: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(uiMessageSchema)\n  });\n  if (metadataSchema) {\n    for (const message of validatedMessages) {\n      await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n        value: message.metadata,\n        schema: metadataSchema\n      });\n    }\n  }\n  if (dataSchemas) {\n    for (const message of validatedMessages) {\n      const dataParts = message.parts.filter(\n        (part) => part.type.startsWith(\"data-\")\n      );\n      for (const dataPart of dataParts) {\n        const dataName = dataPart.type.slice(5);\n        const dataSchema = dataSchemas[dataName];\n        if (!dataSchema) {\n          throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value: dataPart.data,\n            cause: `No data schema found for data part ${dataName}`\n          });\n        }\n        await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n          value: dataPart.data,\n          schema: dataSchema\n        });\n      }\n    }\n  }\n  if (tools) {\n    for (const message of validatedMessages) {\n      const toolParts = message.parts.filter(\n        (part) => part.type.startsWith(\"tool-\")\n      );\n      for (const toolPart of toolParts) {\n        const toolName = toolPart.type.slice(5);\n        const tool3 = tools[toolName];\n        if (!tool3) {\n          throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value: toolPart.input,\n            cause: `No tool schema found for tool part ${toolName}`\n          });\n        }\n        if (toolPart.state === \"input-available\" || toolPart.state === \"output-available\" || toolPart.state === \"output-error\") {\n          await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n            value: toolPart.input,\n            schema: tool3.inputSchema\n          });\n        }\n        if (toolPart.state === \"output-available\" && tool3.outputSchema) {\n          await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n            value: toolPart.output,\n            schema: tool3.outputSchema\n          });\n        }\n      }\n    }\n  }\n  return validatedMessages;\n}\n\n// src/ui-message-stream/create-ui-message-stream.ts\n\nfunction createUIMessageStream({\n  execute,\n  onError = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage,\n  originalMessages,\n  onFinish,\n  generateId: generateId3 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId\n}) {\n  let controller;\n  const ongoingStreamPromises = [];\n  const stream = new ReadableStream({\n    start(controllerArg) {\n      controller = controllerArg;\n    }\n  });\n  function safeEnqueue(data) {\n    try {\n      controller.enqueue(data);\n    } catch (error) {\n    }\n  }\n  try {\n    const result = execute({\n      writer: {\n        write(part) {\n          safeEnqueue(part);\n        },\n        merge(streamArg) {\n          ongoingStreamPromises.push(\n            (async () => {\n              const reader = streamArg.getReader();\n              while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                  break;\n                safeEnqueue(value);\n              }\n            })().catch((error) => {\n              safeEnqueue({\n                type: \"error\",\n                errorText: onError(error)\n              });\n            })\n          );\n        },\n        onError\n      }\n    });\n    if (result) {\n      ongoingStreamPromises.push(\n        result.catch((error) => {\n          safeEnqueue({\n            type: \"error\",\n            errorText: onError(error)\n          });\n        })\n      );\n    }\n  } catch (error) {\n    safeEnqueue({\n      type: \"error\",\n      errorText: onError(error)\n    });\n  }\n  const waitForStreams = new Promise(async (resolve2) => {\n    while (ongoingStreamPromises.length > 0) {\n      await ongoingStreamPromises.shift();\n    }\n    resolve2();\n  });\n  waitForStreams.finally(() => {\n    try {\n      controller.close();\n    } catch (error) {\n    }\n  });\n  return handleUIMessageStreamFinish({\n    stream,\n    messageId: generateId3(),\n    originalMessages,\n    onFinish,\n    onError\n  });\n}\n\n// src/ui-message-stream/read-ui-message-stream.ts\nfunction readUIMessageStream({\n  message,\n  stream,\n  onError,\n  terminateOnError = false\n}) {\n  var _a17;\n  let controller;\n  let hasErrored = false;\n  const outputStream = new ReadableStream({\n    start(controllerParam) {\n      controller = controllerParam;\n    }\n  });\n  const state = createStreamingUIMessageState({\n    messageId: (_a17 = message == null ? void 0 : message.id) != null ? _a17 : \"\",\n    lastMessage: message\n  });\n  const handleError = (error) => {\n    onError == null ? void 0 : onError(error);\n    if (!hasErrored && terminateOnError) {\n      hasErrored = true;\n      controller == null ? void 0 : controller.error(error);\n    }\n  };\n  consumeStream({\n    stream: processUIMessageStream({\n      stream,\n      runUpdateMessageJob(job) {\n        return job({\n          state,\n          write: () => {\n            controller == null ? void 0 : controller.enqueue(structuredClone(state.message));\n          }\n        });\n      },\n      onError: handleError\n    }),\n    onError: handleError\n  }).finally(() => {\n    if (!hasErrored) {\n      controller == null ? void 0 : controller.close();\n    }\n  });\n  return createAsyncIterableStream(outputStream);\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9DQUFvQztBQUNwRTs7QUFFQTtBQUNxRTtBQVNyQzs7QUFFaEM7QUFLZ0M7O0FBRWhDO0FBQzhDO0FBQzlDO0FBQ0EsZ0NBQWdDLEtBQUs7QUFDckM7QUFDQTtBQUNBLDJDQUEyQyx3REFBVTtBQUNyRDtBQUNBLGdCQUFnQixtQ0FBbUMsSUFBSTtBQUN2RCxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3REFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRLE9BQU8sZ0JBQWdCO0FBQ3REO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVEsWUFBWSxTQUFTO0FBQ3BEO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRLEVBQUUsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUSxFQUFFLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMwQzs7QUFFMUM7QUFjMEI7O0FBRTFCO0FBQzZEO0FBQzdEO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBLHlDQUF5Qyx3REFBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usb0RBQU87QUFDN0U7O0FBRUE7QUFHZ0M7O0FBRWhDO0FBQ21FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpQkFBaUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFHMEI7QUFJTTs7QUFFaEM7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3lFOztBQUV6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkVBQTJFLDREQUFlLDRCQUE0QixpRUFBb0I7QUFDMUk7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUF1R0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyaWFuc3Byb3VsZS9jb2RlLWV4cGxhaW5lci9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lMTcgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUxNywgeyBnZXQ6IGFsbFtuYW1lMTddLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBnYXRld2F5IGFzIGdhdGV3YXkyLCBjcmVhdGVHYXRld2F5IH0gZnJvbSBcIkBhaS1zZGsvZ2F0ZXdheVwiO1xuaW1wb3J0IHtcbiAgYXNTY2hlbWEgYXMgYXNTY2hlbWE1LFxuICBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjUsXG4gIGR5bmFtaWNUb29sIGFzIGR5bmFtaWNUb29sMixcbiAgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkMixcbiAganNvblNjaGVtYSBhcyBqc29uU2NoZW1hMixcbiAgdG9vbCBhcyB0b29sMixcbiAgem9kU2NoZW1hXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L2dlbmVyYXRlLXRleHQudHNcbmltcG9ydCB7XG4gIGNyZWF0ZUlkR2VuZXJhdG9yLFxuICBleGVjdXRlVG9vbCxcbiAgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTVcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL2Vycm9yL25vLW91dHB1dC1zcGVjaWZpZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUgPSBcIkFJX05vT3V0cHV0U3BlY2lmaWVkRXJyb3JcIjtcbnZhciBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBOb091dHB1dFNwZWNpZmllZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSA9IFwiTm8gb3V0cHV0IHNwZWNpZmllZC5cIiB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYV0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG59O1xuX2EgPSBzeW1ib2w7XG5cbi8vIHNyYy9sb2dnZXIvbG9nLXdhcm5pbmdzLnRzXG5mdW5jdGlvbiBmb3JtYXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgY29uc3QgcHJlZml4ID0gXCJBSSBTREsgV2FybmluZzpcIjtcbiAgc3dpdGNoICh3YXJuaW5nLnR5cGUpIHtcbiAgICBjYXNlIFwidW5zdXBwb3J0ZWQtc2V0dGluZ1wiOiB7XG4gICAgICBsZXQgbWVzc2FnZSA9IGAke3ByZWZpeH0gVGhlIFwiJHt3YXJuaW5nLnNldHRpbmd9XCIgc2V0dGluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgbW9kZWxgO1xuICAgICAgaWYgKHdhcm5pbmcuZGV0YWlscykge1xuICAgICAgICBtZXNzYWdlICs9IGAgLSAke3dhcm5pbmcuZGV0YWlsc31gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGNhc2UgXCJ1bnN1cHBvcnRlZC10b29sXCI6IHtcbiAgICAgIGNvbnN0IHRvb2xOYW1lID0gXCJuYW1lXCIgaW4gd2FybmluZy50b29sID8gd2FybmluZy50b29sLm5hbWUgOiBcInVua25vd24gdG9vbFwiO1xuICAgICAgbGV0IG1lc3NhZ2UgPSBgJHtwcmVmaXh9IFRoZSB0b29sIFwiJHt0b29sTmFtZX1cIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgbW9kZWxgO1xuICAgICAgaWYgKHdhcm5pbmcuZGV0YWlscykge1xuICAgICAgICBtZXNzYWdlICs9IGAgLSAke3dhcm5pbmcuZGV0YWlsc31gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGNhc2UgXCJvdGhlclwiOiB7XG4gICAgICByZXR1cm4gYCR7cHJlZml4fSAke3dhcm5pbmcubWVzc2FnZX1gO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gYCR7cHJlZml4fSAke0pTT04uc3RyaW5naWZ5KHdhcm5pbmcsIG51bGwsIDIpfWA7XG4gICAgfVxuICB9XG59XG52YXIgRklSU1RfV0FSTklOR19JTkZPX01FU1NBR0UgPSBcIkFJIFNESyBXYXJuaW5nIFN5c3RlbTogVG8gdHVybiBvZmYgd2FybmluZyBsb2dnaW5nLCBzZXQgdGhlIEFJX1NES19MT0dfV0FSTklOR1MgZ2xvYmFsIHRvIGZhbHNlLlwiO1xudmFyIGhhc0xvZ2dlZEJlZm9yZSA9IGZhbHNlO1xudmFyIGxvZ1dhcm5pbmdzID0gKHdhcm5pbmdzKSA9PiB7XG4gIGlmICh3YXJuaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbG9nZ2VyID0gZ2xvYmFsVGhpcy5BSV9TREtfTE9HX1dBUk5JTkdTO1xuICBpZiAobG9nZ2VyID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGxvZ2dlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgbG9nZ2VyKHdhcm5pbmdzKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFoYXNMb2dnZWRCZWZvcmUpIHtcbiAgICBoYXNMb2dnZWRCZWZvcmUgPSB0cnVlO1xuICAgIGNvbnNvbGUuaW5mbyhGSVJTVF9XQVJOSU5HX0lORk9fTUVTU0FHRSk7XG4gIH1cbiAgZm9yIChjb25zdCB3YXJuaW5nIG9mIHdhcm5pbmdzKSB7XG4gICAgY29uc29sZS53YXJuKGZvcm1hdFdhcm5pbmcod2FybmluZykpO1xuICB9XG59O1xuXG4vLyBzcmMvbW9kZWwvcmVzb2x2ZS1tb2RlbC50c1xuaW1wb3J0IHsgZ2F0ZXdheSB9IGZyb20gXCJAYWktc2RrL2dhdGV3YXlcIjtcblxuLy8gc3JjL2Vycm9yL2luZGV4LnRzXG5pbXBvcnQge1xuICBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxNyxcbiAgQVBJQ2FsbEVycm9yLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIHNyYy9lcnJvci9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMiA9IFwiQUlfSW52YWxpZEFyZ3VtZW50RXJyb3JcIjtcbnZhciBtYXJrZXIyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUyfWA7XG52YXIgc3ltYm9sMiA9IFN5bWJvbC5mb3IobWFya2VyMik7XG52YXIgX2EyO1xudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXJhbWV0ZXIsXG4gICAgdmFsdWUsXG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTIsXG4gICAgICBtZXNzYWdlOiBgSW52YWxpZCBhcmd1bWVudCBmb3IgcGFyYW1ldGVyICR7cGFyYW1ldGVyfTogJHttZXNzYWdlfWBcbiAgICB9KTtcbiAgICB0aGlzW19hMl0gPSB0cnVlO1xuICAgIHRoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMi5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjIpO1xuICB9XG59O1xuX2EyID0gc3ltYm9sMjtcblxuLy8gc3JjL2Vycm9yL2ludmFsaWQtc3RyZWFtLXBhcnQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUzID0gXCJBSV9JbnZhbGlkU3RyZWFtUGFydEVycm9yXCI7XG52YXIgbWFya2VyMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDMgPSBTeW1ib2wuZm9yKG1hcmtlcjMpO1xudmFyIF9hMztcbnZhciBJbnZhbGlkU3RyZWFtUGFydEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjaHVuayxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUzLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2EzXSA9IHRydWU7XG4gICAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IzLmhhc01hcmtlcihlcnJvciwgbWFya2VyMyk7XG4gIH1cbn07XG5fYTMgPSBzeW1ib2wzO1xuXG4vLyBzcmMvZXJyb3IvaW52YWxpZC10b29sLWlucHV0LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I0LCBnZXRFcnJvck1lc3NhZ2UgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU0ID0gXCJBSV9JbnZhbGlkVG9vbElucHV0RXJyb3JcIjtcbnZhciBtYXJrZXI0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU0fWA7XG52YXIgc3ltYm9sNCA9IFN5bWJvbC5mb3IobWFya2VyNCk7XG52YXIgX2E0O1xudmFyIEludmFsaWRUb29sSW5wdXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbElucHV0LFxuICAgIHRvb2xOYW1lLFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dCBmb3IgdG9vbCAke3Rvb2xOYW1lfTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTQsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E0XSA9IHRydWU7XG4gICAgdGhpcy50b29sSW5wdXQgPSB0b29sSW5wdXQ7XG4gICAgdGhpcy50b29sTmFtZSA9IHRvb2xOYW1lO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I0Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNCk7XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBzcmMvZXJyb3IvbWNwLWNsaWVudC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTUgPSBcIkFJX01DUENsaWVudEVycm9yXCI7XG52YXIgbWFya2VyNSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNX1gO1xudmFyIHN5bWJvbDUgPSBTeW1ib2wuZm9yKG1hcmtlcjUpO1xudmFyIF9hNTtcbnZhciBNQ1BDbGllbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbmFtZTogbmFtZTE3ID0gXCJNQ1BDbGllbnRFcnJvclwiLFxuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTE3LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I1Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNSk7XG4gIH1cbn07XG5fYTUgPSBzeW1ib2w1O1xuXG4vLyBzcmMvZXJyb3Ivbm8taW1hZ2UtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I2IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNiA9IFwiQUlfTm9JbWFnZUdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyNiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNn1gO1xudmFyIHN5bWJvbDYgPSBTeW1ib2wuZm9yKG1hcmtlcjYpO1xudmFyIF9hNjtcbnZhciBOb0ltYWdlR2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I2IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UgPSBcIk5vIGltYWdlIGdlbmVyYXRlZC5cIixcbiAgICBjYXVzZSxcbiAgICByZXNwb25zZXNcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTYsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E2XSA9IHRydWU7XG4gICAgdGhpcy5yZXNwb25zZXMgPSByZXNwb25zZXM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjYuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxufTtcbl9hNiA9IHN5bWJvbDY7XG5cbi8vIHNyYy9lcnJvci9uby1vYmplY3QtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I3IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNyA9IFwiQUlfTm9PYmplY3RHZW5lcmF0ZWRFcnJvclwiO1xudmFyIG1hcmtlcjcgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTd9YDtcbnZhciBzeW1ib2w3ID0gU3ltYm9sLmZvcihtYXJrZXI3KTtcbnZhciBfYTc7XG52YXIgTm9PYmplY3RHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjcge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gb2JqZWN0IGdlbmVyYXRlZC5cIixcbiAgICBjYXVzZSxcbiAgICB0ZXh0OiB0ZXh0MixcbiAgICByZXNwb25zZSxcbiAgICB1c2FnZSxcbiAgICBmaW5pc2hSZWFzb25cbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTcsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E3XSA9IHRydWU7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDI7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMudXNhZ2UgPSB1c2FnZTtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IGZpbmlzaFJlYXNvbjtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNy5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjcpO1xuICB9XG59O1xuX2E3ID0gc3ltYm9sNztcblxuLy8gc3JjL2Vycm9yL25vLW91dHB1dC1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjggfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU4ID0gXCJBSV9Ob091dHB1dEdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyOCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOH1gO1xudmFyIHN5bWJvbDggPSBTeW1ib2wuZm9yKG1hcmtlcjgpO1xudmFyIF9hODtcbnZhciBOb091dHB1dEdlbmVyYXRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yOCB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gb3V0cHV0IGdlbmVyYXRlZC5cIixcbiAgICBjYXVzZVxuICB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU4LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hOF0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I4Lmhhc01hcmtlcihlcnJvciwgbWFya2VyOCk7XG4gIH1cbn07XG5fYTggPSBzeW1ib2w4O1xuXG4vLyBzcmMvZXJyb3Ivbm8tc3VjaC10b29sLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lOSA9IFwiQUlfTm9TdWNoVG9vbEVycm9yXCI7XG52YXIgbWFya2VyOSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOX1gO1xudmFyIHN5bWJvbDkgPSBTeW1ib2wuZm9yKG1hcmtlcjkpO1xudmFyIF9hOTtcbnZhciBOb1N1Y2hUb29sRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRvb2xOYW1lLFxuICAgIGF2YWlsYWJsZVRvb2xzID0gdm9pZCAwLFxuICAgIG1lc3NhZ2UgPSBgTW9kZWwgdHJpZWQgdG8gY2FsbCB1bmF2YWlsYWJsZSB0b29sICcke3Rvb2xOYW1lfScuICR7YXZhaWxhYmxlVG9vbHMgPT09IHZvaWQgMCA/IFwiTm8gdG9vbHMgYXJlIGF2YWlsYWJsZS5cIiA6IGBBdmFpbGFibGUgdG9vbHM6ICR7YXZhaWxhYmxlVG9vbHMuam9pbihcIiwgXCIpfS5gfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTksIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTldID0gdHJ1ZTtcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gICAgdGhpcy5hdmFpbGFibGVUb29scyA9IGF2YWlsYWJsZVRvb2xzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I5Lmhhc01hcmtlcihlcnJvciwgbWFya2VyOSk7XG4gIH1cbn07XG5fYTkgPSBzeW1ib2w5O1xuXG4vLyBzcmMvZXJyb3IvdG9vbC1jYWxsLXJlcGFpci1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTAsIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2UyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTAgPSBcIkFJX1Rvb2xDYWxsUmVwYWlyRXJyb3JcIjtcbnZhciBtYXJrZXIxMCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTB9YDtcbnZhciBzeW1ib2wxMCA9IFN5bWJvbC5mb3IobWFya2VyMTApO1xudmFyIF9hMTA7XG52YXIgVG9vbENhbGxSZXBhaXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjEwIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNhdXNlLFxuICAgIG9yaWdpbmFsRXJyb3IsXG4gICAgbWVzc2FnZSA9IGBFcnJvciByZXBhaXJpbmcgdG9vbCBjYWxsOiAke2dldEVycm9yTWVzc2FnZTIoY2F1c2UpfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTEwLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMTBdID0gdHJ1ZTtcbiAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEwKTtcbiAgfVxufTtcbl9hMTAgPSBzeW1ib2wxMDtcblxuLy8gc3JjL2Vycm9yL3Vuc3VwcG9ydGVkLW1vZGVsLXZlcnNpb24tZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjExIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBVbnN1cHBvcnRlZE1vZGVsVmVyc2lvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTEge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJBSV9VbnN1cHBvcnRlZE1vZGVsVmVyc2lvbkVycm9yXCIsXG4gICAgICBtZXNzYWdlOiBgVW5zdXBwb3J0ZWQgbW9kZWwgdmVyc2lvbiAke29wdGlvbnMudmVyc2lvbn0gZm9yIHByb3ZpZGVyIFwiJHtvcHRpb25zLnByb3ZpZGVyfVwiIGFuZCBtb2RlbCBcIiR7b3B0aW9ucy5tb2RlbElkfVwiLiBBSSBTREsgNSBvbmx5IHN1cHBvcnRzIG1vZGVscyB0aGF0IGltcGxlbWVudCBzcGVjaWZpY2F0aW9uIHZlcnNpb24gXCJ2MlwiLmBcbiAgICB9KTtcbiAgICB0aGlzLnZlcnNpb24gPSBvcHRpb25zLnZlcnNpb247XG4gICAgdGhpcy5wcm92aWRlciA9IG9wdGlvbnMucHJvdmlkZXI7XG4gICAgdGhpcy5tb2RlbElkID0gb3B0aW9ucy5tb2RlbElkO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvbXB0L2ludmFsaWQtZGF0YS1jb250ZW50LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTExID0gXCJBSV9JbnZhbGlkRGF0YUNvbnRlbnRFcnJvclwiO1xudmFyIG1hcmtlcjExID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMX1gO1xudmFyIHN5bWJvbDExID0gU3ltYm9sLmZvcihtYXJrZXIxMSk7XG52YXIgX2ExMTtcbnZhciBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjEyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRlbnQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGEgY29udGVudC4gRXhwZWN0ZWQgYSBiYXNlNjQgc3RyaW5nLCBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciwgb3IgQnVmZmVyLCBidXQgZ290ICR7dHlwZW9mIGNvbnRlbnR9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTExLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMTFdID0gdHJ1ZTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMi5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjExKTtcbiAgfVxufTtcbl9hMTEgPSBzeW1ib2wxMTtcblxuLy8gc3JjL3Byb21wdC9pbnZhbGlkLW1lc3NhZ2Utcm9sZS1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxMiA9IFwiQUlfSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3JcIjtcbnZhciBtYXJrZXIxMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTJ9YDtcbnZhciBzeW1ib2wxMiA9IFN5bWJvbC5mb3IobWFya2VyMTIpO1xudmFyIF9hMTI7XG52YXIgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxMyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByb2xlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBtZXNzYWdlIHJvbGU6ICcke3JvbGV9Jy4gTXVzdCBiZSBvbmUgb2Y6IFwic3lzdGVtXCIsIFwidXNlclwiLCBcImFzc2lzdGFudFwiLCBcInRvb2xcIi5gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxMiwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTJdID0gdHJ1ZTtcbiAgICB0aGlzLnJvbGUgPSByb2xlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMy5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEyKTtcbiAgfVxufTtcbl9hMTIgPSBzeW1ib2wxMjtcblxuLy8gc3JjL3Byb21wdC9tZXNzYWdlLWNvbnZlcnNpb24tZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE0IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTMgPSBcIkFJX01lc3NhZ2VDb252ZXJzaW9uRXJyb3JcIjtcbnZhciBtYXJrZXIxMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTN9YDtcbnZhciBzeW1ib2wxMyA9IFN5bWJvbC5mb3IobWFya2VyMTMpO1xudmFyIF9hMTM7XG52YXIgTWVzc2FnZUNvbnZlcnNpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjE0IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG9yaWdpbmFsTWVzc2FnZSxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxMywgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTNdID0gdHJ1ZTtcbiAgICB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IG9yaWdpbmFsTWVzc2FnZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTQuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMyk7XG4gIH1cbn07XG5fYTEzID0gc3ltYm9sMTM7XG5cbi8vIHNyYy91dGlsL2Rvd25sb2FkL2Rvd25sb2FkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxNSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTE0ID0gXCJBSV9Eb3dubG9hZEVycm9yXCI7XG52YXIgbWFya2VyMTQgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTE0fWA7XG52YXIgc3ltYm9sMTQgPSBTeW1ib2wuZm9yKG1hcmtlcjE0KTtcbnZhciBfYTE0O1xudmFyIERvd25sb2FkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxNSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgc3RhdHVzQ29kZSxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBjYXVzZSA9PSBudWxsID8gYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH06ICR7c3RhdHVzQ29kZX0gJHtzdGF0dXNUZXh0fWAgOiBgRmFpbGVkIHRvIGRvd25sb2FkICR7dXJsfTogJHtjYXVzZX1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxNCwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTE0XSA9IHRydWU7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxNS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE0KTtcbiAgfVxufTtcbl9hMTQgPSBzeW1ib2wxNDtcblxuLy8gc3JjL3V0aWwvcmV0cnktZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE2IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTUgPSBcIkFJX1JldHJ5RXJyb3JcIjtcbnZhciBtYXJrZXIxNSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTV9YDtcbnZhciBzeW1ib2wxNSA9IFN5bWJvbC5mb3IobWFya2VyMTUpO1xudmFyIF9hMTU7XG52YXIgUmV0cnlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjE2IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgcmVhc29uLFxuICAgIGVycm9yc1xuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE1XSA9IHRydWU7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5sYXN0RXJyb3IgPSBlcnJvcnNbZXJyb3JzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxNi5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE1KTtcbiAgfVxufTtcbl9hMTUgPSBzeW1ib2wxNTtcblxuLy8gc3JjL21vZGVsL3Jlc29sdmUtbW9kZWwudHNcbmZ1bmN0aW9uIHJlc29sdmVMYW5ndWFnZU1vZGVsKG1vZGVsKSB7XG4gIGlmICh0eXBlb2YgbW9kZWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjJcIikge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3Ioe1xuICAgICAgICB2ZXJzaW9uOiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbixcbiAgICAgICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHJldHVybiBnZXRHbG9iYWxQcm92aWRlcigpLmxhbmd1YWdlTW9kZWwobW9kZWwpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVtYmVkZGluZ01vZGVsKG1vZGVsKSB7XG4gIGlmICh0eXBlb2YgbW9kZWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjJcIikge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3Ioe1xuICAgICAgICB2ZXJzaW9uOiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbixcbiAgICAgICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHJldHVybiBnZXRHbG9iYWxQcm92aWRlcigpLnRleHRFbWJlZGRpbmdNb2RlbChcbiAgICBtb2RlbFxuICApO1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsUHJvdmlkZXIoKSB7XG4gIHZhciBfYTE3O1xuICByZXR1cm4gKF9hMTcgPSBnbG9iYWxUaGlzLkFJX1NES19ERUZBVUxUX1BST1ZJREVSKSAhPSBudWxsID8gX2ExNyA6IGdhdGV3YXk7XG59XG5cbi8vIHNyYy9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQudHNcbmltcG9ydCB7XG4gIGlzVXJsU3VwcG9ydGVkXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91dGlsL2RldGVjdC1tZWRpYS10eXBlLnRzXG5pbXBvcnQgeyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbnZhciBpbWFnZU1lZGlhVHlwZVNpZ25hdHVyZXMgPSBbXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvZ2lmXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs3MSwgNzMsIDcwXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiUjBsR1wiXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvcG5nXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsxMzcsIDgwLCA3OCwgNzFdLFxuICAgIGJhc2U2NFByZWZpeDogXCJpVkJPUndcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2pwZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjE2XSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiLzlqL1wiXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2Uvd2VicFwiLFxuICAgIGJ5dGVzUHJlZml4OiBbODIsIDczLCA3MCwgNzBdLFxuICAgIGJhc2U2NFByZWZpeDogXCJVa2xHUmdcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2JtcFwiLFxuICAgIGJ5dGVzUHJlZml4OiBbNjYsIDc3XSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiUWtcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL3RpZmZcIixcbiAgICBieXRlc1ByZWZpeDogWzczLCA3MywgNDIsIDBdLFxuICAgIGJhc2U2NFByZWZpeDogXCJTVWtxQUFcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL3RpZmZcIixcbiAgICBieXRlc1ByZWZpeDogWzc3LCA3NywgMCwgNDJdLFxuICAgIGJhc2U2NFByZWZpeDogXCJUVTBBS2dcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2F2aWZcIixcbiAgICBieXRlc1ByZWZpeDogW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMzIsXG4gICAgICAxMDIsXG4gICAgICAxMTYsXG4gICAgICAxMjEsXG4gICAgICAxMTIsXG4gICAgICA5NyxcbiAgICAgIDExOCxcbiAgICAgIDEwNSxcbiAgICAgIDEwMlxuICAgIF0sXG4gICAgYmFzZTY0UHJlZml4OiBcIkFBQUFJR1owZVhCaGRtbG1cIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2hlaWNcIixcbiAgICBieXRlc1ByZWZpeDogW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMzIsXG4gICAgICAxMDIsXG4gICAgICAxMTYsXG4gICAgICAxMjEsXG4gICAgICAxMTIsXG4gICAgICAxMDQsXG4gICAgICAxMDEsXG4gICAgICAxMDUsXG4gICAgICA5OVxuICAgIF0sXG4gICAgYmFzZTY0UHJlZml4OiBcIkFBQUFJR1owZVhCb1pXbGpcIlxuICB9XG5dO1xudmFyIGF1ZGlvTWVkaWFUeXBlU2lnbmF0dXJlcyA9IFtcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9tcGVnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNTUsIDI1MV0sXG4gICAgYmFzZTY0UHJlZml4OiBcIi8vcz1cIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjUwXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiLy9vPVwiXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vbXBlZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMjU1LCAyNDNdLFxuICAgIGJhc2U2NFByZWZpeDogXCIvL009XCJcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9tcGVnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNTUsIDI0Ml0sXG4gICAgYmFzZTY0UHJlZml4OiBcIi8vST1cIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjI3XSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiLytNPVwiXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vbXBlZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMjU1LCAyMjZdLFxuICAgIGJhc2U2NFByZWZpeDogXCIvK0k9XCJcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby93YXZcIixcbiAgICBieXRlc1ByZWZpeDogWzgyLCA3MywgNzAsIDcwXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiVWtsR1JcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL29nZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbNzksIDEwMywgMTAzLCA4M10sXG4gICAgYmFzZTY0UHJlZml4OiBcIlQyZG5Vd1wiXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vZmxhY1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMTAyLCA3NiwgOTcsIDY3XSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiWmt4aFF3XCJcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9hYWNcIixcbiAgICBieXRlc1ByZWZpeDogWzY0LCAyMSwgMCwgMF0sXG4gICAgYmFzZTY0UHJlZml4OiBcIlFCVUFcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wNFwiLFxuICAgIGJ5dGVzUHJlZml4OiBbMTAyLCAxMTYsIDEyMSwgMTEyXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiWm5SNWNBXCJcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby93ZWJtXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNiwgNjksIDIyMywgMTYzXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiR2tYZlwiXG4gIH1cbl07XG52YXIgc3RyaXBJRDMgPSAoZGF0YSkgPT4ge1xuICBjb25zdCBieXRlcyA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gY29udmVydEJhc2U2NFRvVWludDhBcnJheShkYXRhKSA6IGRhdGE7XG4gIGNvbnN0IGlkM1NpemUgPSAoYnl0ZXNbNl0gJiAxMjcpIDw8IDIxIHwgKGJ5dGVzWzddICYgMTI3KSA8PCAxNCB8IChieXRlc1s4XSAmIDEyNykgPDwgNyB8IGJ5dGVzWzldICYgMTI3O1xuICByZXR1cm4gYnl0ZXMuc2xpY2UoaWQzU2l6ZSArIDEwKTtcbn07XG5mdW5jdGlvbiBzdHJpcElEM1RhZ3NJZlByZXNlbnQoZGF0YSkge1xuICBjb25zdCBoYXNJZDMgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhLnN0YXJ0c1dpdGgoXCJTVVF6XCIpIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICYmIGRhdGEubGVuZ3RoID4gMTAgJiYgZGF0YVswXSA9PT0gNzMgJiYgLy8gJ0knXG4gIGRhdGFbMV0gPT09IDY4ICYmIC8vICdEJ1xuICBkYXRhWzJdID09PSA1MTtcbiAgcmV0dXJuIGhhc0lkMyA/IHN0cmlwSUQzKGRhdGEpIDogZGF0YTtcbn1cbmZ1bmN0aW9uIGRldGVjdE1lZGlhVHlwZSh7XG4gIGRhdGEsXG4gIHNpZ25hdHVyZXNcbn0pIHtcbiAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHN0cmlwSUQzVGFnc0lmUHJlc2VudChkYXRhKTtcbiAgZm9yIChjb25zdCBzaWduYXR1cmUgb2Ygc2lnbmF0dXJlcykge1xuICAgIGlmICh0eXBlb2YgcHJvY2Vzc2VkRGF0YSA9PT0gXCJzdHJpbmdcIiA/IHByb2Nlc3NlZERhdGEuc3RhcnRzV2l0aChzaWduYXR1cmUuYmFzZTY0UHJlZml4KSA6IHByb2Nlc3NlZERhdGEubGVuZ3RoID49IHNpZ25hdHVyZS5ieXRlc1ByZWZpeC5sZW5ndGggJiYgc2lnbmF0dXJlLmJ5dGVzUHJlZml4LmV2ZXJ5KFxuICAgICAgKGJ5dGUsIGluZGV4KSA9PiBwcm9jZXNzZWREYXRhW2luZGV4XSA9PT0gYnl0ZVxuICAgICkpIHtcbiAgICAgIHJldHVybiBzaWduYXR1cmUubWVkaWFUeXBlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBzcmMvdXRpbC9kb3dubG9hZC9kb3dubG9hZC50c1xudmFyIGRvd25sb2FkID0gYXN5bmMgKHsgdXJsIH0pID0+IHtcbiAgdmFyIF9hMTc7XG4gIGNvbnN0IHVybFRleHQgPSB1cmwudG9TdHJpbmcoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybFRleHQpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBEb3dubG9hZEVycm9yKHtcbiAgICAgICAgdXJsOiB1cmxUZXh0LFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogbmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSksXG4gICAgICBtZWRpYVR5cGU6IChfYTE3ID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikpICE9IG51bGwgPyBfYTE3IDogdm9pZCAwXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoRG93bmxvYWRFcnJvci5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBEb3dubG9hZEVycm9yKHsgdXJsOiB1cmxUZXh0LCBjYXVzZTogZXJyb3IgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlsL2Rvd25sb2FkL2Rvd25sb2FkLWZ1bmN0aW9uLnRzXG52YXIgY3JlYXRlRGVmYXVsdERvd25sb2FkRnVuY3Rpb24gPSAoZG93bmxvYWQyID0gZG93bmxvYWQpID0+IChyZXF1ZXN0ZWREb3dubG9hZHMpID0+IFByb21pc2UuYWxsKFxuICByZXF1ZXN0ZWREb3dubG9hZHMubWFwKFxuICAgIGFzeW5jIChyZXF1ZXN0ZWREb3dubG9hZCkgPT4gcmVxdWVzdGVkRG93bmxvYWQuaXNVcmxTdXBwb3J0ZWRCeU1vZGVsID8gbnVsbCA6IGRvd25sb2FkMihyZXF1ZXN0ZWREb3dubG9hZClcbiAgKVxuKTtcblxuLy8gc3JjL3Byb21wdC9kYXRhLWNvbnRlbnQudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE4IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkgYXMgY29udmVydEJhc2U2NFRvVWludDhBcnJheTIsXG4gIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kL3Y0XCI7XG5cbi8vIHNyYy9wcm9tcHQvc3BsaXQtZGF0YS11cmwudHNcbmZ1bmN0aW9uIHNwbGl0RGF0YVVybChkYXRhVXJsKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBkYXRhVXJsLnNwbGl0KFwiLFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWVkaWFUeXBlOiBoZWFkZXIuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiOlwiKVsxXSxcbiAgICAgIGJhc2U2NENvbnRlbnRcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBtZWRpYVR5cGU6IHZvaWQgMCxcbiAgICAgIGJhc2U2NENvbnRlbnQ6IHZvaWQgMFxuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3Byb21wdC9kYXRhLWNvbnRlbnQudHNcbnZhciBkYXRhQ29udGVudFNjaGVtYSA9IHoudW5pb24oW1xuICB6LnN0cmluZygpLFxuICB6Lmluc3RhbmNlb2YoVWludDhBcnJheSksXG4gIHouaW5zdGFuY2VvZihBcnJheUJ1ZmZlciksXG4gIHouY3VzdG9tKFxuICAgIC8vIEJ1ZmZlciBtaWdodCBub3QgYmUgYXZhaWxhYmxlIGluIHNvbWUgZW52aXJvbm1lbnRzIHN1Y2ggYXMgQ2xvdWRGbGFyZTpcbiAgICAodmFsdWUpID0+IHtcbiAgICAgIHZhciBfYTE3LCBfYjtcbiAgICAgIHJldHVybiAoX2IgPSAoX2ExNyA9IGdsb2JhbFRoaXMuQnVmZmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5pc0J1ZmZlcih2YWx1ZSkpICE9IG51bGwgPyBfYiA6IGZhbHNlO1xuICAgIH0sXG4gICAgeyBtZXNzYWdlOiBcIk11c3QgYmUgYSBCdWZmZXJcIiB9XG4gIClcbl0pO1xuZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFYyRGF0YUNvbnRlbnQoY29udGVudCkge1xuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4geyBkYXRhOiBjb250ZW50LCBtZWRpYVR5cGU6IHZvaWQgMCB9O1xuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4geyBkYXRhOiBuZXcgVWludDhBcnJheShjb250ZW50KSwgbWVkaWFUeXBlOiB2b2lkIDAgfTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgY29udGVudCA9IG5ldyBVUkwoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVUkwgJiYgY29udGVudC5wcm90b2NvbCA9PT0gXCJkYXRhOlwiKSB7XG4gICAgY29uc3QgeyBtZWRpYVR5cGU6IGRhdGFVcmxNZWRpYVR5cGUsIGJhc2U2NENvbnRlbnQgfSA9IHNwbGl0RGF0YVVybChcbiAgICAgIGNvbnRlbnQudG9TdHJpbmcoKVxuICAgICk7XG4gICAgaWYgKGRhdGFVcmxNZWRpYVR5cGUgPT0gbnVsbCB8fCBiYXNlNjRDb250ZW50ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBBSVNES0Vycm9yMTgoe1xuICAgICAgICBuYW1lOiBcIkludmFsaWREYXRhQ29udGVudEVycm9yXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdCBpbiBjb250ZW50ICR7Y29udGVudC50b1N0cmluZygpfWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXRhOiBiYXNlNjRDb250ZW50LCBtZWRpYVR5cGU6IGRhdGFVcmxNZWRpYVR5cGUgfTtcbiAgfVxuICByZXR1cm4geyBkYXRhOiBjb250ZW50LCBtZWRpYVR5cGU6IHZvaWQgMCB9O1xufVxuZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmcoY29udGVudCkge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQobmV3IFVpbnQ4QXJyYXkoY29udGVudCkpO1xuICB9XG4gIHJldHVybiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5Mihjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIGRhdGEgY29udGVudC4gQ29udGVudCBzdHJpbmcgaXMgbm90IGEgYmFzZTY0LWVuY29kZWQgbWVkaWEuXCIsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY29udGVudCk7XG4gIH1cbiAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHsgY29udGVudCB9KTtcbn1cblxuLy8gc3JjL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50c1xuYXN5bmMgZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gIHByb21wdCxcbiAgc3VwcG9ydGVkVXJscyxcbiAgZG93bmxvYWQ6IGRvd25sb2FkMiA9IGNyZWF0ZURlZmF1bHREb3dubG9hZEZ1bmN0aW9uKClcbn0pIHtcbiAgY29uc3QgZG93bmxvYWRlZEFzc2V0cyA9IGF3YWl0IGRvd25sb2FkQXNzZXRzKFxuICAgIHByb21wdC5tZXNzYWdlcyxcbiAgICBkb3dubG9hZDIsXG4gICAgc3VwcG9ydGVkVXJsc1xuICApO1xuICByZXR1cm4gW1xuICAgIC4uLnByb21wdC5zeXN0ZW0gIT0gbnVsbCA/IFt7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IHByb21wdC5zeXN0ZW0gfV0gOiBbXSxcbiAgICAuLi5wcm9tcHQubWVzc2FnZXMubWFwKFxuICAgICAgKG1lc3NhZ2UpID0+IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKHsgbWVzc2FnZSwgZG93bmxvYWRlZEFzc2V0cyB9KVxuICAgIClcbiAgXTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKHtcbiAgbWVzc2FnZSxcbiAgZG93bmxvYWRlZEFzc2V0c1xufSkge1xuICBjb25zdCByb2xlID0gbWVzc2FnZS5yb2xlO1xuICBzd2l0Y2ggKHJvbGUpIHtcbiAgICBjYXNlIFwic3lzdGVtXCI6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBtZXNzYWdlLnByb3ZpZGVyT3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogbWVzc2FnZS5wcm92aWRlck9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQubWFwKChwYXJ0KSA9PiBjb252ZXJ0UGFydFRvTGFuZ3VhZ2VNb2RlbFBhcnQocGFydCwgZG93bmxvYWRlZEFzc2V0cykpLmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlICE9PSBcInRleHRcIiB8fCBwYXJ0LnRleHQgIT09IFwiXCIpLFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogbWVzc2FnZS5wcm92aWRlck9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5maWx0ZXIoXG4gICAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IHRleHQgcGFydHM6XG4gICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJ0ZXh0XCIgfHwgcGFydC50ZXh0ICE9PSBcIlwiXG4gICAgICAgICkubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgY29uc3QgcHJvdmlkZXJPcHRpb25zID0gcGFydC5wcm92aWRlck9wdGlvbnM7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBtZWRpYVR5cGUgfSA9IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxWMkRhdGFDb250ZW50KFxuICAgICAgICAgICAgICAgIHBhcnQuZGF0YVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHBhcnQuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgbWVkaWFUeXBlOiBtZWRpYVR5cGUgIT0gbnVsbCA/IG1lZGlhVHlwZSA6IHBhcnQubWVkaWFUeXBlLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZ1wiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnQuaW5wdXQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogcGFydC5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIG91dHB1dDogcGFydC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBtZXNzYWdlLnByb3ZpZGVyT3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoKHBhcnQpID0+ICh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICBvdXRwdXQ6IHBhcnQub3V0cHV0LFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck9wdGlvbnNcbiAgICAgICAgfSkpLFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcm9sZTtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcih7IHJvbGU6IF9leGhhdXN0aXZlQ2hlY2sgfSk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEFzc2V0cyhtZXNzYWdlcywgZG93bmxvYWQyLCBzdXBwb3J0ZWRVcmxzKSB7XG4gIGNvbnN0IHBsYW5uZWREb3dubG9hZHMgPSBtZXNzYWdlcy5maWx0ZXIoKG1lc3NhZ2UpID0+IG1lc3NhZ2Uucm9sZSA9PT0gXCJ1c2VyXCIpLm1hcCgobWVzc2FnZSkgPT4gbWVzc2FnZS5jb250ZW50KS5maWx0ZXIoXG4gICAgKGNvbnRlbnQpID0+IEFycmF5LmlzQXJyYXkoY29udGVudClcbiAgKS5mbGF0KCkuZmlsdGVyKFxuICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiB8fCBwYXJ0LnR5cGUgPT09IFwiZmlsZVwiXG4gICkubWFwKChwYXJ0KSA9PiB7XG4gICAgdmFyIF9hMTc7XG4gICAgY29uc3QgbWVkaWFUeXBlID0gKF9hMTcgPSBwYXJ0Lm1lZGlhVHlwZSkgIT0gbnVsbCA/IF9hMTcgOiBwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiA/IFwiaW1hZ2UvKlwiIDogdm9pZCAwO1xuICAgIGxldCBkYXRhID0gcGFydC50eXBlID09PSBcImltYWdlXCIgPyBwYXJ0LmltYWdlIDogcGFydC5kYXRhO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IG5ldyBVUkwoZGF0YSk7XG4gICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1lZGlhVHlwZSwgZGF0YSB9O1xuICB9KS5maWx0ZXIoXG4gICAgKHBhcnQpID0+IHBhcnQuZGF0YSBpbnN0YW5jZW9mIFVSTFxuICApLm1hcCgocGFydCkgPT4gKHtcbiAgICB1cmw6IHBhcnQuZGF0YSxcbiAgICBpc1VybFN1cHBvcnRlZEJ5TW9kZWw6IHBhcnQubWVkaWFUeXBlICE9IG51bGwgJiYgaXNVcmxTdXBwb3J0ZWQoe1xuICAgICAgdXJsOiBwYXJ0LmRhdGEudG9TdHJpbmcoKSxcbiAgICAgIG1lZGlhVHlwZTogcGFydC5tZWRpYVR5cGUsXG4gICAgICBzdXBwb3J0ZWRVcmxzXG4gICAgfSlcbiAgfSkpO1xuICBjb25zdCBkb3dubG9hZGVkRmlsZXMgPSBhd2FpdCBkb3dubG9hZDIocGxhbm5lZERvd25sb2Fkcyk7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgZG93bmxvYWRlZEZpbGVzLmZpbHRlcihcbiAgICAgIChkb3dubG9hZGVkRmlsZSkgPT4gKGRvd25sb2FkZWRGaWxlID09IG51bGwgPyB2b2lkIDAgOiBkb3dubG9hZGVkRmlsZS5kYXRhKSAhPSBudWxsXG4gICAgKS5tYXAoKHsgZGF0YSwgbWVkaWFUeXBlIH0sIGluZGV4KSA9PiBbXG4gICAgICBwbGFubmVkRG93bmxvYWRzW2luZGV4XS51cmwudG9TdHJpbmcoKSxcbiAgICAgIHsgZGF0YSwgbWVkaWFUeXBlIH1cbiAgICBdKVxuICApO1xufVxuZnVuY3Rpb24gY29udmVydFBhcnRUb0xhbmd1YWdlTW9kZWxQYXJ0KHBhcnQsIGRvd25sb2FkZWRBc3NldHMpIHtcbiAgdmFyIF9hMTc7XG4gIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyT3B0aW9uc1xuICAgIH07XG4gIH1cbiAgbGV0IG9yaWdpbmFsRGF0YTtcbiAgY29uc3QgdHlwZSA9IHBhcnQudHlwZTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImltYWdlXCI6XG4gICAgICBvcmlnaW5hbERhdGEgPSBwYXJ0LmltYWdlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZpbGVcIjpcbiAgICAgIG9yaWdpbmFsRGF0YSA9IHBhcnQuZGF0YTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhcnQgdHlwZTogJHt0eXBlfWApO1xuICB9XG4gIGNvbnN0IHsgZGF0YTogY29udmVydGVkRGF0YSwgbWVkaWFUeXBlOiBjb252ZXJ0ZWRNZWRpYVR5cGUgfSA9IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxWMkRhdGFDb250ZW50KG9yaWdpbmFsRGF0YSk7XG4gIGxldCBtZWRpYVR5cGUgPSBjb252ZXJ0ZWRNZWRpYVR5cGUgIT0gbnVsbCA/IGNvbnZlcnRlZE1lZGlhVHlwZSA6IHBhcnQubWVkaWFUeXBlO1xuICBsZXQgZGF0YSA9IGNvbnZlcnRlZERhdGE7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgY29uc3QgZG93bmxvYWRlZEZpbGUgPSBkb3dubG9hZGVkQXNzZXRzW2RhdGEudG9TdHJpbmcoKV07XG4gICAgaWYgKGRvd25sb2FkZWRGaWxlKSB7XG4gICAgICBkYXRhID0gZG93bmxvYWRlZEZpbGUuZGF0YTtcbiAgICAgIG1lZGlhVHlwZSAhPSBudWxsID8gbWVkaWFUeXBlIDogbWVkaWFUeXBlID0gZG93bmxvYWRlZEZpbGUubWVkaWFUeXBlO1xuICAgIH1cbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiaW1hZ2VcIjoge1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lZGlhVHlwZSA9IChfYTE3ID0gZGV0ZWN0TWVkaWFUeXBlKHsgZGF0YSwgc2lnbmF0dXJlczogaW1hZ2VNZWRpYVR5cGVTaWduYXR1cmVzIH0pKSAhPSBudWxsID8gX2ExNyA6IG1lZGlhVHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICBtZWRpYVR5cGU6IG1lZGlhVHlwZSAhPSBudWxsID8gbWVkaWFUeXBlIDogXCJpbWFnZS8qXCIsXG4gICAgICAgIC8vIGFueSBpbWFnZVxuICAgICAgICBmaWxlbmFtZTogdm9pZCAwLFxuICAgICAgICBkYXRhLFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICBpZiAobWVkaWFUeXBlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZWRpYSB0eXBlIGlzIG1pc3NpbmcgZm9yIGZpbGUgcGFydGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIG1lZGlhVHlwZSxcbiAgICAgICAgZmlsZW5hbWU6IHBhcnQuZmlsZW5hbWUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9wcm9tcHQvcHJlcGFyZS1jYWxsLXNldHRpbmdzLnRzXG5mdW5jdGlvbiBwcmVwYXJlQ2FsbFNldHRpbmdzKHtcbiAgbWF4T3V0cHV0VG9rZW5zLFxuICB0ZW1wZXJhdHVyZSxcbiAgdG9wUCxcbiAgdG9wSyxcbiAgcHJlc2VuY2VQZW5hbHR5LFxuICBmcmVxdWVuY3lQZW5hbHR5LFxuICBzZWVkLFxuICBzdG9wU2VxdWVuY2VzXG59KSB7XG4gIGlmIChtYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhPdXRwdXRUb2tlbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4T3V0cHV0VG9rZW5zXCIsXG4gICAgICAgIHZhbHVlOiBtYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4T3V0cHV0VG9rZW5zIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1heE91dHB1dFRva2VucyA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhPdXRwdXRUb2tlbnNcIixcbiAgICAgICAgdmFsdWU6IG1heE91dHB1dFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhPdXRwdXRUb2tlbnMgbXVzdCBiZSA+PSAxXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdGVtcGVyYXR1cmUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0ZW1wZXJhdHVyZVwiLFxuICAgICAgICB2YWx1ZTogdGVtcGVyYXR1cmUsXG4gICAgICAgIG1lc3NhZ2U6IFwidGVtcGVyYXR1cmUgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRvcFAgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdG9wUCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRvcFBcIixcbiAgICAgICAgdmFsdWU6IHRvcFAsXG4gICAgICAgIG1lc3NhZ2U6IFwidG9wUCBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodG9wSyAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BLICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidG9wS1wiLFxuICAgICAgICB2YWx1ZTogdG9wSyxcbiAgICAgICAgbWVzc2FnZTogXCJ0b3BLIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChwcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcHJlc2VuY2VQZW5hbHR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwicHJlc2VuY2VQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBwcmVzZW5jZVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwicHJlc2VuY2VQZW5hbHR5IG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChmcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGZyZXF1ZW5jeVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJmcmVxdWVuY3lQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiBcImZyZXF1ZW5jeVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHNlZWQgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzZWVkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNlZWRcIixcbiAgICAgICAgdmFsdWU6IHNlZWQsXG4gICAgICAgIG1lc3NhZ2U6IFwic2VlZCBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbWF4T3V0cHV0VG9rZW5zLFxuICAgIHRlbXBlcmF0dXJlLFxuICAgIHRvcFAsXG4gICAgdG9wSyxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBzdG9wU2VxdWVuY2VzLFxuICAgIHNlZWRcbiAgfTtcbn1cblxuLy8gc3JjL3Byb21wdC9wcmVwYXJlLXRvb2xzLWFuZC10b29sLWNob2ljZS50c1xuaW1wb3J0IHsgYXNTY2hlbWEgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9pcy1ub24tZW1wdHktb2JqZWN0LnRzXG5mdW5jdGlvbiBpc05vbkVtcHR5T2JqZWN0KG9iamVjdDIpIHtcbiAgcmV0dXJuIG9iamVjdDIgIT0gbnVsbCAmJiBPYmplY3Qua2V5cyhvYmplY3QyKS5sZW5ndGggPiAwO1xufVxuXG4vLyBzcmMvcHJvbXB0L3ByZXBhcmUtdG9vbHMtYW5kLXRvb2wtY2hvaWNlLnRzXG5mdW5jdGlvbiBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHtcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIGFjdGl2ZVRvb2xzXG59KSB7XG4gIGlmICghaXNOb25FbXB0eU9iamVjdCh0b29scykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbHM6IHZvaWQgMCxcbiAgICAgIHRvb2xDaG9pY2U6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgY29uc3QgZmlsdGVyZWRUb29scyA9IGFjdGl2ZVRvb2xzICE9IG51bGwgPyBPYmplY3QuZW50cmllcyh0b29scykuZmlsdGVyKFxuICAgIChbbmFtZTE3XSkgPT4gYWN0aXZlVG9vbHMuaW5jbHVkZXMobmFtZTE3KVxuICApIDogT2JqZWN0LmVudHJpZXModG9vbHMpO1xuICByZXR1cm4ge1xuICAgIHRvb2xzOiBmaWx0ZXJlZFRvb2xzLm1hcCgoW25hbWUxNywgdG9vbDNdKSA9PiB7XG4gICAgICBjb25zdCB0b29sVHlwZSA9IHRvb2wzLnR5cGU7XG4gICAgICBzd2l0Y2ggKHRvb2xUeXBlKSB7XG4gICAgICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgICBjYXNlIFwiZHluYW1pY1wiOlxuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgbmFtZTogbmFtZTE3LFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRvb2wzLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgaW5wdXRTY2hlbWE6IGFzU2NoZW1hKHRvb2wzLmlucHV0U2NoZW1hKS5qc29uU2NoZW1hLFxuICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiB0b29sMy5wcm92aWRlck9wdGlvbnNcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwicHJvdmlkZXItZGVmaW5lZFwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInByb3ZpZGVyLWRlZmluZWRcIixcbiAgICAgICAgICAgIG5hbWU6IG5hbWUxNyxcbiAgICAgICAgICAgIGlkOiB0b29sMy5pZCxcbiAgICAgICAgICAgIGFyZ3M6IHRvb2wzLmFyZ3NcbiAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gdG9vbFR5cGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0b29sIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdG9vbENob2ljZTogdG9vbENob2ljZSA9PSBudWxsID8geyB0eXBlOiBcImF1dG9cIiB9IDogdHlwZW9mIHRvb2xDaG9pY2UgPT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IHRvb2xDaG9pY2UgfSA6IHsgdHlwZTogXCJ0b29sXCIsIHRvb2xOYW1lOiB0b29sQ2hvaWNlLnRvb2xOYW1lIH1cbiAgfTtcbn1cblxuLy8gc3JjL3Byb21wdC9zdGFuZGFyZGl6ZS1wcm9tcHQudHNcbmltcG9ydCB7IEludmFsaWRQcm9tcHRFcnJvciBhcyBJbnZhbGlkUHJvbXB0RXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNhZmVWYWxpZGF0ZVR5cGVzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejYgfSBmcm9tIFwiem9kL3Y0XCI7XG5cbi8vIHNyYy9wcm9tcHQvbWVzc2FnZS50c1xuaW1wb3J0IHsgeiBhcyB6NSB9IGZyb20gXCJ6b2QvdjRcIjtcblxuLy8gc3JjL3R5cGVzL3Byb3ZpZGVyLW1ldGFkYXRhLnRzXG5pbXBvcnQgeyB6IGFzIHozIH0gZnJvbSBcInpvZC92NFwiO1xuXG4vLyBzcmMvdHlwZXMvanNvbi12YWx1ZS50c1xuaW1wb3J0IHsgeiBhcyB6MiB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciBqc29uVmFsdWVTY2hlbWEgPSB6Mi5sYXp5KFxuICAoKSA9PiB6Mi51bmlvbihbXG4gICAgejIubnVsbCgpLFxuICAgIHoyLnN0cmluZygpLFxuICAgIHoyLm51bWJlcigpLFxuICAgIHoyLmJvb2xlYW4oKSxcbiAgICB6Mi5yZWNvcmQoejIuc3RyaW5nKCksIGpzb25WYWx1ZVNjaGVtYSksXG4gICAgejIuYXJyYXkoanNvblZhbHVlU2NoZW1hKVxuICBdKVxuKTtcblxuLy8gc3JjL3R5cGVzL3Byb3ZpZGVyLW1ldGFkYXRhLnRzXG52YXIgcHJvdmlkZXJNZXRhZGF0YVNjaGVtYSA9IHozLnJlY29yZChcbiAgejMuc3RyaW5nKCksXG4gIHozLnJlY29yZCh6My5zdHJpbmcoKSwganNvblZhbHVlU2NoZW1hKVxuKTtcblxuLy8gc3JjL3Byb21wdC9jb250ZW50LXBhcnQudHNcbmltcG9ydCB7IHogYXMgejQgfSBmcm9tIFwiem9kL3Y0XCI7XG52YXIgdGV4dFBhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwidGV4dFwiKSxcbiAgdGV4dDogejQuc3RyaW5nKCksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBpbWFnZVBhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwiaW1hZ2VcIiksXG4gIGltYWdlOiB6NC51bmlvbihbZGF0YUNvbnRlbnRTY2hlbWEsIHo0Lmluc3RhbmNlb2YoVVJMKV0pLFxuICBtZWRpYVR5cGU6IHo0LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBmaWxlUGFydFNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJmaWxlXCIpLFxuICBkYXRhOiB6NC51bmlvbihbZGF0YUNvbnRlbnRTY2hlbWEsIHo0Lmluc3RhbmNlb2YoVVJMKV0pLFxuICBmaWxlbmFtZTogejQuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgbWVkaWFUeXBlOiB6NC5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIHJlYXNvbmluZ1BhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwicmVhc29uaW5nXCIpLFxuICB0ZXh0OiB6NC5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIHRvb2xDYWxsUGFydFNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJ0b29sLWNhbGxcIiksXG4gIHRvb2xDYWxsSWQ6IHo0LnN0cmluZygpLFxuICB0b29sTmFtZTogejQuc3RyaW5nKCksXG4gIGlucHV0OiB6NC51bmtub3duKCksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICBwcm92aWRlckV4ZWN1dGVkOiB6NC5ib29sZWFuKCkub3B0aW9uYWwoKVxufSk7XG52YXIgb3V0cHV0U2NoZW1hID0gejQuZGlzY3JpbWluYXRlZFVuaW9uKFwidHlwZVwiLCBbXG4gIHo0Lm9iamVjdCh7XG4gICAgdHlwZTogejQubGl0ZXJhbChcInRleHRcIiksXG4gICAgdmFsdWU6IHo0LnN0cmluZygpXG4gIH0pLFxuICB6NC5vYmplY3Qoe1xuICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJqc29uXCIpLFxuICAgIHZhbHVlOiBqc29uVmFsdWVTY2hlbWFcbiAgfSksXG4gIHo0Lm9iamVjdCh7XG4gICAgdHlwZTogejQubGl0ZXJhbChcImVycm9yLXRleHRcIiksXG4gICAgdmFsdWU6IHo0LnN0cmluZygpXG4gIH0pLFxuICB6NC5vYmplY3Qoe1xuICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJlcnJvci1qc29uXCIpLFxuICAgIHZhbHVlOiBqc29uVmFsdWVTY2hlbWFcbiAgfSksXG4gIHo0Lm9iamVjdCh7XG4gICAgdHlwZTogejQubGl0ZXJhbChcImNvbnRlbnRcIiksXG4gICAgdmFsdWU6IHo0LmFycmF5KFxuICAgICAgejQudW5pb24oW1xuICAgICAgICB6NC5vYmplY3Qoe1xuICAgICAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJ0ZXh0XCIpLFxuICAgICAgICAgIHRleHQ6IHo0LnN0cmluZygpXG4gICAgICAgIH0pLFxuICAgICAgICB6NC5vYmplY3Qoe1xuICAgICAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJtZWRpYVwiKSxcbiAgICAgICAgICBkYXRhOiB6NC5zdHJpbmcoKSxcbiAgICAgICAgICBtZWRpYVR5cGU6IHo0LnN0cmluZygpXG4gICAgICAgIH0pXG4gICAgICBdKVxuICAgIClcbiAgfSlcbl0pO1xudmFyIHRvb2xSZXN1bHRQYXJ0U2NoZW1hID0gejQub2JqZWN0KHtcbiAgdHlwZTogejQubGl0ZXJhbChcInRvb2wtcmVzdWx0XCIpLFxuICB0b29sQ2FsbElkOiB6NC5zdHJpbmcoKSxcbiAgdG9vbE5hbWU6IHo0LnN0cmluZygpLFxuICBvdXRwdXQ6IG91dHB1dFNjaGVtYSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xuXG4vLyBzcmMvcHJvbXB0L21lc3NhZ2UudHNcbnZhciBzeXN0ZW1Nb2RlbE1lc3NhZ2VTY2hlbWEgPSB6NS5vYmplY3QoXG4gIHtcbiAgICByb2xlOiB6NS5saXRlcmFsKFwic3lzdGVtXCIpLFxuICAgIGNvbnRlbnQ6IHo1LnN0cmluZygpLFxuICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH1cbik7XG52YXIgY29yZVN5c3RlbU1lc3NhZ2VTY2hlbWEgPSBzeXN0ZW1Nb2RlbE1lc3NhZ2VTY2hlbWE7XG52YXIgdXNlck1vZGVsTWVzc2FnZVNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHJvbGU6IHo1LmxpdGVyYWwoXCJ1c2VyXCIpLFxuICBjb250ZW50OiB6NS51bmlvbihbXG4gICAgejUuc3RyaW5nKCksXG4gICAgejUuYXJyYXkoejUudW5pb24oW3RleHRQYXJ0U2NoZW1hLCBpbWFnZVBhcnRTY2hlbWEsIGZpbGVQYXJ0U2NoZW1hXSkpXG4gIF0pLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZVVzZXJNZXNzYWdlU2NoZW1hID0gdXNlck1vZGVsTWVzc2FnZVNjaGVtYTtcbnZhciBhc3Npc3RhbnRNb2RlbE1lc3NhZ2VTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICByb2xlOiB6NS5saXRlcmFsKFwiYXNzaXN0YW50XCIpLFxuICBjb250ZW50OiB6NS51bmlvbihbXG4gICAgejUuc3RyaW5nKCksXG4gICAgejUuYXJyYXkoXG4gICAgICB6NS51bmlvbihbXG4gICAgICAgIHRleHRQYXJ0U2NoZW1hLFxuICAgICAgICBmaWxlUGFydFNjaGVtYSxcbiAgICAgICAgcmVhc29uaW5nUGFydFNjaGVtYSxcbiAgICAgICAgdG9vbENhbGxQYXJ0U2NoZW1hLFxuICAgICAgICB0b29sUmVzdWx0UGFydFNjaGVtYVxuICAgICAgXSlcbiAgICApXG4gIF0pLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZUFzc2lzdGFudE1lc3NhZ2VTY2hlbWEgPSBhc3Npc3RhbnRNb2RlbE1lc3NhZ2VTY2hlbWE7XG52YXIgdG9vbE1vZGVsTWVzc2FnZVNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHJvbGU6IHo1LmxpdGVyYWwoXCJ0b29sXCIpLFxuICBjb250ZW50OiB6NS5hcnJheSh0b29sUmVzdWx0UGFydFNjaGVtYSksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBjb3JlVG9vbE1lc3NhZ2VTY2hlbWEgPSB0b29sTW9kZWxNZXNzYWdlU2NoZW1hO1xudmFyIG1vZGVsTWVzc2FnZVNjaGVtYSA9IHo1LnVuaW9uKFtcbiAgc3lzdGVtTW9kZWxNZXNzYWdlU2NoZW1hLFxuICB1c2VyTW9kZWxNZXNzYWdlU2NoZW1hLFxuICBhc3Npc3RhbnRNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHRvb2xNb2RlbE1lc3NhZ2VTY2hlbWFcbl0pO1xudmFyIGNvcmVNZXNzYWdlU2NoZW1hID0gbW9kZWxNZXNzYWdlU2NoZW1hO1xuXG4vLyBzcmMvcHJvbXB0L3N0YW5kYXJkaXplLXByb21wdC50c1xuYXN5bmMgZnVuY3Rpb24gc3RhbmRhcmRpemVQcm9tcHQocHJvbXB0KSB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBvciBtZXNzYWdlcyBtdXN0IGJlIGRlZmluZWRcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBhbmQgbWVzc2FnZXMgY2Fubm90IGJlIGRlZmluZWQgYXQgdGhlIHNhbWUgdGltZVwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5zeXN0ZW0gIT0gbnVsbCAmJiB0eXBlb2YgcHJvbXB0LnN5c3RlbSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3IyKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwic3lzdGVtIG11c3QgYmUgYSBzdHJpbmdcIlxuICAgIH0pO1xuICB9XG4gIGxldCBtZXNzYWdlcztcbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiB0eXBlb2YgcHJvbXB0LnByb21wdCA9PT0gXCJzdHJpbmdcIikge1xuICAgIG1lc3NhZ2VzID0gW3sgcm9sZTogXCJ1c2VyXCIsIGNvbnRlbnQ6IHByb21wdC5wcm9tcHQgfV07XG4gIH0gZWxzZSBpZiAocHJvbXB0LnByb21wdCAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkocHJvbXB0LnByb21wdCkpIHtcbiAgICBtZXNzYWdlcyA9IHByb21wdC5wcm9tcHQ7XG4gIH0gZWxzZSBpZiAocHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICBtZXNzYWdlcyA9IHByb21wdC5tZXNzYWdlcztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBvciBtZXNzYWdlcyBtdXN0IGJlIGRlZmluZWRcIlxuICAgIH0pO1xuICB9XG4gIGlmIChtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcIm1lc3NhZ2VzIG11c3Qgbm90IGJlIGVtcHR5XCJcbiAgICB9KTtcbiAgfVxuICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMoe1xuICAgIHZhbHVlOiBtZXNzYWdlcyxcbiAgICBzY2hlbWE6IHo2LmFycmF5KG1vZGVsTWVzc2FnZVNjaGVtYSlcbiAgfSk7XG4gIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcjIoe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJUaGUgbWVzc2FnZXMgbXVzdCBiZSBhIE1vZGVsTWVzc2FnZVtdLiBJZiB5b3UgaGF2ZSBwYXNzZWQgYSBVSU1lc3NhZ2VbXSwgeW91IGNhbiB1c2UgY29udmVydFRvTW9kZWxNZXNzYWdlcyB0byBjb252ZXJ0IHRoZW0uXCIsXG4gICAgICBjYXVzZTogdmFsaWRhdGlvblJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXMsXG4gICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtXG4gIH07XG59XG5cbi8vIHNyYy9wcm9tcHQvd3JhcC1nYXRld2F5LWVycm9yLnRzXG5pbXBvcnQge1xuICBHYXRld2F5QXV0aGVudGljYXRpb25FcnJvcixcbiAgR2F0ZXdheU1vZGVsTm90Rm91bmRFcnJvclxufSBmcm9tIFwiQGFpLXNkay9nYXRld2F5XCI7XG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxOSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiB3cmFwR2F0ZXdheUVycm9yKGVycm9yKSB7XG4gIGlmIChHYXRld2F5QXV0aGVudGljYXRpb25FcnJvci5pc0luc3RhbmNlKGVycm9yKSB8fCBHYXRld2F5TW9kZWxOb3RGb3VuZEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgcmV0dXJuIG5ldyBBSVNES0Vycm9yMTkoe1xuICAgICAgbmFtZTogXCJHYXRld2F5RXJyb3JcIixcbiAgICAgIG1lc3NhZ2U6IFwiVmVyY2VsIEFJIEdhdGV3YXkgYWNjZXNzIGZhaWxlZC4gSWYgeW91IHdhbnQgdG8gdXNlIEFJIFNESyBwcm92aWRlcnMgZGlyZWN0bHksIHVzZSB0aGUgcHJvdmlkZXJzLCBlLmcuIEBhaS1zZGsvb3BlbmFpLCBvciByZWdpc3RlciBhIGRpZmZlcmVudCBnbG9iYWwgZGVmYXVsdCBwcm92aWRlci5cIixcbiAgICAgIGNhdXNlOiBlcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cblxuLy8gc3JjL3RlbGVtZXRyeS9hc3NlbWJsZS1vcGVyYXRpb24tbmFtZS50c1xuZnVuY3Rpb24gYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgb3BlcmF0aW9uSWQsXG4gIHRlbGVtZXRyeVxufSkge1xuICByZXR1cm4ge1xuICAgIC8vIHN0YW5kYXJkaXplZCBvcGVyYXRpb24gYW5kIHJlc291cmNlIG5hbWU6XG4gICAgXCJvcGVyYXRpb24ubmFtZVwiOiBgJHtvcGVyYXRpb25JZH0keyh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkKSAhPSBudWxsID8gYCAke3RlbGVtZXRyeS5mdW5jdGlvbklkfWAgOiBcIlwifWAsXG4gICAgXCJyZXNvdXJjZS5uYW1lXCI6IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWQsXG4gICAgLy8gZGV0YWlsZWQsIEFJIFNESyBzcGVjaWZpYyBkYXRhOlxuICAgIFwiYWkub3BlcmF0aW9uSWRcIjogb3BlcmF0aW9uSWQsXG4gICAgXCJhaS50ZWxlbWV0cnkuZnVuY3Rpb25JZFwiOiB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkXG4gIH07XG59XG5cbi8vIHNyYy90ZWxlbWV0cnkvZ2V0LWJhc2UtdGVsZW1ldHJ5LWF0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgbW9kZWwsXG4gIHNldHRpbmdzLFxuICB0ZWxlbWV0cnksXG4gIGhlYWRlcnNcbn0pIHtcbiAgdmFyIF9hMTc7XG4gIHJldHVybiB7XG4gICAgXCJhaS5tb2RlbC5wcm92aWRlclwiOiBtb2RlbC5wcm92aWRlcixcbiAgICBcImFpLm1vZGVsLmlkXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgLy8gc2V0dGluZ3M6XG4gICAgLi4uT2JqZWN0LmVudHJpZXMoc2V0dGluZ3MpLnJlZHVjZSgoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBhdHRyaWJ1dGVzW2BhaS5zZXR0aW5ncy4ke2tleX1gXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfSwge30pLFxuICAgIC8vIGFkZCBtZXRhZGF0YSBhcyBhdHRyaWJ1dGVzOlxuICAgIC4uLk9iamVjdC5lbnRyaWVzKChfYTE3ID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkubWV0YWRhdGEpICE9IG51bGwgPyBfYTE3IDoge30pLnJlZHVjZShcbiAgICAgIChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgYXR0cmlidXRlc1tgYWkudGVsZW1ldHJ5Lm1ldGFkYXRhLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICAvLyByZXF1ZXN0IGhlYWRlcnNcbiAgICAuLi5PYmplY3QuZW50cmllcyhoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30pLnJlZHVjZSgoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBhdHRyaWJ1dGVzW2BhaS5yZXF1ZXN0LmhlYWRlcnMuJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH0sIHt9KVxuICB9O1xufVxuXG4vLyBzcmMvdGVsZW1ldHJ5L2dldC10cmFjZXIudHNcbmltcG9ydCB7IHRyYWNlIH0gZnJvbSBcIkBvcGVudGVsZW1ldHJ5L2FwaVwiO1xuXG4vLyBzcmMvdGVsZW1ldHJ5L25vb3AtdHJhY2VyLnRzXG52YXIgbm9vcFRyYWNlciA9IHtcbiAgc3RhcnRTcGFuKCkge1xuICAgIHJldHVybiBub29wU3BhbjtcbiAgfSxcbiAgc3RhcnRBY3RpdmVTcGFuKG5hbWUxNywgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYXJnMShub29wU3Bhbik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYXJnMihub29wU3Bhbik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXJnMyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYXJnMyhub29wU3Bhbik7XG4gICAgfVxuICB9XG59O1xudmFyIG5vb3BTcGFuID0ge1xuICBzcGFuQ29udGV4dCgpIHtcbiAgICByZXR1cm4gbm9vcFNwYW5Db250ZXh0O1xuICB9LFxuICBzZXRBdHRyaWJ1dGUoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNldEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZEV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRMaW5rKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRMaW5rcygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc2V0U3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICB1cGRhdGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGlzUmVjb3JkaW5nKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgcmVjb3JkRXhjZXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xudmFyIG5vb3BTcGFuQ29udGV4dCA9IHtcbiAgdHJhY2VJZDogXCJcIixcbiAgc3BhbklkOiBcIlwiLFxuICB0cmFjZUZsYWdzOiAwXG59O1xuXG4vLyBzcmMvdGVsZW1ldHJ5L2dldC10cmFjZXIudHNcbmZ1bmN0aW9uIGdldFRyYWNlcih7XG4gIGlzRW5hYmxlZCA9IGZhbHNlLFxuICB0cmFjZXJcbn0gPSB7fSkge1xuICBpZiAoIWlzRW5hYmxlZCkge1xuICAgIHJldHVybiBub29wVHJhY2VyO1xuICB9XG4gIGlmICh0cmFjZXIpIHtcbiAgICByZXR1cm4gdHJhY2VyO1xuICB9XG4gIHJldHVybiB0cmFjZS5nZXRUcmFjZXIoXCJhaVwiKTtcbn1cblxuLy8gc3JjL3RlbGVtZXRyeS9yZWNvcmQtc3Bhbi50c1xuaW1wb3J0IHsgU3BhblN0YXR1c0NvZGUgfSBmcm9tIFwiQG9wZW50ZWxlbWV0cnkvYXBpXCI7XG5mdW5jdGlvbiByZWNvcmRTcGFuKHtcbiAgbmFtZTogbmFtZTE3LFxuICB0cmFjZXIsXG4gIGF0dHJpYnV0ZXMsXG4gIGZuLFxuICBlbmRXaGVuRG9uZSA9IHRydWVcbn0pIHtcbiAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4obmFtZTE3LCB7IGF0dHJpYnV0ZXMgfSwgYXN5bmMgKHNwYW4pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oc3Bhbik7XG4gICAgICBpZiAoZW5kV2hlbkRvbmUpIHtcbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlY29yZEVycm9yT25TcGFuKHNwYW4sIGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVjb3JkRXJyb3JPblNwYW4oc3BhbiwgZXJyb3IpIHtcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBzcGFuLnJlY29yZEV4Y2VwdGlvbih7XG4gICAgICBuYW1lOiBlcnJvci5uYW1lLFxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICAgIH0pO1xuICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgIGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogU3BhblN0YXR1c0NvZGUuRVJST1IgfSk7XG4gIH1cbn1cblxuLy8gc3JjL3RlbGVtZXRyeS9zZWxlY3QtdGVsZW1ldHJ5LWF0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICB0ZWxlbWV0cnksXG4gIGF0dHJpYnV0ZXNcbn0pIHtcbiAgaWYgKCh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5pc0VuYWJsZWQpICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5yZWR1Y2UoKGF0dHJpYnV0ZXMyLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwiaW5wdXRcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuaW5wdXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKCh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5yZWNvcmRJbnB1dHMpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlczI7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5pbnB1dCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PSBudWxsID8gYXR0cmlidXRlczIgOiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogcmVzdWx0IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCJvdXRwdXRcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUub3V0cHV0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICgodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkucmVjb3JkT3V0cHV0cykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLm91dHB1dCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PSBudWxsID8gYXR0cmlidXRlczIgOiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogdmFsdWUgfTtcbiAgfSwge30pO1xufVxuXG4vLyBzcmMvdGVsZW1ldHJ5L3N0cmluZ2lmeS1mb3ItdGVsZW1ldHJ5LnRzXG5mdW5jdGlvbiBzdHJpbmdpZnlGb3JUZWxlbWV0cnkocHJvbXB0KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShcbiAgICBwcm9tcHQubWFwKChtZXNzYWdlKSA9PiAoe1xuICAgICAgLi4ubWVzc2FnZSxcbiAgICAgIGNvbnRlbnQ6IHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlLmNvbnRlbnQgOiBtZXNzYWdlLmNvbnRlbnQubWFwKFxuICAgICAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcImZpbGVcIiA/IHtcbiAgICAgICAgICAuLi5wYXJ0LFxuICAgICAgICAgIGRhdGE6IHBhcnQuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhwYXJ0LmRhdGEpIDogcGFydC5kYXRhXG4gICAgICAgIH0gOiBwYXJ0XG4gICAgICApXG4gICAgfSkpXG4gICk7XG59XG5cbi8vIHNyYy90eXBlcy91c2FnZS50c1xuZnVuY3Rpb24gYWRkTGFuZ3VhZ2VNb2RlbFVzYWdlKHVzYWdlMSwgdXNhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAgaW5wdXRUb2tlbnM6IGFkZFRva2VuQ291bnRzKHVzYWdlMS5pbnB1dFRva2VucywgdXNhZ2UyLmlucHV0VG9rZW5zKSxcbiAgICBvdXRwdXRUb2tlbnM6IGFkZFRva2VuQ291bnRzKHVzYWdlMS5vdXRwdXRUb2tlbnMsIHVzYWdlMi5vdXRwdXRUb2tlbnMpLFxuICAgIHRvdGFsVG9rZW5zOiBhZGRUb2tlbkNvdW50cyh1c2FnZTEudG90YWxUb2tlbnMsIHVzYWdlMi50b3RhbFRva2VucyksXG4gICAgcmVhc29uaW5nVG9rZW5zOiBhZGRUb2tlbkNvdW50cyhcbiAgICAgIHVzYWdlMS5yZWFzb25pbmdUb2tlbnMsXG4gICAgICB1c2FnZTIucmVhc29uaW5nVG9rZW5zXG4gICAgKSxcbiAgICBjYWNoZWRJbnB1dFRva2VuczogYWRkVG9rZW5Db3VudHMoXG4gICAgICB1c2FnZTEuY2FjaGVkSW5wdXRUb2tlbnMsXG4gICAgICB1c2FnZTIuY2FjaGVkSW5wdXRUb2tlbnNcbiAgICApXG4gIH07XG59XG5mdW5jdGlvbiBhZGRUb2tlbkNvdW50cyh0b2tlbkNvdW50MSwgdG9rZW5Db3VudDIpIHtcbiAgcmV0dXJuIHRva2VuQ291bnQxID09IG51bGwgJiYgdG9rZW5Db3VudDIgPT0gbnVsbCA/IHZvaWQgMCA6ICh0b2tlbkNvdW50MSAhPSBudWxsID8gdG9rZW5Db3VudDEgOiAwKSArICh0b2tlbkNvdW50MiAhPSBudWxsID8gdG9rZW5Db3VudDIgOiAwKTtcbn1cblxuLy8gc3JjL3V0aWwvYXMtYXJyYXkudHNcbmZ1bmN0aW9uIGFzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyBbXSA6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuXG4vLyBzcmMvdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IGRlbGF5LCBnZXRFcnJvck1lc3NhZ2UgYXMgZ2V0RXJyb3JNZXNzYWdlMywgaXNBYm9ydEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIGdldFJldHJ5RGVsYXlJbk1zKHtcbiAgZXJyb3IsXG4gIGV4cG9uZW50aWFsQmFja29mZkRlbGF5XG59KSB7XG4gIGNvbnN0IGhlYWRlcnMgPSBlcnJvci5yZXNwb25zZUhlYWRlcnM7XG4gIGlmICghaGVhZGVycylcbiAgICByZXR1cm4gZXhwb25lbnRpYWxCYWNrb2ZmRGVsYXk7XG4gIGxldCBtcztcbiAgY29uc3QgcmV0cnlBZnRlck1zID0gaGVhZGVyc1tcInJldHJ5LWFmdGVyLW1zXCJdO1xuICBpZiAocmV0cnlBZnRlck1zKSB7XG4gICAgY29uc3QgdGltZW91dE1zID0gcGFyc2VGbG9hdChyZXRyeUFmdGVyTXMpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKHRpbWVvdXRNcykpIHtcbiAgICAgIG1zID0gdGltZW91dE1zO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXRyeUFmdGVyID0gaGVhZGVyc1tcInJldHJ5LWFmdGVyXCJdO1xuICBpZiAocmV0cnlBZnRlciAmJiBtcyA9PT0gdm9pZCAwKSB7XG4gICAgY29uc3QgdGltZW91dFNlY29uZHMgPSBwYXJzZUZsb2F0KHJldHJ5QWZ0ZXIpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKHRpbWVvdXRTZWNvbmRzKSkge1xuICAgICAgbXMgPSB0aW1lb3V0U2Vjb25kcyAqIDFlMztcbiAgICB9IGVsc2Uge1xuICAgICAgbXMgPSBEYXRlLnBhcnNlKHJldHJ5QWZ0ZXIpIC0gRGF0ZS5ub3coKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1zICE9IG51bGwgJiYgIU51bWJlci5pc05hTihtcykgJiYgMCA8PSBtcyAmJiAobXMgPCA2MCAqIDFlMyB8fCBtcyA8IGV4cG9uZW50aWFsQmFja29mZkRlbGF5KSkge1xuICAgIHJldHVybiBtcztcbiAgfVxuICByZXR1cm4gZXhwb25lbnRpYWxCYWNrb2ZmRGVsYXk7XG59XG52YXIgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmUmVzcGVjdGluZ1JldHJ5SGVhZGVycyA9ICh7XG4gIG1heFJldHJpZXMgPSAyLFxuICBpbml0aWFsRGVsYXlJbk1zID0gMmUzLFxuICBiYWNrb2ZmRmFjdG9yID0gMixcbiAgYWJvcnRTaWduYWxcbn0gPSB7fSkgPT4gYXN5bmMgKGYpID0+IF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXM6IGluaXRpYWxEZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3IsXG4gIGFib3J0U2lnbmFsXG59KTtcbmFzeW5jIGZ1bmN0aW9uIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3IsXG4gIGFib3J0U2lnbmFsXG59LCBlcnJvcnMgPSBbXSkge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBmKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA9PT0gMCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZTMoZXJyb3IpO1xuICAgIGNvbnN0IG5ld0Vycm9ycyA9IFsuLi5lcnJvcnMsIGVycm9yXTtcbiAgICBjb25zdCB0cnlOdW1iZXIgPSBuZXdFcnJvcnMubGVuZ3RoO1xuICAgIGlmICh0cnlOdW1iZXIgPiBtYXhSZXRyaWVzKSB7XG4gICAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzLiBMYXN0IGVycm9yOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICByZWFzb246IFwibWF4UmV0cmllc0V4Y2VlZGVkXCIsXG4gICAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgQVBJQ2FsbEVycm9yMi5pc0luc3RhbmNlKGVycm9yKSAmJiBlcnJvci5pc1JldHJ5YWJsZSA9PT0gdHJ1ZSAmJiB0cnlOdW1iZXIgPD0gbWF4UmV0cmllcykge1xuICAgICAgYXdhaXQgZGVsYXkoXG4gICAgICAgIGdldFJldHJ5RGVsYXlJbk1zKHtcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBleHBvbmVudGlhbEJhY2tvZmZEZWxheTogZGVsYXlJbk1zXG4gICAgICAgIH0pLFxuICAgICAgICB7IGFib3J0U2lnbmFsIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihcbiAgICAgICAgZixcbiAgICAgICAge1xuICAgICAgICAgIG1heFJldHJpZXMsXG4gICAgICAgICAgZGVsYXlJbk1zOiBiYWNrb2ZmRmFjdG9yICogZGVsYXlJbk1zLFxuICAgICAgICAgIGJhY2tvZmZGYWN0b3IsXG4gICAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgICAgfSxcbiAgICAgICAgbmV3RXJyb3JzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHJ5TnVtYmVyID09PSAxKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMgd2l0aCBub24tcmV0cnlhYmxlIGVycm9yOiAnJHtlcnJvck1lc3NhZ2V9J2AsXG4gICAgICByZWFzb246IFwiZXJyb3JOb3RSZXRyeWFibGVcIixcbiAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWwvcHJlcGFyZS1yZXRyaWVzLnRzXG5mdW5jdGlvbiBwcmVwYXJlUmV0cmllcyh7XG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsXG59KSB7XG4gIGlmIChtYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4UmV0cmllcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSA+PSAwXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBtYXhSZXRyaWVzUmVzdWx0ID0gbWF4UmV0cmllcyAhPSBudWxsID8gbWF4UmV0cmllcyA6IDI7XG4gIHJldHVybiB7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc1Jlc3VsdCxcbiAgICByZXRyeTogcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmUmVzcGVjdGluZ1JldHJ5SGVhZGVycyh7XG4gICAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzUmVzdWx0LFxuICAgICAgYWJvcnRTaWduYWxcbiAgICB9KVxuICB9O1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9leHRyYWN0LXRleHQtY29udGVudC50c1xuZnVuY3Rpb24gZXh0cmFjdFRleHRDb250ZW50KGNvbnRlbnQpIHtcbiAgY29uc3QgcGFydHMgPSBjb250ZW50LmZpbHRlcihcbiAgICAoY29udGVudDIpID0+IGNvbnRlbnQyLnR5cGUgPT09IFwidGV4dFwiXG4gICk7XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBwYXJ0cy5tYXAoKGNvbnRlbnQyKSA9PiBjb250ZW50Mi50ZXh0KS5qb2luKFwiXCIpO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZWQtZmlsZS50c1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSBhcyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5MyxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCBhcyBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0MlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIERlZmF1bHRHZW5lcmF0ZWRGaWxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZGF0YSxcbiAgICBtZWRpYVR5cGVcbiAgfSkge1xuICAgIGNvbnN0IGlzVWludDhBcnJheSA9IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgIHRoaXMuYmFzZTY0RGF0YSA9IGlzVWludDhBcnJheSA/IHZvaWQgMCA6IGRhdGE7XG4gICAgdGhpcy51aW50OEFycmF5RGF0YSA9IGlzVWludDhBcnJheSA/IGRhdGEgOiB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYVR5cGUgPSBtZWRpYVR5cGU7XG4gIH1cbiAgLy8gbGF6eSBjb252ZXJzaW9uIHdpdGggY2FjaGluZyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBjb252ZXJzaW9uIG92ZXJoZWFkOlxuICBnZXQgYmFzZTY0KCkge1xuICAgIGlmICh0aGlzLmJhc2U2NERhdGEgPT0gbnVsbCkge1xuICAgICAgdGhpcy5iYXNlNjREYXRhID0gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NDIodGhpcy51aW50OEFycmF5RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJhc2U2NERhdGE7XG4gIH1cbiAgLy8gbGF6eSBjb252ZXJzaW9uIHdpdGggY2FjaGluZyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBjb252ZXJzaW9uIG92ZXJoZWFkOlxuICBnZXQgdWludDhBcnJheSgpIHtcbiAgICBpZiAodGhpcy51aW50OEFycmF5RGF0YSA9PSBudWxsKSB7XG4gICAgICB0aGlzLnVpbnQ4QXJyYXlEYXRhID0gY29udmVydEJhc2U2NFRvVWludDhBcnJheTModGhpcy5iYXNlNjREYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudWludDhBcnJheURhdGE7XG4gIH1cbn07XG52YXIgRGVmYXVsdEdlbmVyYXRlZEZpbGVXaXRoVHlwZSA9IGNsYXNzIGV4dGVuZHMgRGVmYXVsdEdlbmVyYXRlZEZpbGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy50eXBlID0gXCJmaWxlXCI7XG4gIH1cbn07XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L3BhcnNlLXRvb2wtY2FsbC50c1xuaW1wb3J0IHtcbiAgYXNTY2hlbWEgYXMgYXNTY2hlbWEyLFxuICBzYWZlUGFyc2VKU09OLFxuICBzYWZlVmFsaWRhdGVUeXBlcyBhcyBzYWZlVmFsaWRhdGVUeXBlczJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlVG9vbENhbGwoe1xuICB0b29sQ2FsbCxcbiAgdG9vbHMsXG4gIHJlcGFpclRvb2xDYWxsLFxuICBzeXN0ZW0sXG4gIG1lc3NhZ2VzXG59KSB7XG4gIHRyeSB7XG4gICAgaWYgKHRvb2xzID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3IoeyB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUgfSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgZG9QYXJzZVRvb2xDYWxsKHsgdG9vbENhbGwsIHRvb2xzIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAocmVwYWlyVG9vbENhbGwgPT0gbnVsbCB8fCAhKE5vU3VjaFRvb2xFcnJvci5pc0luc3RhbmNlKGVycm9yKSB8fCBJbnZhbGlkVG9vbElucHV0RXJyb3IuaXNJbnN0YW5jZShlcnJvcikpKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgbGV0IHJlcGFpcmVkVG9vbENhbGwgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVwYWlyZWRUb29sQ2FsbCA9IGF3YWl0IHJlcGFpclRvb2xDYWxsKHtcbiAgICAgICAgICB0b29sQ2FsbCxcbiAgICAgICAgICB0b29scyxcbiAgICAgICAgICBpbnB1dFNjaGVtYTogKHsgdG9vbE5hbWUgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpbnB1dFNjaGVtYSB9ID0gdG9vbHNbdG9vbE5hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIGFzU2NoZW1hMihpbnB1dFNjaGVtYSkuanNvblNjaGVtYTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICBtZXNzYWdlcyxcbiAgICAgICAgICBlcnJvclxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKHJlcGFpckVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBUb29sQ2FsbFJlcGFpckVycm9yKHtcbiAgICAgICAgICBjYXVzZTogcmVwYWlyRXJyb3IsXG4gICAgICAgICAgb3JpZ2luYWxFcnJvcjogZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocmVwYWlyZWRUb29sQ2FsbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IGRvUGFyc2VUb29sQ2FsbCh7IHRvb2xDYWxsOiByZXBhaXJlZFRvb2xDYWxsLCB0b29scyB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgcGFyc2VkSW5wdXQgPSBhd2FpdCBzYWZlUGFyc2VKU09OKHsgdGV4dDogdG9vbENhbGwuaW5wdXQgfSk7XG4gICAgY29uc3QgaW5wdXQgPSBwYXJzZWRJbnB1dC5zdWNjZXNzID8gcGFyc2VkSW5wdXQudmFsdWUgOiB0b29sQ2FsbC5pbnB1dDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICBpbnB1dCxcbiAgICAgIGR5bmFtaWM6IHRydWUsXG4gICAgICBpbnZhbGlkOiB0cnVlLFxuICAgICAgZXJyb3JcbiAgICB9O1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb1BhcnNlVG9vbENhbGwoe1xuICB0b29sQ2FsbCxcbiAgdG9vbHNcbn0pIHtcbiAgY29uc3QgdG9vbE5hbWUgPSB0b29sQ2FsbC50b29sTmFtZTtcbiAgY29uc3QgdG9vbDMgPSB0b29sc1t0b29sTmFtZV07XG4gIGlmICh0b29sMyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7XG4gICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICBhdmFpbGFibGVUb29sczogT2JqZWN0LmtleXModG9vbHMpXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2NoZW1hID0gYXNTY2hlbWEyKHRvb2wzLmlucHV0U2NoZW1hKTtcbiAgY29uc3QgcGFyc2VSZXN1bHQgPSB0b29sQ2FsbC5pbnB1dC50cmltKCkgPT09IFwiXCIgPyBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlczIoeyB2YWx1ZToge30sIHNjaGVtYSB9KSA6IGF3YWl0IHNhZmVQYXJzZUpTT04oeyB0ZXh0OiB0b29sQ2FsbC5pbnB1dCwgc2NoZW1hIH0pO1xuICBpZiAocGFyc2VSZXN1bHQuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRvb2xJbnB1dEVycm9yKHtcbiAgICAgIHRvb2xOYW1lLFxuICAgICAgdG9vbElucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0b29sMy50eXBlID09PSBcImR5bmFtaWNcIiA/IHtcbiAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgIGlucHV0OiBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICBwcm92aWRlckV4ZWN1dGVkOiB0b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHRvb2xDYWxsLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgZHluYW1pYzogdHJ1ZVxuICB9IDoge1xuICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICB0b29sTmFtZSxcbiAgICBpbnB1dDogcGFyc2VSZXN1bHQudmFsdWUsXG4gICAgcHJvdmlkZXJFeGVjdXRlZDogdG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCxcbiAgICBwcm92aWRlck1ldGFkYXRhOiB0b29sQ2FsbC5wcm92aWRlck1ldGFkYXRhXG4gIH07XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L3N0ZXAtcmVzdWx0LnRzXG52YXIgRGVmYXVsdFN0ZXBSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb250ZW50LFxuICAgIGZpbmlzaFJlYXNvbixcbiAgICB1c2FnZSxcbiAgICB3YXJuaW5ncyxcbiAgICByZXF1ZXN0LFxuICAgIHJlc3BvbnNlLFxuICAgIHByb3ZpZGVyTWV0YWRhdGFcbiAgfSkge1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSBmaW5pc2hSZWFzb247XG4gICAgdGhpcy51c2FnZSA9IHVzYWdlO1xuICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBwcm92aWRlck1ldGFkYXRhO1xuICB9XG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidGV4dFwiKS5tYXAoKHBhcnQpID0+IHBhcnQudGV4dCkuam9pbihcIlwiKTtcbiAgfVxuICBnZXQgcmVhc29uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwicmVhc29uaW5nXCIpO1xuICB9XG4gIGdldCByZWFzb25pbmdUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnJlYXNvbmluZy5sZW5ndGggPT09IDAgPyB2b2lkIDAgOiB0aGlzLnJlYXNvbmluZy5tYXAoKHBhcnQpID0+IHBhcnQudGV4dCkuam9pbihcIlwiKTtcbiAgfVxuICBnZXQgZmlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJmaWxlXCIpLm1hcCgocGFydCkgPT4gcGFydC5maWxlKTtcbiAgfVxuICBnZXQgc291cmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcInNvdXJjZVwiKTtcbiAgfVxuICBnZXQgdG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCIpO1xuICB9XG4gIGdldCBzdGF0aWNUb29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbENhbGxzLmZpbHRlcihcbiAgICAgICh0b29sQ2FsbCkgPT4gdG9vbENhbGwuZHluYW1pYyA9PT0gZmFsc2VcbiAgICApO1xuICB9XG4gIGdldCBkeW5hbWljVG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xDYWxscy5maWx0ZXIoXG4gICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLmR5bmFtaWMgPT09IHRydWVcbiAgICApO1xuICB9XG4gIGdldCB0b29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIpO1xuICB9XG4gIGdldCBzdGF0aWNUb29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy50b29sUmVzdWx0cy5maWx0ZXIoXG4gICAgICAodG9vbFJlc3VsdCkgPT4gdG9vbFJlc3VsdC5keW5hbWljID09PSBmYWxzZVxuICAgICk7XG4gIH1cbiAgZ2V0IGR5bmFtaWNUb29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy50b29sUmVzdWx0cy5maWx0ZXIoXG4gICAgICAodG9vbFJlc3VsdCkgPT4gdG9vbFJlc3VsdC5keW5hbWljID09PSB0cnVlXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvc3RvcC1jb25kaXRpb24udHNcbmZ1bmN0aW9uIHN0ZXBDb3VudElzKHN0ZXBDb3VudCkge1xuICByZXR1cm4gKHsgc3RlcHMgfSkgPT4gc3RlcHMubGVuZ3RoID09PSBzdGVwQ291bnQ7XG59XG5mdW5jdGlvbiBoYXNUb29sQ2FsbCh0b29sTmFtZSkge1xuICByZXR1cm4gKHsgc3RlcHMgfSkgPT4ge1xuICAgIHZhciBfYTE3LCBfYiwgX2M7XG4gICAgcmV0dXJuIChfYyA9IChfYiA9IChfYTE3ID0gc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnNvbWUoXG4gICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLnRvb2xOYW1lID09PSB0b29sTmFtZVxuICAgICkpICE9IG51bGwgPyBfYyA6IGZhbHNlO1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gaXNTdG9wQ29uZGl0aW9uTWV0KHtcbiAgc3RvcENvbmRpdGlvbnMsXG4gIHN0ZXBzXG59KSB7XG4gIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoc3RvcENvbmRpdGlvbnMubWFwKChjb25kaXRpb24pID0+IGNvbmRpdGlvbih7IHN0ZXBzIH0pKSkpLnNvbWUoKHJlc3VsdCkgPT4gcmVzdWx0KTtcbn1cblxuLy8gc3JjL3Byb21wdC9jcmVhdGUtdG9vbC1tb2RlbC1vdXRwdXQudHNcbmltcG9ydCB7XG4gIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2U0XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICBvdXRwdXQsXG4gIHRvb2w6IHRvb2wzLFxuICBlcnJvck1vZGVcbn0pIHtcbiAgaWYgKGVycm9yTW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yLXRleHRcIiwgdmFsdWU6IGdldEVycm9yTWVzc2FnZTQob3V0cHV0KSB9O1xuICB9IGVsc2UgaWYgKGVycm9yTW9kZSA9PT0gXCJqc29uXCIpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yLWpzb25cIiwgdmFsdWU6IHRvSlNPTlZhbHVlKG91dHB1dCkgfTtcbiAgfVxuICBpZiAodG9vbDMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wzLnRvTW9kZWxPdXRwdXQpIHtcbiAgICByZXR1cm4gdG9vbDMudG9Nb2RlbE91dHB1dChvdXRwdXQpO1xuICB9XG4gIHJldHVybiB0eXBlb2Ygb3V0cHV0ID09PSBcInN0cmluZ1wiID8geyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IG91dHB1dCB9IDogeyB0eXBlOiBcImpzb25cIiwgdmFsdWU6IHRvSlNPTlZhbHVlKG91dHB1dCkgfTtcbn1cbmZ1bmN0aW9uIHRvSlNPTlZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gbnVsbCA6IHZhbHVlO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC90by1yZXNwb25zZS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gdG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgY29udGVudDogaW5wdXRDb250ZW50LFxuICB0b29sc1xufSkge1xuICBjb25zdCByZXNwb25zZU1lc3NhZ2VzID0gW107XG4gIGNvbnN0IGNvbnRlbnQgPSBpbnB1dENvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwic291cmNlXCIpLmZpbHRlcihcbiAgICAocGFydCkgPT4gKHBhcnQudHlwZSAhPT0gXCJ0b29sLXJlc3VsdFwiIHx8IHBhcnQucHJvdmlkZXJFeGVjdXRlZCkgJiYgKHBhcnQudHlwZSAhPT0gXCJ0b29sLWVycm9yXCIgfHwgcGFydC5wcm92aWRlckV4ZWN1dGVkKVxuICApLmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlICE9PSBcInRleHRcIiB8fCBwYXJ0LnRleHQubGVuZ3RoID4gMCkubWFwKChwYXJ0KSA9PiB7XG4gICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICBjYXNlIFwicmVhc29uaW5nXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgZGF0YTogcGFydC5maWxlLmJhc2U2NCxcbiAgICAgICAgICBtZWRpYVR5cGU6IHBhcnQuZmlsZS5tZWRpYVR5cGUsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICBpbnB1dDogcGFydC5pbnB1dCxcbiAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgb3V0cHV0OiBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgICAgICAgdG9vbDogdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3BhcnQudG9vbE5hbWVdLFxuICAgICAgICAgICAgb3V0cHV0OiBwYXJ0Lm91dHB1dCxcbiAgICAgICAgICAgIGVycm9yTW9kZTogXCJub25lXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB0cnVlLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICBjYXNlIFwidG9vbC1lcnJvclwiOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgb3V0cHV0OiBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgICAgICAgdG9vbDogdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3BhcnQudG9vbE5hbWVdLFxuICAgICAgICAgICAgb3V0cHV0OiBwYXJ0LmVycm9yLFxuICAgICAgICAgICAgZXJyb3JNb2RlOiBcImpzb25cIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgaWYgKGNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaCh7XG4gICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHRvb2xSZXN1bHRDb250ZW50ID0gaW5wdXRDb250ZW50LmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtZXJyb3JcIikuZmlsdGVyKChwYXJ0KSA9PiAhcGFydC5wcm92aWRlckV4ZWN1dGVkKS5tYXAoKHRvb2xSZXN1bHQpID0+ICh7XG4gICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgIHRvb2xDYWxsSWQ6IHRvb2xSZXN1bHQudG9vbENhbGxJZCxcbiAgICB0b29sTmFtZTogdG9vbFJlc3VsdC50b29sTmFtZSxcbiAgICBvdXRwdXQ6IGNyZWF0ZVRvb2xNb2RlbE91dHB1dCh7XG4gICAgICB0b29sOiB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbdG9vbFJlc3VsdC50b29sTmFtZV0sXG4gICAgICBvdXRwdXQ6IHRvb2xSZXN1bHQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiID8gdG9vbFJlc3VsdC5vdXRwdXQgOiB0b29sUmVzdWx0LmVycm9yLFxuICAgICAgZXJyb3JNb2RlOiB0b29sUmVzdWx0LnR5cGUgPT09IFwidG9vbC1lcnJvclwiID8gXCJ0ZXh0XCIgOiBcIm5vbmVcIlxuICAgIH0pXG4gIH0pKTtcbiAgaWYgKHRvb2xSZXN1bHRDb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICBjb250ZW50OiB0b29sUmVzdWx0Q29udGVudFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXNwb25zZU1lc3NhZ2VzO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZS10ZXh0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkID0gY3JlYXRlSWRHZW5lcmF0b3Ioe1xuICBwcmVmaXg6IFwiYWl0eHRcIixcbiAgc2l6ZTogMjRcbn0pO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUZXh0KHtcbiAgbW9kZWw6IG1vZGVsQXJnLFxuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgc3RvcFdoZW4gPSBzdGVwQ291bnRJcygxKSxcbiAgZXhwZXJpbWVudGFsX291dHB1dDogb3V0cHV0LFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gIHByb3ZpZGVyT3B0aW9ucyxcbiAgZXhwZXJpbWVudGFsX2FjdGl2ZVRvb2xzLFxuICBhY3RpdmVUb29scyA9IGV4cGVyaW1lbnRhbF9hY3RpdmVUb29scyxcbiAgZXhwZXJpbWVudGFsX3ByZXBhcmVTdGVwLFxuICBwcmVwYXJlU3RlcCA9IGV4cGVyaW1lbnRhbF9wcmVwYXJlU3RlcCxcbiAgZXhwZXJpbWVudGFsX3JlcGFpclRvb2xDYWxsOiByZXBhaXJUb29sQ2FsbCxcbiAgZXhwZXJpbWVudGFsX2Rvd25sb2FkOiBkb3dubG9hZDIsXG4gIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICBfaW50ZXJuYWw6IHtcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZCxcbiAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gIH0gPSB7fSxcbiAgb25TdGVwRmluaXNoLFxuICAuLi5zZXR0aW5nc1xufSkge1xuICBjb25zdCBtb2RlbCA9IHJlc29sdmVMYW5ndWFnZU1vZGVsKG1vZGVsQXJnKTtcbiAgY29uc3Qgc3RvcENvbmRpdGlvbnMgPSBhc0FycmF5KHN0b3BXaGVuKTtcbiAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWxcbiAgfSk7XG4gIGNvbnN0IGNhbGxTZXR0aW5ncyA9IHByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyAuLi5jYWxsU2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgaW5pdGlhbFByb21wdCA9IGF3YWl0IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzXG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcmVjb3JkU3Bhbih7XG4gICAgICBuYW1lOiBcImFpLmdlbmVyYXRlVGV4dFwiLFxuICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZVRleHRcIixcbiAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgIC8vIG1vZGVsOlxuICAgICAgICAgIFwiYWkubW9kZWwucHJvdmlkZXJcIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgXCJhaS5tb2RlbC5pZFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICBjb25zdCBjYWxsU2V0dGluZ3MyID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgIGxldCBjdXJyZW50TW9kZWxSZXNwb25zZTtcbiAgICAgICAgbGV0IGNsaWVudFRvb2xDYWxscyA9IFtdO1xuICAgICAgICBsZXQgY2xpZW50VG9vbE91dHB1dHMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlcyA9IFtdO1xuICAgICAgICBjb25zdCBzdGVwcyA9IFtdO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgY29uc3Qgc3RlcElucHV0TWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAuLi5pbml0aWFsUHJvbXB0Lm1lc3NhZ2VzLFxuICAgICAgICAgICAgLi4ucmVzcG9uc2VNZXNzYWdlc1xuICAgICAgICAgIF07XG4gICAgICAgICAgY29uc3QgcHJlcGFyZVN0ZXBSZXN1bHQgPSBhd2FpdCAocHJlcGFyZVN0ZXAgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwKHtcbiAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgc3RlcHMsXG4gICAgICAgICAgICBzdGVwTnVtYmVyOiBzdGVwcy5sZW5ndGgsXG4gICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXNcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgIHByb21wdDoge1xuICAgICAgICAgICAgICBzeXN0ZW06IChfYTE3ID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0LnN5c3RlbSkgIT0gbnVsbCA/IF9hMTcgOiBpbml0aWFsUHJvbXB0LnN5c3RlbSxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IChfYiA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5tZXNzYWdlcykgIT0gbnVsbCA/IF9iIDogc3RlcElucHV0TWVzc2FnZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdXBwb3J0ZWRVcmxzOiBhd2FpdCBtb2RlbC5zdXBwb3J0ZWRVcmxzLFxuICAgICAgICAgICAgZG93bmxvYWQ6IGRvd25sb2FkMlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHN0ZXBNb2RlbCA9IHJlc29sdmVMYW5ndWFnZU1vZGVsKFxuICAgICAgICAgICAgKF9jID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0Lm1vZGVsKSAhPSBudWxsID8gX2MgOiBtb2RlbFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgeyB0b29sQ2hvaWNlOiBzdGVwVG9vbENob2ljZSwgdG9vbHM6IHN0ZXBUb29scyB9ID0gcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7XG4gICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgIHRvb2xDaG9pY2U6IChfZCA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC50b29sQ2hvaWNlKSAhPSBudWxsID8gX2QgOiB0b29sQ2hvaWNlLFxuICAgICAgICAgICAgYWN0aXZlVG9vbHM6IChfZSA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5hY3RpdmVUb29scykgIT0gbnVsbCA/IF9lIDogYWN0aXZlVG9vbHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjdXJyZW50TW9kZWxSZXNwb25zZSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZVRleHQuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vZGVsOlxuICAgICAgICAgICAgICAgICAgICBcImFpLm1vZGVsLnByb3ZpZGVyXCI6IHN0ZXBNb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5tb2RlbC5pZFwiOiBzdGVwTW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvbXB0OlxuICAgICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0cmluZ2lmeUZvclRlbGVtZXRyeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQudG9vbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIGxhbmd1YWdlIG1vZGVsIGxldmVsIHRvb2xzOlxuICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdGVwVG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHN0ZXBUb29scy5tYXAoKHRvb2wzKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sMykpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xDaG9pY2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdGVwVG9vbENob2ljZSAhPSBudWxsID8gSlNPTi5zdHJpbmdpZnkoc3RlcFRvb2xDaG9pY2UpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IHN0ZXBNb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBzdGVwTW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4T3V0cHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogc2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnN0b3Bfc2VxdWVuY2VzXCI6IHNldHRpbmdzLnN0b3BTZXF1ZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogKF9hMTggPSBzZXR0aW5ncy50ZW1wZXJhdHVyZSkgIT0gbnVsbCA/IF9hMTggOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogc2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbjIpID0+IHtcbiAgICAgICAgICAgICAgICAgIHZhciBfYTE5LCBfYjIsIF9jMiwgX2QyLCBfZTIsIF9mMiwgX2cyLCBfaDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0ZXBNb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2FsbFNldHRpbmdzMixcbiAgICAgICAgICAgICAgICAgICAgdG9vbHM6IHN0ZXBUb29scyxcbiAgICAgICAgICAgICAgICAgICAgdG9vbENob2ljZTogc3RlcFRvb2xDaG9pY2UsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlRm9ybWF0OiBvdXRwdXQgPT0gbnVsbCA/IHZvaWQgMCA6IG91dHB1dC5yZXNwb25zZUZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAoX2IyID0gKF9hMTkgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE5LmlkKSAhPSBudWxsID8gX2IyIDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2QyID0gKF9jMiA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi50aW1lc3RhbXApICE9IG51bGwgPyBfZDIgOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2YyID0gKF9lMiA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lMi5tb2RlbElkKSAhPSBudWxsID8gX2YyIDogc3RlcE1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IChfZzIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZzIuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogKF9oID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2guYm9keVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIHNwYW4yLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiByZXN1bHQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBleHRyYWN0VGV4dENvbnRlbnQocmVzdWx0LmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBhc1Rvb2xDYWxscyhyZXN1bHQuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xDYWxscyA9PSBudWxsID8gdm9pZCAwIDogSlNPTi5zdHJpbmdpZnkodG9vbENhbGxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlRGF0YS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlbmFtZSB0ZWxlbWV0cnkgYXR0cmlidXRlcyB0byBpbnB1dFRva2VucyBhbmQgb3V0cHV0VG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiByZXN1bHQudXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogcmVzdWx0LnVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtyZXN1bHQuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHJlc3VsdC51c2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0LnVzYWdlLm91dHB1dFRva2Vuc1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQsIHJlc3BvbnNlOiByZXNwb25zZURhdGEgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3Qgc3RlcFRvb2xDYWxscyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudC5maWx0ZXIoXG4gICAgICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCJcbiAgICAgICAgICAgICkubWFwKFxuICAgICAgICAgICAgICAodG9vbENhbGwpID0+IHBhcnNlVG9vbENhbGwoe1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsLFxuICAgICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICAgIHJlcGFpclRvb2xDYWxsLFxuICAgICAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXNcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2Ygc3RlcFRvb2xDYWxscykge1xuICAgICAgICAgICAgaWYgKHRvb2xDYWxsLmludmFsaWQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b29sMyA9IHRvb2xzW3Rvb2xDYWxsLnRvb2xOYW1lXTtcbiAgICAgICAgICAgIGlmICgodG9vbDMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wzLm9uSW5wdXRBdmFpbGFibGUpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgYXdhaXQgdG9vbDMub25JbnB1dEF2YWlsYWJsZSh7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xDYWxsLmlucHV0LFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpbnZhbGlkVG9vbENhbGxzID0gc3RlcFRvb2xDYWxscy5maWx0ZXIoXG4gICAgICAgICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLmludmFsaWQgJiYgdG9vbENhbGwuZHluYW1pY1xuICAgICAgICAgICk7XG4gICAgICAgICAgY2xpZW50VG9vbE91dHB1dHMgPSBbXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIGludmFsaWRUb29sQ2FsbHMpIHtcbiAgICAgICAgICAgIGNsaWVudFRvb2xPdXRwdXRzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtZXJyb3JcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICBpbnB1dDogdG9vbENhbGwuaW5wdXQsXG4gICAgICAgICAgICAgIGVycm9yOiBnZXRFcnJvck1lc3NhZ2U1KHRvb2xDYWxsLmVycm9yKSxcbiAgICAgICAgICAgICAgZHluYW1pYzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsaWVudFRvb2xDYWxscyA9IHN0ZXBUb29sQ2FsbHMuZmlsdGVyKFxuICAgICAgICAgICAgKHRvb2xDYWxsKSA9PiAhdG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsaWVudFRvb2xPdXRwdXRzLnB1c2goXG4gICAgICAgICAgICAgIC4uLmF3YWl0IGV4ZWN1dGVUb29scyh7XG4gICAgICAgICAgICAgICAgdG9vbENhbGxzOiBjbGllbnRUb29sQ2FsbHMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgKHRvb2xDYWxsKSA9PiAhdG9vbENhbGwuaW52YWxpZFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN0ZXBDb250ZW50ID0gYXNDb250ZW50KHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmNvbnRlbnQsXG4gICAgICAgICAgICB0b29sQ2FsbHM6IHN0ZXBUb29sQ2FsbHMsXG4gICAgICAgICAgICB0b29sT3V0cHV0czogY2xpZW50VG9vbE91dHB1dHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goXG4gICAgICAgICAgICAuLi50b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICAgICAgICAgICAgICBjb250ZW50OiBzdGVwQ29udGVudCxcbiAgICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50U3RlcFJlc3VsdCA9IG5ldyBEZWZhdWx0U3RlcFJlc3VsdCh7XG4gICAgICAgICAgICBjb250ZW50OiBzdGVwQ29udGVudCxcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgdXNhZ2U6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlLFxuICAgICAgICAgICAgd2FybmluZ3M6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLndhcm5pbmdzLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY3VycmVudE1vZGVsUmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgIHJlcXVlc3Q6IChfZiA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlcXVlc3QpICE9IG51bGwgPyBfZiA6IHt9LFxuICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgLi4uY3VycmVudE1vZGVsUmVzcG9uc2UucmVzcG9uc2UsXG4gICAgICAgICAgICAgIC8vIGRlZXAgY2xvbmUgbXNncyB0byBhdm9pZCBtdXRhdGluZyBwYXN0IG1lc3NhZ2VzIGluIG11bHRpLXN0ZXA6XG4gICAgICAgICAgICAgIG1lc3NhZ2VzOiBzdHJ1Y3R1cmVkQ2xvbmUocmVzcG9uc2VNZXNzYWdlcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsb2dXYXJuaW5ncygoX2cgPSBjdXJyZW50TW9kZWxSZXNwb25zZS53YXJuaW5ncykgIT0gbnVsbCA/IF9nIDogW10pO1xuICAgICAgICAgIHN0ZXBzLnB1c2goY3VycmVudFN0ZXBSZXN1bHQpO1xuICAgICAgICAgIGF3YWl0IChvblN0ZXBGaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3RlcEZpbmlzaChjdXJyZW50U3RlcFJlc3VsdCkpO1xuICAgICAgICB9IHdoaWxlIChcbiAgICAgICAgICAvLyB0aGVyZSBhcmUgdG9vbCBjYWxsczpcbiAgICAgICAgICBjbGllbnRUb29sQ2FsbHMubGVuZ3RoID4gMCAmJiAvLyBhbGwgY3VycmVudCB0b29sIGNhbGxzIGhhdmUgb3V0cHV0cyAoaW5jbC4gZXhlY3V0aW9uIGVycm9ycyk6XG4gICAgICAgICAgY2xpZW50VG9vbE91dHB1dHMubGVuZ3RoID09PSBjbGllbnRUb29sQ2FsbHMubGVuZ3RoICYmIC8vIGNvbnRpbnVlIHVudGlsIGEgc3RvcCBjb25kaXRpb24gaXMgbWV0OlxuICAgICAgICAgICFhd2FpdCBpc1N0b3BDb25kaXRpb25NZXQoeyBzdG9wQ29uZGl0aW9ucywgc3RlcHMgfSlcbiAgICAgICAgKTtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBleHRyYWN0VGV4dENvbnRlbnQoY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudClcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbENhbGxzID0gYXNUb29sQ2FsbHMoY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdG9vbENhbGxzID09IG51bGwgPyB2b2lkIDAgOiBKU09OLnN0cmluZ2lmeSh0b29sQ2FsbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXCI6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIGN1cnJlbnRNb2RlbFJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgLy8gVE9ETyByZW5hbWUgdGVsZW1ldHJ5IGF0dHJpYnV0ZXMgdG8gaW5wdXRUb2tlbnMgYW5kIG91dHB1dFRva2Vuc1xuICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiBjdXJyZW50TW9kZWxSZXNwb25zZS51c2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlLm91dHB1dFRva2Vuc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGxhc3RTdGVwID0gc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlVGV4dFJlc3VsdCh7XG4gICAgICAgICAgc3RlcHMsXG4gICAgICAgICAgcmVzb2x2ZWRPdXRwdXQ6IGF3YWl0IChvdXRwdXQgPT0gbnVsbCA/IHZvaWQgMCA6IG91dHB1dC5wYXJzZU91dHB1dChcbiAgICAgICAgICAgIHsgdGV4dDogbGFzdFN0ZXAudGV4dCB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXNwb25zZTogbGFzdFN0ZXAucmVzcG9uc2UsXG4gICAgICAgICAgICAgIHVzYWdlOiBsYXN0U3RlcC51c2FnZSxcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBsYXN0U3RlcC5maW5pc2hSZWFzb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyB3cmFwR2F0ZXdheUVycm9yKGVycm9yKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZVRvb2xzKHtcbiAgdG9vbENhbGxzLFxuICB0b29scyxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnksXG4gIG1lc3NhZ2VzLFxuICBhYm9ydFNpZ25hbCxcbiAgZXhwZXJpbWVudGFsX2NvbnRleHRcbn0pIHtcbiAgY29uc3QgdG9vbE91dHB1dHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICB0b29sQ2FsbHMubWFwKGFzeW5jICh7IHRvb2xDYWxsSWQsIHRvb2xOYW1lLCBpbnB1dCB9KSA9PiB7XG4gICAgICBjb25zdCB0b29sMyA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgIGlmICgodG9vbDMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wzLmV4ZWN1dGUpID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICAgICAgbmFtZTogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwubmFtZVwiOiB0b29sTmFtZSxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwuaWRcIjogdG9vbENhbGxJZCxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwuYXJnc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoaW5wdXQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgdHJhY2VyLFxuICAgICAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gZXhlY3V0ZVRvb2woe1xuICAgICAgICAgICAgICBleGVjdXRlOiB0b29sMy5leGVjdXRlLmJpbmQodG9vbDMpLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwYXJ0IG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICBpZiAocGFydC50eXBlID09PSBcImZpbmFsXCIpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBwYXJ0Lm91dHB1dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLnJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvdXRwdXQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgZHluYW1pYzogdG9vbDMudHlwZSA9PT0gXCJkeW5hbWljXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlY29yZEVycm9yT25TcGFuKHNwYW4sIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1lcnJvclwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICBkeW5hbWljOiB0b29sMy50eXBlID09PSBcImR5bmFtaWNcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pXG4gICk7XG4gIHJldHVybiB0b29sT3V0cHV0cy5maWx0ZXIoXG4gICAgKG91dHB1dCkgPT4gb3V0cHV0ICE9IG51bGxcbiAgKTtcbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVUZXh0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5zdGVwcyA9IG9wdGlvbnMuc3RlcHM7XG4gICAgdGhpcy5yZXNvbHZlZE91dHB1dCA9IG9wdGlvbnMucmVzb2x2ZWRPdXRwdXQ7XG4gIH1cbiAgZ2V0IGZpbmFsU3RlcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwc1t0aGlzLnN0ZXBzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGdldCBjb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5jb250ZW50O1xuICB9XG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50ZXh0O1xuICB9XG4gIGdldCBmaWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAuZmlsZXM7XG4gIH1cbiAgZ2V0IHJlYXNvbmluZ1RleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnJlYXNvbmluZ1RleHQ7XG4gIH1cbiAgZ2V0IHJlYXNvbmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAucmVhc29uaW5nO1xuICB9XG4gIGdldCB0b29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRvb2xDYWxscztcbiAgfVxuICBnZXQgc3RhdGljVG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5zdGF0aWNUb29sQ2FsbHM7XG4gIH1cbiAgZ2V0IGR5bmFtaWNUb29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLmR5bmFtaWNUb29sQ2FsbHM7XG4gIH1cbiAgZ2V0IHRvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50b29sUmVzdWx0cztcbiAgfVxuICBnZXQgc3RhdGljVG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnN0YXRpY1Rvb2xSZXN1bHRzO1xuICB9XG4gIGdldCBkeW5hbWljVG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLmR5bmFtaWNUb29sUmVzdWx0cztcbiAgfVxuICBnZXQgc291cmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAuc291cmNlcztcbiAgfVxuICBnZXQgZmluaXNoUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5maW5pc2hSZWFzb247XG4gIH1cbiAgZ2V0IHdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC53YXJuaW5ncztcbiAgfVxuICBnZXQgcHJvdmlkZXJNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAucHJvdmlkZXJNZXRhZGF0YTtcbiAgfVxuICBnZXQgcmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnJlc3BvbnNlO1xuICB9XG4gIGdldCByZXF1ZXN0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5yZXF1ZXN0O1xuICB9XG4gIGdldCB1c2FnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudXNhZ2U7XG4gIH1cbiAgZ2V0IHRvdGFsVXNhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcHMucmVkdWNlKFxuICAgICAgKHRvdGFsVXNhZ2UsIHN0ZXApID0+IHtcbiAgICAgICAgcmV0dXJuIGFkZExhbmd1YWdlTW9kZWxVc2FnZSh0b3RhbFVzYWdlLCBzdGVwLnVzYWdlKTtcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlucHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgICAgIG91dHB1dFRva2Vuczogdm9pZCAwLFxuICAgICAgICB0b3RhbFRva2Vuczogdm9pZCAwLFxuICAgICAgICByZWFzb25pbmdUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgY2FjaGVkSW5wdXRUb2tlbnM6IHZvaWQgMFxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZ2V0IGV4cGVyaW1lbnRhbF9vdXRwdXQoKSB7XG4gICAgaWYgKHRoaXMucmVzb2x2ZWRPdXRwdXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vT3V0cHV0U3BlY2lmaWVkRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRPdXRwdXQ7XG4gIH1cbn07XG5mdW5jdGlvbiBhc1Rvb2xDYWxscyhjb250ZW50KSB7XG4gIGNvbnN0IHBhcnRzID0gY29udGVudC5maWx0ZXIoXG4gICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIlxuICApO1xuICBpZiAocGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gcGFydHMubWFwKCh0b29sQ2FsbCkgPT4gKHtcbiAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICBpbnB1dDogdG9vbENhbGwuaW5wdXRcbiAgfSkpO1xufVxuZnVuY3Rpb24gYXNDb250ZW50KHtcbiAgY29udGVudCxcbiAgdG9vbENhbGxzLFxuICB0b29sT3V0cHV0c1xufSkge1xuICByZXR1cm4gW1xuICAgIC4uLmNvbnRlbnQubWFwKChwYXJ0KSA9PiB7XG4gICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6XG4gICAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgIGZpbGU6IG5ldyBEZWZhdWx0R2VuZXJhdGVkRmlsZShwYXJ0KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgcmV0dXJuIHRvb2xDYWxscy5maW5kKFxuICAgICAgICAgICAgKHRvb2xDYWxsKSA9PiB0b29sQ2FsbC50b29sQ2FsbElkID09PSBwYXJ0LnRvb2xDYWxsSWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgY29uc3QgdG9vbENhbGwgPSB0b29sQ2FsbHMuZmluZChcbiAgICAgICAgICAgICh0b29sQ2FsbDIpID0+IHRvb2xDYWxsMi50b29sQ2FsbElkID09PSBwYXJ0LnRvb2xDYWxsSWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICh0b29sQ2FsbCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvb2wgY2FsbCAke3BhcnQudG9vbENhbGxJZH0gbm90IGZvdW5kLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydC5pc0Vycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtZXJyb3JcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xDYWxsLmlucHV0LFxuICAgICAgICAgICAgICBlcnJvcjogcGFydC5yZXN1bHQsXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIGR5bmFtaWM6IHRvb2xDYWxsLmR5bmFtaWNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgICAgICAgIG91dHB1dDogcGFydC5yZXN1bHQsXG4gICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB0cnVlLFxuICAgICAgICAgICAgZHluYW1pYzogdG9vbENhbGwuZHluYW1pY1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICAuLi50b29sT3V0cHV0c1xuICBdO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9zdHJlYW0tdGV4dC50c1xuaW1wb3J0IHtcbiAgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTdcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yMixcbiAgaXNBYm9ydEVycm9yIGFzIGlzQWJvcnRFcnJvcjJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3V0aWwvcHJlcGFyZS1oZWFkZXJzLnRzXG5mdW5jdGlvbiBwcmVwYXJlSGVhZGVycyhoZWFkZXJzLCBkZWZhdWx0SGVhZGVycykge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBuZXcgSGVhZGVycyhoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30pO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkZWZhdWx0SGVhZGVycykpIHtcbiAgICBpZiAoIXJlc3BvbnNlSGVhZGVycy5oYXMoa2V5KSkge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlSGVhZGVycztcbn1cblxuLy8gc3JjL3RleHQtc3RyZWFtL2NyZWF0ZS10ZXh0LXN0cmVhbS1yZXNwb25zZS50c1xuZnVuY3Rpb24gY3JlYXRlVGV4dFN0cmVhbVJlc3BvbnNlKHtcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBoZWFkZXJzLFxuICB0ZXh0U3RyZWFtXG59KSB7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UodGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSksIHtcbiAgICBzdGF0dXM6IHN0YXR1cyAhPSBudWxsID8gc3RhdHVzIDogMjAwLFxuICAgIHN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogcHJlcGFyZUhlYWRlcnMoaGVhZGVycywge1xuICAgICAgXCJjb250ZW50LXR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9KVxuICB9KTtcbn1cblxuLy8gc3JjL3V0aWwvd3JpdGUtdG8tc2VydmVyLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICByZXNwb25zZSxcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBoZWFkZXJzLFxuICBzdHJlYW1cbn0pIHtcbiAgcmVzcG9uc2Uud3JpdGVIZWFkKHN0YXR1cyAhPSBudWxsID8gc3RhdHVzIDogMjAwLCBzdGF0dXNUZXh0LCBoZWFkZXJzKTtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICBjb25zdCByZWFkID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgcmVzcG9uc2Uud3JpdGUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgfVxuICB9O1xuICByZWFkKCk7XG59XG5cbi8vIHNyYy90ZXh0LXN0cmVhbS9waXBlLXRleHQtc3RyZWFtLXRvLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2Uoe1xuICByZXNwb25zZSxcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBoZWFkZXJzLFxuICB0ZXh0U3RyZWFtXG59KSB7XG4gIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gICAgcmVzcG9uc2UsXG4gICAgc3RhdHVzLFxuICAgIHN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgcHJlcGFyZUhlYWRlcnMoaGVhZGVycywge1xuICAgICAgICBcImNvbnRlbnQtdHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSkuZW50cmllcygpXG4gICAgKSxcbiAgICBzdHJlYW06IHRleHRTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpXG4gIH0pO1xufVxuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vanNvbi10by1zc2UtdHJhbnNmb3JtLXN0cmVhbS50c1xudmFyIEpzb25Ub1NzZVRyYW5zZm9ybVN0cmVhbSA9IGNsYXNzIGV4dGVuZHMgVHJhbnNmb3JtU3RyZWFtIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHJhbnNmb3JtKHBhcnQsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGBkYXRhOiAke0pTT04uc3RyaW5naWZ5KHBhcnQpfVxuXG5gKTtcbiAgICAgIH0sXG4gICAgICBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcImRhdGE6IFtET05FXVxcblxcblwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL3VpLW1lc3NhZ2Utc3RyZWFtLWhlYWRlcnMudHNcbnZhciBVSV9NRVNTQUdFX1NUUkVBTV9IRUFERVJTID0ge1xuICBcImNvbnRlbnQtdHlwZVwiOiBcInRleHQvZXZlbnQtc3RyZWFtXCIsXG4gIFwiY2FjaGUtY29udHJvbFwiOiBcIm5vLWNhY2hlXCIsXG4gIGNvbm5lY3Rpb246IFwia2VlcC1hbGl2ZVwiLFxuICBcIngtdmVyY2VsLWFpLXVpLW1lc3NhZ2Utc3RyZWFtXCI6IFwidjFcIixcbiAgXCJ4LWFjY2VsLWJ1ZmZlcmluZ1wiOiBcIm5vXCJcbiAgLy8gZGlzYWJsZSBuZ2lueCBidWZmZXJpbmdcbn07XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS9jcmVhdGUtdWktbWVzc2FnZS1zdHJlYW0tcmVzcG9uc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZVVJTWVzc2FnZVN0cmVhbVJlc3BvbnNlKHtcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBoZWFkZXJzLFxuICBzdHJlYW0sXG4gIGNvbnN1bWVTc2VTdHJlYW1cbn0pIHtcbiAgbGV0IHNzZVN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChuZXcgSnNvblRvU3NlVHJhbnNmb3JtU3RyZWFtKCkpO1xuICBpZiAoY29uc3VtZVNzZVN0cmVhbSkge1xuICAgIGNvbnN0IFtzdHJlYW0xLCBzdHJlYW0yXSA9IHNzZVN0cmVhbS50ZWUoKTtcbiAgICBzc2VTdHJlYW0gPSBzdHJlYW0xO1xuICAgIGNvbnN1bWVTc2VTdHJlYW0oeyBzdHJlYW06IHN0cmVhbTIgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShzc2VTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpLCB7XG4gICAgc3RhdHVzLFxuICAgIHN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogcHJlcGFyZUhlYWRlcnMoaGVhZGVycywgVUlfTUVTU0FHRV9TVFJFQU1fSEVBREVSUylcbiAgfSk7XG59XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS9nZXQtcmVzcG9uc2UtdWktbWVzc2FnZS1pZC50c1xuZnVuY3Rpb24gZ2V0UmVzcG9uc2VVSU1lc3NhZ2VJZCh7XG4gIG9yaWdpbmFsTWVzc2FnZXMsXG4gIHJlc3BvbnNlTWVzc2FnZUlkXG59KSB7XG4gIGlmIChvcmlnaW5hbE1lc3NhZ2VzID09IG51bGwpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IGxhc3RNZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlc1tvcmlnaW5hbE1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gKGxhc3RNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TWVzc2FnZS5yb2xlKSA9PT0gXCJhc3Npc3RhbnRcIiA/IGxhc3RNZXNzYWdlLmlkIDogdHlwZW9mIHJlc3BvbnNlTWVzc2FnZUlkID09PSBcImZ1bmN0aW9uXCIgPyByZXNwb25zZU1lc3NhZ2VJZCgpIDogcmVzcG9uc2VNZXNzYWdlSWQ7XG59XG5cbi8vIHNyYy91aS9wcm9jZXNzLXVpLW1lc3NhZ2Utc3RyZWFtLnRzXG5pbXBvcnQge1xuICB2YWxpZGF0ZVR5cGVzXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS91aS1tZXNzYWdlLWNodW5rcy50c1xuaW1wb3J0IHsgeiBhcyB6NyB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciB1aU1lc3NhZ2VDaHVua1NjaGVtYSA9IHo3LnVuaW9uKFtcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwidGV4dC1zdGFydFwiKSxcbiAgICBpZDogejcuc3RyaW5nKCksXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH0pLFxuICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0ZXh0LWRlbHRhXCIpLFxuICAgIGlkOiB6Ny5zdHJpbmcoKSxcbiAgICBkZWx0YTogejcuc3RyaW5nKCksXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH0pLFxuICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0ZXh0LWVuZFwiKSxcbiAgICBpZDogejcuc3RyaW5nKCksXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH0pLFxuICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJlcnJvclwiKSxcbiAgICBlcnJvclRleHQ6IHo3LnN0cmluZygpXG4gIH0pLFxuICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0b29sLWlucHV0LXN0YXJ0XCIpLFxuICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpLFxuICAgIHRvb2xOYW1lOiB6Ny5zdHJpbmcoKSxcbiAgICBwcm92aWRlckV4ZWN1dGVkOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICBkeW5hbWljOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwidG9vbC1pbnB1dC1kZWx0YVwiKSxcbiAgICB0b29sQ2FsbElkOiB6Ny5zdHJpbmcoKSxcbiAgICBpbnB1dFRleHREZWx0YTogejcuc3RyaW5nKClcbiAgfSksXG4gIHo3LnN0cmljdE9iamVjdCh7XG4gICAgdHlwZTogejcubGl0ZXJhbChcInRvb2wtaW5wdXQtYXZhaWxhYmxlXCIpLFxuICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpLFxuICAgIHRvb2xOYW1lOiB6Ny5zdHJpbmcoKSxcbiAgICBpbnB1dDogejcudW5rbm93bigpLFxuICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo3LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICBkeW5hbWljOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwidG9vbC1pbnB1dC1lcnJvclwiKSxcbiAgICB0b29sQ2FsbElkOiB6Ny5zdHJpbmcoKSxcbiAgICB0b29sTmFtZTogejcuc3RyaW5nKCksXG4gICAgaW5wdXQ6IHo3LnVua25vd24oKSxcbiAgICBwcm92aWRlckV4ZWN1dGVkOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgZHluYW1pYzogejcuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgZXJyb3JUZXh0OiB6Ny5zdHJpbmcoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwidG9vbC1vdXRwdXQtYXZhaWxhYmxlXCIpLFxuICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpLFxuICAgIG91dHB1dDogejcudW5rbm93bigpLFxuICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo3LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIGR5bmFtaWM6IHo3LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIHByZWxpbWluYXJ5OiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwidG9vbC1vdXRwdXQtZXJyb3JcIiksXG4gICAgdG9vbENhbGxJZDogejcuc3RyaW5nKCksXG4gICAgZXJyb3JUZXh0OiB6Ny5zdHJpbmcoKSxcbiAgICBwcm92aWRlckV4ZWN1dGVkOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICBkeW5hbWljOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwicmVhc29uaW5nXCIpLFxuICAgIHRleHQ6IHo3LnN0cmluZygpLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwicmVhc29uaW5nLXN0YXJ0XCIpLFxuICAgIGlkOiB6Ny5zdHJpbmcoKSxcbiAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgfSksXG4gIHo3LnN0cmljdE9iamVjdCh7XG4gICAgdHlwZTogejcubGl0ZXJhbChcInJlYXNvbmluZy1kZWx0YVwiKSxcbiAgICBpZDogejcuc3RyaW5nKCksXG4gICAgZGVsdGE6IHo3LnN0cmluZygpLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwicmVhc29uaW5nLWVuZFwiKSxcbiAgICBpZDogejcuc3RyaW5nKCksXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH0pLFxuICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJyZWFzb25pbmctcGFydC1maW5pc2hcIilcbiAgfSksXG4gIHo3LnN0cmljdE9iamVjdCh7XG4gICAgdHlwZTogejcubGl0ZXJhbChcInNvdXJjZS11cmxcIiksXG4gICAgc291cmNlSWQ6IHo3LnN0cmluZygpLFxuICAgIHVybDogejcuc3RyaW5nKCksXG4gICAgdGl0bGU6IHo3LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH0pLFxuICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJzb3VyY2UtZG9jdW1lbnRcIiksXG4gICAgc291cmNlSWQ6IHo3LnN0cmluZygpLFxuICAgIG1lZGlhVHlwZTogejcuc3RyaW5nKCksXG4gICAgdGl0bGU6IHo3LnN0cmluZygpLFxuICAgIGZpbGVuYW1lOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwiZmlsZVwiKSxcbiAgICB1cmw6IHo3LnN0cmluZygpLFxuICAgIG1lZGlhVHlwZTogejcuc3RyaW5nKCksXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH0pLFxuICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgIHR5cGU6IHo3LnN0cmluZygpLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKSxcbiAgICBpZDogejcuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBkYXRhOiB6Ny51bmtub3duKCksXG4gICAgdHJhbnNpZW50OiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwic3RhcnQtc3RlcFwiKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwiZmluaXNoLXN0ZXBcIilcbiAgfSksXG4gIHo3LnN0cmljdE9iamVjdCh7XG4gICAgdHlwZTogejcubGl0ZXJhbChcInN0YXJ0XCIpLFxuICAgIG1lc3NhZ2VJZDogejcuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBtZXNzYWdlTWV0YWRhdGE6IHo3LnVua25vd24oKS5vcHRpb25hbCgpXG4gIH0pLFxuICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJmaW5pc2hcIiksXG4gICAgbWVzc2FnZU1ldGFkYXRhOiB6Ny51bmtub3duKCkub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwiYWJvcnRcIilcbiAgfSksXG4gIHo3LnN0cmljdE9iamVjdCh7XG4gICAgdHlwZTogejcubGl0ZXJhbChcIm1lc3NhZ2UtbWV0YWRhdGFcIiksXG4gICAgbWVzc2FnZU1ldGFkYXRhOiB6Ny51bmtub3duKClcbiAgfSlcbl0pO1xuZnVuY3Rpb24gaXNEYXRhVUlNZXNzYWdlQ2h1bmsoY2h1bmspIHtcbiAgcmV0dXJuIGNodW5rLnR5cGUuc3RhcnRzV2l0aChcImRhdGEtXCIpO1xufVxuXG4vLyBzcmMvdXRpbC9tZXJnZS1vYmplY3RzLnRzXG5mdW5jdGlvbiBtZXJnZU9iamVjdHMoYmFzZSwgb3ZlcnJpZGVzKSB7XG4gIGlmIChiYXNlID09PSB2b2lkIDAgJiYgb3ZlcnJpZGVzID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChiYXNlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVzO1xuICB9XG4gIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHsgLi4uYmFzZSB9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvdmVycmlkZXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG92ZXJyaWRlcywga2V5KSkge1xuICAgICAgY29uc3Qgb3ZlcnJpZGVzVmFsdWUgPSBvdmVycmlkZXNba2V5XTtcbiAgICAgIGlmIChvdmVycmlkZXNWYWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGtleSBpbiBiYXNlID8gYmFzZVtrZXldIDogdm9pZCAwO1xuICAgICAgY29uc3QgaXNTb3VyY2VPYmplY3QgPSBvdmVycmlkZXNWYWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2Ygb3ZlcnJpZGVzVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkob3ZlcnJpZGVzVmFsdWUpICYmICEob3ZlcnJpZGVzVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJiAhKG92ZXJyaWRlc1ZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKTtcbiAgICAgIGNvbnN0IGlzVGFyZ2V0T2JqZWN0ID0gYmFzZVZhbHVlICE9PSBudWxsICYmIGJhc2VWYWx1ZSAhPT0gdm9pZCAwICYmIHR5cGVvZiBiYXNlVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoYmFzZVZhbHVlKSAmJiAhKGJhc2VWYWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmICEoYmFzZVZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKTtcbiAgICAgIGlmIChpc1NvdXJjZU9iamVjdCAmJiBpc1RhcmdldE9iamVjdCkge1xuICAgICAgICByZXN1bHRba2V5XSA9IG1lcmdlT2JqZWN0cyhcbiAgICAgICAgICBiYXNlVmFsdWUsXG4gICAgICAgICAgb3ZlcnJpZGVzVmFsdWVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gb3ZlcnJpZGVzVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy91dGlsL3BhcnNlLXBhcnRpYWwtanNvbi50c1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiBhcyBzYWZlUGFyc2VKU09OMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91dGlsL2ZpeC1qc29uLnRzXG5mdW5jdGlvbiBmaXhKc29uKGlucHV0KSB7XG4gIGNvbnN0IHN0YWNrID0gW1wiUk9PVFwiXTtcbiAgbGV0IGxhc3RWYWxpZEluZGV4ID0gLTE7XG4gIGxldCBsaXRlcmFsU3RhcnQgPSBudWxsO1xuICBmdW5jdGlvbiBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBzd2FwU3RhdGUpIHtcbiAgICB7XG4gICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX1NUUklOR1wiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZlwiOlxuICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICBjYXNlIFwiblwiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIGxpdGVyYWxTdGFydCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTElURVJBTFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiLVwiOiB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTlVNQkVSXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgIGNhc2UgXCIyXCI6XG4gICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgIGNhc2UgXCI1XCI6XG4gICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgIGNhc2UgXCI4XCI6XG4gICAgICAgIGNhc2UgXCI5XCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTlVNQkVSXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ7XCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX1NUQVJUXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJbXCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfU1RBUlRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSkge1xuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIn1cIjoge1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKSB7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gaW5wdXRbaV07XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgc3dpdGNoIChjdXJyZW50U3RhdGUpIHtcbiAgICAgIGNhc2UgXCJST09UXCI6XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiRklOSVNIXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX1NUQVJUXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwifVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0tFWVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiOlwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiOiB7XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXFxcXFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX1NUUklOR19FU0NBUEVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfU1RBUlRcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiOiB7XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HX0VTQ0FQRVwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9OVU1CRVJcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgICAgY2FzZSBcIjVcIjpcbiAgICAgICAgICBjYXNlIFwiNlwiOlxuICAgICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgICAgY2FzZSBcIjhcIjpcbiAgICAgICAgICBjYXNlIFwiOVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImVcIjpcbiAgICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgY2FzZSBcIi5cIjoge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ9XCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9MSVRFUkFMXCI6IHtcbiAgICAgICAgY29uc3QgcGFydGlhbExpdGVyYWwgPSBpbnB1dC5zdWJzdHJpbmcobGl0ZXJhbFN0YXJ0LCBpICsgMSk7XG4gICAgICAgIGlmICghXCJmYWxzZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpICYmICFcInRydWVcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSAmJiAhXCJudWxsXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCByZXN1bHQgPSBpbnB1dC5zbGljZSgwLCBsYXN0VmFsaWRJbmRleCArIDEpO1xuICBmb3IgKGxldCBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0YWNrW2ldO1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9ICdcIic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfS0VZXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9TVEFSVFwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHJlc3VsdCArPSBcIn1cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX1NUQVJUXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfTElURVJBTFwiOiB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxMaXRlcmFsID0gaW5wdXQuc3Vic3RyaW5nKGxpdGVyYWxTdGFydCwgaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgaWYgKFwidHJ1ZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwidHJ1ZVwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJmYWxzZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwiZmFsc2VcIi5zbGljZShwYXJ0aWFsTGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKFwibnVsbFwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwibnVsbFwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3V0aWwvcGFyc2UtcGFydGlhbC1qc29uLnRzXG5hc3luYyBmdW5jdGlvbiBwYXJzZVBhcnRpYWxKc29uKGpzb25UZXh0KSB7XG4gIGlmIChqc29uVGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCwgc3RhdGU6IFwidW5kZWZpbmVkLWlucHV0XCIgfTtcbiAgfVxuICBsZXQgcmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTjIoeyB0ZXh0OiBqc29uVGV4dCB9KTtcbiAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdC52YWx1ZSwgc3RhdGU6IFwic3VjY2Vzc2Z1bC1wYXJzZVwiIH07XG4gIH1cbiAgcmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTjIoeyB0ZXh0OiBmaXhKc29uKGpzb25UZXh0KSB9KTtcbiAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdC52YWx1ZSwgc3RhdGU6IFwicmVwYWlyZWQtcGFyc2VcIiB9O1xuICB9XG4gIHJldHVybiB7IHZhbHVlOiB2b2lkIDAsIHN0YXRlOiBcImZhaWxlZC1wYXJzZVwiIH07XG59XG5cbi8vIHNyYy91aS91aS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gaXNUb29sVUlQYXJ0KHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQudHlwZS5zdGFydHNXaXRoKFwidG9vbC1cIik7XG59XG5mdW5jdGlvbiBpc0R5bmFtaWNUb29sVUlQYXJ0KHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJkeW5hbWljLXRvb2xcIjtcbn1cbmZ1bmN0aW9uIGlzVG9vbE9yRHluYW1pY1Rvb2xVSVBhcnQocGFydCkge1xuICByZXR1cm4gaXNUb29sVUlQYXJ0KHBhcnQpIHx8IGlzRHluYW1pY1Rvb2xVSVBhcnQocGFydCk7XG59XG5mdW5jdGlvbiBnZXRUb29sTmFtZShwYXJ0KSB7XG4gIHJldHVybiBwYXJ0LnR5cGUuc3BsaXQoXCItXCIpLnNsaWNlKDEpLmpvaW4oXCItXCIpO1xufVxuZnVuY3Rpb24gZ2V0VG9vbE9yRHluYW1pY1Rvb2xOYW1lKHBhcnQpIHtcbiAgcmV0dXJuIGlzRHluYW1pY1Rvb2xVSVBhcnQocGFydCkgPyBwYXJ0LnRvb2xOYW1lIDogZ2V0VG9vbE5hbWUocGFydCk7XG59XG5cbi8vIHNyYy91aS9wcm9jZXNzLXVpLW1lc3NhZ2Utc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1pbmdVSU1lc3NhZ2VTdGF0ZSh7XG4gIGxhc3RNZXNzYWdlLFxuICBtZXNzYWdlSWRcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlOiAobGFzdE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RNZXNzYWdlLnJvbGUpID09PSBcImFzc2lzdGFudFwiID8gbGFzdE1lc3NhZ2UgOiB7XG4gICAgICBpZDogbWVzc2FnZUlkLFxuICAgICAgbWV0YWRhdGE6IHZvaWQgMCxcbiAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICBwYXJ0czogW11cbiAgICB9LFxuICAgIGFjdGl2ZVRleHRQYXJ0czoge30sXG4gICAgYWN0aXZlUmVhc29uaW5nUGFydHM6IHt9LFxuICAgIHBhcnRpYWxUb29sQ2FsbHM6IHt9XG4gIH07XG59XG5mdW5jdGlvbiBwcm9jZXNzVUlNZXNzYWdlU3RyZWFtKHtcbiAgc3RyZWFtLFxuICBtZXNzYWdlTWV0YWRhdGFTY2hlbWEsXG4gIGRhdGFQYXJ0U2NoZW1hcyxcbiAgcnVuVXBkYXRlTWVzc2FnZUpvYixcbiAgb25FcnJvcixcbiAgb25Ub29sQ2FsbCxcbiAgb25EYXRhXG59KSB7XG4gIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgYXdhaXQgcnVuVXBkYXRlTWVzc2FnZUpvYihhc3luYyAoeyBzdGF0ZSwgd3JpdGUgfSkgPT4ge1xuICAgICAgICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kO1xuICAgICAgICAgIGZ1bmN0aW9uIGdldFRvb2xJbnZvY2F0aW9uKHRvb2xDYWxsSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9ucyA9IHN0YXRlLm1lc3NhZ2UucGFydHMuZmlsdGVyKGlzVG9vbFVJUGFydCk7XG4gICAgICAgICAgICBjb25zdCB0b29sSW52b2NhdGlvbiA9IHRvb2xJbnZvY2F0aW9ucy5maW5kKFxuICAgICAgICAgICAgICAoaW52b2NhdGlvbikgPT4gaW52b2NhdGlvbi50b29sQ2FsbElkID09PSB0b29sQ2FsbElkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHRvb2xJbnZvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwidG9vbC1vdXRwdXQtZXJyb3IgbXVzdCBiZSBwcmVjZWRlZCBieSBhIHRvb2wtaW5wdXQtYXZhaWxhYmxlXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b29sSW52b2NhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gZ2V0RHluYW1pY1Rvb2xJbnZvY2F0aW9uKHRvb2xDYWxsSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9ucyA9IHN0YXRlLm1lc3NhZ2UucGFydHMuZmlsdGVyKFxuICAgICAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcImR5bmFtaWMtdG9vbFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb24gPSB0b29sSW52b2NhdGlvbnMuZmluZChcbiAgICAgICAgICAgICAgKGludm9jYXRpb24pID0+IGludm9jYXRpb24udG9vbENhbGxJZCA9PT0gdG9vbENhbGxJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh0b29sSW52b2NhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcInRvb2wtb3V0cHV0LWVycm9yIG11c3QgYmUgcHJlY2VkZWQgYnkgYSB0b29sLWlucHV0LWF2YWlsYWJsZVwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9vbEludm9jYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRvb2xQYXJ0KG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHN0YXRlLm1lc3NhZ2UucGFydHMuZmluZChcbiAgICAgICAgICAgICAgKHBhcnQyKSA9PiBpc1Rvb2xVSVBhcnQocGFydDIpICYmIHBhcnQyLnRvb2xDYWxsSWQgPT09IG9wdGlvbnMudG9vbENhbGxJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGFueU9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgYW55UGFydCA9IHBhcnQ7XG4gICAgICAgICAgICBpZiAocGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHBhcnQuc3RhdGUgPSBvcHRpb25zLnN0YXRlO1xuICAgICAgICAgICAgICBhbnlQYXJ0LmlucHV0ID0gYW55T3B0aW9ucy5pbnB1dDtcbiAgICAgICAgICAgICAgYW55UGFydC5vdXRwdXQgPSBhbnlPcHRpb25zLm91dHB1dDtcbiAgICAgICAgICAgICAgYW55UGFydC5lcnJvclRleHQgPSBhbnlPcHRpb25zLmVycm9yVGV4dDtcbiAgICAgICAgICAgICAgYW55UGFydC5yYXdJbnB1dCA9IGFueU9wdGlvbnMucmF3SW5wdXQ7XG4gICAgICAgICAgICAgIGFueVBhcnQucHJlbGltaW5hcnkgPSBhbnlPcHRpb25zLnByZWxpbWluYXJ5O1xuICAgICAgICAgICAgICBhbnlQYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgPSAoX2ExOCA9IGFueU9wdGlvbnMucHJvdmlkZXJFeGVjdXRlZCkgIT0gbnVsbCA/IF9hMTggOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQ7XG4gICAgICAgICAgICAgIGlmIChhbnlPcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCAmJiBwYXJ0LnN0YXRlID09PSBcImlucHV0LWF2YWlsYWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgcGFydC5jYWxsUHJvdmlkZXJNZXRhZGF0YSA9IGFueU9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBgdG9vbC0ke29wdGlvbnMudG9vbE5hbWV9YCxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBvcHRpb25zLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGFueU9wdGlvbnMuaW5wdXQsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBhbnlPcHRpb25zLm91dHB1dCxcbiAgICAgICAgICAgICAgICByYXdJbnB1dDogYW55T3B0aW9ucy5yYXdJbnB1dCxcbiAgICAgICAgICAgICAgICBlcnJvclRleHQ6IGFueU9wdGlvbnMuZXJyb3JUZXh0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGFueU9wdGlvbnMucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICBwcmVsaW1pbmFyeTogYW55T3B0aW9ucy5wcmVsaW1pbmFyeSxcbiAgICAgICAgICAgICAgICAuLi5hbnlPcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IGFueU9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUR5bmFtaWNUb29sUGFydChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBzdGF0ZS5tZXNzYWdlLnBhcnRzLmZpbmQoXG4gICAgICAgICAgICAgIChwYXJ0MikgPT4gcGFydDIudHlwZSA9PT0gXCJkeW5hbWljLXRvb2xcIiAmJiBwYXJ0Mi50b29sQ2FsbElkID09PSBvcHRpb25zLnRvb2xDYWxsSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBhbnlPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGFueVBhcnQgPSBwYXJ0O1xuICAgICAgICAgICAgaWYgKHBhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBwYXJ0LnN0YXRlID0gb3B0aW9ucy5zdGF0ZTtcbiAgICAgICAgICAgICAgYW55UGFydC50b29sTmFtZSA9IG9wdGlvbnMudG9vbE5hbWU7XG4gICAgICAgICAgICAgIGFueVBhcnQuaW5wdXQgPSBhbnlPcHRpb25zLmlucHV0O1xuICAgICAgICAgICAgICBhbnlQYXJ0Lm91dHB1dCA9IGFueU9wdGlvbnMub3V0cHV0O1xuICAgICAgICAgICAgICBhbnlQYXJ0LmVycm9yVGV4dCA9IGFueU9wdGlvbnMuZXJyb3JUZXh0O1xuICAgICAgICAgICAgICBhbnlQYXJ0LnJhd0lucHV0ID0gKF9hMTggPSBhbnlPcHRpb25zLnJhd0lucHV0KSAhPSBudWxsID8gX2ExOCA6IGFueVBhcnQucmF3SW5wdXQ7XG4gICAgICAgICAgICAgIGFueVBhcnQucHJlbGltaW5hcnkgPSBhbnlPcHRpb25zLnByZWxpbWluYXJ5O1xuICAgICAgICAgICAgICBpZiAoYW55T3B0aW9ucy5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgJiYgcGFydC5zdGF0ZSA9PT0gXCJpbnB1dC1hdmFpbGFibGVcIikge1xuICAgICAgICAgICAgICAgIHBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgPSBhbnlPcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJkeW5hbWljLXRvb2xcIixcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogb3B0aW9ucy50b29sTmFtZSxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBvcHRpb25zLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGFueU9wdGlvbnMuaW5wdXQsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBhbnlPcHRpb25zLm91dHB1dCxcbiAgICAgICAgICAgICAgICBlcnJvclRleHQ6IGFueU9wdGlvbnMuZXJyb3JUZXh0LFxuICAgICAgICAgICAgICAgIHByZWxpbWluYXJ5OiBhbnlPcHRpb25zLnByZWxpbWluYXJ5LFxuICAgICAgICAgICAgICAgIC4uLmFueU9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBjYWxsUHJvdmlkZXJNZXRhZGF0YTogYW55T3B0aW9ucy5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXN5bmMgZnVuY3Rpb24gdXBkYXRlTWVzc2FnZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCBtZXJnZWRNZXRhZGF0YSA9IHN0YXRlLm1lc3NhZ2UubWV0YWRhdGEgIT0gbnVsbCA/IG1lcmdlT2JqZWN0cyhzdGF0ZS5tZXNzYWdlLm1ldGFkYXRhLCBtZXRhZGF0YSkgOiBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VNZXRhZGF0YVNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdmFsaWRhdGVUeXBlcyh7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogbWVyZ2VkTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICBzY2hlbWE6IG1lc3NhZ2VNZXRhZGF0YVNjaGVtYVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UubWV0YWRhdGEgPSBtZXJnZWRNZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dC1zdGFydFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRleHRQYXJ0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJzdHJlYW1pbmdcIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0UGFydHNbY2h1bmsuaWRdID0gdGV4dFBhcnQ7XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaCh0ZXh0UGFydCk7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjoge1xuICAgICAgICAgICAgICBjb25zdCB0ZXh0UGFydCA9IHN0YXRlLmFjdGl2ZVRleHRQYXJ0c1tjaHVuay5pZF07XG4gICAgICAgICAgICAgIHRleHRQYXJ0LnRleHQgKz0gY2h1bmsuZGVsdGE7XG4gICAgICAgICAgICAgIHRleHRQYXJ0LnByb3ZpZGVyTWV0YWRhdGEgPSAoX2ExNyA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYTE3IDogdGV4dFBhcnQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGV4dC1lbmRcIjoge1xuICAgICAgICAgICAgICBjb25zdCB0ZXh0UGFydCA9IHN0YXRlLmFjdGl2ZVRleHRQYXJ0c1tjaHVuay5pZF07XG4gICAgICAgICAgICAgIHRleHRQYXJ0LnN0YXRlID0gXCJkb25lXCI7XG4gICAgICAgICAgICAgIHRleHRQYXJ0LnByb3ZpZGVyTWV0YWRhdGEgPSAoX2IgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2IgOiB0ZXh0UGFydC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuYWN0aXZlVGV4dFBhcnRzW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLXN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVhc29uaW5nUGFydCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJzdHJlYW1pbmdcIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0c1tjaHVuay5pZF0gPSByZWFzb25pbmdQYXJ0O1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2gocmVhc29uaW5nUGFydCk7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlYXNvbmluZ1BhcnQgPSBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0c1tjaHVuay5pZF07XG4gICAgICAgICAgICAgIHJlYXNvbmluZ1BhcnQudGV4dCArPSBjaHVuay5kZWx0YTtcbiAgICAgICAgICAgICAgcmVhc29uaW5nUGFydC5wcm92aWRlck1ldGFkYXRhID0gKF9jID0gY2h1bmsucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9jIDogcmVhc29uaW5nUGFydC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmctZW5kXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVhc29uaW5nUGFydCA9IHN0YXRlLmFjdGl2ZVJlYXNvbmluZ1BhcnRzW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgcmVhc29uaW5nUGFydC5wcm92aWRlck1ldGFkYXRhID0gKF9kID0gY2h1bmsucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9kIDogcmVhc29uaW5nUGFydC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICByZWFzb25pbmdQYXJ0LnN0YXRlID0gXCJkb25lXCI7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0c1tjaHVuay5pZF07XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogY2h1bmsubWVkaWFUeXBlLFxuICAgICAgICAgICAgICAgIHVybDogY2h1bmsudXJsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzb3VyY2UtdXJsXCI6IHtcbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNvdXJjZS11cmxcIixcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogY2h1bmsuc291cmNlSWQsXG4gICAgICAgICAgICAgICAgdXJsOiBjaHVuay51cmwsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGNodW5rLnRpdGxlLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInNvdXJjZS1kb2N1bWVudFwiOiB7XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzb3VyY2UtZG9jdW1lbnRcIixcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogY2h1bmsuc291cmNlSWQsXG4gICAgICAgICAgICAgICAgbWVkaWFUeXBlOiBjaHVuay5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGNodW5rLnRpdGxlLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBjaHVuay5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LXN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb25zID0gc3RhdGUubWVzc2FnZS5wYXJ0cy5maWx0ZXIoaXNUb29sVUlQYXJ0KTtcbiAgICAgICAgICAgICAgc3RhdGUucGFydGlhbFRvb2xDYWxsc1tjaHVuay50b29sQ2FsbElkXSA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBpbmRleDogdG9vbEludm9jYXRpb25zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBkeW5hbWljOiBjaHVuay5keW5hbWljXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChjaHVuay5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJpbnB1dC1zdHJlYW1pbmdcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiB2b2lkIDBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiaW5wdXQtc3RyZWFtaW5nXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtZGVsdGFcIjoge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsVG9vbENhbGwgPSBzdGF0ZS5wYXJ0aWFsVG9vbENhbGxzW2NodW5rLnRvb2xDYWxsSWRdO1xuICAgICAgICAgICAgICBwYXJ0aWFsVG9vbENhbGwudGV4dCArPSBjaHVuay5pbnB1dFRleHREZWx0YTtcbiAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZTogcGFydGlhbEFyZ3MgfSA9IGF3YWl0IHBhcnNlUGFydGlhbEpzb24oXG4gICAgICAgICAgICAgICAgcGFydGlhbFRvb2xDYWxsLnRleHRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRpYWxUb29sQ2FsbC5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydGlhbFRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiaW5wdXQtc3RyZWFtaW5nXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogcGFydGlhbEFyZ3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnRpYWxUb29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcImlucHV0LXN0cmVhbWluZ1wiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnRpYWxBcmdzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1hdmFpbGFibGVcIjoge1xuICAgICAgICAgICAgICBpZiAoY2h1bmsuZHluYW1pYykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUR5bmFtaWNUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiaW5wdXQtYXZhaWxhYmxlXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogY2h1bmsuaW5wdXQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcImlucHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IGNodW5rLmlucHV0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBpZiAob25Ub29sQ2FsbCAmJiAhY2h1bmsucHJvdmlkZXJFeGVjdXRlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uVG9vbENhbGwoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGw6IGNodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1lcnJvclwiOiB7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJvdXRwdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBjaHVuay5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIGVycm9yVGV4dDogY2h1bmsuZXJyb3JUZXh0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVRvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJvdXRwdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICByYXdJbnB1dDogY2h1bmsuaW5wdXQsXG4gICAgICAgICAgICAgICAgICBlcnJvclRleHQ6IGNodW5rLmVycm9yVGV4dCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGNodW5rLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1vdXRwdXQtYXZhaWxhYmxlXCI6IHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLmR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sSW52b2NhdGlvbiA9IGdldER5bmFtaWNUb29sSW52b2NhdGlvbihcbiAgICAgICAgICAgICAgICAgIGNodW5rLnRvb2xDYWxsSWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUR5bmFtaWNUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xJbnZvY2F0aW9uLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwib3V0cHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xJbnZvY2F0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgICAgb3V0cHV0OiBjaHVuay5vdXRwdXQsXG4gICAgICAgICAgICAgICAgICBwcmVsaW1pbmFyeTogY2h1bmsucHJlbGltaW5hcnlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sSW52b2NhdGlvbiA9IGdldFRvb2xJbnZvY2F0aW9uKGNodW5rLnRvb2xDYWxsSWQpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVRvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogZ2V0VG9vbE5hbWUodG9vbEludm9jYXRpb24pLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwib3V0cHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xJbnZvY2F0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgICAgb3V0cHV0OiBjaHVuay5vdXRwdXQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBjaHVuay5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgICAgcHJlbGltaW5hcnk6IGNodW5rLnByZWxpbWluYXJ5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1vdXRwdXQtZXJyb3JcIjoge1xuICAgICAgICAgICAgICBpZiAoY2h1bmsuZHluYW1pYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9uID0gZ2V0RHluYW1pY1Rvb2xJbnZvY2F0aW9uKFxuICAgICAgICAgICAgICAgICAgY2h1bmsudG9vbENhbGxJZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbEludm9jYXRpb24udG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJvdXRwdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiB0b29sSW52b2NhdGlvbi5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIGVycm9yVGV4dDogY2h1bmsuZXJyb3JUZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb24gPSBnZXRUb29sSW52b2NhdGlvbihjaHVuay50b29sQ2FsbElkKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGdldFRvb2xOYW1lKHRvb2xJbnZvY2F0aW9uKSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIm91dHB1dC1lcnJvclwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xJbnZvY2F0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgICAgcmF3SW5wdXQ6IHRvb2xJbnZvY2F0aW9uLnJhd0lucHV0LFxuICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBjaHVuay5lcnJvclRleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdGFydC1zdGVwXCI6IHtcbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKHsgdHlwZTogXCJzdGVwLXN0YXJ0XCIgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmlzaC1zdGVwXCI6IHtcbiAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlVGV4dFBhcnRzID0ge307XG4gICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVJlYXNvbmluZ1BhcnRzID0ge307XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLm1lc3NhZ2VJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5pZCA9IGNodW5rLm1lc3NhZ2VJZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVNZXNzYWdlTWV0YWRhdGEoY2h1bmsubWVzc2FnZU1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLm1lc3NhZ2VJZCAhPSBudWxsIHx8IGNodW5rLm1lc3NhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVNZXNzYWdlTWV0YWRhdGEoY2h1bmsubWVzc2FnZU1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLm1lc3NhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlLW1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlTWVzc2FnZU1ldGFkYXRhKGNodW5rLm1lc3NhZ2VNZXRhZGF0YSk7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5tZXNzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgICAgICBvbkVycm9yID09IG51bGwgPyB2b2lkIDAgOiBvbkVycm9yKG5ldyBFcnJvcihjaHVuay5lcnJvclRleHQpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIGlmIChpc0RhdGFVSU1lc3NhZ2VDaHVuayhjaHVuaykpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGRhdGFQYXJ0U2NoZW1hcyA9PSBudWxsID8gdm9pZCAwIDogZGF0YVBhcnRTY2hlbWFzW2NodW5rLnR5cGVdKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBhd2FpdCB2YWxpZGF0ZVR5cGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogZGF0YVBhcnRTY2hlbWFzW2NodW5rLnR5cGVdXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YUNodW5rID0gY2h1bms7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFDaHVuay50cmFuc2llbnQpIHtcbiAgICAgICAgICAgICAgICAgIG9uRGF0YSA9PSBudWxsID8gdm9pZCAwIDogb25EYXRhKGRhdGFDaHVuayk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdVSVBhcnQgPSBkYXRhQ2h1bmsuaWQgIT0gbnVsbCA/IHN0YXRlLm1lc3NhZ2UucGFydHMuZmluZChcbiAgICAgICAgICAgICAgICAgIChjaHVua0FyZykgPT4gZGF0YUNodW5rLnR5cGUgPT09IGNodW5rQXJnLnR5cGUgJiYgZGF0YUNodW5rLmlkID09PSBjaHVua0FyZy5pZFxuICAgICAgICAgICAgICAgICkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVUlQYXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVUlQYXJ0LmRhdGEgPSBkYXRhQ2h1bmsuZGF0YTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKGRhdGFDaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uRGF0YSA9PSBudWxsID8gdm9pZCAwIDogb25EYXRhKGRhdGFDaHVuayk7XG4gICAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vaGFuZGxlLXVpLW1lc3NhZ2Utc3RyZWFtLWZpbmlzaC50c1xuZnVuY3Rpb24gaGFuZGxlVUlNZXNzYWdlU3RyZWFtRmluaXNoKHtcbiAgbWVzc2FnZUlkLFxuICBvcmlnaW5hbE1lc3NhZ2VzID0gW10sXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBzdHJlYW1cbn0pIHtcbiAgbGV0IGxhc3RNZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlcyA9PSBudWxsID8gdm9pZCAwIDogb3JpZ2luYWxNZXNzYWdlc1tvcmlnaW5hbE1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICBpZiAoKGxhc3RNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TWVzc2FnZS5yb2xlKSAhPT0gXCJhc3Npc3RhbnRcIikge1xuICAgIGxhc3RNZXNzYWdlID0gdm9pZCAwO1xuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2VJZCA9IGxhc3RNZXNzYWdlLmlkO1xuICB9XG4gIGxldCBpc0Fib3J0ZWQgPSBmYWxzZTtcbiAgY29uc3QgaWRJbmplY3RlZFN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRDaHVuayA9IGNodW5rO1xuICAgICAgICAgIGlmIChzdGFydENodW5rLm1lc3NhZ2VJZCA9PSBudWxsICYmIG1lc3NhZ2VJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydENodW5rLm1lc3NhZ2VJZCA9IG1lc3NhZ2VJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwiYWJvcnRcIikge1xuICAgICAgICAgIGlzQWJvcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xuICBpZiAob25GaW5pc2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBpZEluamVjdGVkU3RyZWFtO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gY3JlYXRlU3RyZWFtaW5nVUlNZXNzYWdlU3RhdGUoe1xuICAgIGxhc3RNZXNzYWdlOiBsYXN0TWVzc2FnZSA/IHN0cnVjdHVyZWRDbG9uZShsYXN0TWVzc2FnZSkgOiB2b2lkIDAsXG4gICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQgIT0gbnVsbCA/IG1lc3NhZ2VJZCA6IFwiXCJcbiAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHN0cmVhbVxuICB9KTtcbiAgY29uc3QgcnVuVXBkYXRlTWVzc2FnZUpvYiA9IGFzeW5jIChqb2IpID0+IHtcbiAgICBhd2FpdCBqb2IoeyBzdGF0ZSwgd3JpdGU6ICgpID0+IHtcbiAgICB9IH0pO1xuICB9O1xuICBsZXQgZmluaXNoQ2FsbGVkID0gZmFsc2U7XG4gIGNvbnN0IGNhbGxPbkZpbmlzaCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoZmluaXNoQ2FsbGVkIHx8ICFvbkZpbmlzaCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaW5pc2hDYWxsZWQgPSB0cnVlO1xuICAgIGNvbnN0IGlzQ29udGludWF0aW9uID0gc3RhdGUubWVzc2FnZS5pZCA9PT0gKGxhc3RNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TWVzc2FnZS5pZCk7XG4gICAgYXdhaXQgb25GaW5pc2goe1xuICAgICAgaXNBYm9ydGVkLFxuICAgICAgaXNDb250aW51YXRpb24sXG4gICAgICByZXNwb25zZU1lc3NhZ2U6IHN0YXRlLm1lc3NhZ2UsXG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICAuLi5pc0NvbnRpbnVhdGlvbiA/IG9yaWdpbmFsTWVzc2FnZXMuc2xpY2UoMCwgLTEpIDogb3JpZ2luYWxNZXNzYWdlcyxcbiAgICAgICAgc3RhdGUubWVzc2FnZVxuICAgICAgXVxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gcHJvY2Vzc1VJTWVzc2FnZVN0cmVhbSh7XG4gICAgc3RyZWFtOiBpZEluamVjdGVkU3RyZWFtLFxuICAgIHJ1blVwZGF0ZU1lc3NhZ2VKb2IsXG4gICAgb25FcnJvclxuICB9KS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2FuY2VsIGlzIHN0aWxsIG5ldyBhbmQgbWlzc2luZyBmcm9tIHR5cGVzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2Zvcm1TdHJlYW0jYnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gICAgICBhc3luYyBjYW5jZWwoKSB7XG4gICAgICAgIGF3YWl0IGNhbGxPbkZpbmlzaCgpO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKCkge1xuICAgICAgICBhd2FpdCBjYWxsT25GaW5pc2goKTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vcGlwZS11aS1tZXNzYWdlLXN0cmVhbS10by1yZXNwb25zZS50c1xuZnVuY3Rpb24gcGlwZVVJTWVzc2FnZVN0cmVhbVRvUmVzcG9uc2Uoe1xuICByZXNwb25zZSxcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBoZWFkZXJzLFxuICBzdHJlYW0sXG4gIGNvbnN1bWVTc2VTdHJlYW1cbn0pIHtcbiAgbGV0IHNzZVN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChuZXcgSnNvblRvU3NlVHJhbnNmb3JtU3RyZWFtKCkpO1xuICBpZiAoY29uc3VtZVNzZVN0cmVhbSkge1xuICAgIGNvbnN0IFtzdHJlYW0xLCBzdHJlYW0yXSA9IHNzZVN0cmVhbS50ZWUoKTtcbiAgICBzc2VTdHJlYW0gPSBzdHJlYW0xO1xuICAgIGNvbnN1bWVTc2VTdHJlYW0oeyBzdHJlYW06IHN0cmVhbTIgfSk7XG4gIH1cbiAgd3JpdGVUb1NlcnZlclJlc3BvbnNlKHtcbiAgICByZXNwb25zZSxcbiAgICBzdGF0dXMsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBwcmVwYXJlSGVhZGVycyhoZWFkZXJzLCBVSV9NRVNTQUdFX1NUUkVBTV9IRUFERVJTKS5lbnRyaWVzKClcbiAgICApLFxuICAgIHN0cmVhbTogc3NlU3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKVxuICB9KTtcbn1cblxuLy8gc3JjL3V0aWwvYXN5bmMtaXRlcmFibGUtc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHNvdXJjZSkge1xuICBjb25zdCBzdHJlYW0gPSBzb3VyY2UucGlwZVRocm91Z2gobmV3IFRyYW5zZm9ybVN0cmVhbSgpKTtcbiAgc3RyZWFtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMuZ2V0UmVhZGVyKCk7XG4gICAgbGV0IGZpbmlzaGVkID0gZmFsc2U7XG4gICAgYXN5bmMgZnVuY3Rpb24gY2xlYW51cChjYW5jZWxTdHJlYW0pIHtcbiAgICAgIHZhciBfYTE3O1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGNhbmNlbFN0cmVhbSkge1xuICAgICAgICAgIGF3YWl0ICgoX2ExNyA9IHJlYWRlci5jYW5jZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNhbGwocmVhZGVyKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBSZWFkcyB0aGUgbmV4dCBjaHVuayBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBuZXh0IEl0ZXJhdG9yUmVzdWx0LlxuICAgICAgICovXG4gICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdm9pZCAwIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBhd2FpdCBjbGVhbnVwKHRydWUpO1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB2b2lkIDAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWUgfTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCBvbiBlYXJseSBleGl0IChlLmcuLCBicmVhayBmcm9tIGZvci1hd2FpdCkuXG4gICAgICAgKiBFbnN1cmVzIHRoZSBzdHJlYW0gaXMgY2FuY2VsbGVkIGFuZCByZXNvdXJjZXMgYXJlIHJlbGVhc2VkLlxuICAgICAgICogQHJldHVybnMgQSBwcm9taXNlIHJlc29sdmluZyB0byBhIGNvbXBsZXRlZCBJdGVyYXRvclJlc3VsdC5cbiAgICAgICAqL1xuICAgICAgYXN5bmMgcmV0dXJuKCkge1xuICAgICAgICBhd2FpdCBjbGVhbnVwKHRydWUpO1xuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdm9pZCAwIH07XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgb24gZWFybHkgZXhpdCB3aXRoIGVycm9yLlxuICAgICAgICogRW5zdXJlcyB0aGUgc3RyZWFtIGlzIGNhbmNlbGxlZCBhbmQgcmVzb3VyY2VzIGFyZSByZWxlYXNlZCwgdGhlbiByZXRocm93cyB0aGUgZXJyb3IuXG4gICAgICAgKiBAcGFyYW0gZXJyIFRoZSBlcnJvciB0byB0aHJvdy5cbiAgICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2l0aCB0aGUgcHJvdmlkZWQgZXJyb3IuXG4gICAgICAgKi9cbiAgICAgIGFzeW5jIHRocm93KGVycikge1xuICAgICAgICBhd2FpdCBjbGVhbnVwKHRydWUpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuLy8gc3JjL3V0aWwvY29uc3VtZS1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVTdHJlYW0oe1xuICBzdHJlYW0sXG4gIG9uRXJyb3Jcbn0pIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICB0cnkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSlcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIG9uRXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRXJyb3IoZXJyb3IpO1xuICB9IGZpbmFsbHkge1xuICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICB9XG59XG5cbi8vIHNyYy91dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZTI7XG4gIGxldCByZWplY3Q7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlMiA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgcmVzb2x2ZTogcmVzb2x2ZTIsXG4gICAgcmVqZWN0XG4gIH07XG59XG5cbi8vIHNyYy91dGlsL2NyZWF0ZS1zdGl0Y2hhYmxlLXN0cmVhbS50c1xuZnVuY3Rpb24gY3JlYXRlU3RpdGNoYWJsZVN0cmVhbSgpIHtcbiAgbGV0IGlubmVyU3RyZWFtUmVhZGVycyA9IFtdO1xuICBsZXQgY29udHJvbGxlciA9IG51bGw7XG4gIGxldCBpc0Nsb3NlZCA9IGZhbHNlO1xuICBsZXQgd2FpdEZvck5ld1N0cmVhbSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gIGNvbnN0IHRlcm1pbmF0ZSA9ICgpID0+IHtcbiAgICBpc0Nsb3NlZCA9IHRydWU7XG4gICAgd2FpdEZvck5ld1N0cmVhbS5yZXNvbHZlKCk7XG4gICAgaW5uZXJTdHJlYW1SZWFkZXJzLmZvckVhY2goKHJlYWRlcikgPT4gcmVhZGVyLmNhbmNlbCgpKTtcbiAgICBpbm5lclN0cmVhbVJlYWRlcnMgPSBbXTtcbiAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NQdWxsID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0Nsb3NlZCAmJiBpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB3YWl0Rm9yTmV3U3RyZWFtID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICAgIGF3YWl0IHdhaXRGb3JOZXdTdHJlYW0ucHJvbWlzZTtcbiAgICAgIHJldHVybiBwcm9jZXNzUHVsbCgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaW5uZXJTdHJlYW1SZWFkZXJzWzBdLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGlubmVyU3RyZWFtUmVhZGVycy5zaGlmdCgpO1xuICAgICAgICBpZiAoaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhd2FpdCBwcm9jZXNzUHVsbCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ2xvc2VkKSB7XG4gICAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgIGlubmVyU3RyZWFtUmVhZGVycy5zaGlmdCgpO1xuICAgICAgdGVybWluYXRlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHN0cmVhbTogbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0KGNvbnRyb2xsZXJQYXJhbSkge1xuICAgICAgICBjb250cm9sbGVyID0gY29udHJvbGxlclBhcmFtO1xuICAgICAgfSxcbiAgICAgIHB1bGw6IHByb2Nlc3NQdWxsLFxuICAgICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiBpbm5lclN0cmVhbVJlYWRlcnMpIHtcbiAgICAgICAgICBhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzID0gW107XG4gICAgICAgIGlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBhZGRTdHJlYW06IChpbm5lclN0cmVhbSkgPT4ge1xuICAgICAgaWYgKGlzQ2xvc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgaW5uZXIgc3RyZWFtOiBvdXRlciBzdHJlYW0gaXMgY2xvc2VkXCIpO1xuICAgICAgfVxuICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzLnB1c2goaW5uZXJTdHJlYW0uZ2V0UmVhZGVyKCkpO1xuICAgICAgd2FpdEZvck5ld1N0cmVhbS5yZXNvbHZlKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHcmFjZWZ1bGx5IGNsb3NlIHRoZSBvdXRlciBzdHJlYW0uIFRoaXMgd2lsbCBsZXQgdGhlIGlubmVyIHN0cmVhbXNcbiAgICAgKiBmaW5pc2ggcHJvY2Vzc2luZyBhbmQgdGhlbiBjbG9zZSB0aGUgb3V0ZXIgc3RyZWFtLlxuICAgICAqL1xuICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICBpc0Nsb3NlZCA9IHRydWU7XG4gICAgICB3YWl0Rm9yTmV3U3RyZWFtLnJlc29sdmUoKTtcbiAgICAgIGlmIChpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IGNsb3NlIHRoZSBvdXRlciBzdHJlYW0uIFRoaXMgd2lsbCBjYW5jZWwgYWxsIGlubmVyIHN0cmVhbXNcbiAgICAgKiBhbmQgY2xvc2UgdGhlIG91dGVyIHN0cmVhbS5cbiAgICAgKi9cbiAgICB0ZXJtaW5hdGVcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWwvZGVsYXllZC1wcm9taXNlLnRzXG52YXIgRGVsYXllZFByb21pc2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInBlbmRpbmdcIiB9O1xuICAgIHRoaXMuX3Jlc29sdmUgPSB2b2lkIDA7XG4gICAgdGhpcy5fcmVqZWN0ID0gdm9pZCAwO1xuICB9XG4gIGdldCBwcm9taXNlKCkge1xuICAgIGlmICh0aGlzLl9wcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlMiwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0dXMudHlwZSA9PT0gXCJyZXNvbHZlZFwiKSB7XG4gICAgICAgIHJlc29sdmUyKHRoaXMuc3RhdHVzLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMudHlwZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgIHJlamVjdCh0aGlzLnN0YXR1cy5lcnJvcik7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTI7XG4gICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gIH1cbiAgcmVzb2x2ZSh2YWx1ZSkge1xuICAgIHZhciBfYTE3O1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInJlc29sdmVkXCIsIHZhbHVlIH07XG4gICAgaWYgKHRoaXMuX3Byb21pc2UpIHtcbiAgICAgIChfYTE3ID0gdGhpcy5fcmVzb2x2ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJlamVjdChlcnJvcikge1xuICAgIHZhciBfYTE3O1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInJlamVjdGVkXCIsIGVycm9yIH07XG4gICAgaWYgKHRoaXMuX3Byb21pc2UpIHtcbiAgICAgIChfYTE3ID0gdGhpcy5fcmVqZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy91dGlsL25vdy50c1xuZnVuY3Rpb24gbm93KCkge1xuICB2YXIgX2ExNywgX2I7XG4gIHJldHVybiAoX2IgPSAoX2ExNyA9IGdsb2JhbFRoaXMgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMucGVyZm9ybWFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3Lm5vdygpKSAhPSBudWxsID8gX2IgOiBEYXRlLm5vdygpO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9ydW4tdG9vbHMtdHJhbnNmb3JtYXRpb24udHNcbmltcG9ydCB7XG4gIGV4ZWN1dGVUb29sIGFzIGV4ZWN1dGVUb29sMixcbiAgZ2VuZXJhdGVJZCxcbiAgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTZcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICB0b29scyxcbiAgZ2VuZXJhdG9yU3RyZWFtLFxuICB0cmFjZXIsXG4gIHRlbGVtZXRyeSxcbiAgc3lzdGVtLFxuICBtZXNzYWdlcyxcbiAgYWJvcnRTaWduYWwsXG4gIHJlcGFpclRvb2xDYWxsLFxuICBleHBlcmltZW50YWxfY29udGV4dFxufSkge1xuICBsZXQgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyID0gbnVsbDtcbiAgY29uc3QgdG9vbFJlc3VsdHNTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgb3V0c3RhbmRpbmdUb29sUmVzdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHRvb2xJbnB1dHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgbGV0IGZpbmlzaENodW5rID0gdm9pZCAwO1xuICBmdW5jdGlvbiBhdHRlbXB0Q2xvc2UoKSB7XG4gICAgaWYgKGNhbkNsb3NlICYmIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgaWYgKGZpbmlzaENodW5rICE9IG51bGwpIHtcbiAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoZmluaXNoQ2h1bmspO1xuICAgICAgfVxuICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZvcndhcmRTdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rLnR5cGU7XG4gICAgICBzd2l0Y2ggKGNodW5rVHlwZSkge1xuICAgICAgICBjYXNlIFwic3RyZWFtLXN0YXJ0XCI6XG4gICAgICAgIGNhc2UgXCJ0ZXh0LXN0YXJ0XCI6XG4gICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgIGNhc2UgXCJ0ZXh0LWVuZFwiOlxuICAgICAgICBjYXNlIFwicmVhc29uaW5nLXN0YXJ0XCI6XG4gICAgICAgIGNhc2UgXCJyZWFzb25pbmctZGVsdGFcIjpcbiAgICAgICAgY2FzZSBcInJlYXNvbmluZy1lbmRcIjpcbiAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtc3RhcnRcIjpcbiAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtZGVsdGFcIjpcbiAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtZW5kXCI6XG4gICAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6XG4gICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICBjYXNlIFwicmF3XCI6IHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICBmaWxlOiBuZXcgRGVmYXVsdEdlbmVyYXRlZEZpbGVXaXRoVHlwZSh7XG4gICAgICAgICAgICAgIGRhdGE6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICAgIG1lZGlhVHlwZTogY2h1bmsubWVkaWFUeXBlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgIGZpbmlzaENodW5rID0ge1xuICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY2h1bmsuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgdXNhZ2U6IGNodW5rLnVzYWdlLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gYXdhaXQgcGFyc2VUb29sQ2FsbCh7XG4gICAgICAgICAgICAgIHRvb2xDYWxsOiBjaHVuayxcbiAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgIHJlcGFpclRvb2xDYWxsLFxuICAgICAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0b29sQ2FsbCk7XG4gICAgICAgICAgICBpZiAodG9vbENhbGwuaW52YWxpZCkge1xuICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWVycm9yXCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xDYWxsLmlucHV0LFxuICAgICAgICAgICAgICAgIGVycm9yOiBnZXRFcnJvck1lc3NhZ2U2KHRvb2xDYWxsLmVycm9yKSxcbiAgICAgICAgICAgICAgICBkeW5hbWljOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRvb2wzID0gdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdO1xuICAgICAgICAgICAgdG9vbElucHV0cy5zZXQodG9vbENhbGwudG9vbENhbGxJZCwgdG9vbENhbGwuaW5wdXQpO1xuICAgICAgICAgICAgaWYgKHRvb2wzLm9uSW5wdXRBdmFpbGFibGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBhd2FpdCB0b29sMy5vbklucHV0QXZhaWxhYmxlKHtcbiAgICAgICAgICAgICAgICBpbnB1dDogdG9vbENhbGwuaW5wdXQsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlcyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b29sMy5leGVjdXRlICE9IG51bGwgJiYgdG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBjb25zdCB0b29sRXhlY3V0aW9uSWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuYWRkKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5uYW1lXCI6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLmlkXCI6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwuYXJnc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sQ2FsbC5pbnB1dClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBleGVjdXRlVG9vbDIoe1xuICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGU6IHRvb2wzLmV4ZWN1dGUuYmluZCh0b29sMyksXG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xDYWxsLmlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udG9vbENhbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IHBhcnQub3V0cHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucGFydC50eXBlID09PSBcInByZWxpbWluYXJ5XCIgJiYge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVsaW1pbmFyeTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiZmluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gcGFydC5vdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmRFcnJvck9uU3BhbihzcGFuLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi50b29sQ2FsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sUmVzdWx0cy5kZWxldGUodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdENsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuZGVsZXRlKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgICAgICBhdHRlbXB0Q2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob3V0cHV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgY29uc3QgdG9vbE5hbWUgPSBjaHVuay50b29sTmFtZTtcbiAgICAgICAgICBpZiAoY2h1bmsuaXNFcnJvcikge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtZXJyb3JcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgIGlucHV0OiB0b29sSW5wdXRzLmdldChjaHVuay50b29sQ2FsbElkKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgZXJyb3I6IGNodW5rLnJlc3VsdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgIGlucHV0OiB0b29sSW5wdXRzLmdldChjaHVuay50b29sQ2FsbElkKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiBjaHVuay5yZXN1bHQsXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGNodW5rLnByb3ZpZGVyRXhlY3V0ZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rVHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZsdXNoKCkge1xuICAgICAgY2FuQ2xvc2UgPSB0cnVlO1xuICAgICAgYXR0ZW1wdENsb3NlKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2VuZXJhdG9yU3RyZWFtLnBpcGVUaHJvdWdoKGZvcndhcmRTdHJlYW0pLnBpcGVUbyhcbiAgICAgICAgICBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICB0b29sUmVzdWx0c1N0cmVhbS5waXBlVG8oXG4gICAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICBdKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9zdHJlYW0tdGV4dC50c1xudmFyIG9yaWdpbmFsR2VuZXJhdGVJZDIgPSBjcmVhdGVJZEdlbmVyYXRvcjIoe1xuICBwcmVmaXg6IFwiYWl0eHRcIixcbiAgc2l6ZTogMjRcbn0pO1xuZnVuY3Rpb24gc3RyZWFtVGV4dCh7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgc3RvcFdoZW4gPSBzdGVwQ291bnRJcygxKSxcbiAgZXhwZXJpbWVudGFsX291dHB1dDogb3V0cHV0LFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gIHByZXBhcmVTdGVwLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIGV4cGVyaW1lbnRhbF9hY3RpdmVUb29scyxcbiAgYWN0aXZlVG9vbHMgPSBleHBlcmltZW50YWxfYWN0aXZlVG9vbHMsXG4gIGV4cGVyaW1lbnRhbF9yZXBhaXJUb29sQ2FsbDogcmVwYWlyVG9vbENhbGwsXG4gIGV4cGVyaW1lbnRhbF90cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgZXhwZXJpbWVudGFsX2Rvd25sb2FkOiBkb3dubG9hZDIsXG4gIGluY2x1ZGVSYXdDaHVua3MgPSBmYWxzZSxcbiAgb25DaHVuayxcbiAgb25FcnJvciA9ICh7IGVycm9yIH0pID0+IHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgfSxcbiAgb25GaW5pc2gsXG4gIG9uQWJvcnQsXG4gIG9uU3RlcEZpbmlzaCxcbiAgZXhwZXJpbWVudGFsX2NvbnRleHQsXG4gIF9pbnRlcm5hbDoge1xuICAgIG5vdzogbm93MiA9IG5vdyxcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZDIsXG4gICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICB9ID0ge30sXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIHJldHVybiBuZXcgRGVmYXVsdFN0cmVhbVRleHRSZXN1bHQoe1xuICAgIG1vZGVsOiByZXNvbHZlTGFuZ3VhZ2VNb2RlbChtb2RlbCksXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3MsXG4gICAgbWF4UmV0cmllcyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIHRvb2xzLFxuICAgIHRvb2xDaG9pY2UsXG4gICAgdHJhbnNmb3JtczogYXNBcnJheSh0cmFuc2Zvcm0pLFxuICAgIGFjdGl2ZVRvb2xzLFxuICAgIHJlcGFpclRvb2xDYWxsLFxuICAgIHN0b3BDb25kaXRpb25zOiBhc0FycmF5KHN0b3BXaGVuKSxcbiAgICBvdXRwdXQsXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIHByZXBhcmVTdGVwLFxuICAgIGluY2x1ZGVSYXdDaHVua3MsXG4gICAgb25DaHVuayxcbiAgICBvbkVycm9yLFxuICAgIG9uRmluaXNoLFxuICAgIG9uQWJvcnQsXG4gICAgb25TdGVwRmluaXNoLFxuICAgIG5vdzogbm93MixcbiAgICBjdXJyZW50RGF0ZSxcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyxcbiAgICBleHBlcmltZW50YWxfY29udGV4dCxcbiAgICBkb3dubG9hZDogZG93bmxvYWQyXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlT3V0cHV0VHJhbnNmb3JtU3RyZWFtKG91dHB1dCkge1xuICBpZiAoIW91dHB1dCkge1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyBwYXJ0OiBjaHVuaywgcGFydGlhbE91dHB1dDogdm9pZCAwIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGxldCBmaXJzdFRleHRDaHVua0lkID0gdm9pZCAwO1xuICBsZXQgdGV4dDIgPSBcIlwiO1xuICBsZXQgdGV4dENodW5rID0gXCJcIjtcbiAgbGV0IGxhc3RQdWJsaXNoZWRKc29uID0gXCJcIjtcbiAgZnVuY3Rpb24gcHVibGlzaFRleHRDaHVuayh7XG4gICAgY29udHJvbGxlcixcbiAgICBwYXJ0aWFsT3V0cHV0ID0gdm9pZCAwXG4gIH0pIHtcbiAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgcGFydDoge1xuICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgaWQ6IGZpcnN0VGV4dENodW5rSWQsXG4gICAgICAgIHRleHQ6IHRleHRDaHVua1xuICAgICAgfSxcbiAgICAgIHBhcnRpYWxPdXRwdXRcbiAgICB9KTtcbiAgICB0ZXh0Q2h1bmsgPSBcIlwiO1xuICB9XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChjaHVuay50eXBlID09PSBcImZpbmlzaC1zdGVwXCIgJiYgdGV4dENodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcHVibGlzaFRleHRDaHVuayh7IGNvbnRyb2xsZXIgfSk7XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LWRlbHRhXCIgJiYgY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LXN0YXJ0XCIgJiYgY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LWVuZFwiKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHBhcnQ6IGNodW5rLCBwYXJ0aWFsT3V0cHV0OiB2b2lkIDAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdFRleHRDaHVua0lkID09IG51bGwpIHtcbiAgICAgICAgZmlyc3RUZXh0Q2h1bmtJZCA9IGNodW5rLmlkO1xuICAgICAgfSBlbHNlIGlmIChjaHVuay5pZCAhPT0gZmlyc3RUZXh0Q2h1bmtJZCkge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyBwYXJ0OiBjaHVuaywgcGFydGlhbE91dHB1dDogdm9pZCAwIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LXN0YXJ0XCIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgcGFydDogY2h1bmssIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMCB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1lbmRcIikge1xuICAgICAgICBpZiAodGV4dENodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwdWJsaXNoVGV4dENodW5rKHsgY29udHJvbGxlciB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyBwYXJ0OiBjaHVuaywgcGFydGlhbE91dHB1dDogdm9pZCAwIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0ZXh0MiArPSBjaHVuay50ZXh0O1xuICAgICAgdGV4dENodW5rICs9IGNodW5rLnRleHQ7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvdXRwdXQucGFyc2VQYXJ0aWFsKHsgdGV4dDogdGV4dDIgfSk7XG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEpzb24gPSBKU09OLnN0cmluZ2lmeShyZXN1bHQucGFydGlhbCk7XG4gICAgICAgIGlmIChjdXJyZW50SnNvbiAhPT0gbGFzdFB1Ymxpc2hlZEpzb24pIHtcbiAgICAgICAgICBwdWJsaXNoVGV4dENodW5rKHsgY29udHJvbGxlciwgcGFydGlhbE91dHB1dDogcmVzdWx0LnBhcnRpYWwgfSk7XG4gICAgICAgICAgbGFzdFB1Ymxpc2hlZEpzb24gPSBjdXJyZW50SnNvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdFN0cmVhbVRleHRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5ncyxcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsLFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgdG9vbHMsXG4gICAgdG9vbENob2ljZSxcbiAgICB0cmFuc2Zvcm1zLFxuICAgIGFjdGl2ZVRvb2xzLFxuICAgIHJlcGFpclRvb2xDYWxsLFxuICAgIHN0b3BDb25kaXRpb25zLFxuICAgIG91dHB1dCxcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgcHJlcGFyZVN0ZXAsXG4gICAgaW5jbHVkZVJhd0NodW5rcyxcbiAgICBub3c6IG5vdzIsXG4gICAgY3VycmVudERhdGUsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMsXG4gICAgb25DaHVuayxcbiAgICBvbkVycm9yLFxuICAgIG9uRmluaXNoLFxuICAgIG9uQWJvcnQsXG4gICAgb25TdGVwRmluaXNoLFxuICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICAgIGRvd25sb2FkOiBkb3dubG9hZDJcbiAgfSkge1xuICAgIHRoaXMuX3RvdGFsVXNhZ2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLl9maW5pc2hSZWFzb24gPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLl9zdGVwcyA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMub3V0cHV0ID0gb3V0cHV0O1xuICAgIHRoaXMuaW5jbHVkZVJhd0NodW5rcyA9IGluY2x1ZGVSYXdDaHVua3M7XG4gICAgdGhpcy50b29scyA9IHRvb2xzO1xuICAgIGxldCBzdGVwRmluaXNoO1xuICAgIGxldCByZWNvcmRlZENvbnRlbnQgPSBbXTtcbiAgICBjb25zdCByZWNvcmRlZFJlc3BvbnNlTWVzc2FnZXMgPSBbXTtcbiAgICBsZXQgcmVjb3JkZWRGaW5pc2hSZWFzb24gPSB2b2lkIDA7XG4gICAgbGV0IHJlY29yZGVkVG90YWxVc2FnZSA9IHZvaWQgMDtcbiAgICBsZXQgcmVjb3JkZWRSZXF1ZXN0ID0ge307XG4gICAgbGV0IHJlY29yZGVkV2FybmluZ3MgPSBbXTtcbiAgICBjb25zdCByZWNvcmRlZFN0ZXBzID0gW107XG4gICAgbGV0IHJvb3RTcGFuO1xuICAgIGxldCBhY3RpdmVUZXh0Q29udGVudCA9IHt9O1xuICAgIGxldCBhY3RpdmVSZWFzb25pbmdDb250ZW50ID0ge307XG4gICAgY29uc3QgZXZlbnRQcm9jZXNzb3IgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICB2YXIgX2ExNywgX2IsIF9jO1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICBjb25zdCB7IHBhcnQgfSA9IGNodW5rO1xuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRleHQtZGVsdGFcIiB8fCBwYXJ0LnR5cGUgPT09IFwicmVhc29uaW5nLWRlbHRhXCIgfHwgcGFydC50eXBlID09PSBcInNvdXJjZVwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1pbnB1dC1zdGFydFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLWlucHV0LWRlbHRhXCIgfHwgcGFydC50eXBlID09PSBcInJhd1wiKSB7XG4gICAgICAgICAgYXdhaXQgKG9uQ2h1bmsgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2h1bmsoeyBjaHVuazogcGFydCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgYXdhaXQgb25FcnJvcih7IGVycm9yOiB3cmFwR2F0ZXdheUVycm9yKHBhcnQuZXJyb3IpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dC1zdGFydFwiKSB7XG4gICAgICAgICAgYWN0aXZlVGV4dENvbnRlbnRbcGFydC5pZF0gPSB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKGFjdGl2ZVRleHRDb250ZW50W3BhcnQuaWRdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZVRleHQgPSBhY3RpdmVUZXh0Q29udGVudFtwYXJ0LmlkXTtcbiAgICAgICAgICBpZiAoYWN0aXZlVGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICBwYXJ0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgdGV4dCBwYXJ0ICR7cGFydC5pZH0gbm90IGZvdW5kYFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwYXJ0aWFsT3V0cHV0OiB2b2lkIDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY3RpdmVUZXh0LnRleHQgKz0gcGFydC50ZXh0O1xuICAgICAgICAgIGFjdGl2ZVRleHQucHJvdmlkZXJNZXRhZGF0YSA9IChfYTE3ID0gcGFydC5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2ExNyA6IGFjdGl2ZVRleHQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRleHQtZW5kXCIpIHtcbiAgICAgICAgICBkZWxldGUgYWN0aXZlVGV4dENvbnRlbnRbcGFydC5pZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmctc3RhcnRcIikge1xuICAgICAgICAgIGFjdGl2ZVJlYXNvbmluZ0NvbnRlbnRbcGFydC5pZF0gPSB7XG4gICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmVjb3JkZWRDb250ZW50LnB1c2goYWN0aXZlUmVhc29uaW5nQ29udGVudFtwYXJ0LmlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmctZGVsdGFcIikge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZVJlYXNvbmluZyA9IGFjdGl2ZVJlYXNvbmluZ0NvbnRlbnRbcGFydC5pZF07XG4gICAgICAgICAgaWYgKGFjdGl2ZVJlYXNvbmluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICBwYXJ0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgcmVhc29uaW5nIHBhcnQgJHtwYXJ0LmlkfSBub3QgZm91bmRgXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjdGl2ZVJlYXNvbmluZy50ZXh0ICs9IHBhcnQudGV4dDtcbiAgICAgICAgICBhY3RpdmVSZWFzb25pbmcucHJvdmlkZXJNZXRhZGF0YSA9IChfYiA9IHBhcnQucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9iIDogYWN0aXZlUmVhc29uaW5nLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmctZW5kXCIpIHtcbiAgICAgICAgICBjb25zdCBhY3RpdmVSZWFzb25pbmcgPSBhY3RpdmVSZWFzb25pbmdDb250ZW50W3BhcnQuaWRdO1xuICAgICAgICAgIGlmIChhY3RpdmVSZWFzb25pbmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgcGFydDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBlcnJvcjogYHJlYXNvbmluZyBwYXJ0ICR7cGFydC5pZH0gbm90IGZvdW5kYFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwYXJ0aWFsT3V0cHV0OiB2b2lkIDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY3RpdmVSZWFzb25pbmcucHJvdmlkZXJNZXRhZGF0YSA9IChfYyA9IHBhcnQucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9jIDogYWN0aXZlUmVhc29uaW5nLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgZGVsZXRlIGFjdGl2ZVJlYXNvbmluZ0NvbnRlbnRbcGFydC5pZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaCh7IHR5cGU6IFwiZmlsZVwiLCBmaWxlOiBwYXJ0LmZpbGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCIpIHtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgJiYgIXBhcnQucHJlbGltaW5hcnkpIHtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtZXJyb3JcIikge1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwic3RhcnQtc3RlcFwiKSB7XG4gICAgICAgICAgcmVjb3JkZWRSZXF1ZXN0ID0gcGFydC5yZXF1ZXN0O1xuICAgICAgICAgIHJlY29yZGVkV2FybmluZ3MgPSBwYXJ0Lndhcm5pbmdzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiZmluaXNoLXN0ZXBcIikge1xuICAgICAgICAgIGNvbnN0IHN0ZXBNZXNzYWdlcyA9IHRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gICAgICAgICAgICBjb250ZW50OiByZWNvcmRlZENvbnRlbnQsXG4gICAgICAgICAgICB0b29sc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGVwUmVzdWx0ID0gbmV3IERlZmF1bHRTdGVwUmVzdWx0KHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHJlY29yZGVkQ29udGVudCxcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogcGFydC5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICB1c2FnZTogcGFydC51c2FnZSxcbiAgICAgICAgICAgIHdhcm5pbmdzOiByZWNvcmRlZFdhcm5pbmdzLFxuICAgICAgICAgICAgcmVxdWVzdDogcmVjb3JkZWRSZXF1ZXN0LFxuICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgLi4ucGFydC5yZXNwb25zZSxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IFsuLi5yZWNvcmRlZFJlc3BvbnNlTWVzc2FnZXMsIC4uLnN0ZXBNZXNzYWdlc11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhd2FpdCAob25TdGVwRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvblN0ZXBGaW5pc2goY3VycmVudFN0ZXBSZXN1bHQpKTtcbiAgICAgICAgICBsb2dXYXJuaW5ncyhyZWNvcmRlZFdhcm5pbmdzKTtcbiAgICAgICAgICByZWNvcmRlZFN0ZXBzLnB1c2goY3VycmVudFN0ZXBSZXN1bHQpO1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudCA9IFtdO1xuICAgICAgICAgIGFjdGl2ZVJlYXNvbmluZ0NvbnRlbnQgPSB7fTtcbiAgICAgICAgICBhY3RpdmVUZXh0Q29udGVudCA9IHt9O1xuICAgICAgICAgIHJlY29yZGVkUmVzcG9uc2VNZXNzYWdlcy5wdXNoKC4uLnN0ZXBNZXNzYWdlcyk7XG4gICAgICAgICAgc3RlcEZpbmlzaC5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJmaW5pc2hcIikge1xuICAgICAgICAgIHJlY29yZGVkVG90YWxVc2FnZSA9IHBhcnQudG90YWxVc2FnZTtcbiAgICAgICAgICByZWNvcmRlZEZpbmlzaFJlYXNvbiA9IHBhcnQuZmluaXNoUmVhc29uO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChyZWNvcmRlZFN0ZXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTm9PdXRwdXRHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb3V0cHV0IGdlbmVyYXRlZC4gQ2hlY2sgdGhlIHN0cmVhbSBmb3IgZXJyb3JzLlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuX2ZpbmlzaFJlYXNvbi5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgc2VsZi5fdG90YWxVc2FnZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgc2VsZi5fc3RlcHMucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmluaXNoUmVhc29uID0gcmVjb3JkZWRGaW5pc2hSZWFzb24gIT0gbnVsbCA/IHJlY29yZGVkRmluaXNoUmVhc29uIDogXCJ1bmtub3duXCI7XG4gICAgICAgICAgY29uc3QgdG90YWxVc2FnZSA9IHJlY29yZGVkVG90YWxVc2FnZSAhPSBudWxsID8gcmVjb3JkZWRUb3RhbFVzYWdlIDoge1xuICAgICAgICAgICAgaW5wdXRUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgICAgIG91dHB1dFRva2Vuczogdm9pZCAwLFxuICAgICAgICAgICAgdG90YWxUb2tlbnM6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgICAgc2VsZi5fZmluaXNoUmVhc29uLnJlc29sdmUoZmluaXNoUmVhc29uKTtcbiAgICAgICAgICBzZWxmLl90b3RhbFVzYWdlLnJlc29sdmUodG90YWxVc2FnZSk7XG4gICAgICAgICAgc2VsZi5fc3RlcHMucmVzb2x2ZShyZWNvcmRlZFN0ZXBzKTtcbiAgICAgICAgICBjb25zdCBmaW5hbFN0ZXAgPSByZWNvcmRlZFN0ZXBzW3JlY29yZGVkU3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgYXdhaXQgKG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7XG4gICAgICAgICAgICBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICB0b3RhbFVzYWdlLFxuICAgICAgICAgICAgdXNhZ2U6IGZpbmFsU3RlcC51c2FnZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGZpbmFsU3RlcC5jb250ZW50LFxuICAgICAgICAgICAgdGV4dDogZmluYWxTdGVwLnRleHQsXG4gICAgICAgICAgICByZWFzb25pbmdUZXh0OiBmaW5hbFN0ZXAucmVhc29uaW5nVGV4dCxcbiAgICAgICAgICAgIHJlYXNvbmluZzogZmluYWxTdGVwLnJlYXNvbmluZyxcbiAgICAgICAgICAgIGZpbGVzOiBmaW5hbFN0ZXAuZmlsZXMsXG4gICAgICAgICAgICBzb3VyY2VzOiBmaW5hbFN0ZXAuc291cmNlcyxcbiAgICAgICAgICAgIHRvb2xDYWxsczogZmluYWxTdGVwLnRvb2xDYWxscyxcbiAgICAgICAgICAgIHN0YXRpY1Rvb2xDYWxsczogZmluYWxTdGVwLnN0YXRpY1Rvb2xDYWxscyxcbiAgICAgICAgICAgIGR5bmFtaWNUb29sQ2FsbHM6IGZpbmFsU3RlcC5keW5hbWljVG9vbENhbGxzLFxuICAgICAgICAgICAgdG9vbFJlc3VsdHM6IGZpbmFsU3RlcC50b29sUmVzdWx0cyxcbiAgICAgICAgICAgIHN0YXRpY1Rvb2xSZXN1bHRzOiBmaW5hbFN0ZXAuc3RhdGljVG9vbFJlc3VsdHMsXG4gICAgICAgICAgICBkeW5hbWljVG9vbFJlc3VsdHM6IGZpbmFsU3RlcC5keW5hbWljVG9vbFJlc3VsdHMsXG4gICAgICAgICAgICByZXF1ZXN0OiBmaW5hbFN0ZXAucmVxdWVzdCxcbiAgICAgICAgICAgIHJlc3BvbnNlOiBmaW5hbFN0ZXAucmVzcG9uc2UsXG4gICAgICAgICAgICB3YXJuaW5nczogZmluYWxTdGVwLndhcm5pbmdzLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogZmluYWxTdGVwLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICBzdGVwczogcmVjb3JkZWRTdGVwc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByb290U3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjogeyBvdXRwdXQ6ICgpID0+IGZpbmFsU3RlcC50ZXh0IH0sXG4gICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTE3O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChfYTE3ID0gZmluYWxTdGVwLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcubGVuZ3RoKSA/IEpTT04uc3RyaW5naWZ5KGZpbmFsU3RlcC50b29sQ2FsbHMpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXCI6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgZmluYWxTdGVwLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuaW5wdXRUb2tlbnNcIjogdG90YWxVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICBcImFpLnVzYWdlLm91dHB1dFRva2Vuc1wiOiB0b3RhbFVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRvdGFsVG9rZW5zXCI6IHRvdGFsVXNhZ2UudG90YWxUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJhaS51c2FnZS5yZWFzb25pbmdUb2tlbnNcIjogdG90YWxVc2FnZS5yZWFzb25pbmdUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jYWNoZWRJbnB1dFRva2Vuc1wiOiB0b3RhbFVzYWdlLmNhY2hlZElucHV0VG9rZW5zXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICByb290U3Bhbi5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHN0aXRjaGFibGVTdHJlYW0gPSBjcmVhdGVTdGl0Y2hhYmxlU3RyZWFtKCk7XG4gICAgdGhpcy5hZGRTdHJlYW0gPSBzdGl0Y2hhYmxlU3RyZWFtLmFkZFN0cmVhbTtcbiAgICB0aGlzLmNsb3NlU3RyZWFtID0gc3RpdGNoYWJsZVN0cmVhbS5jbG9zZTtcbiAgICBjb25zdCByZWFkZXIgPSBzdGl0Y2hhYmxlU3RyZWFtLnN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICBsZXQgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJzdGFydFwiIH0pO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgICBvbkFib3J0ID09IG51bGwgPyB2b2lkIDAgOiBvbkFib3J0KHsgc3RlcHM6IHJlY29yZGVkU3RlcHMgfSk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJhYm9ydFwiIH0pO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFib3J0U2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydFNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGlmIChpc0Fib3J0RXJyb3IyKGVycm9yKSAmJiAoYWJvcnRTaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLmFib3J0ZWQpKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYW5jZWwocmVhc29uKSB7XG4gICAgICAgIHJldHVybiBzdGl0Y2hhYmxlU3RyZWFtLnN0cmVhbS5jYW5jZWwocmVhc29uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybSBvZiB0cmFuc2Zvcm1zKSB7XG4gICAgICBzdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgIHRyYW5zZm9ybSh7XG4gICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgc3RvcFN0cmVhbSgpIHtcbiAgICAgICAgICAgIHN0aXRjaGFibGVTdHJlYW0udGVybWluYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5iYXNlU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZU91dHB1dFRyYW5zZm9ybVN0cmVhbShvdXRwdXQpKS5waXBlVGhyb3VnaChldmVudFByb2Nlc3Nvcik7XG4gICAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICAgIGFib3J0U2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gICAgY29uc3QgY2FsbFNldHRpbmdzID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICBtb2RlbCxcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzZXR0aW5nczogeyAuLi5jYWxsU2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJlY29yZFNwYW4oe1xuICAgICAgbmFtZTogXCJhaS5zdHJlYW1UZXh0XCIsXG4gICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHsgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtVGV4dFwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB0cmFjZXIsXG4gICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICBmbjogYXN5bmMgKHJvb3RTcGFuQXJnKSA9PiB7XG4gICAgICAgIHJvb3RTcGFuID0gcm9vdFNwYW5Bcmc7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVN0ZXAoe1xuICAgICAgICAgIGN1cnJlbnRTdGVwLFxuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgICAgdXNhZ2VcbiAgICAgICAgfSkge1xuICAgICAgICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICBjb25zdCBpbmNsdWRlUmF3Q2h1bmtzMiA9IHNlbGYuaW5jbHVkZVJhd0NodW5rcztcbiAgICAgICAgICBzdGVwRmluaXNoID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgICAgICAgY29uc3QgaW5pdGlhbFByb21wdCA9IGF3YWl0IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3Qgc3RlcElucHV0TWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAuLi5pbml0aWFsUHJvbXB0Lm1lc3NhZ2VzLFxuICAgICAgICAgICAgLi4ucmVzcG9uc2VNZXNzYWdlc1xuICAgICAgICAgIF07XG4gICAgICAgICAgY29uc3QgcHJlcGFyZVN0ZXBSZXN1bHQgPSBhd2FpdCAocHJlcGFyZVN0ZXAgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwKHtcbiAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgc3RlcHM6IHJlY29yZGVkU3RlcHMsXG4gICAgICAgICAgICBzdGVwTnVtYmVyOiByZWNvcmRlZFN0ZXBzLmxlbmd0aCxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiB7XG4gICAgICAgICAgICAgIHN5c3RlbTogKF9hMTcgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQuc3lzdGVtKSAhPSBudWxsID8gX2ExNyA6IGluaXRpYWxQcm9tcHQuc3lzdGVtLFxuICAgICAgICAgICAgICBtZXNzYWdlczogKF9iID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0Lm1lc3NhZ2VzKSAhPSBudWxsID8gX2IgOiBzdGVwSW5wdXRNZXNzYWdlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1cHBvcnRlZFVybHM6IGF3YWl0IG1vZGVsLnN1cHBvcnRlZFVybHMsXG4gICAgICAgICAgICBkb3dubG9hZDogZG93bmxvYWQyXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3Qgc3RlcE1vZGVsID0gcmVzb2x2ZUxhbmd1YWdlTW9kZWwoXG4gICAgICAgICAgICAoX2MgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQubW9kZWwpICE9IG51bGwgPyBfYyA6IG1vZGVsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCB7IHRvb2xDaG9pY2U6IHN0ZXBUb29sQ2hvaWNlLCB0b29sczogc3RlcFRvb2xzIH0gPSBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHtcbiAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgdG9vbENob2ljZTogKF9kID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0LnRvb2xDaG9pY2UpICE9IG51bGwgPyBfZCA6IHRvb2xDaG9pY2UsXG4gICAgICAgICAgICBhY3RpdmVUb29sczogKF9lID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0LmFjdGl2ZVRvb2xzKSAhPSBudWxsID8gX2UgOiBhY3RpdmVUb29sc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHJlc3VsdDogeyBzdHJlYW06IHN0cmVhbTIsIHJlc3BvbnNlLCByZXF1ZXN0IH0sXG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zXG4gICAgICAgICAgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICAgIG5hbWU6IFwiYWkuc3RyZWFtVGV4dC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtVGV4dC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBtb2RlbDpcbiAgICAgICAgICAgICAgICAgIFwiYWkubW9kZWwucHJvdmlkZXJcIjogc3RlcE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgXCJhaS5tb2RlbC5pZFwiOiBzdGVwTW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgIC8vIHByb21wdDpcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0cmluZ2lmeUZvclRlbGVtZXRyeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIGxhbmd1YWdlIG1vZGVsIGxldmVsIHRvb2xzOlxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gc3RlcFRvb2xzID09IG51bGwgPyB2b2lkIDAgOiBzdGVwVG9vbHMubWFwKCh0b29sMykgPT4gSlNPTi5zdHJpbmdpZnkodG9vbDMpKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xDaG9pY2VcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gc3RlcFRvb2xDaG9pY2UgIT0gbnVsbCA/IEpTT04uc3RyaW5naWZ5KHN0ZXBUb29sQ2hvaWNlKSA6IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBzdGVwTW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IHN0ZXBNb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBjYWxsU2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBjYWxsU2V0dGluZ3MubWF4T3V0cHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IGNhbGxTZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnN0b3Bfc2VxdWVuY2VzXCI6IGNhbGxTZXR0aW5ncy5zdG9wU2VxdWVuY2VzLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBjYWxsU2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IGNhbGxTZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBjYWxsU2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICBmbjogYXN5bmMgKGRvU3RyZWFtU3BhbjIpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogbm93MigpLFxuICAgICAgICAgICAgICAgICAgLy8gZ2V0IGJlZm9yZSB0aGUgY2FsbFxuICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuOiBkb1N0cmVhbVNwYW4yLFxuICAgICAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBzdGVwTW9kZWwuZG9TdHJlYW0oe1xuICAgICAgICAgICAgICAgICAgICAuLi5jYWxsU2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xzOiBzdGVwVG9vbHMsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xDaG9pY2U6IHN0ZXBUb29sQ2hvaWNlLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZUZvcm1hdDogb3V0cHV0ID09IG51bGwgPyB2b2lkIDAgOiBvdXRwdXQucmVzcG9uc2VGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVSYXdDaHVua3M6IGluY2x1ZGVSYXdDaHVua3MyXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBzdHJlYW1XaXRoVG9vbFJlc3VsdHMgPSBydW5Ub29sc1RyYW5zZm9ybWF0aW9uKHtcbiAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgZ2VuZXJhdG9yU3RyZWFtOiBzdHJlYW0yLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgcmVwYWlyVG9vbENhbGwsXG4gICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3Qgc3RlcFJlcXVlc3QgPSByZXF1ZXN0ICE9IG51bGwgPyByZXF1ZXN0IDoge307XG4gICAgICAgICAgY29uc3Qgc3RlcFRvb2xDYWxscyA9IFtdO1xuICAgICAgICAgIGNvbnN0IHN0ZXBUb29sT3V0cHV0cyA9IFtdO1xuICAgICAgICAgIGxldCB3YXJuaW5ncztcbiAgICAgICAgICBjb25zdCBhY3RpdmVUb29sQ2FsbFRvb2xOYW1lcyA9IHt9O1xuICAgICAgICAgIGxldCBzdGVwRmluaXNoUmVhc29uID0gXCJ1bmtub3duXCI7XG4gICAgICAgICAgbGV0IHN0ZXBVc2FnZSA9IHtcbiAgICAgICAgICAgIGlucHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgICAgICAgICBvdXRwdXRUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgICAgIHRvdGFsVG9rZW5zOiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGxldCBzdGVwUHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICBsZXQgc3RlcEZpcnN0Q2h1bmsgPSB0cnVlO1xuICAgICAgICAgIGxldCBzdGVwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICBpZDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogY3VycmVudERhdGUoKSxcbiAgICAgICAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGxldCBhY3RpdmVUZXh0ID0gXCJcIjtcbiAgICAgICAgICBzZWxmLmFkZFN0cmVhbShcbiAgICAgICAgICAgIHN0cmVhbVdpdGhUb29sUmVzdWx0cy5waXBlVGhyb3VnaChcbiAgICAgICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2ExOCwgX2IyLCBfYzIsIF9kMjtcbiAgICAgICAgICAgICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInN0cmVhbS1zdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzID0gY2h1bmsud2FybmluZ3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChzdGVwRmlyc3RDaHVuaykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc1RvRmlyc3RDaHVuayA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wTXM7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maXJzdENodW5rXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVua1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0YXJ0LXN0ZXBcIixcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBzdGVwUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nczogd2FybmluZ3MgIT0gbnVsbCA/IHdhcm5pbmdzIDogW11cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQtc3RhcnRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQtZW5kXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsuZGVsdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjaHVuay5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2h1bmsuZGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlVGV4dCArPSBjaHVuay5kZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1zdGFydFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLWVuZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjaHVuay5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNodW5rLmRlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFRvb2xDYWxscy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaHVuay5wcmVsaW1pbmFyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFRvb2xPdXRwdXRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1lcnJvclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwVG9vbE91dHB1dHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogKF9hMTggPSBjaHVuay5pZCkgIT0gbnVsbCA/IF9hMTggOiBzdGVwUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfYjIgPSBjaHVuay50aW1lc3RhbXApICE9IG51bGwgPyBfYjIgOiBzdGVwUmVzcG9uc2UudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxJZDogKF9jMiA9IGNodW5rLm1vZGVsSWQpICE9IG51bGwgPyBfYzIgOiBzdGVwUmVzcG9uc2UubW9kZWxJZFxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFVzYWdlID0gY2h1bmsudXNhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcEZpbmlzaFJlYXNvbiA9IGNodW5rLmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwUHJvdmlkZXJNZXRhZGF0YSA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNUb0ZpbmlzaCA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wTXM7XG4gICAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmFkZEV2ZW50KFwiYWkuc3RyZWFtLmZpbmlzaFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaW5pc2hcIjogbXNUb0ZpbmlzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuYXZnT3V0cHV0VG9rZW5zUGVyU2Vjb25kXCI6IDFlMyAqICgoX2QyID0gc3RlcFVzYWdlLm91dHB1dFRva2VucykgIT0gbnVsbCA/IF9kMiA6IDApIC8gbXNUb0ZpbmlzaFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzb3VyY2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtc3RhcnRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRvb2xDYWxsVG9vbE5hbWVzW2NodW5rLmlkXSA9IGNodW5rLnRvb2xOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2wzID0gdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW2NodW5rLnRvb2xOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRvb2wzID09IG51bGwgPyB2b2lkIDAgOiB0b29sMy5vbklucHV0U3RhcnQpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRvb2wzLm9uSW5wdXRTdGFydCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWM6ICh0b29sMyA9PSBudWxsID8gdm9pZCAwIDogdG9vbDMudHlwZSkgPT09IFwiZHluYW1pY1wiXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtZW5kXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYWN0aXZlVG9vbENhbGxUb29sTmFtZXNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtZGVsdGFcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gYWN0aXZlVG9vbENhbGxUb29sTmFtZXNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2wzID0gdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRvb2wzID09IG51bGwgPyB2b2lkIDAgOiB0b29sMy5vbklucHV0RGVsdGEpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRvb2wzLm9uSW5wdXREZWx0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VGV4dERlbHRhOiBjaHVuay5kZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcEZpbmlzaFJlYXNvbiA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmF3XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZVJhd0NodW5rczIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBjaHVua1R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNodW5rIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBpbnZva2Ugb25GaW5pc2ggY2FsbGJhY2sgYW5kIHJlc29sdmUgdG9vbFJlc3VsdHMgcHJvbWlzZSB3aGVuIHRoZSBzdHJlYW0gaXMgYWJvdXQgdG8gY2xvc2U6XG4gICAgICAgICAgICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc3RlcFRvb2xDYWxsc0pzb24gPSBzdGVwVG9vbENhbGxzLmxlbmd0aCA+IDAgPyBKU09OLnN0cmluZ2lmeShzdGVwVG9vbENhbGxzKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gYWN0aXZlVGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBzdGVwVG9vbENhbGxzSnNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmlkXCI6IHN0ZXBSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tb2RlbFwiOiBzdGVwUmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogc3RlcFJlc3BvbnNlLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGFcIjogSlNPTi5zdHJpbmdpZnkoc3RlcFByb3ZpZGVyTWV0YWRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmlucHV0VG9rZW5zXCI6IHN0ZXBVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5vdXRwdXRUb2tlbnNcIjogc3RlcFVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b3RhbFRva2Vuc1wiOiBzdGVwVXNhZ2UudG90YWxUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucmVhc29uaW5nVG9rZW5zXCI6IHN0ZXBVc2FnZS5yZWFzb25pbmdUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnNcIjogc3RlcFVzYWdlLmNhY2hlZElucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtzdGVwRmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiBzdGVwUmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHN0ZXBVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2Uub3V0cHV0X3Rva2Vuc1wiOiBzdGVwVXNhZ2Uub3V0cHV0VG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uZW5kKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbmlzaC1zdGVwXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgdXNhZ2U6IHN0ZXBVc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogc3RlcFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uc3RlcFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY29tYmluZWRVc2FnZSA9IGFkZExhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZSwgc3RlcFVzYWdlKTtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHN0ZXBGaW5pc2gucHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFRvb2xDYWxscyA9IHN0ZXBUb29sQ2FsbHMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRUb29sT3V0cHV0cyA9IHN0ZXBUb29sT3V0cHV0cy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICh0b29sT3V0cHV0KSA9PiB0b29sT3V0cHV0LnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2xpZW50VG9vbENhbGxzLmxlbmd0aCA+IDAgJiYgLy8gYWxsIGN1cnJlbnQgdG9vbCBjYWxscyBoYXZlIG91dHB1dHMgKGluY2wuIGV4ZWN1dGlvbiBlcnJvcnMpOlxuICAgICAgICAgICAgICAgICAgY2xpZW50VG9vbE91dHB1dHMubGVuZ3RoID09PSBjbGllbnRUb29sQ2FsbHMubGVuZ3RoICYmIC8vIGNvbnRpbnVlIHVudGlsIGEgc3RvcCBjb25kaXRpb24gaXMgbWV0OlxuICAgICAgICAgICAgICAgICAgIWF3YWl0IGlzU3RvcENvbmRpdGlvbk1ldCh7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BDb25kaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICBzdGVwczogcmVjb3JkZWRTdGVwc1xuICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgIC4uLnRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSB0cmFuc2Zvcm1lZCBjb250ZW50IHRvIGNyZWF0ZSB0aGUgbWVzc2FnZXMgZm9yIHRoZSBuZXh0IHN0ZXA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZGVkU3RlcHNbcmVjb3JkZWRTdGVwcy5sZW5ndGggLSAxXS5jb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0cmVhbVN0ZXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0ZXA6IGN1cnJlbnRTdGVwICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2FnZTogY29tYmluZWRVc2FnZVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2VTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICB0b3RhbFVzYWdlOiBjb21iaW5lZFVzYWdlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlU3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgc3RyZWFtU3RlcCh7XG4gICAgICAgICAgY3VycmVudFN0ZXA6IDAsXG4gICAgICAgICAgcmVzcG9uc2VNZXNzYWdlczogW10sXG4gICAgICAgICAgdXNhZ2U6IHtcbiAgICAgICAgICAgIGlucHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgICAgICAgICBvdXRwdXRUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgICAgIHRvdGFsVG9rZW5zOiB2b2lkIDBcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgc2VsZi5hZGRTdHJlYW0oXG4gICAgICAgIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgc2VsZi5jbG9zZVN0cmVhbSgpO1xuICAgIH0pO1xuICB9XG4gIGdldCBzdGVwcygpIHtcbiAgICB0aGlzLmNvbnN1bWVTdHJlYW0oKTtcbiAgICByZXR1cm4gdGhpcy5fc3RlcHMucHJvbWlzZTtcbiAgfVxuICBnZXQgZmluYWxTdGVwKCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBzLnRoZW4oKHN0ZXBzKSA9PiBzdGVwc1tzdGVwcy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuY29udGVudCk7XG4gIH1cbiAgZ2V0IHdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLndhcm5pbmdzKTtcbiAgfVxuICBnZXQgcHJvdmlkZXJNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5wcm92aWRlck1ldGFkYXRhKTtcbiAgfVxuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC50ZXh0KTtcbiAgfVxuICBnZXQgcmVhc29uaW5nVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5yZWFzb25pbmdUZXh0KTtcbiAgfVxuICBnZXQgcmVhc29uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnJlYXNvbmluZyk7XG4gIH1cbiAgZ2V0IHNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuc291cmNlcyk7XG4gIH1cbiAgZ2V0IGZpbGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLmZpbGVzKTtcbiAgfVxuICBnZXQgdG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnRvb2xDYWxscyk7XG4gIH1cbiAgZ2V0IHN0YXRpY1Rvb2xDYWxscygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5zdGF0aWNUb29sQ2FsbHMpO1xuICB9XG4gIGdldCBkeW5hbWljVG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLmR5bmFtaWNUb29sQ2FsbHMpO1xuICB9XG4gIGdldCB0b29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC50b29sUmVzdWx0cyk7XG4gIH1cbiAgZ2V0IHN0YXRpY1Rvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnN0YXRpY1Rvb2xSZXN1bHRzKTtcbiAgfVxuICBnZXQgZHluYW1pY1Rvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLmR5bmFtaWNUb29sUmVzdWx0cyk7XG4gIH1cbiAgZ2V0IHVzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnVzYWdlKTtcbiAgfVxuICBnZXQgcmVxdWVzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5yZXF1ZXN0KTtcbiAgfVxuICBnZXQgcmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAucmVzcG9uc2UpO1xuICB9XG4gIGdldCB0b3RhbFVzYWdlKCkge1xuICAgIHRoaXMuY29uc3VtZVN0cmVhbSgpO1xuICAgIHJldHVybiB0aGlzLl90b3RhbFVzYWdlLnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbmlzaFJlYXNvbigpIHtcbiAgICB0aGlzLmNvbnN1bWVTdHJlYW0oKTtcbiAgICByZXR1cm4gdGhpcy5fZmluaXNoUmVhc29uLnByb21pc2U7XG4gIH1cbiAgLyoqXG4gIFNwbGl0IG91dCBhIG5ldyBzdHJlYW0gZnJvbSB0aGUgb3JpZ2luYWwgc3RyZWFtLlxuICBUaGUgb3JpZ2luYWwgc3RyZWFtIGlzIHJlcGxhY2VkIHRvIGFsbG93IGZvciBmdXJ0aGVyIHNwbGl0dGluZyxcbiAgc2luY2Ugd2UgZG8gbm90IGtub3cgaG93IG1hbnkgdGltZXMgdGhlIHN0cmVhbSB3aWxsIGJlIHNwbGl0LlxuICBcbiAgTm90ZTogdGhpcyBsZWFkcyB0byBidWZmZXJpbmcgdGhlIHN0cmVhbSBjb250ZW50IG9uIHRoZSBzZXJ2ZXIuXG4gIEhvd2V2ZXIsIHRoZSBMTE0gcmVzdWx0cyBhcmUgZXhwZWN0ZWQgdG8gYmUgc21hbGwgZW5vdWdoIHRvIG5vdCBjYXVzZSBpc3N1ZXMuXG4gICAgICovXG4gIHRlZVN0cmVhbSgpIHtcbiAgICBjb25zdCBbc3RyZWFtMSwgc3RyZWFtMl0gPSB0aGlzLmJhc2VTdHJlYW0udGVlKCk7XG4gICAgdGhpcy5iYXNlU3RyZWFtID0gc3RyZWFtMjtcbiAgICByZXR1cm4gc3RyZWFtMTtcbiAgfVxuICBnZXQgdGV4dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMudGVlU3RyZWFtKCkucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybSh7IHBhcnQgfSwgY29udHJvbGxlcikge1xuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnQudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgZ2V0IGZ1bGxTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICB0aGlzLnRlZVN0cmVhbSgpLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oeyBwYXJ0IH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBhc3luYyBjb25zdW1lU3RyZWFtKG9wdGlvbnMpIHtcbiAgICB2YXIgX2ExNztcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY29uc3VtZVN0cmVhbSh7XG4gICAgICAgIHN0cmVhbTogdGhpcy5mdWxsU3RyZWFtLFxuICAgICAgICBvbkVycm9yOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uRXJyb3JcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAoX2ExNyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25FcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbChvcHRpb25zLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIGdldCBleHBlcmltZW50YWxfcGFydGlhbE91dHB1dFN0cmVhbSgpIHtcbiAgICBpZiAodGhpcy5vdXRwdXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vT3V0cHV0U3BlY2lmaWVkRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICB0aGlzLnRlZVN0cmVhbSgpLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oeyBwYXJ0aWFsT3V0cHV0IH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0aWFsT3V0cHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnRpYWxPdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHRvVUlNZXNzYWdlU3RyZWFtKHtcbiAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgIGdlbmVyYXRlTWVzc2FnZUlkLFxuICAgIG9uRmluaXNoLFxuICAgIG1lc3NhZ2VNZXRhZGF0YSxcbiAgICBzZW5kUmVhc29uaW5nID0gdHJ1ZSxcbiAgICBzZW5kU291cmNlcyA9IGZhbHNlLFxuICAgIHNlbmRTdGFydCA9IHRydWUsXG4gICAgc2VuZEZpbmlzaCA9IHRydWUsXG4gICAgb25FcnJvciA9IGdldEVycm9yTWVzc2FnZTdcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlSWQgPSBnZW5lcmF0ZU1lc3NhZ2VJZCAhPSBudWxsID8gZ2V0UmVzcG9uc2VVSU1lc3NhZ2VJZCh7XG4gICAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgICAgcmVzcG9uc2VNZXNzYWdlSWQ6IGdlbmVyYXRlTWVzc2FnZUlkXG4gICAgfSkgOiB2b2lkIDA7XG4gICAgY29uc3QgdG9vbE5hbWVzQnlDYWxsSWQgPSB7fTtcbiAgICBjb25zdCBpc0R5bmFtaWMgPSAodG9vbENhbGxJZCkgPT4ge1xuICAgICAgdmFyIF9hMTcsIF9iO1xuICAgICAgY29uc3QgdG9vbE5hbWUgPSB0b29sTmFtZXNCeUNhbGxJZFt0b29sQ2FsbElkXTtcbiAgICAgIGNvbnN0IGR5bmFtaWMgPSAoKF9iID0gKF9hMTcgPSB0aGlzLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExN1t0b29sTmFtZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYi50eXBlKSA9PT0gXCJkeW5hbWljXCI7XG4gICAgICByZXR1cm4gZHluYW1pYyA/IHRydWUgOiB2b2lkIDA7XG4gICAgfTtcbiAgICBjb25zdCBiYXNlU3RyZWFtID0gdGhpcy5mdWxsU3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIHRyYW5zZm9ybTogYXN5bmMgKHBhcnQsIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlTWV0YWRhdGFWYWx1ZSA9IG1lc3NhZ2VNZXRhZGF0YSA9PSBudWxsID8gdm9pZCAwIDogbWVzc2FnZU1ldGFkYXRhKHsgcGFydCB9KTtcbiAgICAgICAgICBjb25zdCBwYXJ0VHlwZSA9IHBhcnQudHlwZTtcbiAgICAgICAgICBzd2l0Y2ggKHBhcnRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dC1zdGFydFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIGlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgIGRlbHRhOiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRleHQtZW5kXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZW5kXCIsXG4gICAgICAgICAgICAgICAgaWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1zdGFydFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctc3RhcnRcIixcbiAgICAgICAgICAgICAgICBpZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgaWYgKHNlbmRSZWFzb25pbmcpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgIGlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgICAgZGVsdGE6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLWVuZFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctZW5kXCIsXG4gICAgICAgICAgICAgICAgaWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogcGFydC5maWxlLm1lZGlhVHlwZSxcbiAgICAgICAgICAgICAgICB1cmw6IGBkYXRhOiR7cGFydC5maWxlLm1lZGlhVHlwZX07YmFzZTY0LCR7cGFydC5maWxlLmJhc2U2NH1gXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzb3VyY2VcIjoge1xuICAgICAgICAgICAgICBpZiAoc2VuZFNvdXJjZXMgJiYgcGFydC5zb3VyY2VUeXBlID09PSBcInVybFwiKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwic291cmNlLXVybFwiLFxuICAgICAgICAgICAgICAgICAgc291cmNlSWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgICB1cmw6IHBhcnQudXJsLFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IHBhcnQudGl0bGUsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzZW5kU291cmNlcyAmJiBwYXJ0LnNvdXJjZVR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInNvdXJjZS1kb2N1bWVudFwiLFxuICAgICAgICAgICAgICAgICAgc291cmNlSWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgICBtZWRpYVR5cGU6IHBhcnQubWVkaWFUeXBlLFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IHBhcnQudGl0bGUsXG4gICAgICAgICAgICAgICAgICBmaWxlbmFtZTogcGFydC5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1zdGFydFwiOiB7XG4gICAgICAgICAgICAgIHRvb2xOYW1lc0J5Q2FsbElkW3BhcnQuaWRdID0gcGFydC50b29sTmFtZTtcbiAgICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IGlzRHluYW1pYyhwYXJ0LmlkKTtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtaW5wdXQtc3RhcnRcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJFeGVjdXRlZCAhPSBudWxsID8geyBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgfSA6IHt9LFxuICAgICAgICAgICAgICAgIC4uLmR5bmFtaWMgIT0gbnVsbCA/IHsgZHluYW1pYyB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtZGVsdGFcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1pbnB1dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgaW5wdXRUZXh0RGVsdGE6IHBhcnQuZGVsdGFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgIHRvb2xOYW1lc0J5Q2FsbElkW3BhcnQudG9vbENhbGxJZF0gPSBwYXJ0LnRvb2xOYW1lO1xuICAgICAgICAgICAgICBjb25zdCBkeW5hbWljID0gaXNEeW5hbWljKHBhcnQudG9vbENhbGxJZCk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0LmludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWlucHV0LWVycm9yXCIsXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlckV4ZWN1dGVkICE9IG51bGwgPyB7IHByb3ZpZGVyRXhlY3V0ZWQ6IHBhcnQucHJvdmlkZXJFeGVjdXRlZCB9IDoge30sXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIC4uLmR5bmFtaWMgIT0gbnVsbCA/IHsgZHluYW1pYyB9IDoge30sXG4gICAgICAgICAgICAgICAgICBlcnJvclRleHQ6IG9uRXJyb3IocGFydC5lcnJvcilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWlucHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogcGFydC5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJFeGVjdXRlZCAhPSBudWxsID8geyBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgfSA6IHt9LFxuICAgICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge30sXG4gICAgICAgICAgICAgICAgICAuLi5keW5hbWljICE9IG51bGwgPyB7IGR5bmFtaWMgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgICAgICBjb25zdCBkeW5hbWljID0gaXNEeW5hbWljKHBhcnQudG9vbENhbGxJZCk7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLW91dHB1dC1hdmFpbGFibGVcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBwYXJ0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgIT0gbnVsbCA/IHsgcHJvdmlkZXJFeGVjdXRlZDogcGFydC5wcm92aWRlckV4ZWN1dGVkIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnByZWxpbWluYXJ5ICE9IG51bGwgPyB7IHByZWxpbWluYXJ5OiBwYXJ0LnByZWxpbWluYXJ5IH0gOiB7fSxcbiAgICAgICAgICAgICAgICAuLi5keW5hbWljICE9IG51bGwgPyB7IGR5bmFtaWMgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWVycm9yXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IGlzRHluYW1pYyhwYXJ0LnRvb2xDYWxsSWQpO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1vdXRwdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBvbkVycm9yKHBhcnQuZXJyb3IpLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJFeGVjdXRlZCAhPSBudWxsID8geyBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgfSA6IHt9LFxuICAgICAgICAgICAgICAgIC4uLmR5bmFtaWMgIT0gbnVsbCA/IHsgZHluYW1pYyB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBvbkVycm9yKHBhcnQuZXJyb3IpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdGFydC1zdGVwXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJzdGFydC1zdGVwXCIgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmlzaC1zdGVwXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJmaW5pc2gtc3RlcFwiIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdGFydFwiOiB7XG4gICAgICAgICAgICAgIGlmIChzZW5kU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgLi4ubWVzc2FnZU1ldGFkYXRhVmFsdWUgIT0gbnVsbCA/IHsgbWVzc2FnZU1ldGFkYXRhOiBtZXNzYWdlTWV0YWRhdGFWYWx1ZSB9IDoge30sXG4gICAgICAgICAgICAgICAgICAuLi5yZXNwb25zZU1lc3NhZ2VJZCAhPSBudWxsID8geyBtZXNzYWdlSWQ6IHJlc3BvbnNlTWVzc2FnZUlkIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgIGlmIChzZW5kRmluaXNoKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICAgICAgICAuLi5tZXNzYWdlTWV0YWRhdGFWYWx1ZSAhPSBudWxsID8geyBtZXNzYWdlTWV0YWRhdGE6IG1lc3NhZ2VNZXRhZGF0YVZhbHVlIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImFib3J0XCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWVuZFwiOiB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOiB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBwYXJ0VHlwZTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNodW5rIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZU1ldGFkYXRhVmFsdWUgIT0gbnVsbCAmJiBwYXJ0VHlwZSAhPT0gXCJzdGFydFwiICYmIHBhcnRUeXBlICE9PSBcImZpbmlzaFwiKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcIm1lc3NhZ2UtbWV0YWRhdGFcIixcbiAgICAgICAgICAgICAgbWVzc2FnZU1ldGFkYXRhOiBtZXNzYWdlTWV0YWRhdGFWYWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICBoYW5kbGVVSU1lc3NhZ2VTdHJlYW1GaW5pc2goe1xuICAgICAgICBzdHJlYW06IGJhc2VTdHJlYW0sXG4gICAgICAgIG1lc3NhZ2VJZDogcmVzcG9uc2VNZXNzYWdlSWQgIT0gbnVsbCA/IHJlc3BvbnNlTWVzc2FnZUlkIDogZ2VuZXJhdGVNZXNzYWdlSWQgPT0gbnVsbCA/IHZvaWQgMCA6IGdlbmVyYXRlTWVzc2FnZUlkKCksXG4gICAgICAgIG9yaWdpbmFsTWVzc2FnZXMsXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICBvbkVycm9yXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgcGlwZVVJTWVzc2FnZVN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgIGdlbmVyYXRlTWVzc2FnZUlkLFxuICAgIG9uRmluaXNoLFxuICAgIG1lc3NhZ2VNZXRhZGF0YSxcbiAgICBzZW5kUmVhc29uaW5nLFxuICAgIHNlbmRTb3VyY2VzLFxuICAgIHNlbmRGaW5pc2gsXG4gICAgc2VuZFN0YXJ0LFxuICAgIG9uRXJyb3IsXG4gICAgLi4uaW5pdFxuICB9ID0ge30pIHtcbiAgICBwaXBlVUlNZXNzYWdlU3RyZWFtVG9SZXNwb25zZSh7XG4gICAgICByZXNwb25zZSxcbiAgICAgIHN0cmVhbTogdGhpcy50b1VJTWVzc2FnZVN0cmVhbSh7XG4gICAgICAgIG9yaWdpbmFsTWVzc2FnZXMsXG4gICAgICAgIGdlbmVyYXRlTWVzc2FnZUlkLFxuICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgbWVzc2FnZU1ldGFkYXRhLFxuICAgICAgICBzZW5kUmVhc29uaW5nLFxuICAgICAgICBzZW5kU291cmNlcyxcbiAgICAgICAgc2VuZEZpbmlzaCxcbiAgICAgICAgc2VuZFN0YXJ0LFxuICAgICAgICBvbkVycm9yXG4gICAgICB9KSxcbiAgICAgIC4uLmluaXRcbiAgICB9KTtcbiAgfVxuICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIGluaXQpIHtcbiAgICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICB0ZXh0U3RyZWFtOiB0aGlzLnRleHRTdHJlYW0sXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbiAgdG9VSU1lc3NhZ2VTdHJlYW1SZXNwb25zZSh7XG4gICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICBnZW5lcmF0ZU1lc3NhZ2VJZCxcbiAgICBvbkZpbmlzaCxcbiAgICBtZXNzYWdlTWV0YWRhdGEsXG4gICAgc2VuZFJlYXNvbmluZyxcbiAgICBzZW5kU291cmNlcyxcbiAgICBzZW5kRmluaXNoLFxuICAgIHNlbmRTdGFydCxcbiAgICBvbkVycm9yLFxuICAgIC4uLmluaXRcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVVJTWVzc2FnZVN0cmVhbVJlc3BvbnNlKHtcbiAgICAgIHN0cmVhbTogdGhpcy50b1VJTWVzc2FnZVN0cmVhbSh7XG4gICAgICAgIG9yaWdpbmFsTWVzc2FnZXMsXG4gICAgICAgIGdlbmVyYXRlTWVzc2FnZUlkLFxuICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgbWVzc2FnZU1ldGFkYXRhLFxuICAgICAgICBzZW5kUmVhc29uaW5nLFxuICAgICAgICBzZW5kU291cmNlcyxcbiAgICAgICAgc2VuZEZpbmlzaCxcbiAgICAgICAgc2VuZFN0YXJ0LFxuICAgICAgICBvbkVycm9yXG4gICAgICB9KSxcbiAgICAgIC4uLmluaXRcbiAgICB9KTtcbiAgfVxuICB0b1RleHRTdHJlYW1SZXNwb25zZShpbml0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRleHRTdHJlYW1SZXNwb25zZSh7XG4gICAgICB0ZXh0U3RyZWFtOiB0aGlzLnRleHRTdHJlYW0sXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91aS9jb252ZXJ0LXRvLW1vZGVsLW1lc3NhZ2VzLnRzXG5mdW5jdGlvbiBjb252ZXJ0VG9Nb2RlbE1lc3NhZ2VzKG1lc3NhZ2VzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG1vZGVsTWVzc2FnZXMgPSBbXTtcbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaWdub3JlSW5jb21wbGV0ZVRvb2xDYWxscykge1xuICAgIG1lc3NhZ2VzID0gbWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiAoe1xuICAgICAgLi4ubWVzc2FnZSxcbiAgICAgIHBhcnRzOiBtZXNzYWdlLnBhcnRzLmZpbHRlcihcbiAgICAgICAgKHBhcnQpID0+ICFpc1Rvb2xPckR5bmFtaWNUb29sVUlQYXJ0KHBhcnQpIHx8IHBhcnQuc3RhdGUgIT09IFwiaW5wdXQtc3RyZWFtaW5nXCIgJiYgcGFydC5zdGF0ZSAhPT0gXCJpbnB1dC1hdmFpbGFibGVcIlxuICAgICAgKVxuICAgIH0pKTtcbiAgfVxuICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICBzd2l0Y2ggKG1lc3NhZ2Uucm9sZSkge1xuICAgICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICAgIGNvbnN0IHRleHRQYXJ0cyA9IG1lc3NhZ2UucGFydHMuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidGV4dFwiKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJNZXRhZGF0YSA9IHRleHRQYXJ0cy5yZWR1Y2UoKGFjYywgcGFydCkgPT4ge1xuICAgICAgICAgIGlmIChwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4uYWNjLCAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICBtb2RlbE1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgY29udGVudDogdGV4dFBhcnRzLm1hcCgocGFydCkgPT4gcGFydC50ZXh0KS5qb2luKFwiXCIpLFxuICAgICAgICAgIC4uLk9iamVjdC5rZXlzKHByb3ZpZGVyTWV0YWRhdGEpLmxlbmd0aCA+IDAgPyB7IHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBtb2RlbE1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UucGFydHMuZmlsdGVyKFxuICAgICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIgfHwgcGFydC50eXBlID09PSBcImZpbGVcIlxuICAgICAgICAgICkubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogcGFydC5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgICBmaWxlbmFtZTogcGFydC5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHBhcnQudXJsLFxuICAgICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImFzc2lzdGFudFwiOiB7XG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgICBsZXQgcHJvY2Vzc0Jsb2NrMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9hMTcsIF9iO1xuICAgICAgICAgICAgaWYgKGJsb2NrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgYmxvY2spIHtcbiAgICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydC50eXBlID09PSBcImZpbGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogcGFydC5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgICBmaWxlbmFtZTogcGFydC5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHBhcnQudXJsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydC50eXBlID09PSBcInJlYXNvbmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQudHlwZSA9PT0gXCJkeW5hbWljLXRvb2xcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gcGFydC50b29sTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAocGFydC5zdGF0ZSAhPT0gXCJpbnB1dC1zdHJlYW1pbmdcIikge1xuICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnQuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzVG9vbFVJUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gZ2V0VG9vbE5hbWUocGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQuc3RhdGUgIT09IFwiaW5wdXQtc3RyZWFtaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiID8gKF9hMTcgPSBwYXJ0LmlucHV0KSAhPSBudWxsID8gX2ExNyA6IHBhcnQucmF3SW5wdXQgOiBwYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAocGFydC5wcm92aWRlckV4ZWN1dGVkID09PSB0cnVlICYmIChwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1hdmFpbGFibGVcIiB8fCBwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiID8gcGFydC5lcnJvclRleHQgOiBwYXJ0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2w6IChfYiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYlt0b29sTmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1vZGU6IHBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWVycm9yXCIgPyBcImpzb25cIiA6IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBwYXJ0O1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFydDogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RlbE1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICBjb250ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xQYXJ0cyA9IGJsb2NrLmZpbHRlcihcbiAgICAgICAgICAgICAgKHBhcnQpID0+IGlzVG9vbFVJUGFydChwYXJ0KSAmJiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWUgfHwgcGFydC50eXBlID09PSBcImR5bmFtaWMtdG9vbFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHRvb2xQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIG1vZGVsTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogdG9vbFBhcnRzLm1hcCgodG9vbFBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b29sUGFydC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwib3V0cHV0LWVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvdXRwdXQtYXZhaWxhYmxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IHRvb2xQYXJ0LnR5cGUgPT09IFwiZHluYW1pYy10b29sXCIgPyB0b29sUGFydC50b29sTmFtZSA6IGdldFRvb2xOYW1lKHRvb2xQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbFBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IHRvb2xQYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiID8gdG9vbFBhcnQuZXJyb3JUZXh0IDogdG9vbFBhcnQub3V0cHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sOiAoX2ExOCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTE4W3Rvb2xOYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNb2RlOiB0b29sUGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtZXJyb3JcIiA/IFwidGV4dFwiIDogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAob3V0cHV0KSA9PiBvdXRwdXQgIT0gbnVsbFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jayA9IFtdO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHByb2Nlc3NCbG9jayA9IHByb2Nlc3NCbG9jazI7XG4gICAgICAgICAgbGV0IGJsb2NrID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIG1lc3NhZ2UucGFydHMpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dFwiIHx8IHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmdcIiB8fCBwYXJ0LnR5cGUgPT09IFwiZmlsZVwiIHx8IHBhcnQudHlwZSA9PT0gXCJkeW5hbWljLXRvb2xcIiB8fCBpc1Rvb2xVSVBhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgYmxvY2sucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydC50eXBlID09PSBcInN0ZXAtc3RhcnRcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQmxvY2syKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3NCbG9jazIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1lc3NhZ2Uucm9sZTtcbiAgICAgICAgdGhyb3cgbmV3IE1lc3NhZ2VDb252ZXJzaW9uRXJyb3Ioe1xuICAgICAgICAgIG9yaWdpbmFsTWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICBtZXNzYWdlOiBgVW5zdXBwb3J0ZWQgcm9sZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RlbE1lc3NhZ2VzO1xufVxudmFyIGNvbnZlcnRUb0NvcmVNZXNzYWdlcyA9IGNvbnZlcnRUb01vZGVsTWVzc2FnZXM7XG5cbi8vIHNyYy9hZ2VudC9hZ2VudC50c1xudmFyIEFnZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgfVxuICBnZXQgdG9vbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MudG9vbHM7XG4gIH1cbiAgYXN5bmMgZ2VuZXJhdGUob3B0aW9ucykge1xuICAgIHJldHVybiBnZW5lcmF0ZVRleHQoeyAuLi50aGlzLnNldHRpbmdzLCAuLi5vcHRpb25zIH0pO1xuICB9XG4gIHN0cmVhbShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN0cmVhbVRleHQoeyAuLi50aGlzLnNldHRpbmdzLCAuLi5vcHRpb25zIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVzcG9uc2Ugb2JqZWN0IHRoYXQgc3RyZWFtcyBVSSBtZXNzYWdlcyB0byB0aGUgY2xpZW50LlxuICAgKi9cbiAgcmVzcG9uZChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtKHtcbiAgICAgIHByb21wdDogY29udmVydFRvTW9kZWxNZXNzYWdlcyhvcHRpb25zLm1lc3NhZ2VzKVxuICAgIH0pLnRvVUlNZXNzYWdlU3RyZWFtUmVzcG9uc2UoKTtcbiAgfVxufTtcblxuLy8gc3JjL2VtYmVkL2VtYmVkLnRzXG5hc3luYyBmdW5jdGlvbiBlbWJlZCh7XG4gIG1vZGVsOiBtb2RlbEFyZyxcbiAgdmFsdWUsXG4gIHByb3ZpZGVyT3B0aW9ucyxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICBjb25zdCBtb2RlbCA9IHJlc29sdmVFbWJlZGRpbmdNb2RlbChtb2RlbEFyZyk7XG4gIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5lbWJlZFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5lbWJlZFwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICBcImFpLnZhbHVlXCI6IHsgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgY29uc3QgeyBlbWJlZGRpbmcsIHVzYWdlLCByZXNwb25zZSwgcHJvdmlkZXJNZXRhZGF0YSB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IChcbiAgICAgICAgICAvLyBuZXN0ZWQgc3BhbnMgdG8gYWxpZ24gd2l0aCB0aGUgZW1iZWRNYW55IHRlbGVtZXRyeSBkYXRhOlxuICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZC5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkLmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7IGlucHV0OiAoKSA9PiBbSlNPTi5zdHJpbmdpZnkodmFsdWUpXSB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExNztcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogW3ZhbHVlXSxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nMiA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5nc1swXTtcbiAgICAgICAgICAgICAgY29uc3QgdXNhZ2UyID0gKF9hMTcgPSBtb2RlbFJlc3BvbnNlLnVzYWdlKSAhPSBudWxsID8gX2ExNyA6IHsgdG9rZW5zOiBOYU4gfTtcbiAgICAgICAgICAgICAgZG9FbWJlZFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAoZW1iZWRkaW5nMykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nMylcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlMi50b2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVtYmVkZGluZzogZW1iZWRkaW5nMixcbiAgICAgICAgICAgICAgICB1c2FnZTogdXNhZ2UyLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1vZGVsUmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogbW9kZWxSZXNwb25zZS5yZXNwb25zZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBcImFpLmVtYmVkZGluZ1wiOiB7IG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UudG9rZW5zXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdEVtYmVkUmVzdWx0KHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGVtYmVkZGluZyxcbiAgICAgICAgdXNhZ2UsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgIHJlc3BvbnNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRFbWJlZFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHRoaXMuZW1iZWRkaW5nID0gb3B0aW9ucy5lbWJlZGRpbmc7XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbC9zcGxpdC1hcnJheS50c1xuZnVuY3Rpb24gc3BsaXRBcnJheShhcnJheSwgY2h1bmtTaXplKSB7XG4gIGlmIChjaHVua1NpemUgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICByZXN1bHQucHVzaChhcnJheS5zbGljZShpLCBpICsgY2h1bmtTaXplKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL2VtYmVkL2VtYmVkLW1hbnkudHNcbmFzeW5jIGZ1bmN0aW9uIGVtYmVkTWFueSh7XG4gIG1vZGVsOiBtb2RlbEFyZyxcbiAgdmFsdWVzLFxuICBtYXhQYXJhbGxlbENhbGxzID0gSW5maW5pdHksXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICBjb25zdCBtb2RlbCA9IHJlc29sdmVFbWJlZGRpbmdNb2RlbChtb2RlbEFyZyk7XG4gIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5lbWJlZE1hbnlcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHsgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWRNYW55XCIsIHRlbGVtZXRyeSB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICBjb25zdCBbbWF4RW1iZWRkaW5nc1BlckNhbGwsIHN1cHBvcnRzUGFyYWxsZWxDYWxsc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIG1vZGVsLm1heEVtYmVkZGluZ3NQZXJDYWxsLFxuICAgICAgICBtb2RlbC5zdXBwb3J0c1BhcmFsbGVsQ2FsbHNcbiAgICAgIF0pO1xuICAgICAgaWYgKG1heEVtYmVkZGluZ3NQZXJDYWxsID09IG51bGwgfHwgbWF4RW1iZWRkaW5nc1BlckNhbGwgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGNvbnN0IHsgZW1iZWRkaW5nczogZW1iZWRkaW5nczIsIHVzYWdlLCByZXNwb25zZSwgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YTIgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gdmFsdWVzLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgIGZuOiBhc3luYyAoZG9FbWJlZFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbFJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZG9FbWJlZCh7XG4gICAgICAgICAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmdzMyA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncztcbiAgICAgICAgICAgICAgICBjb25zdCB1c2FnZTIgPSAoX2ExOCA9IG1vZGVsUmVzcG9uc2UudXNhZ2UpICE9IG51bGwgPyBfYTE4IDogeyB0b2tlbnM6IE5hTiB9O1xuICAgICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5nczMubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZTIudG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgZW1iZWRkaW5nczogZW1iZWRkaW5nczMsXG4gICAgICAgICAgICAgICAgICB1c2FnZTogdXNhZ2UyLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmVzcG9uc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MyLm1hcCgoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZS50b2tlbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZE1hbnlSZXN1bHQoe1xuICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMixcbiAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhMixcbiAgICAgICAgICByZXNwb25zZXM6IFtyZXNwb25zZV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZUNodW5rcyA9IHNwbGl0QXJyYXkodmFsdWVzLCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCk7XG4gICAgICBjb25zdCBlbWJlZGRpbmdzID0gW107XG4gICAgICBjb25zdCByZXNwb25zZXMgPSBbXTtcbiAgICAgIGxldCB0b2tlbnMgPSAwO1xuICAgICAgbGV0IHByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICBjb25zdCBwYXJhbGxlbENodW5rcyA9IHNwbGl0QXJyYXkoXG4gICAgICAgIHZhbHVlQ2h1bmtzLFxuICAgICAgICBzdXBwb3J0c1BhcmFsbGVsQ2FsbHMgPyBtYXhQYXJhbGxlbENhbGxzIDogMVxuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3QgcGFyYWxsZWxDaHVuayBvZiBwYXJhbGxlbENodW5rcykge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgcGFyYWxsZWxDaHVuay5tYXAoKGNodW5rKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmV0cnkoKCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IGNodW5rLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgICBmbjogYXN5bmMgKGRvRW1iZWRTcGFuKSA9PiB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmdzMiA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncztcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHVzYWdlID0gKF9hMTggPSBtb2RlbFJlc3BvbnNlLnVzYWdlKSAhPSBudWxsID8gX2ExOCA6IHsgdG9rZW5zOiBOYU4gfTtcbiAgICAgICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MyLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZS50b2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZW1iZWRkaW5nczogZW1iZWRkaW5nczIsXG4gICAgICAgICAgICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtb2RlbFJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBtb2RlbFJlc3BvbnNlLnJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgZW1iZWRkaW5ncy5wdXNoKC4uLnJlc3VsdC5lbWJlZGRpbmdzKTtcbiAgICAgICAgICByZXNwb25zZXMucHVzaChyZXN1bHQucmVzcG9uc2UpO1xuICAgICAgICAgIHRva2VucyArPSByZXN1bHQudXNhZ2UudG9rZW5zO1xuICAgICAgICAgIGlmIChyZXN1bHQucHJvdmlkZXJNZXRhZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFwcm92aWRlck1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEgPSB7IC4uLnJlc3VsdC5wcm92aWRlck1ldGFkYXRhIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtwcm92aWRlck5hbWUsIG1ldGFkYXRhXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICAgICAgICAgICAgICByZXN1bHQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgLi4uKF9hMTcgPSBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0pICE9IG51bGwgPyBfYTE3IDoge30sXG4gICAgICAgICAgICAgICAgICAuLi5tZXRhZGF0YVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5ncy5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB0b2tlbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRNYW55UmVzdWx0KHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICBlbWJlZGRpbmdzLFxuICAgICAgICB1c2FnZTogeyB0b2tlbnMgfSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgcmVzcG9uc2VzXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRFbWJlZE1hbnlSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICAgIHRoaXMuZW1iZWRkaW5ncyA9IG9wdGlvbnMuZW1iZWRkaW5ncztcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgfVxufTtcblxuLy8gc3JjL2dlbmVyYXRlLWltYWdlL2dlbmVyYXRlLWltYWdlLnRzXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUltYWdlKHtcbiAgbW9kZWwsXG4gIHByb21wdCxcbiAgbiA9IDEsXG4gIG1heEltYWdlc1BlckNhbGwsXG4gIHNpemUsXG4gIGFzcGVjdFJhdGlvLFxuICBzZWVkLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzXG59KSB7XG4gIHZhciBfYTE3LCBfYjtcbiAgaWYgKG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uICE9PSBcInYyXCIpIHtcbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvcih7XG4gICAgICB2ZXJzaW9uOiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbixcbiAgICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgICB9KTtcbiAgfVxuICBjb25zdCB7IHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3QgbWF4SW1hZ2VzUGVyQ2FsbFdpdGhEZWZhdWx0ID0gKF9hMTcgPSBtYXhJbWFnZXNQZXJDYWxsICE9IG51bGwgPyBtYXhJbWFnZXNQZXJDYWxsIDogYXdhaXQgaW52b2tlTW9kZWxNYXhJbWFnZXNQZXJDYWxsKG1vZGVsKSkgIT0gbnVsbCA/IF9hMTcgOiAxO1xuICBjb25zdCBjYWxsQ291bnQgPSBNYXRoLmNlaWwobiAvIG1heEltYWdlc1BlckNhbGxXaXRoRGVmYXVsdCk7XG4gIGNvbnN0IGNhbGxJbWFnZUNvdW50cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGNhbGxDb3VudCB9LCAoXywgaSkgPT4ge1xuICAgIGlmIChpIDwgY2FsbENvdW50IC0gMSkge1xuICAgICAgcmV0dXJuIG1heEltYWdlc1BlckNhbGxXaXRoRGVmYXVsdDtcbiAgICB9XG4gICAgY29uc3QgcmVtYWluZGVyID0gbiAlIG1heEltYWdlc1BlckNhbGxXaXRoRGVmYXVsdDtcbiAgICByZXR1cm4gcmVtYWluZGVyID09PSAwID8gbWF4SW1hZ2VzUGVyQ2FsbFdpdGhEZWZhdWx0IDogcmVtYWluZGVyO1xuICB9KTtcbiAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGNhbGxJbWFnZUNvdW50cy5tYXAoXG4gICAgICBhc3luYyAoY2FsbEltYWdlQ291bnQpID0+IHJldHJ5KFxuICAgICAgICAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgbjogY2FsbEltYWdlQ291bnQsXG4gICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIGFzcGVjdFJhdGlvLFxuICAgICAgICAgIHNlZWQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck9wdGlvbnMgIT0gbnVsbCA/IHByb3ZpZGVyT3B0aW9ucyA6IHt9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKVxuICApO1xuICBjb25zdCBpbWFnZXMgPSBbXTtcbiAgY29uc3Qgd2FybmluZ3MgPSBbXTtcbiAgY29uc3QgcmVzcG9uc2VzID0gW107XG4gIGNvbnN0IHByb3ZpZGVyTWV0YWRhdGEgPSB7fTtcbiAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgIGltYWdlcy5wdXNoKFxuICAgICAgLi4ucmVzdWx0LmltYWdlcy5tYXAoXG4gICAgICAgIChpbWFnZSkgPT4ge1xuICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlZEZpbGUoe1xuICAgICAgICAgICAgZGF0YTogaW1hZ2UsXG4gICAgICAgICAgICBtZWRpYVR5cGU6IChfYTE4ID0gZGV0ZWN0TWVkaWFUeXBlKHtcbiAgICAgICAgICAgICAgZGF0YTogaW1hZ2UsXG4gICAgICAgICAgICAgIHNpZ25hdHVyZXM6IGltYWdlTWVkaWFUeXBlU2lnbmF0dXJlc1xuICAgICAgICAgICAgfSkpICE9IG51bGwgPyBfYTE4IDogXCJpbWFnZS9wbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgICB3YXJuaW5ncy5wdXNoKC4uLnJlc3VsdC53YXJuaW5ncyk7XG4gICAgaWYgKHJlc3VsdC5wcm92aWRlck1ldGFkYXRhKSB7XG4gICAgICBmb3IgKGNvbnN0IFtwcm92aWRlck5hbWUsIG1ldGFkYXRhXSBvZiBPYmplY3QuZW50cmllcyhyZXN1bHQucHJvdmlkZXJNZXRhZGF0YSkpIHtcbiAgICAgICAgKF9iID0gcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdKSAhPSBudWxsID8gX2IgOiBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0gPSB7IGltYWdlczogW10gfTtcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdLmltYWdlcy5wdXNoKFxuICAgICAgICAgIC4uLnJlc3VsdC5wcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0uaW1hZ2VzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3BvbnNlcy5wdXNoKHJlc3VsdC5yZXNwb25zZSk7XG4gIH1cbiAgbG9nV2FybmluZ3Mod2FybmluZ3MpO1xuICBpZiAoIWltYWdlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgTm9JbWFnZUdlbmVyYXRlZEVycm9yKHsgcmVzcG9uc2VzIH0pO1xuICB9XG4gIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlSW1hZ2VSZXN1bHQoe1xuICAgIGltYWdlcyxcbiAgICB3YXJuaW5ncyxcbiAgICByZXNwb25zZXMsXG4gICAgcHJvdmlkZXJNZXRhZGF0YVxuICB9KTtcbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVJbWFnZVJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuaW1hZ2VzID0gb3B0aW9ucy5pbWFnZXM7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gIH1cbiAgZ2V0IGltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlc1swXTtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGludm9rZU1vZGVsTWF4SW1hZ2VzUGVyQ2FsbChtb2RlbCkge1xuICBjb25zdCBpc0Z1bmN0aW9uID0gbW9kZWwubWF4SW1hZ2VzUGVyQ2FsbCBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICBpZiAoIWlzRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gbW9kZWwubWF4SW1hZ2VzUGVyQ2FsbDtcbiAgfVxuICByZXR1cm4gbW9kZWwubWF4SW1hZ2VzUGVyQ2FsbCh7XG4gICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICB9KTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC9nZW5lcmF0ZS1vYmplY3QudHNcbmltcG9ydCB7XG4gIGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yM1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9leHRyYWN0LXJlYXNvbmluZy1jb250ZW50LnRzXG5mdW5jdGlvbiBleHRyYWN0UmVhc29uaW5nQ29udGVudChjb250ZW50KSB7XG4gIGNvbnN0IHBhcnRzID0gY29udGVudC5maWx0ZXIoXG4gICAgKGNvbnRlbnQyKSA9PiBjb250ZW50Mi50eXBlID09PSBcInJlYXNvbmluZ1wiXG4gICk7XG4gIHJldHVybiBwYXJ0cy5sZW5ndGggPT09IDAgPyB2b2lkIDAgOiBwYXJ0cy5tYXAoKGNvbnRlbnQyKSA9PiBjb250ZW50Mi50ZXh0KS5qb2luKFwiXFxuXCIpO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtb2JqZWN0L291dHB1dC1zdHJhdGVneS50c1xuaW1wb3J0IHtcbiAgaXNKU09OQXJyYXksXG4gIGlzSlNPTk9iamVjdCxcbiAgVHlwZVZhbGlkYXRpb25FcnJvciBhcyBUeXBlVmFsaWRhdGlvbkVycm9yMixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgYXMgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBhc1NjaGVtYSBhcyBhc1NjaGVtYTMsXG4gIHNhZmVWYWxpZGF0ZVR5cGVzIGFzIHNhZmVWYWxpZGF0ZVR5cGVzM1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIG5vU2NoZW1hT3V0cHV0U3RyYXRlZ3kgPSB7XG4gIHR5cGU6IFwibm8tc2NoZW1hXCIsXG4gIGpzb25TY2hlbWE6IHZvaWQgMCxcbiAgYXN5bmMgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHsgdmFsdWUsIHRleHREZWx0YSB9KSB7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHsgcGFydGlhbDogdmFsdWUsIHRleHREZWx0YSB9IH07XG4gIH0sXG4gIGFzeW5jIHZhbGlkYXRlRmluYWxSZXN1bHQodmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiByZXNwb25zZSBkaWQgbm90IG1hdGNoIHNjaGVtYS5cIixcbiAgICAgICAgdGV4dDogY29udGV4dC50ZXh0LFxuICAgICAgICByZXNwb25zZTogY29udGV4dC5yZXNwb25zZSxcbiAgICAgICAgdXNhZ2U6IGNvbnRleHQudXNhZ2UsXG4gICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dC5maW5pc2hSZWFzb25cbiAgICAgIH0pXG4gICAgfSA6IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWUgfTtcbiAgfSxcbiAgY3JlYXRlRWxlbWVudFN0cmVhbSgpIHtcbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyKHtcbiAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiZWxlbWVudCBzdHJlYW1zIGluIG5vLXNjaGVtYSBtb2RlXCJcbiAgICB9KTtcbiAgfVxufTtcbnZhciBvYmplY3RPdXRwdXRTdHJhdGVneSA9IChzY2hlbWEpID0+ICh7XG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIGpzb25TY2hlbWE6IHNjaGVtYS5qc29uU2NoZW1hLFxuICBhc3luYyB2YWxpZGF0ZVBhcnRpYWxSZXN1bHQoeyB2YWx1ZSwgdGV4dERlbHRhIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIC8vIE5vdGU6IGN1cnJlbnRseSBubyB2YWxpZGF0aW9uIG9mIHBhcnRpYWwgcmVzdWx0czpcbiAgICAgICAgcGFydGlhbDogdmFsdWUsXG4gICAgICAgIHRleHREZWx0YVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFzeW5jIHZhbGlkYXRlRmluYWxSZXN1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gc2FmZVZhbGlkYXRlVHlwZXMzKHsgdmFsdWUsIHNjaGVtYSB9KTtcbiAgfSxcbiAgY3JlYXRlRWxlbWVudFN0cmVhbSgpIHtcbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyKHtcbiAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiZWxlbWVudCBzdHJlYW1zIGluIG9iamVjdCBtb2RlXCJcbiAgICB9KTtcbiAgfVxufSk7XG52YXIgYXJyYXlPdXRwdXRTdHJhdGVneSA9IChzY2hlbWEpID0+IHtcbiAgY29uc3QgeyAkc2NoZW1hLCAuLi5pdGVtU2NoZW1hIH0gPSBzY2hlbWEuanNvblNjaGVtYTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICAvLyB3cmFwIGluIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFycmF5IG9mIGVsZW1lbnRzLCBzaW5jZSBtb3N0IExMTXMgd2lsbCBub3RcbiAgICAvLyBiZSBhYmxlIHRvIGdlbmVyYXRlIGFuIGFycmF5IGRpcmVjdGx5OlxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBvcHRpbWl6YXRpb246IHVzZSBhcnJheXMgZGlyZWN0bHkgd2hlbiBtb2RlbCBzdXBwb3J0cyBncmFtbWFyLWd1aWRlZCBnZW5lcmF0aW9uXG4gICAganNvblNjaGVtYToge1xuICAgICAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGVsZW1lbnRzOiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IGl0ZW1TY2hlbWEgfVxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkOiBbXCJlbGVtZW50c1wiXSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgIH0sXG4gICAgYXN5bmMgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHtcbiAgICAgIHZhbHVlLFxuICAgICAgbGF0ZXN0T2JqZWN0LFxuICAgICAgaXNGaXJzdERlbHRhLFxuICAgICAgaXNGaW5hbERlbHRhXG4gICAgfSkge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgIWlzSlNPTkFycmF5KHZhbHVlLmVsZW1lbnRzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjIoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFuIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRBcnJheSA9IHZhbHVlLmVsZW1lbnRzO1xuICAgICAgY29uc3QgcmVzdWx0QXJyYXkgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gaW5wdXRBcnJheVtpXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMzKHsgdmFsdWU6IGVsZW1lbnQsIHNjaGVtYSB9KTtcbiAgICAgICAgaWYgKGkgPT09IGlucHV0QXJyYXkubGVuZ3RoIC0gMSAmJiAhaXNGaW5hbERlbHRhKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0QXJyYXkucHVzaChyZXN1bHQudmFsdWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHVibGlzaGVkRWxlbWVudENvdW50ID0gKF9hMTcgPSBsYXRlc3RPYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGxhdGVzdE9iamVjdC5sZW5ndGgpICE9IG51bGwgPyBfYTE3IDogMDtcbiAgICAgIGxldCB0ZXh0RGVsdGEgPSBcIlwiO1xuICAgICAgaWYgKGlzRmlyc3REZWx0YSkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCJbXCI7XG4gICAgICB9XG4gICAgICBpZiAocHVibGlzaGVkRWxlbWVudENvdW50ID4gMCkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCIsXCI7XG4gICAgICB9XG4gICAgICB0ZXh0RGVsdGEgKz0gcmVzdWx0QXJyYXkuc2xpY2UocHVibGlzaGVkRWxlbWVudENvdW50KS5tYXAoKGVsZW1lbnQpID0+IEpTT04uc3RyaW5naWZ5KGVsZW1lbnQpKS5qb2luKFwiLFwiKTtcbiAgICAgIGlmIChpc0ZpbmFsRGVsdGEpIHtcbiAgICAgICAgdGV4dERlbHRhICs9IFwiXVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBwYXJ0aWFsOiByZXN1bHRBcnJheSxcbiAgICAgICAgICB0ZXh0RGVsdGFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzeW5jIHZhbGlkYXRlRmluYWxSZXN1bHQodmFsdWUpIHtcbiAgICAgIGlmICghaXNKU09OT2JqZWN0KHZhbHVlKSB8fCAhaXNKU09OQXJyYXkodmFsdWUuZWxlbWVudHMpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yMih7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYW4gYXJyYXkgb2YgZWxlbWVudHNcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBpbnB1dEFycmF5ID0gdmFsdWUuZWxlbWVudHM7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgaW5wdXRBcnJheSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlczMoeyB2YWx1ZTogZWxlbWVudCwgc2NoZW1hIH0pO1xuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IGlucHV0QXJyYXkgfTtcbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnRTdHJlYW0ob3JpZ2luYWxTdHJlYW0pIHtcbiAgICAgIGxldCBwdWJsaXNoZWRFbGVtZW50cyA9IDA7XG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgICAgb3JpZ2luYWxTdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhcnJheSA9IGNodW5rLm9iamVjdDtcbiAgICAgICAgICAgICAgICAgIGZvciAoOyBwdWJsaXNoZWRFbGVtZW50cyA8IGFycmF5Lmxlbmd0aDsgcHVibGlzaGVkRWxlbWVudHMrKykge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYXJyYXlbcHVibGlzaGVkRWxlbWVudHNdKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9O1xufTtcbnZhciBlbnVtT3V0cHV0U3RyYXRlZ3kgPSAoZW51bVZhbHVlcykgPT4ge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIC8vIHdyYXAgaW4gb2JqZWN0IHRoYXQgY29udGFpbnMgcmVzdWx0LCBzaW5jZSBtb3N0IExMTXMgd2lsbCBub3RcbiAgICAvLyBiZSBhYmxlIHRvIGdlbmVyYXRlIGFuIGVudW0gdmFsdWUgZGlyZWN0bHk6XG4gICAgLy8gcG9zc2libGUgZnV0dXJlIG9wdGltaXphdGlvbjogdXNlIGVudW1zIGRpcmVjdGx5IHdoZW4gbW9kZWwgc3VwcG9ydHMgdG9wLWxldmVsIGVudW1zXG4gICAganNvblNjaGVtYToge1xuICAgICAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHJlc3VsdDogeyB0eXBlOiBcInN0cmluZ1wiLCBlbnVtOiBlbnVtVmFsdWVzIH1cbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogW1wicmVzdWx0XCJdLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlXG4gICAgfSxcbiAgICBhc3luYyB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlKSB7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnJlc3VsdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjIoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogJ3ZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBzdHJpbmcgaW4gdGhlIFwicmVzdWx0XCIgcHJvcGVydHkuJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5yZXN1bHQ7XG4gICAgICByZXR1cm4gZW51bVZhbHVlcy5pbmNsdWRlcyhyZXN1bHQpID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0IH0gOiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3IyKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIGluIHRoZSBlbnVtXCJcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSxcbiAgICBhc3luYyB2YWxpZGF0ZVBhcnRpYWxSZXN1bHQoeyB2YWx1ZSwgdGV4dERlbHRhIH0pIHtcbiAgICAgIGlmICghaXNKU09OT2JqZWN0KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUucmVzdWx0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yMih7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiAndmFsdWUgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIHN0cmluZyBpbiB0aGUgXCJyZXN1bHRcIiBwcm9wZXJ0eS4nXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLnJlc3VsdDtcbiAgICAgIGNvbnN0IHBvc3NpYmxlRW51bVZhbHVlcyA9IGVudW1WYWx1ZXMuZmlsdGVyKFxuICAgICAgICAoZW51bVZhbHVlKSA9PiBlbnVtVmFsdWUuc3RhcnRzV2l0aChyZXN1bHQpXG4gICAgICApO1xuICAgICAgaWYgKHZhbHVlLnJlc3VsdC5sZW5ndGggPT09IDAgfHwgcG9zc2libGVFbnVtVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjIoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIGluIHRoZSBlbnVtXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBwYXJ0aWFsOiBwb3NzaWJsZUVudW1WYWx1ZXMubGVuZ3RoID4gMSA/IHJlc3VsdCA6IHBvc3NpYmxlRW51bVZhbHVlc1swXSxcbiAgICAgICAgICB0ZXh0RGVsdGFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnRTdHJlYW0oKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyKHtcbiAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJlbGVtZW50IHN0cmVhbXMgaW4gZW51bSBtb2RlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBnZXRPdXRwdXRTdHJhdGVneSh7XG4gIG91dHB1dCxcbiAgc2NoZW1hLFxuICBlbnVtVmFsdWVzXG59KSB7XG4gIHN3aXRjaCAob3V0cHV0KSB7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgcmV0dXJuIG9iamVjdE91dHB1dFN0cmF0ZWd5KGFzU2NoZW1hMyhzY2hlbWEpKTtcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIHJldHVybiBhcnJheU91dHB1dFN0cmF0ZWd5KGFzU2NoZW1hMyhzY2hlbWEpKTtcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgcmV0dXJuIGVudW1PdXRwdXRTdHJhdGVneShlbnVtVmFsdWVzKTtcbiAgICBjYXNlIFwibm8tc2NoZW1hXCI6XG4gICAgICByZXR1cm4gbm9TY2hlbWFPdXRwdXRTdHJhdGVneTtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gb3V0cHV0O1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvdXRwdXQ6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC9wYXJzZS1hbmQtdmFsaWRhdGUtb2JqZWN0LXJlc3VsdC50c1xuaW1wb3J0IHsgSlNPTlBhcnNlRXJyb3IgYXMgSlNPTlBhcnNlRXJyb3IyLCBUeXBlVmFsaWRhdGlvbkVycm9yIGFzIFR5cGVWYWxpZGF0aW9uRXJyb3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNhZmVQYXJzZUpTT04gYXMgc2FmZVBhcnNlSlNPTjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VBbmRWYWxpZGF0ZU9iamVjdFJlc3VsdChyZXN1bHQsIG91dHB1dFN0cmF0ZWd5LCBjb250ZXh0KSB7XG4gIGNvbnN0IHBhcnNlUmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTjMoeyB0ZXh0OiByZXN1bHQgfSk7XG4gIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogY291bGQgbm90IHBhcnNlIHRoZSByZXNwb25zZS5cIixcbiAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgIHRleHQ6IHJlc3VsdCxcbiAgICAgIHJlc3BvbnNlOiBjb250ZXh0LnJlc3BvbnNlLFxuICAgICAgdXNhZ2U6IGNvbnRleHQudXNhZ2UsXG4gICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQuZmluaXNoUmVhc29uXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlRmluYWxSZXN1bHQoXG4gICAgcGFyc2VSZXN1bHQudmFsdWUsXG4gICAge1xuICAgICAgdGV4dDogcmVzdWx0LFxuICAgICAgcmVzcG9uc2U6IGNvbnRleHQucmVzcG9uc2UsXG4gICAgICB1c2FnZTogY29udGV4dC51c2FnZVxuICAgIH1cbiAgKTtcbiAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3IsXG4gICAgICB0ZXh0OiByZXN1bHQsXG4gICAgICByZXNwb25zZTogY29udGV4dC5yZXNwb25zZSxcbiAgICAgIHVzYWdlOiBjb250ZXh0LnVzYWdlLFxuICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0LmZpbmlzaFJlYXNvblxuICAgIH0pO1xuICB9XG4gIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlO1xufVxuYXN5bmMgZnVuY3Rpb24gcGFyc2VBbmRWYWxpZGF0ZU9iamVjdFJlc3VsdFdpdGhSZXBhaXIocmVzdWx0LCBvdXRwdXRTdHJhdGVneSwgcmVwYWlyVGV4dCwgY29udGV4dCkge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBwYXJzZUFuZFZhbGlkYXRlT2JqZWN0UmVzdWx0KHJlc3VsdCwgb3V0cHV0U3RyYXRlZ3ksIGNvbnRleHQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChyZXBhaXJUZXh0ICE9IG51bGwgJiYgTm9PYmplY3RHZW5lcmF0ZWRFcnJvci5pc0luc3RhbmNlKGVycm9yKSAmJiAoSlNPTlBhcnNlRXJyb3IyLmlzSW5zdGFuY2UoZXJyb3IuY2F1c2UpIHx8IFR5cGVWYWxpZGF0aW9uRXJyb3IzLmlzSW5zdGFuY2UoZXJyb3IuY2F1c2UpKSkge1xuICAgICAgY29uc3QgcmVwYWlyZWRUZXh0ID0gYXdhaXQgcmVwYWlyVGV4dCh7XG4gICAgICAgIHRleHQ6IHJlc3VsdCxcbiAgICAgICAgZXJyb3I6IGVycm9yLmNhdXNlXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXBhaXJlZFRleHQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgcGFyc2VBbmRWYWxpZGF0ZU9iamVjdFJlc3VsdChcbiAgICAgICAgcmVwYWlyZWRUZXh0LFxuICAgICAgICBvdXRwdXRTdHJhdGVneSxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC92YWxpZGF0ZS1vYmplY3QtZ2VuZXJhdGlvbi1pbnB1dC50c1xuZnVuY3Rpb24gdmFsaWRhdGVPYmplY3RHZW5lcmF0aW9uSW5wdXQoe1xuICBvdXRwdXQsXG4gIHNjaGVtYSxcbiAgc2NoZW1hTmFtZSxcbiAgc2NoZW1hRGVzY3JpcHRpb24sXG4gIGVudW1WYWx1ZXNcbn0pIHtcbiAgaWYgKG91dHB1dCAhPSBudWxsICYmIG91dHB1dCAhPT0gXCJvYmplY3RcIiAmJiBvdXRwdXQgIT09IFwiYXJyYXlcIiAmJiBvdXRwdXQgIT09IFwiZW51bVwiICYmIG91dHB1dCAhPT0gXCJuby1zY2hlbWFcIikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBwYXJhbWV0ZXI6IFwib3V0cHV0XCIsXG4gICAgICB2YWx1ZTogb3V0cHV0LFxuICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIG91dHB1dCB0eXBlLlwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJuby1zY2hlbWFcIikge1xuICAgIGlmIChzY2hlbWEgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFEZXNjcmlwdGlvblwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGRlc2NyaXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hTmFtZSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hTmFtZVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hTmFtZSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgbmFtZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGlzIHJlcXVpcmVkIGZvciBvYmplY3Qgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIG9iamVjdCBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcImFycmF5XCIpIHtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJFbGVtZW50IHNjaGVtYSBpcyByZXF1aXJlZCBmb3IgYXJyYXkgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGFycmF5IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChvdXRwdXQgPT09IFwiZW51bVwiKSB7XG4gICAgaWYgKHNjaGVtYSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFEZXNjcmlwdGlvblwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGRlc2NyaXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYU5hbWUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYU5hbWVcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYU5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIG5hbWUgaXMgbm90IHN1cHBvcnRlZCBmb3IgZW51bSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZW51bVZhbHVlcyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICB2YWx1ZTogZW51bVZhbHVlcyxcbiAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBhcmUgcmVxdWlyZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBlbnVtVmFsdWVzKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIG11c3QgYmUgc3RyaW5ncy5cIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC9nZW5lcmF0ZS1vYmplY3QudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQzID0gY3JlYXRlSWRHZW5lcmF0b3IzKHsgcHJlZml4OiBcImFpb2JqXCIsIHNpemU6IDI0IH0pO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVPYmplY3Qob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgbW9kZWw6IG1vZGVsQXJnLFxuICAgIG91dHB1dCA9IFwib2JqZWN0XCIsXG4gICAgc3lzdGVtLFxuICAgIHByb21wdCxcbiAgICBtZXNzYWdlcyxcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsLFxuICAgIGhlYWRlcnMsXG4gICAgZXhwZXJpbWVudGFsX3JlcGFpclRleHQ6IHJlcGFpclRleHQsXG4gICAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICAgIGV4cGVyaW1lbnRhbF9kb3dubG9hZDogZG93bmxvYWQyLFxuICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICBfaW50ZXJuYWw6IHtcbiAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkMyxcbiAgICAgIGN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICB9ID0ge30sXG4gICAgLi4uc2V0dGluZ3NcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG1vZGVsID0gcmVzb2x2ZUxhbmd1YWdlTW9kZWwobW9kZWxBcmcpO1xuICBjb25zdCBlbnVtVmFsdWVzID0gXCJlbnVtXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZW51bSA6IHZvaWQgMDtcbiAgY29uc3Qge1xuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgc2NoZW1hTmFtZVxuICB9ID0gXCJzY2hlbWFcIiBpbiBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuICB2YWxpZGF0ZU9iamVjdEdlbmVyYXRpb25JbnB1dCh7XG4gICAgb3V0cHV0LFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgc2NoZW1hTmFtZSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBlbnVtVmFsdWVzXG4gIH0pO1xuICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3Qgb3V0cHV0U3RyYXRlZ3kgPSBnZXRPdXRwdXRTdHJhdGVneSh7XG4gICAgb3V0cHV0LFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgY29uc3QgY2FsbFNldHRpbmdzID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IC4uLmNhbGxTZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcmVjb3JkU3Bhbih7XG4gICAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0XCIsXG4gICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlT2JqZWN0XCIsXG4gICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImFpLnNjaGVtYVwiOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hICE9IG51bGwgPyB7IGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hKSB9IDogdm9pZCAwLFxuICAgICAgICAgIFwiYWkuc2NoZW1hLm5hbWVcIjogc2NoZW1hTmFtZSxcbiAgICAgICAgICBcImFpLnNjaGVtYS5kZXNjcmlwdGlvblwiOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgICBcImFpLnNldHRpbmdzLm91dHB1dFwiOiBvdXRwdXRTdHJhdGVneS50eXBlXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICAgIHZhciBfYTE3O1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBsZXQgZmluaXNoUmVhc29uO1xuICAgICAgICBsZXQgdXNhZ2U7XG4gICAgICAgIGxldCB3YXJuaW5ncztcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcmVxdWVzdDtcbiAgICAgICAgbGV0IHJlc3VsdFByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgIGxldCByZWFzb25pbmc7XG4gICAgICAgIGNvbnN0IHN0YW5kYXJkaXplZFByb21wdCA9IGF3YWl0IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgIHByb21wdDogc3RhbmRhcmRpemVkUHJvbXB0LFxuICAgICAgICAgIHN1cHBvcnRlZFVybHM6IGF3YWl0IG1vZGVsLnN1cHBvcnRlZFVybHMsXG4gICAgICAgICAgZG93bmxvYWQ6IGRvd25sb2FkMlxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVSZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZU9iamVjdC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gc3RyaW5naWZ5Rm9yVGVsZW1ldHJ5KHByb21wdE1lc3NhZ2VzKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBjYWxsU2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogY2FsbFNldHRpbmdzLm1heE91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogY2FsbFNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IGNhbGxTZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IGNhbGxTZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogY2FsbFNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTE4LCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlRm9ybWF0OiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICAgIHNjaGVtYTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHNjaGVtYU5hbWUsXG4gICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpZDogKF9iID0gKF9hMTggPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOC5pZCkgIT0gbnVsbCA/IF9iIDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfZCA9IChfYyA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYy50aW1lc3RhbXApICE9IG51bGwgPyBfZCA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgICAgICAgICAgbW9kZWxJZDogKF9mID0gKF9lID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm1vZGVsSWQpICE9IG51bGwgPyBfZiA6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogKF9nID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogKF9oID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9oLmJvZHlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY29uc3QgdGV4dDIgPSBleHRyYWN0VGV4dENvbnRlbnQocmVzdWx0Mi5jb250ZW50KTtcbiAgICAgICAgICAgICAgY29uc3QgcmVhc29uaW5nMiA9IGV4dHJhY3RSZWFzb25pbmdDb250ZW50KHJlc3VsdDIuY29udGVudCk7XG4gICAgICAgICAgICAgIGlmICh0ZXh0MiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiB0aGUgbW9kZWwgZGlkIG5vdCByZXR1cm4gYSByZXNwb25zZS5cIixcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZURhdGEsXG4gICAgICAgICAgICAgICAgICB1c2FnZTogcmVzdWx0Mi51c2FnZSxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogcmVzdWx0Mi5maW5pc2hSZWFzb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiByZXN1bHQyLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IHRleHQyIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiByZXNwb25zZURhdGEudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyByZW5hbWUgdGVsZW1ldHJ5IGF0dHJpYnV0ZXMgdG8gaW5wdXRUb2tlbnMgYW5kIG91dHB1dFRva2Vuc1xuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogcmVzdWx0Mi51c2FnZS5vdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW3Jlc3VsdDIuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5vdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnJlc3VsdDIsXG4gICAgICAgICAgICAgICAgb2JqZWN0VGV4dDogdGV4dDIsXG4gICAgICAgICAgICAgICAgcmVhc29uaW5nOiByZWFzb25pbmcyLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlRGF0YVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlUmVzdWx0Lm9iamVjdFRleHQ7XG4gICAgICAgIGZpbmlzaFJlYXNvbiA9IGdlbmVyYXRlUmVzdWx0LmZpbmlzaFJlYXNvbjtcbiAgICAgICAgdXNhZ2UgPSBnZW5lcmF0ZVJlc3VsdC51c2FnZTtcbiAgICAgICAgd2FybmluZ3MgPSBnZW5lcmF0ZVJlc3VsdC53YXJuaW5ncztcbiAgICAgICAgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YSA9IGdlbmVyYXRlUmVzdWx0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgIHJlcXVlc3QgPSAoX2ExNyA9IGdlbmVyYXRlUmVzdWx0LnJlcXVlc3QpICE9IG51bGwgPyBfYTE3IDoge307XG4gICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmVzcG9uc2VEYXRhO1xuICAgICAgICByZWFzb25pbmcgPSBnZW5lcmF0ZVJlc3VsdC5yZWFzb25pbmc7XG4gICAgICAgIGxvZ1dhcm5pbmdzKHdhcm5pbmdzKTtcbiAgICAgICAgY29uc3Qgb2JqZWN0MiA9IGF3YWl0IHBhcnNlQW5kVmFsaWRhdGVPYmplY3RSZXN1bHRXaXRoUmVwYWlyKFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICBvdXRwdXRTdHJhdGVneSxcbiAgICAgICAgICByZXBhaXJUZXh0LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb25cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QyKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGFcIjogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAvLyBUT0RPIHJlbmFtZSB0ZWxlbWV0cnkgYXR0cmlidXRlcyB0byBpbnB1dFRva2VucyBhbmQgb3V0cHV0VG9rZW5zXG4gICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogdXNhZ2Uub3V0cHV0VG9rZW5zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0R2VuZXJhdGVPYmplY3RSZXN1bHQoe1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0MixcbiAgICAgICAgICByZWFzb25pbmcsXG4gICAgICAgICAgZmluaXNoUmVhc29uLFxuICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgIHdhcm5pbmdzLFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0UHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyB3cmFwR2F0ZXdheUVycm9yKGVycm9yKTtcbiAgfVxufVxudmFyIERlZmF1bHRHZW5lcmF0ZU9iamVjdFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub2JqZWN0ID0gb3B0aW9ucy5vYmplY3Q7XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSBvcHRpb25zLmZpbmlzaFJlYXNvbjtcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgdGhpcy5yZXNwb25zZSA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgdGhpcy5yZXF1ZXN0ID0gb3B0aW9ucy5yZXF1ZXN0O1xuICAgIHRoaXMucmVhc29uaW5nID0gb3B0aW9ucy5yZWFzb25pbmc7XG4gIH1cbiAgdG9Kc29uUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTE3O1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5vYmplY3QpLCB7XG4gICAgICBzdGF0dXM6IChfYTE3ID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTE3IDogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZUhlYWRlcnMoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzLCB7XG4gICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZ2VuZXJhdGUtb2JqZWN0L3N0cmVhbS1vYmplY3QudHNcbmltcG9ydCB7XG4gIGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yNFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9jb3NpbmUtc2ltaWxhcml0eS50c1xuZnVuY3Rpb24gY29zaW5lU2ltaWxhcml0eSh2ZWN0b3IxLCB2ZWN0b3IyKSB7XG4gIGlmICh2ZWN0b3IxLmxlbmd0aCAhPT0gdmVjdG9yMi5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgcGFyYW1ldGVyOiBcInZlY3RvcjEsdmVjdG9yMlwiLFxuICAgICAgdmFsdWU6IHsgdmVjdG9yMUxlbmd0aDogdmVjdG9yMS5sZW5ndGgsIHZlY3RvcjJMZW5ndGg6IHZlY3RvcjIubGVuZ3RoIH0sXG4gICAgICBtZXNzYWdlOiBgVmVjdG9ycyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoYFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IG4gPSB2ZWN0b3IxLmxlbmd0aDtcbiAgaWYgKG4gPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgbWFnbml0dWRlU3F1YXJlZDEgPSAwO1xuICBsZXQgbWFnbml0dWRlU3F1YXJlZDIgPSAwO1xuICBsZXQgZG90UHJvZHVjdCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgY29uc3QgdmFsdWUxID0gdmVjdG9yMVtpXTtcbiAgICBjb25zdCB2YWx1ZTIgPSB2ZWN0b3IyW2ldO1xuICAgIG1hZ25pdHVkZVNxdWFyZWQxICs9IHZhbHVlMSAqIHZhbHVlMTtcbiAgICBtYWduaXR1ZGVTcXVhcmVkMiArPSB2YWx1ZTIgKiB2YWx1ZTI7XG4gICAgZG90UHJvZHVjdCArPSB2YWx1ZTEgKiB2YWx1ZTI7XG4gIH1cbiAgcmV0dXJuIG1hZ25pdHVkZVNxdWFyZWQxID09PSAwIHx8IG1hZ25pdHVkZVNxdWFyZWQyID09PSAwID8gMCA6IGRvdFByb2R1Y3QgLyAoTWF0aC5zcXJ0KG1hZ25pdHVkZVNxdWFyZWQxKSAqIE1hdGguc3FydChtYWduaXR1ZGVTcXVhcmVkMikpO1xufVxuXG4vLyBzcmMvdXRpbC9kYXRhLXVybC50c1xuZnVuY3Rpb24gZ2V0VGV4dEZyb21EYXRhVXJsKGRhdGFVcmwpIHtcbiAgY29uc3QgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBkYXRhVXJsLnNwbGl0KFwiLFwiKTtcbiAgY29uc3QgbWVkaWFUeXBlID0gaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV07XG4gIGlmIChtZWRpYVR5cGUgPT0gbnVsbCB8fCBiYXNlNjRDb250ZW50ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdFwiKTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuYXRvYihiYXNlNjRDb250ZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY29kaW5nIGRhdGEgVVJMYCk7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWwvaXMtZGVlcC1lcXVhbC1kYXRhLnRzXG5mdW5jdGlvbiBpc0RlZXBFcXVhbERhdGEob2JqMSwgb2JqMikge1xuICBpZiAob2JqMSA9PT0gb2JqMilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKG9iajEgPT0gbnVsbCB8fCBvYmoyID09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIG9iajEgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iajIgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIG9iajEgPT09IG9iajI7XG4gIGlmIChvYmoxLmNvbnN0cnVjdG9yICE9PSBvYmoyLmNvbnN0cnVjdG9yKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKG9iajEgaW5zdGFuY2VvZiBEYXRlICYmIG9iajIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG9iajEuZ2V0VGltZSgpID09PSBvYmoyLmdldFRpbWUoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmoxKSkge1xuICAgIGlmIChvYmoxLmxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2ldLCBvYmoyW2ldKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzMSkge1xuICAgIGlmICgha2V5czIuaW5jbHVkZXMoa2V5KSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2tleV0sIG9iajJba2V5XSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy91dGlsL3NlcmlhbC1qb2ItZXhlY3V0b3IudHNcbnZhciBTZXJpYWxKb2JFeGVjdXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc1F1ZXVlKCkge1xuICAgIGlmICh0aGlzLmlzUHJvY2Vzc2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgd2hpbGUgKHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgdGhpcy5xdWV1ZVswXSgpO1xuICAgICAgdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgIH1cbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG4gIGFzeW5jIHJ1bihqb2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUyLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucXVldWUucHVzaChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgam9iKCk7XG4gICAgICAgICAgcmVzb2x2ZTIoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZvaWQgdGhpcy5wcm9jZXNzUXVldWUoKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWwvc2ltdWxhdGUtcmVhZGFibGUtc3RyZWFtLnRzXG5pbXBvcnQgeyBkZWxheSBhcyBkZWxheUZ1bmN0aW9uIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIHNpbXVsYXRlUmVhZGFibGVTdHJlYW0oe1xuICBjaHVua3MsXG4gIGluaXRpYWxEZWxheUluTXMgPSAwLFxuICBjaHVua0RlbGF5SW5NcyA9IDAsXG4gIF9pbnRlcm5hbFxufSkge1xuICB2YXIgX2ExNztcbiAgY29uc3QgZGVsYXkyID0gKF9hMTcgPSBfaW50ZXJuYWwgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnRlcm5hbC5kZWxheSkgIT0gbnVsbCA/IF9hMTcgOiBkZWxheUZ1bmN0aW9uO1xuICBsZXQgaW5kZXggPSAwO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChpbmRleCA8IGNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgYXdhaXQgZGVsYXkyKGluZGV4ID09PSAwID8gaW5pdGlhbERlbGF5SW5NcyA6IGNodW5rRGVsYXlJbk1zKTtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rc1tpbmRleCsrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC9zdHJlYW0tb2JqZWN0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkNCA9IGNyZWF0ZUlkR2VuZXJhdG9yNCh7IHByZWZpeDogXCJhaW9ialwiLCBzaXplOiAyNCB9KTtcbmZ1bmN0aW9uIHN0cmVhbU9iamVjdChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBtb2RlbCxcbiAgICBvdXRwdXQgPSBcIm9iamVjdFwiLFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgbWF4UmV0cmllcyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBoZWFkZXJzLFxuICAgIGV4cGVyaW1lbnRhbF9yZXBhaXJUZXh0OiByZXBhaXJUZXh0LFxuICAgIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgICBleHBlcmltZW50YWxfZG93bmxvYWQ6IGRvd25sb2FkMixcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgb25FcnJvciA9ICh7IGVycm9yIH0pID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH0sXG4gICAgb25GaW5pc2gsXG4gICAgX2ludGVybmFsOiB7XG4gICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZDQsXG4gICAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgbm93OiBub3cyID0gbm93XG4gICAgfSA9IHt9LFxuICAgIC4uLnNldHRpbmdzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBlbnVtVmFsdWVzID0gXCJlbnVtXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmVudW0gPyBvcHRpb25zLmVudW0gOiB2b2lkIDA7XG4gIGNvbnN0IHtcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uLFxuICAgIHNjaGVtYU5hbWVcbiAgfSA9IFwic2NoZW1hXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcbiAgdmFsaWRhdGVPYmplY3RHZW5lcmF0aW9uSW5wdXQoe1xuICAgIG91dHB1dCxcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgY29uc3Qgb3V0cHV0U3RyYXRlZ3kgPSBnZXRPdXRwdXRTdHJhdGVneSh7XG4gICAgb3V0cHV0LFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgcmV0dXJuIG5ldyBEZWZhdWx0U3RyZWFtT2JqZWN0UmVzdWx0KHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5ncyxcbiAgICBtYXhSZXRyaWVzLFxuICAgIGFib3J0U2lnbmFsLFxuICAgIG91dHB1dFN0cmF0ZWd5LFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgc2NoZW1hTmFtZSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgcmVwYWlyVGV4dCxcbiAgICBvbkVycm9yLFxuICAgIG9uRmluaXNoLFxuICAgIGRvd25sb2FkOiBkb3dubG9hZDIsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMsXG4gICAgY3VycmVudERhdGUsXG4gICAgbm93OiBub3cyXG4gIH0pO1xufVxudmFyIERlZmF1bHRTdHJlYW1PYmplY3RSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtb2RlbDogbW9kZWxBcmcsXG4gICAgaGVhZGVycyxcbiAgICB0ZWxlbWV0cnksXG4gICAgc2V0dGluZ3MsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBvdXRwdXRTdHJhdGVneSxcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIHJlcGFpclRleHQsXG4gICAgb25FcnJvcixcbiAgICBvbkZpbmlzaCxcbiAgICBkb3dubG9hZDogZG93bmxvYWQyLFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzLFxuICAgIGN1cnJlbnREYXRlLFxuICAgIG5vdzogbm93MlxuICB9KSB7XG4gICAgdGhpcy5fb2JqZWN0ID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5fdXNhZ2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLl9wcm92aWRlck1ldGFkYXRhID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5fd2FybmluZ3MgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5fcmVzcG9uc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLl9maW5pc2hSZWFzb24gPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICBjb25zdCBtb2RlbCA9IHJlc29sdmVMYW5ndWFnZU1vZGVsKG1vZGVsQXJnKTtcbiAgICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgICAgYWJvcnRTaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBjYWxsU2V0dGluZ3MgPSBwcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIG1vZGVsLFxuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNldHRpbmdzOiB7IC4uLmNhbGxTZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gICAgfSk7XG4gICAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3Qgc3RpdGNoYWJsZVN0cmVhbSA9IGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKTtcbiAgICBjb25zdCBldmVudFByb2Nlc3NvciA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICBvbkVycm9yKHsgZXJyb3I6IHdyYXBHYXRld2F5RXJyb3IoY2h1bmsuZXJyb3IpIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5iYXNlU3RyZWFtID0gc3RpdGNoYWJsZVN0cmVhbS5zdHJlYW0ucGlwZVRocm91Z2goZXZlbnRQcm9jZXNzb3IpO1xuICAgIHJlY29yZFNwYW4oe1xuICAgICAgbmFtZTogXCJhaS5zdHJlYW1PYmplY3RcIixcbiAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtT2JqZWN0XCIsXG4gICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImFpLnNjaGVtYVwiOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hICE9IG51bGwgPyB7IGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hKSB9IDogdm9pZCAwLFxuICAgICAgICAgIFwiYWkuc2NoZW1hLm5hbWVcIjogc2NoZW1hTmFtZSxcbiAgICAgICAgICBcImFpLnNjaGVtYS5kZXNjcmlwdGlvblwiOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgICBcImFpLnNldHRpbmdzLm91dHB1dFwiOiBvdXRwdXRTdHJhdGVneS50eXBlXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgZm46IGFzeW5jIChyb290U3BhbikgPT4ge1xuICAgICAgICBjb25zdCBzdGFuZGFyZGl6ZWRQcm9tcHQgPSBhd2FpdCBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgcmVzcG9uc2VGb3JtYXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hLFxuICAgICAgICAgICAgbmFtZTogc2NoZW1hTmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFEZXNjcmlwdGlvblxuICAgICAgICAgIH0sXG4gICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgcHJvbXB0OiBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgIHByb21wdDogc3RhbmRhcmRpemVkUHJvbXB0LFxuICAgICAgICAgICAgc3VwcG9ydGVkVXJsczogYXdhaXQgbW9kZWwuc3VwcG9ydGVkVXJscyxcbiAgICAgICAgICAgIGRvd25sb2FkOiBkb3dubG9hZDJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBpbmNsdWRlUmF3Q2h1bmtzOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IHtcbiAgICAgICAgICB0cmFuc2Zvcm06IChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLmRlbHRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzdHJlYW0tc3RhcnRcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlc3VsdDogeyBzdHJlYW0sIHJlc3BvbnNlLCByZXF1ZXN0IH0sXG4gICAgICAgICAgZG9TdHJlYW1TcGFuLFxuICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXNcbiAgICAgICAgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5zdHJlYW1PYmplY3QuZG9TdHJlYW1cIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtT2JqZWN0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gc3RyaW5naWZ5Rm9yVGVsZW1ldHJ5KGNhbGxPcHRpb25zLnByb21wdClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogY2FsbFNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IGNhbGxTZXR0aW5ncy5tYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IGNhbGxTZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBjYWxsU2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBjYWxsU2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IGNhbGxTZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb1N0cmVhbVNwYW4yKSA9PiAoe1xuICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zOiBub3cyKCksXG4gICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMixcbiAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBtb2RlbC5kb1N0cmVhbShjYWxsT3B0aW9ucylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgc2VsZi5fcmVxdWVzdC5yZXNvbHZlKHJlcXVlc3QgIT0gbnVsbCA/IHJlcXVlc3QgOiB7fSk7XG4gICAgICAgIGxldCB3YXJuaW5ncztcbiAgICAgICAgbGV0IHVzYWdlID0ge1xuICAgICAgICAgIGlucHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgICAgICAgb3V0cHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgICAgICAgdG90YWxUb2tlbnM6IHZvaWQgMFxuICAgICAgICB9O1xuICAgICAgICBsZXQgZmluaXNoUmVhc29uO1xuICAgICAgICBsZXQgcHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgbGV0IG9iamVjdDI7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgbGV0IGFjY3VtdWxhdGVkVGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCB0ZXh0RGVsdGEgPSBcIlwiO1xuICAgICAgICBsZXQgZnVsbFJlc3BvbnNlID0ge1xuICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgICAgIHRpbWVzdGFtcDogY3VycmVudERhdGUoKSxcbiAgICAgICAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkXG4gICAgICAgIH07XG4gICAgICAgIGxldCBsYXRlc3RPYmplY3RKc29uID0gdm9pZCAwO1xuICAgICAgICBsZXQgbGF0ZXN0T2JqZWN0ID0gdm9pZCAwO1xuICAgICAgICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZTtcbiAgICAgICAgbGV0IGlzRmlyc3REZWx0YSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0odHJhbnNmb3JtZXIpKS5waXBlVGhyb3VnaChcbiAgICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgICB2YXIgX2ExNywgX2IsIF9jO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSBcIm9iamVjdFwiICYmIGNodW5rLnR5cGUgPT09IFwic3RyZWFtLXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICB3YXJuaW5ncyA9IGNodW5rLndhcm5pbmdzO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNGaXJzdENodW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNUb0ZpcnN0Q2h1bmsgPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgICAgIGlzRmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maXJzdENodW5rXCIsIHtcbiAgICAgICAgICAgICAgICAgIFwiYWkuc3RyZWFtLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgXCJhaS5zdHJlYW0ubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRUZXh0ICs9IGNodW5rO1xuICAgICAgICAgICAgICAgIHRleHREZWx0YSArPSBjaHVuaztcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlOiBjdXJyZW50T2JqZWN0SnNvbiwgc3RhdGU6IHBhcnNlU3RhdGUgfSA9IGF3YWl0IHBhcnNlUGFydGlhbEpzb24oYWNjdW11bGF0ZWRUZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE9iamVjdEpzb24gIT09IHZvaWQgMCAmJiAhaXNEZWVwRXF1YWxEYXRhKGxhdGVzdE9iamVjdEpzb24sIGN1cnJlbnRPYmplY3RKc29uKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlUGFydGlhbFJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50T2JqZWN0SnNvbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhLFxuICAgICAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3REZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgaXNGaW5hbERlbHRhOiBwYXJzZVN0YXRlID09PSBcInN1Y2Nlc3NmdWwtcGFyc2VcIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzICYmICFpc0RlZXBFcXVhbERhdGEoXG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC52YWx1ZS5wYXJ0aWFsXG4gICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdEpzb24gPSBjdXJyZW50T2JqZWN0SnNvbjtcbiAgICAgICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0ID0gdmFsaWRhdGlvblJlc3VsdC52YWx1ZS5wYXJ0aWFsO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBsYXRlc3RPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhOiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLnRleHREZWx0YVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdERlbHRhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgICAgICAgZnVsbFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogKF9hMTcgPSBjaHVuay5pZCkgIT0gbnVsbCA/IF9hMTcgOiBmdWxsUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9iID0gY2h1bmsudGltZXN0YW1wKSAhPSBudWxsID8gX2IgOiBmdWxsUmVzcG9uc2UudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2MgPSBjaHVuay5tb2RlbElkKSAhPSBudWxsID8gX2MgOiBmdWxsUmVzcG9uc2UubW9kZWxJZFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlmICh0ZXh0RGVsdGEgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsIHRleHREZWx0YSB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IGNodW5rLmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICAgICAgICAgIHVzYWdlID0gY2h1bmsudXNhZ2U7XG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhID0gY2h1bmsucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNodW5rLFxuICAgICAgICAgICAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGZ1bGxSZXNwb25zZVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBsb2dXYXJuaW5ncyh3YXJuaW5ncyAhPSBudWxsID8gd2FybmluZ3MgOiBbXSk7XG4gICAgICAgICAgICAgICAgICBzZWxmLl91c2FnZS5yZXNvbHZlKHVzYWdlKTtcbiAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb3ZpZGVyTWV0YWRhdGEucmVzb2x2ZShwcm92aWRlck1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgIHNlbGYuX3dhcm5pbmdzLnJlc29sdmUod2FybmluZ3MpO1xuICAgICAgICAgICAgICAgICAgc2VsZi5fcmVzcG9uc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmZ1bGxSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgc2VsZi5fZmluaXNoUmVhc29uLnJlc29sdmUoZmluaXNoUmVhc29uICE9IG51bGwgPyBmaW5pc2hSZWFzb24gOiBcInVua25vd25cIik7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QyID0gYXdhaXQgcGFyc2VBbmRWYWxpZGF0ZU9iamVjdFJlc3VsdFdpdGhSZXBhaXIoXG4gICAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFN0cmF0ZWd5LFxuICAgICAgICAgICAgICAgICAgICAgIHJlcGFpclRleHQsXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGZ1bGxSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9vYmplY3QucmVzb2x2ZShvYmplY3QyKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9vYmplY3QucmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBpbnZva2Ugb25GaW5pc2ggY2FsbGJhY2sgYW5kIHJlc29sdmUgdG9vbFJlc3VsdHMgcHJvbWlzZSB3aGVuIHRoZSBzdHJlYW0gaXMgYWJvdXQgdG8gY2xvc2U6XG4gICAgICAgICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmluYWxVc2FnZSA9IHVzYWdlICE9IG51bGwgPyB1c2FnZSA6IHtcbiAgICAgICAgICAgICAgICAgIHByb21wdFRva2VuczogTmFOLFxuICAgICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogTmFOLFxuICAgICAgICAgICAgICAgICAgdG90YWxUb2tlbnM6IE5hTlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0MilcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogZnVsbFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogZnVsbFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogZnVsbFJlc3BvbnNlLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShwcm92aWRlck1ldGFkYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmlucHV0VG9rZW5zXCI6IGZpbmFsVXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5vdXRwdXRUb2tlbnNcIjogZmluYWxVc2FnZS5vdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b3RhbFRva2Vuc1wiOiBmaW5hbFVzYWdlLnRvdGFsVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucmVhc29uaW5nVG9rZW5zXCI6IGZpbmFsVXNhZ2UucmVhc29uaW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnNcIjogZmluYWxVc2FnZS5jYWNoZWRJbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW2ZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogZnVsbFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IGZ1bGxSZXNwb25zZS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiBmaW5hbFVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogZmluYWxVc2FnZS5vdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICByb290U3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuaW5wdXRUb2tlbnNcIjogZmluYWxVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLm91dHB1dFRva2Vuc1wiOiBmaW5hbFVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRvdGFsVG9rZW5zXCI6IGZpbmFsVXNhZ2UudG90YWxUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5yZWFzb25pbmdUb2tlbnNcIjogZmluYWxVc2FnZS5yZWFzb25pbmdUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jYWNoZWRJbnB1dFRva2Vuc1wiOiBmaW5hbFVzYWdlLmNhY2hlZElucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0MilcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShwcm92aWRlck1ldGFkYXRhKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYXdhaXQgKG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7XG4gICAgICAgICAgICAgICAgICB1c2FnZTogZmluYWxVc2FnZSxcbiAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0MixcbiAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZnVsbFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvcjogZXJyb3IyIH0pO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJvb3RTcGFuLmVuZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgc3RpdGNoYWJsZVN0cmVhbS5hZGRTdHJlYW0odHJhbnNmb3JtZWRTdHJlYW0pO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgc3RpdGNoYWJsZVN0cmVhbS5hZGRTdHJlYW0oXG4gICAgICAgIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgc3RpdGNoYWJsZVN0cmVhbS5jbG9zZSgpO1xuICAgIH0pO1xuICAgIHRoaXMub3V0cHV0U3RyYXRlZ3kgPSBvdXRwdXRTdHJhdGVneTtcbiAgfVxuICBnZXQgb2JqZWN0KCkge1xuICAgIHJldHVybiB0aGlzLl9vYmplY3QucHJvbWlzZTtcbiAgfVxuICBnZXQgdXNhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzYWdlLnByb21pc2U7XG4gIH1cbiAgZ2V0IHByb3ZpZGVyTWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3ZpZGVyTWV0YWRhdGEucHJvbWlzZTtcbiAgfVxuICBnZXQgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dhcm5pbmdzLnByb21pc2U7XG4gIH1cbiAgZ2V0IHJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QucHJvbWlzZTtcbiAgfVxuICBnZXQgcmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlLnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbmlzaFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZmluaXNoUmVhc29uLnByb21pc2U7XG4gIH1cbiAgZ2V0IHBhcnRpYWxPYmplY3RTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICB0aGlzLmJhc2VTdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsub2JqZWN0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVuaztcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGdldCBlbGVtZW50U3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dFN0cmF0ZWd5LmNyZWF0ZUVsZW1lbnRTdHJlYW0odGhpcy5iYXNlU3RyZWFtKTtcbiAgfVxuICBnZXQgdGV4dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMuYmFzZVN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgZ2V0IGZ1bGxTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy5iYXNlU3RyZWFtKTtcbiAgfVxuICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIGluaXQpIHtcbiAgICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICB0ZXh0U3RyZWFtOiB0aGlzLnRleHRTdHJlYW0sXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbiAgdG9UZXh0U3RyZWFtUmVzcG9uc2UoaW5pdCkge1xuICAgIHJldHVybiBjcmVhdGVUZXh0U3RyZWFtUmVzcG9uc2Uoe1xuICAgICAgdGV4dFN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLFxuICAgICAgLi4uaW5pdFxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3Ivbm8tc3BlZWNoLWdlbmVyYXRlZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMjAgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIE5vU3BlZWNoR2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IyMCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkFJX05vU3BlZWNoR2VuZXJhdGVkRXJyb3JcIixcbiAgICAgIG1lc3NhZ2U6IFwiTm8gc3BlZWNoIGF1ZGlvIGdlbmVyYXRlZC5cIlxuICAgIH0pO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gIH1cbn07XG5cbi8vIHNyYy9nZW5lcmF0ZS1zcGVlY2gvZ2VuZXJhdGVkLWF1ZGlvLWZpbGUudHNcbnZhciBEZWZhdWx0R2VuZXJhdGVkQXVkaW9GaWxlID0gY2xhc3MgZXh0ZW5kcyBEZWZhdWx0R2VuZXJhdGVkRmlsZSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXRhLFxuICAgIG1lZGlhVHlwZVxuICB9KSB7XG4gICAgc3VwZXIoeyBkYXRhLCBtZWRpYVR5cGUgfSk7XG4gICAgbGV0IGZvcm1hdCA9IFwibXAzXCI7XG4gICAgaWYgKG1lZGlhVHlwZSkge1xuICAgICAgY29uc3QgbWVkaWFUeXBlUGFydHMgPSBtZWRpYVR5cGUuc3BsaXQoXCIvXCIpO1xuICAgICAgaWYgKG1lZGlhVHlwZVBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBpZiAobWVkaWFUeXBlICE9PSBcImF1ZGlvL21wZWdcIikge1xuICAgICAgICAgIGZvcm1hdCA9IG1lZGlhVHlwZVBhcnRzWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm9ybWF0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQXVkaW8gZm9ybWF0IG11c3QgYmUgcHJvdmlkZWQgb3IgZGV0ZXJtaW5hYmxlIGZyb20gbWVkaWEgdHlwZVwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgfVxufTtcblxuLy8gc3JjL2dlbmVyYXRlLXNwZWVjaC9nZW5lcmF0ZS1zcGVlY2gudHNcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlU3BlZWNoKHtcbiAgbW9kZWwsXG4gIHRleHQ6IHRleHQyLFxuICB2b2ljZSxcbiAgb3V0cHV0Rm9ybWF0LFxuICBpbnN0cnVjdGlvbnMsXG4gIHNwZWVkLFxuICBsYW5ndWFnZSxcbiAgcHJvdmlkZXJPcHRpb25zID0ge30sXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzXG59KSB7XG4gIHZhciBfYTE3O1xuICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjJcIikge1xuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE1vZGVsVmVyc2lvbkVycm9yKHtcbiAgICAgIHZlcnNpb246IG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uLFxuICAgICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHsgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgdm9pY2UsXG4gICAgICBvdXRwdXRGb3JtYXQsXG4gICAgICBpbnN0cnVjdGlvbnMsXG4gICAgICBzcGVlZCxcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBoZWFkZXJzLFxuICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgfSlcbiAgKTtcbiAgaWYgKCFyZXN1bHQuYXVkaW8gfHwgcmVzdWx0LmF1ZGlvLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBOb1NwZWVjaEdlbmVyYXRlZEVycm9yKHsgcmVzcG9uc2VzOiBbcmVzdWx0LnJlc3BvbnNlXSB9KTtcbiAgfVxuICBsb2dXYXJuaW5ncyhyZXN1bHQud2FybmluZ3MpO1xuICByZXR1cm4gbmV3IERlZmF1bHRTcGVlY2hSZXN1bHQoe1xuICAgIGF1ZGlvOiBuZXcgRGVmYXVsdEdlbmVyYXRlZEF1ZGlvRmlsZSh7XG4gICAgICBkYXRhOiByZXN1bHQuYXVkaW8sXG4gICAgICBtZWRpYVR5cGU6IChfYTE3ID0gZGV0ZWN0TWVkaWFUeXBlKHtcbiAgICAgICAgZGF0YTogcmVzdWx0LmF1ZGlvLFxuICAgICAgICBzaWduYXR1cmVzOiBhdWRpb01lZGlhVHlwZVNpZ25hdHVyZXNcbiAgICAgIH0pKSAhPSBudWxsID8gX2ExNyA6IFwiYXVkaW8vbXAzXCJcbiAgICB9KSxcbiAgICB3YXJuaW5nczogcmVzdWx0Lndhcm5pbmdzLFxuICAgIHJlc3BvbnNlczogW3Jlc3VsdC5yZXNwb25zZV0sXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0LnByb3ZpZGVyTWV0YWRhdGFcbiAgfSk7XG59XG52YXIgRGVmYXVsdFNwZWVjaFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfYTE3O1xuICAgIHRoaXMuYXVkaW8gPSBvcHRpb25zLmF1ZGlvO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gKF9hMTcgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYTE3IDoge307XG4gIH1cbn07XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L291dHB1dC50c1xudmFyIG91dHB1dF9leHBvcnRzID0ge307XG5fX2V4cG9ydChvdXRwdXRfZXhwb3J0cywge1xuICBvYmplY3Q6ICgpID0+IG9iamVjdCxcbiAgdGV4dDogKCkgPT4gdGV4dFxufSk7XG5pbXBvcnQge1xuICBhc1NjaGVtYSBhcyBhc1NjaGVtYTQsXG4gIHNhZmVQYXJzZUpTT04gYXMgc2FmZVBhcnNlSlNPTjQsXG4gIHNhZmVWYWxpZGF0ZVR5cGVzIGFzIHNhZmVWYWxpZGF0ZVR5cGVzNFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIHRleHQgPSAoKSA9PiAoe1xuICB0eXBlOiBcInRleHRcIixcbiAgcmVzcG9uc2VGb3JtYXQ6IHsgdHlwZTogXCJ0ZXh0XCIgfSxcbiAgYXN5bmMgcGFyc2VQYXJ0aWFsKHsgdGV4dDogdGV4dDIgfSkge1xuICAgIHJldHVybiB7IHBhcnRpYWw6IHRleHQyIH07XG4gIH0sXG4gIGFzeW5jIHBhcnNlT3V0cHV0KHsgdGV4dDogdGV4dDIgfSkge1xuICAgIHJldHVybiB0ZXh0MjtcbiAgfVxufSk7XG52YXIgb2JqZWN0ID0gKHtcbiAgc2NoZW1hOiBpbnB1dFNjaGVtYVxufSkgPT4ge1xuICBjb25zdCBzY2hlbWEgPSBhc1NjaGVtYTQoaW5wdXRTY2hlbWEpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgcmVzcG9uc2VGb3JtYXQ6IHtcbiAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgc2NoZW1hOiBzY2hlbWEuanNvblNjaGVtYVxuICAgIH0sXG4gICAgYXN5bmMgcGFyc2VQYXJ0aWFsKHsgdGV4dDogdGV4dDIgfSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGFyc2VQYXJ0aWFsSnNvbih0ZXh0Mik7XG4gICAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgICBjYXNlIFwiZmFpbGVkLXBhcnNlXCI6XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWQtaW5wdXRcIjpcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICBjYXNlIFwicmVwYWlyZWQtcGFyc2VcIjpcbiAgICAgICAgY2FzZSBcInN1Y2Nlc3NmdWwtcGFyc2VcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gTm90ZTogY3VycmVudGx5IG5vIHZhbGlkYXRpb24gb2YgcGFydGlhbCByZXN1bHRzOlxuICAgICAgICAgICAgcGFydGlhbDogcmVzdWx0LnZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSByZXN1bHQuc3RhdGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJzZSBzdGF0ZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBwYXJzZU91dHB1dCh7IHRleHQ6IHRleHQyIH0sIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTjQoeyB0ZXh0OiB0ZXh0MiB9KTtcbiAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiBjb3VsZCBub3QgcGFyc2UgdGhlIHJlc3BvbnNlLlwiLFxuICAgICAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICByZXNwb25zZTogY29udGV4dC5yZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogY29udGV4dC51c2FnZSxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQuZmluaXNoUmVhc29uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHNhZmVWYWxpZGF0ZVR5cGVzNCh7XG4gICAgICAgIHZhbHVlOiBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICAgICAgc2NoZW1hXG4gICAgICB9KTtcbiAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgICAgIGNhdXNlOiB2YWxpZGF0aW9uUmVzdWx0LmVycm9yLFxuICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgIHJlc3BvbnNlOiBjb250ZXh0LnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBjb250ZXh0LnVzYWdlLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dC5maW5pc2hSZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsaWRhdGlvblJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9zbW9vdGgtc3RyZWFtLnRzXG5pbXBvcnQgeyBkZWxheSBhcyBvcmlnaW5hbERlbGF5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIGFzIEludmFsaWRBcmd1bWVudEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgQ0hVTktJTkdfUkVHRVhQUyA9IHtcbiAgd29yZDogL1xcUytcXHMrL20sXG4gIGxpbmU6IC9cXG4rL21cbn07XG5mdW5jdGlvbiBzbW9vdGhTdHJlYW0oe1xuICBkZWxheUluTXMgPSAxMCxcbiAgY2h1bmtpbmcgPSBcIndvcmRcIixcbiAgX2ludGVybmFsOiB7IGRlbGF5OiBkZWxheTIgPSBvcmlnaW5hbERlbGF5IH0gPSB7fVxufSA9IHt9KSB7XG4gIGxldCBkZXRlY3RDaHVuaztcbiAgaWYgKHR5cGVvZiBjaHVua2luZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZGV0ZWN0Q2h1bmsgPSAoYnVmZmVyKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaCA9IGNodW5raW5nKGJ1ZmZlcik7XG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghbWF0Y2gubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2h1bmtpbmcgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBub24tZW1wdHkgc3RyaW5nLmApO1xuICAgICAgfVxuICAgICAgaWYgKCFidWZmZXIuc3RhcnRzV2l0aChtYXRjaCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDaHVua2luZyBmdW5jdGlvbiBtdXN0IHJldHVybiBhIG1hdGNoIHRoYXQgaXMgYSBwcmVmaXggb2YgdGhlIGJ1ZmZlci4gUmVjZWl2ZWQ6IFwiJHttYXRjaH1cIiBleHBlY3RlZCB0byBzdGFydCB3aXRoIFwiJHtidWZmZXJ9XCJgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjaHVua2luZ1JlZ2V4ID0gdHlwZW9mIGNodW5raW5nID09PSBcInN0cmluZ1wiID8gQ0hVTktJTkdfUkVHRVhQU1tjaHVua2luZ10gOiBjaHVua2luZztcbiAgICBpZiAoY2h1bmtpbmdSZWdleCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IyKHtcbiAgICAgICAgYXJndW1lbnQ6IFwiY2h1bmtpbmdcIixcbiAgICAgICAgbWVzc2FnZTogYENodW5raW5nIG11c3QgYmUgXCJ3b3JkXCIgb3IgXCJsaW5lXCIgb3IgYSBSZWdFeHAuIFJlY2VpdmVkOiAke2NodW5raW5nfWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkZXRlY3RDaHVuayA9IChidWZmZXIpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoID0gY2h1bmtpbmdSZWdleC5leGVjKGJ1ZmZlcik7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAobWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IG1hdGNoWzBdKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gICAgbGV0IGlkID0gXCJcIjtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKGNodW5rLnR5cGUgIT09IFwidGV4dC1kZWx0YVwiKSB7XG4gICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtZGVsdGFcIiwgdGV4dDogYnVmZmVyLCBpZCB9KTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHVuay5pZCAhPT0gaWQgJiYgYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtZGVsdGFcIiwgdGV4dDogYnVmZmVyLCBpZCB9KTtcbiAgICAgICAgICBidWZmZXIgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlciArPSBjaHVuay50ZXh0O1xuICAgICAgICBpZCA9IGNodW5rLmlkO1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBkZXRlY3RDaHVuayhidWZmZXIpKSAhPSBudWxsKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsIHRleHQ6IG1hdGNoLCBpZCB9KTtcbiAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UobWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgICBhd2FpdCBkZWxheTIoZGVsYXlJbk1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG4vLyBzcmMvbWlkZGxld2FyZS9kZWZhdWx0LXNldHRpbmdzLW1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGRlZmF1bHRTZXR0aW5nc01pZGRsZXdhcmUoe1xuICBzZXR0aW5nc1xufSkge1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmVWZXJzaW9uOiBcInYyXCIsXG4gICAgdHJhbnNmb3JtUGFyYW1zOiBhc3luYyAoeyBwYXJhbXMgfSkgPT4ge1xuICAgICAgcmV0dXJuIG1lcmdlT2JqZWN0cyhzZXR0aW5ncywgcGFyYW1zKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy91dGlsL2dldC1wb3RlbnRpYWwtc3RhcnQtaW5kZXgudHNcbmZ1bmN0aW9uIGdldFBvdGVudGlhbFN0YXJ0SW5kZXgodGV4dDIsIHNlYXJjaGVkVGV4dCkge1xuICBpZiAoc2VhcmNoZWRUZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGRpcmVjdEluZGV4ID0gdGV4dDIuaW5kZXhPZihzZWFyY2hlZFRleHQpO1xuICBpZiAoZGlyZWN0SW5kZXggIT09IC0xKSB7XG4gICAgcmV0dXJuIGRpcmVjdEluZGV4O1xuICB9XG4gIGZvciAobGV0IGkgPSB0ZXh0Mi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHN1ZmZpeCA9IHRleHQyLnN1YnN0cmluZyhpKTtcbiAgICBpZiAoc2VhcmNoZWRUZXh0LnN0YXJ0c1dpdGgoc3VmZml4KSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBzcmMvbWlkZGxld2FyZS9leHRyYWN0LXJlYXNvbmluZy1taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBleHRyYWN0UmVhc29uaW5nTWlkZGxld2FyZSh7XG4gIHRhZ05hbWUsXG4gIHNlcGFyYXRvciA9IFwiXFxuXCIsXG4gIHN0YXJ0V2l0aFJlYXNvbmluZyA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IG9wZW5pbmdUYWcgPSBgPCR7dGFnTmFtZX0+YDtcbiAgY29uc3QgY2xvc2luZ1RhZyA9IGA8LyR7dGFnTmFtZX0+YDtcbiAgcmV0dXJuIHtcbiAgICBtaWRkbGV3YXJlVmVyc2lvbjogXCJ2MlwiLFxuICAgIHdyYXBHZW5lcmF0ZTogYXN5bmMgKHsgZG9HZW5lcmF0ZSB9KSA9PiB7XG4gICAgICBjb25zdCB7IGNvbnRlbnQsIC4uLnJlc3QgfSA9IGF3YWl0IGRvR2VuZXJhdGUoKTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkQ29udGVudCA9IFtdO1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKHBhcnQudHlwZSAhPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1lZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0MiA9IHN0YXJ0V2l0aFJlYXNvbmluZyA/IG9wZW5pbmdUYWcgKyBwYXJ0LnRleHQgOiBwYXJ0LnRleHQ7XG4gICAgICAgIGNvbnN0IHJlZ2V4cCA9IG5ldyBSZWdFeHAoYCR7b3BlbmluZ1RhZ30oLio/KSR7Y2xvc2luZ1RhZ31gLCBcImdzXCIpO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gQXJyYXkuZnJvbSh0ZXh0Mi5tYXRjaEFsbChyZWdleHApKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRyYW5zZm9ybWVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlYXNvbmluZ1RleHQgPSBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IG1hdGNoWzFdKS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIGxldCB0ZXh0V2l0aG91dFJlYXNvbmluZyA9IHRleHQyO1xuICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlc1tpXTtcbiAgICAgICAgICBjb25zdCBiZWZvcmVNYXRjaCA9IHRleHRXaXRob3V0UmVhc29uaW5nLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICBjb25zdCBhZnRlck1hdGNoID0gdGV4dFdpdGhvdXRSZWFzb25pbmcuc2xpY2UoXG4gICAgICAgICAgICBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGV4dFdpdGhvdXRSZWFzb25pbmcgPSBiZWZvcmVNYXRjaCArIChiZWZvcmVNYXRjaC5sZW5ndGggPiAwICYmIGFmdGVyTWF0Y2gubGVuZ3RoID4gMCA/IHNlcGFyYXRvciA6IFwiXCIpICsgYWZ0ZXJNYXRjaDtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2Zvcm1lZENvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICB0ZXh0OiByZWFzb25pbmdUZXh0XG4gICAgICAgIH0pO1xuICAgICAgICB0cmFuc2Zvcm1lZENvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgdGV4dDogdGV4dFdpdGhvdXRSZWFzb25pbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBjb250ZW50OiB0cmFuc2Zvcm1lZENvbnRlbnQsIC4uLnJlc3QgfTtcbiAgICB9LFxuICAgIHdyYXBTdHJlYW06IGFzeW5jICh7IGRvU3RyZWFtIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgc3RyZWFtLCAuLi5yZXN0IH0gPSBhd2FpdCBkb1N0cmVhbSgpO1xuICAgICAgY29uc3QgcmVhc29uaW5nRXh0cmFjdGlvbnMgPSB7fTtcbiAgICAgIGxldCBkZWxheWVkVGV4dFN0YXJ0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RyZWFtOiBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICBkZWxheWVkVGV4dFN0YXJ0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtZW5kXCIgJiYgZGVsYXllZFRleHRTdGFydCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShkZWxheWVkVGV4dFN0YXJ0KTtcbiAgICAgICAgICAgICAgICBkZWxheWVkVGV4dFN0YXJ0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjaHVuay50eXBlICE9PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZWFzb25pbmdFeHRyYWN0aW9uc1tjaHVuay5pZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlYXNvbmluZ0V4dHJhY3Rpb25zW2NodW5rLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgIGlzRmlyc3RSZWFzb25pbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICBpc0ZpcnN0VGV4dDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGFmdGVyU3dpdGNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGlzUmVhc29uaW5nOiBzdGFydFdpdGhSZWFzb25pbmcsXG4gICAgICAgICAgICAgICAgICBidWZmZXI6IFwiXCIsXG4gICAgICAgICAgICAgICAgICBpZENvdW50ZXI6IDAsXG4gICAgICAgICAgICAgICAgICB0ZXh0SWQ6IGNodW5rLmlkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBhY3RpdmVFeHRyYWN0aW9uID0gcmVhc29uaW5nRXh0cmFjdGlvbnNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlciArPSBjaHVuay5kZWx0YTtcbiAgICAgICAgICAgICAgZnVuY3Rpb24gcHVibGlzaCh0ZXh0Mikge1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0Mi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBhY3RpdmVFeHRyYWN0aW9uLmFmdGVyU3dpdGNoICYmIChhY3RpdmVFeHRyYWN0aW9uLmlzUmVhc29uaW5nID8gIWFjdGl2ZUV4dHJhY3Rpb24uaXNGaXJzdFJlYXNvbmluZyA6ICFhY3RpdmVFeHRyYWN0aW9uLmlzRmlyc3RUZXh0KSA/IHNlcGFyYXRvciA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZyAmJiAoYWN0aXZlRXh0cmFjdGlvbi5hZnRlclN3aXRjaCB8fCBhY3RpdmVFeHRyYWN0aW9uLmlzRmlyc3RSZWFzb25pbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctc3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogYHJlYXNvbmluZy0ke2FjdGl2ZUV4dHJhY3Rpb24uaWRDb3VudGVyfWBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZykge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZGVsdGE6IHByZWZpeCArIHRleHQyLFxuICAgICAgICAgICAgICAgICAgICAgIGlkOiBgcmVhc29uaW5nLSR7YWN0aXZlRXh0cmFjdGlvbi5pZENvdW50ZXJ9YFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxheWVkVGV4dFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGRlbGF5ZWRUZXh0U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGF5ZWRUZXh0U3RhcnQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICBkZWx0YTogcHJlZml4ICsgdGV4dDIsXG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IGFjdGl2ZUV4dHJhY3Rpb24udGV4dElkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5hZnRlclN3aXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5pc0ZpcnN0UmVhc29uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVFeHRyYWN0aW9uLmlzRmlyc3RUZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VGFnID0gYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZyA/IGNsb3NpbmdUYWcgOiBvcGVuaW5nVGFnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBnZXRQb3RlbnRpYWxTdGFydEluZGV4KFxuICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5idWZmZXIsXG4gICAgICAgICAgICAgICAgICBuZXh0VGFnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBwdWJsaXNoKGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwdWJsaXNoKGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyLnNsaWNlKDAsIHN0YXJ0SW5kZXgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZEZ1bGxNYXRjaCA9IHN0YXJ0SW5kZXggKyBuZXh0VGFnLmxlbmd0aCA8PSBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kRnVsbE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlciA9IGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ICsgbmV4dFRhZy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZykge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLWVuZFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGlkOiBgcmVhc29uaW5nLSR7YWN0aXZlRXh0cmFjdGlvbi5pZENvdW50ZXIrK31gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZyA9ICFhY3RpdmVFeHRyYWN0aW9uLmlzUmVhc29uaW5nO1xuICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5hZnRlclN3aXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyID0gYWN0aXZlRXh0cmFjdGlvbi5idWZmZXIuc2xpY2Uoc3RhcnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIC4uLnJlc3RcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWlkZGxld2FyZS9zaW11bGF0ZS1zdHJlYW1pbmctbWlkZGxld2FyZS50c1xuZnVuY3Rpb24gc2ltdWxhdGVTdHJlYW1pbmdNaWRkbGV3YXJlKCkge1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmVWZXJzaW9uOiBcInYyXCIsXG4gICAgd3JhcFN0cmVhbTogYXN5bmMgKHsgZG9HZW5lcmF0ZSB9KSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkb0dlbmVyYXRlKCk7XG4gICAgICBsZXQgaWQgPSAwO1xuICAgICAgY29uc3Qgc2ltdWxhdGVkU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcInN0cmVhbS1zdGFydFwiLFxuICAgICAgICAgICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5nc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwicmVzcG9uc2UtbWV0YWRhdGFcIiwgLi4ucmVzdWx0LnJlc3BvbnNlIH0pO1xuICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiByZXN1bHQuY29udGVudCkge1xuICAgICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0LnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0LXN0YXJ0XCIsIGlkOiBTdHJpbmcoaWQpIH0pO1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBTdHJpbmcoaWQpLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YTogcGFydC50ZXh0XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1lbmRcIiwgaWQ6IFN0cmluZyhpZCkgfSk7XG4gICAgICAgICAgICAgICAgICBpZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctc3RhcnRcIixcbiAgICAgICAgICAgICAgICAgIGlkOiBTdHJpbmcoaWQpLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICBpZDogU3RyaW5nKGlkKSxcbiAgICAgICAgICAgICAgICAgIGRlbHRhOiBwYXJ0LnRleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInJlYXNvbmluZy1lbmRcIiwgaWQ6IFN0cmluZyhpZCkgfSk7XG4gICAgICAgICAgICAgICAgaWQrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgZmluaXNoUmVhc29uOiByZXN1bHQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgdXNhZ2U6IHJlc3VsdC51c2FnZSxcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbTogc2ltdWxhdGVkU3RyZWFtLFxuICAgICAgICByZXF1ZXN0OiByZXN1bHQucmVxdWVzdCxcbiAgICAgICAgcmVzcG9uc2U6IHJlc3VsdC5yZXNwb25zZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9taWRkbGV3YXJlL3dyYXAtbGFuZ3VhZ2UtbW9kZWwudHNcbnZhciB3cmFwTGFuZ3VhZ2VNb2RlbCA9ICh7XG4gIG1vZGVsLFxuICBtaWRkbGV3YXJlOiBtaWRkbGV3YXJlQXJnLFxuICBtb2RlbElkLFxuICBwcm92aWRlcklkXG59KSA9PiB7XG4gIHJldHVybiBhc0FycmF5KG1pZGRsZXdhcmVBcmcpLnJldmVyc2UoKS5yZWR1Y2UoKHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSkgPT4ge1xuICAgIHJldHVybiBkb1dyYXAoeyBtb2RlbDogd3JhcHBlZE1vZGVsLCBtaWRkbGV3YXJlLCBtb2RlbElkLCBwcm92aWRlcklkIH0pO1xuICB9LCBtb2RlbCk7XG59O1xudmFyIGRvV3JhcCA9ICh7XG4gIG1vZGVsLFxuICBtaWRkbGV3YXJlOiB7XG4gICAgdHJhbnNmb3JtUGFyYW1zLFxuICAgIHdyYXBHZW5lcmF0ZSxcbiAgICB3cmFwU3RyZWFtLFxuICAgIG92ZXJyaWRlUHJvdmlkZXIsXG4gICAgb3ZlcnJpZGVNb2RlbElkLFxuICAgIG92ZXJyaWRlU3VwcG9ydGVkVXJsc1xuICB9LFxuICBtb2RlbElkLFxuICBwcm92aWRlcklkXG59KSA9PiB7XG4gIHZhciBfYTE3LCBfYiwgX2M7XG4gIGFzeW5jIGZ1bmN0aW9uIGRvVHJhbnNmb3JtKHtcbiAgICBwYXJhbXMsXG4gICAgdHlwZVxuICB9KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBhcmFtcyA/IGF3YWl0IHRyYW5zZm9ybVBhcmFtcyh7IHBhcmFtcywgdHlwZSwgbW9kZWwgfSkgOiBwYXJhbXM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2MlwiLFxuICAgIHByb3ZpZGVyOiAoX2ExNyA9IHByb3ZpZGVySWQgIT0gbnVsbCA/IHByb3ZpZGVySWQgOiBvdmVycmlkZVByb3ZpZGVyID09IG51bGwgPyB2b2lkIDAgOiBvdmVycmlkZVByb3ZpZGVyKHsgbW9kZWwgfSkpICE9IG51bGwgPyBfYTE3IDogbW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWxJZDogKF9iID0gbW9kZWxJZCAhPSBudWxsID8gbW9kZWxJZCA6IG92ZXJyaWRlTW9kZWxJZCA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVNb2RlbElkKHsgbW9kZWwgfSkpICE9IG51bGwgPyBfYiA6IG1vZGVsLm1vZGVsSWQsXG4gICAgc3VwcG9ydGVkVXJsczogKF9jID0gb3ZlcnJpZGVTdXBwb3J0ZWRVcmxzID09IG51bGwgPyB2b2lkIDAgOiBvdmVycmlkZVN1cHBvcnRlZFVybHMoeyBtb2RlbCB9KSkgIT0gbnVsbCA/IF9jIDogbW9kZWwuc3VwcG9ydGVkVXJscyxcbiAgICBhc3luYyBkb0dlbmVyYXRlKHBhcmFtcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCBkb1RyYW5zZm9ybSh7IHBhcmFtcywgdHlwZTogXCJnZW5lcmF0ZVwiIH0pO1xuICAgICAgY29uc3QgZG9HZW5lcmF0ZSA9IGFzeW5jICgpID0+IG1vZGVsLmRvR2VuZXJhdGUodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgY29uc3QgZG9TdHJlYW0gPSBhc3luYyAoKSA9PiBtb2RlbC5kb1N0cmVhbSh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICByZXR1cm4gd3JhcEdlbmVyYXRlID8gd3JhcEdlbmVyYXRlKHtcbiAgICAgICAgZG9HZW5lcmF0ZSxcbiAgICAgICAgZG9TdHJlYW0sXG4gICAgICAgIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsXG4gICAgICAgIG1vZGVsXG4gICAgICB9KSA6IGRvR2VuZXJhdGUoKTtcbiAgICB9LFxuICAgIGFzeW5jIGRvU3RyZWFtKHBhcmFtcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCBkb1RyYW5zZm9ybSh7IHBhcmFtcywgdHlwZTogXCJzdHJlYW1cIiB9KTtcbiAgICAgIGNvbnN0IGRvR2VuZXJhdGUgPSBhc3luYyAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgIGNvbnN0IGRvU3RyZWFtID0gYXN5bmMgKCkgPT4gbW9kZWwuZG9TdHJlYW0odHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBTdHJlYW0gPyB3cmFwU3RyZWFtKHsgZG9HZW5lcmF0ZSwgZG9TdHJlYW0sIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsIG1vZGVsIH0pIDogZG9TdHJlYW0oKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvbWlkZGxld2FyZS93cmFwLXByb3ZpZGVyLnRzXG5mdW5jdGlvbiB3cmFwUHJvdmlkZXIoe1xuICBwcm92aWRlcixcbiAgbGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmVcbn0pIHtcbiAgY29uc3Qgd3JhcHBlZFByb3ZpZGVyID0ge1xuICAgIGxhbmd1YWdlTW9kZWwobW9kZWxJZCkge1xuICAgICAgbGV0IG1vZGVsID0gcHJvdmlkZXIubGFuZ3VhZ2VNb2RlbChtb2RlbElkKTtcbiAgICAgIG1vZGVsID0gd3JhcExhbmd1YWdlTW9kZWwoe1xuICAgICAgICBtb2RlbCxcbiAgICAgICAgbWlkZGxld2FyZTogbGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG4gICAgdGV4dEVtYmVkZGluZ01vZGVsOiBwcm92aWRlci50ZXh0RW1iZWRkaW5nTW9kZWwsXG4gICAgaW1hZ2VNb2RlbDogcHJvdmlkZXIuaW1hZ2VNb2RlbCxcbiAgICB0cmFuc2NyaXB0aW9uTW9kZWw6IHByb3ZpZGVyLnRyYW5zY3JpcHRpb25Nb2RlbCxcbiAgICBzcGVlY2hNb2RlbDogcHJvdmlkZXIuc3BlZWNoTW9kZWxcbiAgfTtcbiAgcmV0dXJuIHdyYXBwZWRQcm92aWRlcjtcbn1cblxuLy8gc3JjL3JlZ2lzdHJ5L2N1c3RvbS1wcm92aWRlci50c1xuaW1wb3J0IHtcbiAgTm9TdWNoTW9kZWxFcnJvciBhcyBOb1N1Y2hNb2RlbEVycm9yMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gY3VzdG9tUHJvdmlkZXIoe1xuICBsYW5ndWFnZU1vZGVscyxcbiAgdGV4dEVtYmVkZGluZ01vZGVscyxcbiAgaW1hZ2VNb2RlbHMsXG4gIHRyYW5zY3JpcHRpb25Nb2RlbHMsXG4gIHNwZWVjaE1vZGVscyxcbiAgZmFsbGJhY2tQcm92aWRlclxufSkge1xuICByZXR1cm4ge1xuICAgIGxhbmd1YWdlTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKGxhbmd1YWdlTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiBsYW5ndWFnZU1vZGVscykge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci5sYW5ndWFnZU1vZGVsKG1vZGVsSWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3IyKHsgbW9kZWxJZCwgbW9kZWxUeXBlOiBcImxhbmd1YWdlTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIHRleHRFbWJlZGRpbmdNb2RlbChtb2RlbElkKSB7XG4gICAgICBpZiAodGV4dEVtYmVkZGluZ01vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gdGV4dEVtYmVkZGluZ01vZGVscykge1xuICAgICAgICByZXR1cm4gdGV4dEVtYmVkZGluZ01vZGVsc1ttb2RlbElkXTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWxsYmFja1Byb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLnRleHRFbWJlZGRpbmdNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJ0ZXh0RW1iZWRkaW5nTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIGltYWdlTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKGltYWdlTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiBpbWFnZU1vZGVscykge1xuICAgICAgICByZXR1cm4gaW1hZ2VNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogZmFsbGJhY2tQcm92aWRlci5pbWFnZU1vZGVsKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLmltYWdlTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwiaW1hZ2VNb2RlbFwiIH0pO1xuICAgIH0sXG4gICAgdHJhbnNjcmlwdGlvbk1vZGVsKG1vZGVsSWQpIHtcbiAgICAgIGlmICh0cmFuc2NyaXB0aW9uTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiB0cmFuc2NyaXB0aW9uTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2NyaXB0aW9uTW9kZWxzW21vZGVsSWRdO1xuICAgICAgfVxuICAgICAgaWYgKGZhbGxiYWNrUHJvdmlkZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGZhbGxiYWNrUHJvdmlkZXIudHJhbnNjcmlwdGlvbk1vZGVsKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLnRyYW5zY3JpcHRpb25Nb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJ0cmFuc2NyaXB0aW9uTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIHNwZWVjaE1vZGVsKG1vZGVsSWQpIHtcbiAgICAgIGlmIChzcGVlY2hNb2RlbHMgIT0gbnVsbCAmJiBtb2RlbElkIGluIHNwZWVjaE1vZGVscykge1xuICAgICAgICByZXR1cm4gc3BlZWNoTW9kZWxzW21vZGVsSWRdO1xuICAgICAgfVxuICAgICAgaWYgKGZhbGxiYWNrUHJvdmlkZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGZhbGxiYWNrUHJvdmlkZXIuc3BlZWNoTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUHJvdmlkZXIuc3BlZWNoTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwic3BlZWNoTW9kZWxcIiB9KTtcbiAgICB9XG4gIH07XG59XG52YXIgZXhwZXJpbWVudGFsX2N1c3RvbVByb3ZpZGVyID0gY3VzdG9tUHJvdmlkZXI7XG5cbi8vIHNyYy9yZWdpc3RyeS9uby1zdWNoLXByb3ZpZGVyLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IyMSwgTm9TdWNoTW9kZWxFcnJvciBhcyBOb1N1Y2hNb2RlbEVycm9yMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTE2ID0gXCJBSV9Ob1N1Y2hQcm92aWRlckVycm9yXCI7XG52YXIgbWFya2VyMTYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTE2fWA7XG52YXIgc3ltYm9sMTYgPSBTeW1ib2wuZm9yKG1hcmtlcjE2KTtcbnZhciBfYTE2O1xudmFyIE5vU3VjaFByb3ZpZGVyRXJyb3IgPSBjbGFzcyBleHRlbmRzIE5vU3VjaE1vZGVsRXJyb3IzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1vZGVsSWQsXG4gICAgbW9kZWxUeXBlLFxuICAgIHByb3ZpZGVySWQsXG4gICAgYXZhaWxhYmxlUHJvdmlkZXJzLFxuICAgIG1lc3NhZ2UgPSBgTm8gc3VjaCBwcm92aWRlcjogJHtwcm92aWRlcklkfSAoYXZhaWxhYmxlIHByb3ZpZGVyczogJHthdmFpbGFibGVQcm92aWRlcnMuam9pbigpfSlgXG4gIH0pIHtcbiAgICBzdXBlcih7IGVycm9yTmFtZTogbmFtZTE2LCBtb2RlbElkLCBtb2RlbFR5cGUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE2XSA9IHRydWU7XG4gICAgdGhpcy5wcm92aWRlcklkID0gcHJvdmlkZXJJZDtcbiAgICB0aGlzLmF2YWlsYWJsZVByb3ZpZGVycyA9IGF2YWlsYWJsZVByb3ZpZGVycztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMjEuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNik7XG4gIH1cbn07XG5fYTE2ID0gc3ltYm9sMTY7XG5cbi8vIHNyYy9yZWdpc3RyeS9wcm92aWRlci1yZWdpc3RyeS50c1xuaW1wb3J0IHtcbiAgTm9TdWNoTW9kZWxFcnJvciBhcyBOb1N1Y2hNb2RlbEVycm9yNFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gY3JlYXRlUHJvdmlkZXJSZWdpc3RyeShwcm92aWRlcnMsIHtcbiAgc2VwYXJhdG9yID0gXCI6XCIsXG4gIGxhbmd1YWdlTW9kZWxNaWRkbGV3YXJlXG59ID0ge30pIHtcbiAgY29uc3QgcmVnaXN0cnkgPSBuZXcgRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkoe1xuICAgIHNlcGFyYXRvcixcbiAgICBsYW5ndWFnZU1vZGVsTWlkZGxld2FyZVxuICB9KTtcbiAgZm9yIChjb25zdCBbaWQsIHByb3ZpZGVyXSBvZiBPYmplY3QuZW50cmllcyhwcm92aWRlcnMpKSB7XG4gICAgcmVnaXN0cnkucmVnaXN0ZXJQcm92aWRlcih7IGlkLCBwcm92aWRlciB9KTtcbiAgfVxuICByZXR1cm4gcmVnaXN0cnk7XG59XG52YXIgZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnkgPSBjcmVhdGVQcm92aWRlclJlZ2lzdHJ5O1xudmFyIERlZmF1bHRQcm92aWRlclJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc2VwYXJhdG9yLFxuICAgIGxhbmd1YWdlTW9kZWxNaWRkbGV3YXJlXG4gIH0pIHtcbiAgICB0aGlzLnByb3ZpZGVycyA9IHt9O1xuICAgIHRoaXMuc2VwYXJhdG9yID0gc2VwYXJhdG9yO1xuICAgIHRoaXMubGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmUgPSBsYW5ndWFnZU1vZGVsTWlkZGxld2FyZTtcbiAgfVxuICByZWdpc3RlclByb3ZpZGVyKHtcbiAgICBpZCxcbiAgICBwcm92aWRlclxuICB9KSB7XG4gICAgdGhpcy5wcm92aWRlcnNbaWRdID0gcHJvdmlkZXI7XG4gIH1cbiAgZ2V0UHJvdmlkZXIoaWQsIG1vZGVsVHlwZSkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5wcm92aWRlcnNbaWRdO1xuICAgIGlmIChwcm92aWRlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoUHJvdmlkZXJFcnJvcih7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGUsXG4gICAgICAgIHByb3ZpZGVySWQ6IGlkLFxuICAgICAgICBhdmFpbGFibGVQcm92aWRlcnM6IE9iamVjdC5rZXlzKHRoaXMucHJvdmlkZXJzKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm92aWRlcjtcbiAgfVxuICBzcGxpdElkKGlkLCBtb2RlbFR5cGUpIHtcbiAgICBjb25zdCBpbmRleCA9IGlkLmluZGV4T2YodGhpcy5zZXBhcmF0b3IpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGUsXG4gICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkICR7bW9kZWxUeXBlfSBpZCBmb3IgcmVnaXN0cnk6ICR7aWR9IChtdXN0IGJlIGluIHRoZSBmb3JtYXQgXCJwcm92aWRlcklkJHt0aGlzLnNlcGFyYXRvcn1tb2RlbElkXCIpYFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbaWQuc2xpY2UoMCwgaW5kZXgpLCBpZC5zbGljZShpbmRleCArIHRoaXMuc2VwYXJhdG9yLmxlbmd0aCldO1xuICB9XG4gIGxhbmd1YWdlTW9kZWwoaWQpIHtcbiAgICB2YXIgX2ExNywgX2I7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcImxhbmd1YWdlTW9kZWxcIik7XG4gICAgbGV0IG1vZGVsID0gKF9iID0gKF9hMTcgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQsIFwibGFuZ3VhZ2VNb2RlbFwiKSkubGFuZ3VhZ2VNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoXG4gICAgICBfYTE3LFxuICAgICAgbW9kZWxJZFxuICAgICk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7IG1vZGVsSWQ6IGlkLCBtb2RlbFR5cGU6IFwibGFuZ3VhZ2VNb2RlbFwiIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5sYW5ndWFnZU1vZGVsTWlkZGxld2FyZSAhPSBudWxsKSB7XG4gICAgICBtb2RlbCA9IHdyYXBMYW5ndWFnZU1vZGVsKHtcbiAgICAgICAgbW9kZWwsXG4gICAgICAgIG1pZGRsZXdhcmU6IHRoaXMubGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgdGV4dEVtYmVkZGluZ01vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcInRleHRFbWJlZGRpbmdNb2RlbFwiKTtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJvdmlkZXJJZCwgXCJ0ZXh0RW1iZWRkaW5nTW9kZWxcIik7XG4gICAgY29uc3QgbW9kZWwgPSAoX2ExNyA9IHByb3ZpZGVyLnRleHRFbWJlZGRpbmdNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGU6IFwidGV4dEVtYmVkZGluZ01vZGVsXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgaW1hZ2VNb2RlbChpZCkge1xuICAgIHZhciBfYTE3O1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCwgXCJpbWFnZU1vZGVsXCIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkLCBcImltYWdlTW9kZWxcIik7XG4gICAgY29uc3QgbW9kZWwgPSAoX2ExNyA9IHByb3ZpZGVyLmltYWdlTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNhbGwocHJvdmlkZXIsIG1vZGVsSWQpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoeyBtb2RlbElkOiBpZCwgbW9kZWxUeXBlOiBcImltYWdlTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHRyYW5zY3JpcHRpb25Nb2RlbChpZCkge1xuICAgIHZhciBfYTE3O1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCwgXCJ0cmFuc2NyaXB0aW9uTW9kZWxcIik7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQsIFwidHJhbnNjcmlwdGlvbk1vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMTcgPSBwcm92aWRlci50cmFuc2NyaXB0aW9uTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNhbGwocHJvdmlkZXIsIG1vZGVsSWQpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlOiBcInRyYW5zY3JpcHRpb25Nb2RlbFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHNwZWVjaE1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcInNwZWVjaE1vZGVsXCIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkLCBcInNwZWVjaE1vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMTcgPSBwcm92aWRlci5zcGVlY2hNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7IG1vZGVsSWQ6IGlkLCBtb2RlbFR5cGU6IFwic3BlZWNoTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG59O1xuXG4vLyBzcmMvdG9vbC9tY3AvbWNwLWNsaWVudC50c1xuaW1wb3J0IHtcbiAgZHluYW1pY1Rvb2wsXG4gIGpzb25TY2hlbWEsXG4gIHRvb2xcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3Rvb2wvbWNwL21jcC1zc2UtdHJhbnNwb3J0LnRzXG5pbXBvcnQgeyBFdmVudFNvdXJjZVBhcnNlclN0cmVhbSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy90b29sL21jcC9qc29uLXJwYy1tZXNzYWdlLnRzXG5pbXBvcnQgeyB6IGFzIHo5IH0gZnJvbSBcInpvZC92NFwiO1xuXG4vLyBzcmMvdG9vbC9tY3AvdHlwZXMudHNcbmltcG9ydCB7IHogYXMgejggfSBmcm9tIFwiem9kL3Y0XCI7XG52YXIgTEFURVNUX1BST1RPQ09MX1ZFUlNJT04gPSBcIjIwMjUtMDYtMThcIjtcbnZhciBTVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTlMgPSBbXG4gIExBVEVTVF9QUk9UT0NPTF9WRVJTSU9OLFxuICBcIjIwMjUtMDMtMjZcIixcbiAgXCIyMDI0LTExLTA1XCJcbl07XG52YXIgQ2xpZW50T3JTZXJ2ZXJJbXBsZW1lbnRhdGlvblNjaGVtYSA9IHo4Lmxvb3NlT2JqZWN0KHtcbiAgbmFtZTogejguc3RyaW5nKCksXG4gIHZlcnNpb246IHo4LnN0cmluZygpXG59KTtcbnZhciBCYXNlUGFyYW1zU2NoZW1hID0gejgubG9vc2VPYmplY3Qoe1xuICBfbWV0YTogejgub3B0aW9uYWwoejgub2JqZWN0KHt9KS5sb29zZSgpKVxufSk7XG52YXIgUmVzdWx0U2NoZW1hID0gQmFzZVBhcmFtc1NjaGVtYTtcbnZhciBSZXF1ZXN0U2NoZW1hID0gejgub2JqZWN0KHtcbiAgbWV0aG9kOiB6OC5zdHJpbmcoKSxcbiAgcGFyYW1zOiB6OC5vcHRpb25hbChCYXNlUGFyYW1zU2NoZW1hKVxufSk7XG52YXIgU2VydmVyQ2FwYWJpbGl0aWVzU2NoZW1hID0gejgubG9vc2VPYmplY3Qoe1xuICBleHBlcmltZW50YWw6IHo4Lm9wdGlvbmFsKHo4Lm9iamVjdCh7fSkubG9vc2UoKSksXG4gIGxvZ2dpbmc6IHo4Lm9wdGlvbmFsKHo4Lm9iamVjdCh7fSkubG9vc2UoKSksXG4gIHByb21wdHM6IHo4Lm9wdGlvbmFsKFxuICAgIHo4Lmxvb3NlT2JqZWN0KHtcbiAgICAgIGxpc3RDaGFuZ2VkOiB6OC5vcHRpb25hbCh6OC5ib29sZWFuKCkpXG4gICAgfSlcbiAgKSxcbiAgcmVzb3VyY2VzOiB6OC5vcHRpb25hbChcbiAgICB6OC5sb29zZU9iamVjdCh7XG4gICAgICBzdWJzY3JpYmU6IHo4Lm9wdGlvbmFsKHo4LmJvb2xlYW4oKSksXG4gICAgICBsaXN0Q2hhbmdlZDogejgub3B0aW9uYWwoejguYm9vbGVhbigpKVxuICAgIH0pXG4gICksXG4gIHRvb2xzOiB6OC5vcHRpb25hbChcbiAgICB6OC5sb29zZU9iamVjdCh7XG4gICAgICBsaXN0Q2hhbmdlZDogejgub3B0aW9uYWwoejguYm9vbGVhbigpKVxuICAgIH0pXG4gIClcbn0pO1xudmFyIEluaXRpYWxpemVSZXN1bHRTY2hlbWEgPSBSZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgcHJvdG9jb2xWZXJzaW9uOiB6OC5zdHJpbmcoKSxcbiAgY2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXNTY2hlbWEsXG4gIHNlcnZlckluZm86IENsaWVudE9yU2VydmVySW1wbGVtZW50YXRpb25TY2hlbWEsXG4gIGluc3RydWN0aW9uczogejgub3B0aW9uYWwoejguc3RyaW5nKCkpXG59KTtcbnZhciBQYWdpbmF0ZWRSZXN1bHRTY2hlbWEgPSBSZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgbmV4dEN1cnNvcjogejgub3B0aW9uYWwoejguc3RyaW5nKCkpXG59KTtcbnZhciBUb29sU2NoZW1hID0gejgub2JqZWN0KHtcbiAgbmFtZTogejguc3RyaW5nKCksXG4gIGRlc2NyaXB0aW9uOiB6OC5vcHRpb25hbCh6OC5zdHJpbmcoKSksXG4gIGlucHV0U2NoZW1hOiB6OC5vYmplY3Qoe1xuICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJvYmplY3RcIiksXG4gICAgcHJvcGVydGllczogejgub3B0aW9uYWwoejgub2JqZWN0KHt9KS5sb29zZSgpKVxuICB9KS5sb29zZSgpXG59KS5sb29zZSgpO1xudmFyIExpc3RUb29sc1Jlc3VsdFNjaGVtYSA9IFBhZ2luYXRlZFJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICB0b29sczogejguYXJyYXkoVG9vbFNjaGVtYSlcbn0pO1xudmFyIFRleHRDb250ZW50U2NoZW1hID0gejgub2JqZWN0KHtcbiAgdHlwZTogejgubGl0ZXJhbChcInRleHRcIiksXG4gIHRleHQ6IHo4LnN0cmluZygpXG59KS5sb29zZSgpO1xudmFyIEltYWdlQ29udGVudFNjaGVtYSA9IHo4Lm9iamVjdCh7XG4gIHR5cGU6IHo4LmxpdGVyYWwoXCJpbWFnZVwiKSxcbiAgZGF0YTogejguYmFzZTY0KCksXG4gIG1pbWVUeXBlOiB6OC5zdHJpbmcoKVxufSkubG9vc2UoKTtcbnZhciBSZXNvdXJjZUNvbnRlbnRzU2NoZW1hID0gejgub2JqZWN0KHtcbiAgLyoqXG4gICAqIFRoZSBVUkkgb2YgdGhpcyByZXNvdXJjZS5cbiAgICovXG4gIHVyaTogejguc3RyaW5nKCksXG4gIC8qKlxuICAgKiBUaGUgTUlNRSB0eXBlIG9mIHRoaXMgcmVzb3VyY2UsIGlmIGtub3duLlxuICAgKi9cbiAgbWltZVR5cGU6IHo4Lm9wdGlvbmFsKHo4LnN0cmluZygpKVxufSkubG9vc2UoKTtcbnZhciBUZXh0UmVzb3VyY2VDb250ZW50c1NjaGVtYSA9IFJlc291cmNlQ29udGVudHNTY2hlbWEuZXh0ZW5kKHtcbiAgdGV4dDogejguc3RyaW5nKClcbn0pO1xudmFyIEJsb2JSZXNvdXJjZUNvbnRlbnRzU2NoZW1hID0gUmVzb3VyY2VDb250ZW50c1NjaGVtYS5leHRlbmQoe1xuICBibG9iOiB6OC5iYXNlNjQoKVxufSk7XG52YXIgRW1iZWRkZWRSZXNvdXJjZVNjaGVtYSA9IHo4Lm9iamVjdCh7XG4gIHR5cGU6IHo4LmxpdGVyYWwoXCJyZXNvdXJjZVwiKSxcbiAgcmVzb3VyY2U6IHo4LnVuaW9uKFtUZXh0UmVzb3VyY2VDb250ZW50c1NjaGVtYSwgQmxvYlJlc291cmNlQ29udGVudHNTY2hlbWFdKVxufSkubG9vc2UoKTtcbnZhciBDYWxsVG9vbFJlc3VsdFNjaGVtYSA9IFJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICBjb250ZW50OiB6OC5hcnJheShcbiAgICB6OC51bmlvbihbVGV4dENvbnRlbnRTY2hlbWEsIEltYWdlQ29udGVudFNjaGVtYSwgRW1iZWRkZWRSZXNvdXJjZVNjaGVtYV0pXG4gICksXG4gIGlzRXJyb3I6IHo4LmJvb2xlYW4oKS5kZWZhdWx0KGZhbHNlKS5vcHRpb25hbCgpXG59KS5vcihcbiAgUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gICAgdG9vbFJlc3VsdDogejgudW5rbm93bigpXG4gIH0pXG4pO1xuXG4vLyBzcmMvdG9vbC9tY3AvanNvbi1ycGMtbWVzc2FnZS50c1xudmFyIEpTT05SUENfVkVSU0lPTiA9IFwiMi4wXCI7XG52YXIgSlNPTlJQQ1JlcXVlc3RTY2hlbWEgPSB6OS5vYmplY3Qoe1xuICBqc29ucnBjOiB6OS5saXRlcmFsKEpTT05SUENfVkVSU0lPTiksXG4gIGlkOiB6OS51bmlvbihbejkuc3RyaW5nKCksIHo5Lm51bWJlcigpLmludCgpXSlcbn0pLm1lcmdlKFJlcXVlc3RTY2hlbWEpLnN0cmljdCgpO1xudmFyIEpTT05SUENSZXNwb25zZVNjaGVtYSA9IHo5Lm9iamVjdCh7XG4gIGpzb25ycGM6IHo5LmxpdGVyYWwoSlNPTlJQQ19WRVJTSU9OKSxcbiAgaWQ6IHo5LnVuaW9uKFt6OS5zdHJpbmcoKSwgejkubnVtYmVyKCkuaW50KCldKSxcbiAgcmVzdWx0OiBSZXN1bHRTY2hlbWFcbn0pLnN0cmljdCgpO1xudmFyIEpTT05SUENFcnJvclNjaGVtYSA9IHo5Lm9iamVjdCh7XG4gIGpzb25ycGM6IHo5LmxpdGVyYWwoSlNPTlJQQ19WRVJTSU9OKSxcbiAgaWQ6IHo5LnVuaW9uKFt6OS5zdHJpbmcoKSwgejkubnVtYmVyKCkuaW50KCldKSxcbiAgZXJyb3I6IHo5Lm9iamVjdCh7XG4gICAgY29kZTogejkubnVtYmVyKCkuaW50KCksXG4gICAgbWVzc2FnZTogejkuc3RyaW5nKCksXG4gICAgZGF0YTogejkub3B0aW9uYWwoejkudW5rbm93bigpKVxuICB9KVxufSkuc3RyaWN0KCk7XG52YXIgSlNPTlJQQ05vdGlmaWNhdGlvblNjaGVtYSA9IHo5Lm9iamVjdCh7XG4gIGpzb25ycGM6IHo5LmxpdGVyYWwoSlNPTlJQQ19WRVJTSU9OKVxufSkubWVyZ2UoXG4gIHo5Lm9iamVjdCh7XG4gICAgbWV0aG9kOiB6OS5zdHJpbmcoKSxcbiAgICBwYXJhbXM6IHo5Lm9wdGlvbmFsKEJhc2VQYXJhbXNTY2hlbWEpXG4gIH0pXG4pLnN0cmljdCgpO1xudmFyIEpTT05SUENNZXNzYWdlU2NoZW1hID0gejkudW5pb24oW1xuICBKU09OUlBDUmVxdWVzdFNjaGVtYSxcbiAgSlNPTlJQQ05vdGlmaWNhdGlvblNjaGVtYSxcbiAgSlNPTlJQQ1Jlc3BvbnNlU2NoZW1hLFxuICBKU09OUlBDRXJyb3JTY2hlbWFcbl0pO1xuXG4vLyBzcmMvdG9vbC9tY3AvbWNwLXNzZS10cmFuc3BvcnQudHNcbnZhciBTc2VNQ1BUcmFuc3BvcnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgaGVhZGVyc1xuICB9KSB7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVybCA9IG5ldyBVUkwodXJsKTtcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICB9XG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZTIsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlMigpO1xuICAgICAgfVxuICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCBlc3RhYmxpc2hDb25uZWN0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB2YXIgX2ExNywgX2IsIF9jO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpO1xuICAgICAgICAgIGhlYWRlcnMuc2V0KFwiQWNjZXB0XCIsIFwidGV4dC9ldmVudC1zdHJlYW1cIik7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLnVybC5ocmVmLCB7XG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiAoX2ExNyA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5zaWduYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rIHx8ICFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGBNQ1AgU1NFIFRyYW5zcG9ydCBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIChfYiA9IHRoaXMub25lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHJlc3BvbnNlLmJvZHkucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpLnBpcGVUaHJvdWdoKG5ldyBFdmVudFNvdXJjZVBhcnNlclN0cmVhbSgpKTtcbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgY29uc3QgcHJvY2Vzc0V2ZW50cyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTE4LCBfYjIsIF9jMjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJNQ1AgU1NFIFRyYW5zcG9ydCBFcnJvcjogQ29ubmVjdGlvbiBjbG9zZWQgdW5leHBlY3RlZGx5XCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXZlbnQsIGRhdGEgfSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChldmVudCA9PT0gXCJlbmRwb2ludFwiKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50ID0gbmV3IFVSTChkYXRhLCB0aGlzLnVybCk7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRwb2ludC5vcmlnaW4gIT09IHRoaXMudXJsLm9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBNQ1AgU1NFIFRyYW5zcG9ydCBFcnJvcjogRW5kcG9pbnQgb3JpZ2luIGRvZXMgbm90IG1hdGNoIGNvbm5lY3Rpb24gb3JpZ2luOiAke3RoaXMuZW5kcG9pbnQub3JpZ2lufWBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlMigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09IFwibWVzc2FnZVwiKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTlJQQ01lc3NhZ2VTY2hlbWEucGFyc2UoXG4gICAgICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShkYXRhKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAoX2ExOCA9IHRoaXMub25tZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOC5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJNQ1AgU1NFIFRyYW5zcG9ydCBFcnJvcjogRmFpbGVkIHRvIHBhcnNlIG1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIChfYjIgPSB0aGlzLm9uZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYjIuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIChfYzIgPSB0aGlzLm9uZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYzIuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLnNzZUNvbm5lY3Rpb24gPSB7XG4gICAgICAgICAgICBjbG9zZTogKCkgPT4gcmVhZGVyLmNhbmNlbCgpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBwcm9jZXNzRXZlbnRzKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgKF9jID0gdGhpcy5vbmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVzdGFibGlzaENvbm5lY3Rpb24oKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICB2YXIgX2ExNywgX2IsIF9jO1xuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgKF9hMTcgPSB0aGlzLnNzZUNvbm5lY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNsb3NlKCk7XG4gICAgKF9iID0gdGhpcy5hYm9ydENvbnRyb2xsZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5hYm9ydCgpO1xuICAgIChfYyA9IHRoaXMub25jbG9zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwodGhpcyk7XG4gIH1cbiAgYXN5bmMgc2VuZChtZXNzYWdlKSB7XG4gICAgdmFyIF9hMTcsIF9iLCBfYztcbiAgICBpZiAoIXRoaXMuZW5kcG9pbnQgfHwgIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIk1DUCBTU0UgVHJhbnNwb3J0IEVycm9yOiBOb3QgY29ubmVjdGVkXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyk7XG4gICAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICBjb25zdCBpbml0ID0ge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSxcbiAgICAgICAgc2lnbmFsOiAoX2ExNyA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5zaWduYWxcbiAgICAgIH07XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuZW5kcG9pbnQsIGluaXQpO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCB0ZXh0MiA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGBNQ1AgU1NFIFRyYW5zcG9ydCBFcnJvcjogUE9TVGluZyB0byBlbmRwb2ludCAoSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30pOiAke3RleHQyfWBcbiAgICAgICAgfSk7XG4gICAgICAgIChfYiA9IHRoaXMub25lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIChfYyA9IHRoaXMub25lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3Rvb2wvbWNwL21jcC10cmFuc3BvcnQudHNcbmZ1bmN0aW9uIGNyZWF0ZU1jcFRyYW5zcG9ydChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy50eXBlICE9PSBcInNzZVwiKSB7XG4gICAgdGhyb3cgbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IFwiVW5zdXBwb3J0ZWQgb3IgaW52YWxpZCB0cmFuc3BvcnQgY29uZmlndXJhdGlvbi4gSWYgeW91IGFyZSB1c2luZyBhIGN1c3RvbSB0cmFuc3BvcnQsIG1ha2Ugc3VyZSBpdCBpbXBsZW1lbnRzIHRoZSBNQ1BUcmFuc3BvcnQgaW50ZXJmYWNlLlwiXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBTc2VNQ1BUcmFuc3BvcnQoY29uZmlnKTtcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tTWNwVHJhbnNwb3J0KHRyYW5zcG9ydCkge1xuICByZXR1cm4gXCJzdGFydFwiIGluIHRyYW5zcG9ydCAmJiB0eXBlb2YgdHJhbnNwb3J0LnN0YXJ0ID09PSBcImZ1bmN0aW9uXCIgJiYgXCJzZW5kXCIgaW4gdHJhbnNwb3J0ICYmIHR5cGVvZiB0cmFuc3BvcnQuc2VuZCA9PT0gXCJmdW5jdGlvblwiICYmIFwiY2xvc2VcIiBpbiB0cmFuc3BvcnQgJiYgdHlwZW9mIHRyYW5zcG9ydC5jbG9zZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vLyBzcmMvdG9vbC9tY3AvbWNwLWNsaWVudC50c1xudmFyIENMSUVOVF9WRVJTSU9OID0gXCIxLjAuMFwiO1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlTUNQQ2xpZW50KGNvbmZpZykge1xuICBjb25zdCBjbGllbnQgPSBuZXcgRGVmYXVsdE1DUENsaWVudChjb25maWcpO1xuICBhd2FpdCBjbGllbnQuaW5pdCgpO1xuICByZXR1cm4gY2xpZW50O1xufVxudmFyIERlZmF1bHRNQ1BDbGllbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0cmFuc3BvcnQ6IHRyYW5zcG9ydENvbmZpZyxcbiAgICBuYW1lOiBuYW1lMTcgPSBcImFpLXNkay1tY3AtY2xpZW50XCIsXG4gICAgb25VbmNhdWdodEVycm9yXG4gIH0pIHtcbiAgICB0aGlzLnJlcXVlc3RNZXNzYWdlSWQgPSAwO1xuICAgIHRoaXMucmVzcG9uc2VIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5zZXJ2ZXJDYXBhYmlsaXRpZXMgPSB7fTtcbiAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLm9uVW5jYXVnaHRFcnJvciA9IG9uVW5jYXVnaHRFcnJvcjtcbiAgICBpZiAoaXNDdXN0b21NY3BUcmFuc3BvcnQodHJhbnNwb3J0Q29uZmlnKSkge1xuICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnRDb25maWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNwb3J0ID0gY3JlYXRlTWNwVHJhbnNwb3J0KHRyYW5zcG9ydENvbmZpZyk7XG4gICAgfVxuICAgIHRoaXMudHJhbnNwb3J0Lm9uY2xvc2UgPSAoKSA9PiB0aGlzLm9uQ2xvc2UoKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5vbmVycm9yID0gKGVycm9yKSA9PiB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgIHRoaXMudHJhbnNwb3J0Lm9ubWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICBpZiAoXCJtZXRob2RcIiBpbiBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMub25FcnJvcihcbiAgICAgICAgICBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJVbnN1cHBvcnRlZCBtZXNzYWdlIHR5cGVcIlxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMub25SZXNwb25zZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50SW5mbyA9IHtcbiAgICAgIG5hbWU6IG5hbWUxNyxcbiAgICAgIHZlcnNpb246IENMSUVOVF9WRVJTSU9OXG4gICAgfTtcbiAgfVxuICBhc3luYyBpbml0KCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnRyYW5zcG9ydC5zdGFydCgpO1xuICAgICAgdGhpcy5pc0Nsb3NlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgIG1ldGhvZDogXCJpbml0aWFsaXplXCIsXG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBwcm90b2NvbFZlcnNpb246IExBVEVTVF9QUk9UT0NPTF9WRVJTSU9OLFxuICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiB7fSxcbiAgICAgICAgICAgIGNsaWVudEluZm86IHRoaXMuY2xpZW50SW5mb1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0U2NoZW1hOiBJbml0aWFsaXplUmVzdWx0U2NoZW1hXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiU2VydmVyIHNlbnQgaW52YWxpZCBpbml0aWFsaXplIHJlc3VsdFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFTVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTlMuaW5jbHVkZXMocmVzdWx0LnByb3RvY29sVmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBgU2VydmVyJ3MgcHJvdG9jb2wgdmVyc2lvbiBpcyBub3Qgc3VwcG9ydGVkOiAke3Jlc3VsdC5wcm90b2NvbFZlcnNpb259YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VydmVyQ2FwYWJpbGl0aWVzID0gcmVzdWx0LmNhcGFiaWxpdGllcztcbiAgICAgIGF3YWl0IHRoaXMubm90aWZpY2F0aW9uKHtcbiAgICAgICAgbWV0aG9kOiBcIm5vdGlmaWNhdGlvbnMvaW5pdGlhbGl6ZWRcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgYXdhaXQgdGhpcy5jbG9zZSgpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHZhciBfYTE3O1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKVxuICAgICAgcmV0dXJuO1xuICAgIGF3YWl0ICgoX2ExNyA9IHRoaXMudHJhbnNwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jbG9zZSgpKTtcbiAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgfVxuICBhc3NlcnRDYXBhYmlsaXR5KG1ldGhvZCkge1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlIFwiaW5pdGlhbGl6ZVwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b29scy9saXN0XCI6XG4gICAgICBjYXNlIFwidG9vbHMvY2FsbFwiOlxuICAgICAgICBpZiAoIXRoaXMuc2VydmVyQ2FwYWJpbGl0aWVzLnRvb2xzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCB0b29sc2BcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogYFVuc3VwcG9ydGVkIG1ldGhvZDogJHttZXRob2R9YFxuICAgICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVxdWVzdCh7XG4gICAgcmVxdWVzdCxcbiAgICByZXN1bHRTY2hlbWEsXG4gICAgb3B0aW9uc1xuICB9KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlMiwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgICAgIG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIkF0dGVtcHRlZCB0byBzZW5kIGEgcmVxdWVzdCBmcm9tIGEgY2xvc2VkIGNsaWVudFwiXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXNzZXJ0Q2FwYWJpbGl0eShyZXF1ZXN0Lm1ldGhvZCk7XG4gICAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbDtcbiAgICAgIHNpZ25hbCA9PSBudWxsID8gdm9pZCAwIDogc2lnbmFsLnRocm93SWZBYm9ydGVkKCk7XG4gICAgICBjb25zdCBtZXNzYWdlSWQgPSB0aGlzLnJlcXVlc3RNZXNzYWdlSWQrKztcbiAgICAgIGNvbnN0IGpzb25ycGNSZXF1ZXN0ID0ge1xuICAgICAgICAuLi5yZXF1ZXN0LFxuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBpZDogbWVzc2FnZUlkXG4gICAgICB9O1xuICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5yZXNwb25zZUhhbmRsZXJzLmRlbGV0ZShtZXNzYWdlSWQpO1xuICAgICAgfTtcbiAgICAgIHRoaXMucmVzcG9uc2VIYW5kbGVycy5zZXQobWVzc2FnZUlkLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKHNpZ25hbCA9PSBudWxsID8gdm9pZCAwIDogc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgICAgICAgbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJSZXF1ZXN0IHdhcyBhYm9ydGVkXCIsXG4gICAgICAgICAgICAgIGNhdXNlOiBzaWduYWwucmVhc29uXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdFNjaGVtYS5wYXJzZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgIHJlc29sdmUyKHJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VFcnJvciA9IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwYXJzZSBzZXJ2ZXIgcmVzcG9uc2VcIixcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlamVjdChwYXJzZUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKGpzb25ycGNSZXF1ZXN0KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgbGlzdFRvb2xzKHtcbiAgICBwYXJhbXMsXG4gICAgb3B0aW9uc1xuICB9ID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kOiBcInRvb2xzL2xpc3RcIiwgcGFyYW1zIH0sXG4gICAgICAgIHJlc3VsdFNjaGVtYTogTGlzdFRvb2xzUmVzdWx0U2NoZW1hLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNhbGxUb29sKHtcbiAgICBuYW1lOiBuYW1lMTcsXG4gICAgYXJncyxcbiAgICBvcHRpb25zXG4gIH0pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kOiBcInRvb2xzL2NhbGxcIiwgcGFyYW1zOiB7IG5hbWU6IG5hbWUxNywgYXJndW1lbnRzOiBhcmdzIH0gfSxcbiAgICAgICAgcmVzdWx0U2NoZW1hOiBDYWxsVG9vbFJlc3VsdFNjaGVtYSxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHNpZ25hbDogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5hYm9ydFNpZ25hbFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIG5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCBqc29ucnBjTm90aWZpY2F0aW9uID0ge1xuICAgICAgLi4ubm90aWZpY2F0aW9uLFxuICAgICAganNvbnJwYzogXCIyLjBcIlxuICAgIH07XG4gICAgYXdhaXQgdGhpcy50cmFuc3BvcnQuc2VuZChqc29ucnBjTm90aWZpY2F0aW9uKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNldCBvZiBBSSBTREsgdG9vbHMgZnJvbSB0aGUgTUNQIHNlcnZlclxuICAgKiBAcmV0dXJucyBBIHJlY29yZCBvZiB0b29sIG5hbWVzIHRvIHRoZWlyIGltcGxlbWVudGF0aW9uc1xuICAgKi9cbiAgYXN5bmMgdG9vbHMoe1xuICAgIHNjaGVtYXMgPSBcImF1dG9tYXRpY1wiXG4gIH0gPSB7fSkge1xuICAgIHZhciBfYTE3O1xuICAgIGNvbnN0IHRvb2xzID0ge307XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGxpc3RUb29sc1Jlc3VsdCA9IGF3YWl0IHRoaXMubGlzdFRvb2xzKCk7XG4gICAgICBmb3IgKGNvbnN0IHsgbmFtZTogbmFtZTE3LCBkZXNjcmlwdGlvbiwgaW5wdXRTY2hlbWEgfSBvZiBsaXN0VG9vbHNSZXN1bHQudG9vbHMpIHtcbiAgICAgICAgaWYgKHNjaGVtYXMgIT09IFwiYXV0b21hdGljXCIgJiYgIShuYW1lMTcgaW4gc2NoZW1hcykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgZXhlY3V0ZSA9IGFzeW5jIChhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMTg7XG4gICAgICAgICAgKF9hMTggPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmFib3J0U2lnbmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOC50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxUb29sKHsgbmFtZTogbmFtZTE3LCBhcmdzLCBvcHRpb25zIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b29sV2l0aEV4ZWN1dGUgPSBzY2hlbWFzID09PSBcImF1dG9tYXRpY1wiID8gZHluYW1pY1Rvb2woe1xuICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgIGlucHV0U2NoZW1hOiBqc29uU2NoZW1hKHtcbiAgICAgICAgICAgIC4uLmlucHV0U2NoZW1hLFxuICAgICAgICAgICAgcHJvcGVydGllczogKF9hMTcgPSBpbnB1dFNjaGVtYS5wcm9wZXJ0aWVzKSAhPSBudWxsID8gX2ExNyA6IHt9LFxuICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlXG4gICAgICAgICAgfSksXG4gICAgICAgICAgZXhlY3V0ZVxuICAgICAgICB9KSA6IHRvb2woe1xuICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgIGlucHV0U2NoZW1hOiBzY2hlbWFzW25hbWUxN10uaW5wdXRTY2hlbWEsXG4gICAgICAgICAgZXhlY3V0ZVxuICAgICAgICB9KTtcbiAgICAgICAgdG9vbHNbbmFtZTE3XSA9IHRvb2xXaXRoRXhlY3V0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b29scztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIG9uQ2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogXCJDb25uZWN0aW9uIGNsb3NlZFwiXG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMucmVzcG9uc2VIYW5kbGVycy52YWx1ZXMoKSkge1xuICAgICAgaGFuZGxlcihlcnJvcik7XG4gICAgfVxuICAgIHRoaXMucmVzcG9uc2VIYW5kbGVycy5jbGVhcigpO1xuICB9XG4gIG9uRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAodGhpcy5vblVuY2F1Z2h0RXJyb3IpIHtcbiAgICAgIHRoaXMub25VbmNhdWdodEVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgb25SZXNwb25zZShyZXNwb25zZSkge1xuICAgIGNvbnN0IG1lc3NhZ2VJZCA9IE51bWJlcihyZXNwb25zZS5pZCk7XG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMucmVzcG9uc2VIYW5kbGVycy5nZXQobWVzc2FnZUlkKTtcbiAgICBpZiAoaGFuZGxlciA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgUHJvdG9jb2wgZXJyb3I6IFJlY2VpdmVkIGEgcmVzcG9uc2UgZm9yIGFuIHVua25vd24gbWVzc2FnZSBJRDogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICByZXNwb25zZVxuICAgICAgICApfWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnJlc3BvbnNlSGFuZGxlcnMuZGVsZXRlKG1lc3NhZ2VJZCk7XG4gICAgaGFuZGxlcihcbiAgICAgIFwicmVzdWx0XCIgaW4gcmVzcG9uc2UgPyByZXNwb25zZSA6IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLmVycm9yLm1lc3NhZ2UsXG4gICAgICAgIGNhdXNlOiByZXNwb25zZS5lcnJvclxuICAgICAgfSlcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3Ivbm8tdHJhbnNjcmlwdC1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjIyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBOb1RyYW5zY3JpcHRHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjIyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiQUlfTm9UcmFuc2NyaXB0R2VuZXJhdGVkRXJyb3JcIixcbiAgICAgIG1lc3NhZ2U6IFwiTm8gdHJhbnNjcmlwdCBnZW5lcmF0ZWQuXCJcbiAgICB9KTtcbiAgICB0aGlzLnJlc3BvbnNlcyA9IG9wdGlvbnMucmVzcG9uc2VzO1xuICB9XG59O1xuXG4vLyBzcmMvdHJhbnNjcmliZS90cmFuc2NyaWJlLnRzXG5hc3luYyBmdW5jdGlvbiB0cmFuc2NyaWJlKHtcbiAgbW9kZWwsXG4gIGF1ZGlvLFxuICBwcm92aWRlck9wdGlvbnMgPSB7fSxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnNcbn0pIHtcbiAgaWYgKG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uICE9PSBcInYyXCIpIHtcbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvcih7XG4gICAgICB2ZXJzaW9uOiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbixcbiAgICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgICB9KTtcbiAgfVxuICBjb25zdCB7IHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3QgYXVkaW9EYXRhID0gYXVkaW8gaW5zdGFuY2VvZiBVUkwgPyAoYXdhaXQgZG93bmxvYWQoeyB1cmw6IGF1ZGlvIH0pKS5kYXRhIDogY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGF1ZGlvKTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgKCkgPT4ge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICByZXR1cm4gbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgIGF1ZGlvOiBhdWRpb0RhdGEsXG4gICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgICAgIG1lZGlhVHlwZTogKF9hMTcgPSBkZXRlY3RNZWRpYVR5cGUoe1xuICAgICAgICAgIGRhdGE6IGF1ZGlvRGF0YSxcbiAgICAgICAgICBzaWduYXR1cmVzOiBhdWRpb01lZGlhVHlwZVNpZ25hdHVyZXNcbiAgICAgICAgfSkpICE9IG51bGwgPyBfYTE3IDogXCJhdWRpby93YXZcIlxuICAgICAgfSk7XG4gICAgfVxuICApO1xuICBsb2dXYXJuaW5ncyhyZXN1bHQud2FybmluZ3MpO1xuICBpZiAoIXJlc3VsdC50ZXh0KSB7XG4gICAgdGhyb3cgbmV3IE5vVHJhbnNjcmlwdEdlbmVyYXRlZEVycm9yKHsgcmVzcG9uc2VzOiBbcmVzdWx0LnJlc3BvbnNlXSB9KTtcbiAgfVxuICByZXR1cm4gbmV3IERlZmF1bHRUcmFuc2NyaXB0aW9uUmVzdWx0KHtcbiAgICB0ZXh0OiByZXN1bHQudGV4dCxcbiAgICBzZWdtZW50czogcmVzdWx0LnNlZ21lbnRzLFxuICAgIGxhbmd1YWdlOiByZXN1bHQubGFuZ3VhZ2UsXG4gICAgZHVyYXRpb25JblNlY29uZHM6IHJlc3VsdC5kdXJhdGlvbkluU2Vjb25kcyxcbiAgICB3YXJuaW5nczogcmVzdWx0Lndhcm5pbmdzLFxuICAgIHJlc3BvbnNlczogW3Jlc3VsdC5yZXNwb25zZV0sXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0LnByb3ZpZGVyTWV0YWRhdGFcbiAgfSk7XG59XG52YXIgRGVmYXVsdFRyYW5zY3JpcHRpb25SZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2ExNztcbiAgICB0aGlzLnRleHQgPSBvcHRpb25zLnRleHQ7XG4gICAgdGhpcy5zZWdtZW50cyA9IG9wdGlvbnMuc2VnbWVudHM7XG4gICAgdGhpcy5sYW5ndWFnZSA9IG9wdGlvbnMubGFuZ3VhZ2U7XG4gICAgdGhpcy5kdXJhdGlvbkluU2Vjb25kcyA9IG9wdGlvbnMuZHVyYXRpb25JblNlY29uZHM7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSAoX2ExNyA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9hMTcgOiB7fTtcbiAgfVxufTtcblxuLy8gc3JjL3VpL2NhbGwtY29tcGxldGlvbi1hcGkudHNcbmltcG9ydCB7IHBhcnNlSnNvbkV2ZW50U3RyZWFtIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3VpL3Byb2Nlc3MtdGV4dC1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NUZXh0U3RyZWFtKHtcbiAgc3RyZWFtLFxuICBvblRleHRQYXJ0XG59KSB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkuZ2V0UmVhZGVyKCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGF3YWl0IG9uVGV4dFBhcnQodmFsdWUpO1xuICB9XG59XG5cbi8vIHNyYy91aS9jYWxsLWNvbXBsZXRpb24tYXBpLnRzXG52YXIgZ2V0T3JpZ2luYWxGZXRjaCA9ICgpID0+IGZldGNoO1xuYXN5bmMgZnVuY3Rpb24gY2FsbENvbXBsZXRpb25BcGkoe1xuICBhcGksXG4gIHByb21wdCxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIHN0cmVhbVByb3RvY29sID0gXCJkYXRhXCIsXG4gIHNldENvbXBsZXRpb24sXG4gIHNldExvYWRpbmcsXG4gIHNldEVycm9yLFxuICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBmZXRjaDogZmV0Y2gyID0gZ2V0T3JpZ2luYWxGZXRjaCgpXG59KSB7XG4gIHZhciBfYTE3O1xuICB0cnkge1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3Iodm9pZCAwKTtcbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKGFib3J0Q29udHJvbGxlcik7XG4gICAgc2V0Q29tcGxldGlvbihcIlwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoMihhcGksIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgLi4uYm9keVxuICAgICAgfSksXG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLmhlYWRlcnNcbiAgICAgIH0sXG4gICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAoX2ExNyA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgIT0gbnVsbCA/IF9hMTcgOiBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS5cIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIHN3aXRjaCAoc3RyZWFtUHJvdG9jb2wpIHtcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgYXdhaXQgcHJvY2Vzc1RleHRTdHJlYW0oe1xuICAgICAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgICBvblRleHRQYXJ0OiAoY2h1bmspID0+IHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaHVuaztcbiAgICAgICAgICAgIHNldENvbXBsZXRpb24ocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkYXRhXCI6IHtcbiAgICAgICAgYXdhaXQgY29uc3VtZVN0cmVhbSh7XG4gICAgICAgICAgc3RyZWFtOiBwYXJzZUpzb25FdmVudFN0cmVhbSh7XG4gICAgICAgICAgICBzdHJlYW06IHJlc3BvbnNlLmJvZHksXG4gICAgICAgICAgICBzY2hlbWE6IHVpTWVzc2FnZUNodW5rU2NoZW1hXG4gICAgICAgICAgfSkucGlwZVRocm91Z2goXG4gICAgICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICAgICAgYXN5bmMgdHJhbnNmb3JtKHBhcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgcGFydC5lcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtUGFydCA9IHBhcnQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbVBhcnQudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHJlYW1QYXJ0LmRlbHRhO1xuICAgICAgICAgICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtUGFydC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHJlYW1QYXJ0LmVycm9yVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICksXG4gICAgICAgICAgb25FcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gc3RyZWFtUHJvdG9jb2w7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gcHJvdG9jb2w6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgIG9uRmluaXNoKHByb21wdCwgcmVzdWx0KTtcbiAgICB9XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0RXJyb3IoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgfVxufVxuXG4vLyBzcmMvdWkvY2hhdC50c1xuaW1wb3J0IHtcbiAgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkRnVuY1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdWkvY29udmVydC1maWxlLWxpc3QtdG8tZmlsZS11aS1wYXJ0cy50c1xuYXN5bmMgZnVuY3Rpb24gY29udmVydEZpbGVMaXN0VG9GaWxlVUlQYXJ0cyhmaWxlcykge1xuICBpZiAoZmlsZXMgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoIWdsb2JhbFRoaXMuRmlsZUxpc3QgfHwgIShmaWxlcyBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRmlsZUxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmlsZUxpc3QgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudFwiKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgQXJyYXkuZnJvbShmaWxlcykubWFwKGFzeW5jIChmaWxlKSA9PiB7XG4gICAgICBjb25zdCB7IG5hbWU6IG5hbWUxNywgdHlwZSB9ID0gZmlsZTtcbiAgICAgIGNvbnN0IGRhdGFVcmwgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZTIsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gKHJlYWRlckV2ZW50KSA9PiB7XG4gICAgICAgICAgdmFyIF9hMTc7XG4gICAgICAgICAgcmVzb2x2ZTIoKF9hMTcgPSByZWFkZXJFdmVudC50YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gKGVycm9yKSA9PiByZWplY3QoZXJyb3IpO1xuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIG1lZGlhVHlwZTogdHlwZSxcbiAgICAgICAgZmlsZW5hbWU6IG5hbWUxNyxcbiAgICAgICAgdXJsOiBkYXRhVXJsXG4gICAgICB9O1xuICAgIH0pXG4gICk7XG59XG5cbi8vIHNyYy91aS9kZWZhdWx0LWNoYXQtdHJhbnNwb3J0LnRzXG5pbXBvcnQgeyBwYXJzZUpzb25FdmVudFN0cmVhbSBhcyBwYXJzZUpzb25FdmVudFN0cmVhbTIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdWkvaHR0cC1jaGF0LXRyYW5zcG9ydC50c1xuaW1wb3J0IHsgcmVzb2x2ZSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgSHR0cENoYXRUcmFuc3BvcnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBhcGkgPSBcIi9hcGkvY2hhdFwiLFxuICAgIGNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keSxcbiAgICBmZXRjaDogZmV0Y2gyLFxuICAgIHByZXBhcmVTZW5kTWVzc2FnZXNSZXF1ZXN0LFxuICAgIHByZXBhcmVSZWNvbm5lY3RUb1N0cmVhbVJlcXVlc3RcbiAgfSkge1xuICAgIHRoaXMuYXBpID0gYXBpO1xuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5mZXRjaCA9IGZldGNoMjtcbiAgICB0aGlzLnByZXBhcmVTZW5kTWVzc2FnZXNSZXF1ZXN0ID0gcHJlcGFyZVNlbmRNZXNzYWdlc1JlcXVlc3Q7XG4gICAgdGhpcy5wcmVwYXJlUmVjb25uZWN0VG9TdHJlYW1SZXF1ZXN0ID0gcHJlcGFyZVJlY29ubmVjdFRvU3RyZWFtUmVxdWVzdDtcbiAgfVxuICBhc3luYyBzZW5kTWVzc2FnZXMoe1xuICAgIGFib3J0U2lnbmFsLFxuICAgIC4uLm9wdGlvbnNcbiAgfSkge1xuICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCByZXNvbHZlZEJvZHkgPSBhd2FpdCByZXNvbHZlKHRoaXMuYm9keSk7XG4gICAgY29uc3QgcmVzb2x2ZWRIZWFkZXJzID0gYXdhaXQgcmVzb2x2ZSh0aGlzLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlc29sdmVkQ3JlZGVudGlhbHMgPSBhd2FpdCByZXNvbHZlKHRoaXMuY3JlZGVudGlhbHMpO1xuICAgIGNvbnN0IHByZXBhcmVkUmVxdWVzdCA9IGF3YWl0ICgoX2ExNyA9IHRoaXMucHJlcGFyZVNlbmRNZXNzYWdlc1JlcXVlc3QpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNhbGwodGhpcywge1xuICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgIGlkOiBvcHRpb25zLmNoYXRJZCxcbiAgICAgIG1lc3NhZ2VzOiBvcHRpb25zLm1lc3NhZ2VzLFxuICAgICAgYm9keTogeyAuLi5yZXNvbHZlZEJvZHksIC4uLm9wdGlvbnMuYm9keSB9LFxuICAgICAgaGVhZGVyczogeyAuLi5yZXNvbHZlZEhlYWRlcnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9LFxuICAgICAgY3JlZGVudGlhbHM6IHJlc29sdmVkQ3JlZGVudGlhbHMsXG4gICAgICByZXF1ZXN0TWV0YWRhdGE6IG9wdGlvbnMubWV0YWRhdGEsXG4gICAgICB0cmlnZ2VyOiBvcHRpb25zLnRyaWdnZXIsXG4gICAgICBtZXNzYWdlSWQ6IG9wdGlvbnMubWVzc2FnZUlkXG4gICAgfSkpO1xuICAgIGNvbnN0IGFwaSA9IChfYiA9IHByZXBhcmVkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZWRSZXF1ZXN0LmFwaSkgIT0gbnVsbCA/IF9iIDogdGhpcy5hcGk7XG4gICAgY29uc3QgaGVhZGVycyA9IChwcmVwYXJlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVkUmVxdWVzdC5oZWFkZXJzKSAhPT0gdm9pZCAwID8gcHJlcGFyZWRSZXF1ZXN0LmhlYWRlcnMgOiB7IC4uLnJlc29sdmVkSGVhZGVycywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgY29uc3QgYm9keSA9IChwcmVwYXJlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVkUmVxdWVzdC5ib2R5KSAhPT0gdm9pZCAwID8gcHJlcGFyZWRSZXF1ZXN0LmJvZHkgOiB7XG4gICAgICAuLi5yZXNvbHZlZEJvZHksXG4gICAgICAuLi5vcHRpb25zLmJvZHksXG4gICAgICBpZDogb3B0aW9ucy5jaGF0SWQsXG4gICAgICBtZXNzYWdlczogb3B0aW9ucy5tZXNzYWdlcyxcbiAgICAgIHRyaWdnZXI6IG9wdGlvbnMudHJpZ2dlcixcbiAgICAgIG1lc3NhZ2VJZDogb3B0aW9ucy5tZXNzYWdlSWRcbiAgICB9O1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gKF9jID0gcHJlcGFyZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlZFJlcXVlc3QuY3JlZGVudGlhbHMpICE9IG51bGwgPyBfYyA6IHJlc29sdmVkQ3JlZGVudGlhbHM7XG4gICAgY29uc3QgZmV0Y2gyID0gKF9kID0gdGhpcy5mZXRjaCkgIT0gbnVsbCA/IF9kIDogZ2xvYmFsVGhpcy5mZXRjaDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoMihhcGksIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5oZWFkZXJzXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIHNpZ25hbDogYWJvcnRTaWduYWxcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIChfZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgIT0gbnVsbCA/IF9lIDogXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVzcG9uc2VTdHJlYW0ocmVzcG9uc2UuYm9keSk7XG4gIH1cbiAgYXN5bmMgcmVjb25uZWN0VG9TdHJlYW0ob3B0aW9ucykge1xuICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCByZXNvbHZlZEJvZHkgPSBhd2FpdCByZXNvbHZlKHRoaXMuYm9keSk7XG4gICAgY29uc3QgcmVzb2x2ZWRIZWFkZXJzID0gYXdhaXQgcmVzb2x2ZSh0aGlzLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlc29sdmVkQ3JlZGVudGlhbHMgPSBhd2FpdCByZXNvbHZlKHRoaXMuY3JlZGVudGlhbHMpO1xuICAgIGNvbnN0IHByZXBhcmVkUmVxdWVzdCA9IGF3YWl0ICgoX2ExNyA9IHRoaXMucHJlcGFyZVJlY29ubmVjdFRvU3RyZWFtUmVxdWVzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbCh0aGlzLCB7XG4gICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgaWQ6IG9wdGlvbnMuY2hhdElkLFxuICAgICAgYm9keTogeyAuLi5yZXNvbHZlZEJvZHksIC4uLm9wdGlvbnMuYm9keSB9LFxuICAgICAgaGVhZGVyczogeyAuLi5yZXNvbHZlZEhlYWRlcnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9LFxuICAgICAgY3JlZGVudGlhbHM6IHJlc29sdmVkQ3JlZGVudGlhbHMsXG4gICAgICByZXF1ZXN0TWV0YWRhdGE6IG9wdGlvbnMubWV0YWRhdGFcbiAgICB9KSk7XG4gICAgY29uc3QgYXBpID0gKF9iID0gcHJlcGFyZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlZFJlcXVlc3QuYXBpKSAhPSBudWxsID8gX2IgOiBgJHt0aGlzLmFwaX0vJHtvcHRpb25zLmNoYXRJZH0vc3RyZWFtYDtcbiAgICBjb25zdCBoZWFkZXJzID0gKHByZXBhcmVkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZWRSZXF1ZXN0LmhlYWRlcnMpICE9PSB2b2lkIDAgPyBwcmVwYXJlZFJlcXVlc3QuaGVhZGVycyA6IHsgLi4ucmVzb2x2ZWRIZWFkZXJzLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IChfYyA9IHByZXBhcmVkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZWRSZXF1ZXN0LmNyZWRlbnRpYWxzKSAhPSBudWxsID8gX2MgOiByZXNvbHZlZENyZWRlbnRpYWxzO1xuICAgIGNvbnN0IGZldGNoMiA9IChfZCA9IHRoaXMuZmV0Y2gpICE9IG51bGwgPyBfZCA6IGdsb2JhbFRoaXMuZmV0Y2g7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaDIoYXBpLCB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgY3JlZGVudGlhbHNcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIChfZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgIT0gbnVsbCA/IF9lIDogXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVzcG9uc2VTdHJlYW0ocmVzcG9uc2UuYm9keSk7XG4gIH1cbn07XG5cbi8vIHNyYy91aS9kZWZhdWx0LWNoYXQtdHJhbnNwb3J0LnRzXG52YXIgRGVmYXVsdENoYXRUcmFuc3BvcnQgPSBjbGFzcyBleHRlbmRzIEh0dHBDaGF0VHJhbnNwb3J0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cbiAgcHJvY2Vzc1Jlc3BvbnNlU3RyZWFtKHN0cmVhbSkge1xuICAgIHJldHVybiBwYXJzZUpzb25FdmVudFN0cmVhbTIoe1xuICAgICAgc3RyZWFtLFxuICAgICAgc2NoZW1hOiB1aU1lc3NhZ2VDaHVua1NjaGVtYVxuICAgIH0pLnBpcGVUaHJvdWdoKFxuICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgIGlmICghY2h1bmsuc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhyb3cgY2h1bmsuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL3VpL2NoYXQudHNcbnZhciBBYnN0cmFjdENoYXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IGdlbmVyYXRlSWRGdW5jLFxuICAgIGlkID0gZ2VuZXJhdGVJZDMoKSxcbiAgICB0cmFuc3BvcnQgPSBuZXcgRGVmYXVsdENoYXRUcmFuc3BvcnQoKSxcbiAgICBtZXNzYWdlTWV0YWRhdGFTY2hlbWEsXG4gICAgZGF0YVBhcnRTY2hlbWFzLFxuICAgIHN0YXRlLFxuICAgIG9uRXJyb3IsXG4gICAgb25Ub29sQ2FsbCxcbiAgICBvbkZpbmlzaCxcbiAgICBvbkRhdGEsXG4gICAgc2VuZEF1dG9tYXRpY2FsbHlXaGVuXG4gIH0pIHtcbiAgICB0aGlzLmFjdGl2ZVJlc3BvbnNlID0gdm9pZCAwO1xuICAgIHRoaXMuam9iRXhlY3V0b3IgPSBuZXcgU2VyaWFsSm9iRXhlY3V0b3IoKTtcbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIG9yIHJlcGxhY2VzIGEgdXNlciBtZXNzYWdlIHRvIHRoZSBjaGF0IGxpc3QuIFRoaXMgdHJpZ2dlcnMgdGhlIEFQSSBjYWxsIHRvIGZldGNoXG4gICAgICogdGhlIGFzc2lzdGFudCdzIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogSWYgYSBtZXNzYWdlSWQgaXMgcHJvdmlkZWQsIHRoZSBtZXNzYWdlIHdpbGwgYmUgcmVwbGFjZWQuXG4gICAgICovXG4gICAgdGhpcy5zZW5kTWVzc2FnZSA9IGFzeW5jIChtZXNzYWdlLCBvcHRpb25zKSA9PiB7XG4gICAgICB2YXIgX2ExNywgX2IsIF9jLCBfZDtcbiAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCh7XG4gICAgICAgICAgdHJpZ2dlcjogXCJzdWJtaXQtbWVzc2FnZVwiLFxuICAgICAgICAgIG1lc3NhZ2VJZDogKF9hMTcgPSB0aGlzLmxhc3RNZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5pZCxcbiAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgdWlNZXNzYWdlO1xuICAgICAgaWYgKFwidGV4dFwiIGluIG1lc3NhZ2UgfHwgXCJmaWxlc1wiIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZmlsZVBhcnRzID0gQXJyYXkuaXNBcnJheShtZXNzYWdlLmZpbGVzKSA/IG1lc3NhZ2UuZmlsZXMgOiBhd2FpdCBjb252ZXJ0RmlsZUxpc3RUb0ZpbGVVSVBhcnRzKG1lc3NhZ2UuZmlsZXMpO1xuICAgICAgICB1aU1lc3NhZ2UgPSB7XG4gICAgICAgICAgcGFydHM6IFtcbiAgICAgICAgICAgIC4uLmZpbGVQYXJ0cyxcbiAgICAgICAgICAgIC4uLlwidGV4dFwiIGluIG1lc3NhZ2UgJiYgbWVzc2FnZS50ZXh0ICE9IG51bGwgPyBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS50ZXh0IH1dIDogW11cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1aU1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubWVzc2FnZUlkICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZUluZGV4ID0gdGhpcy5zdGF0ZS5tZXNzYWdlcy5maW5kSW5kZXgoXG4gICAgICAgICAgKG0pID0+IG0uaWQgPT09IG1lc3NhZ2UubWVzc2FnZUlkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtZXNzYWdlSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtZXNzYWdlIHdpdGggaWQgJHttZXNzYWdlLm1lc3NhZ2VJZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubWVzc2FnZXNbbWVzc2FnZUluZGV4XS5yb2xlICE9PSBcInVzZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBtZXNzYWdlIHdpdGggaWQgJHttZXNzYWdlLm1lc3NhZ2VJZH0gaXMgbm90IGEgdXNlciBtZXNzYWdlYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5tZXNzYWdlcyA9IHRoaXMuc3RhdGUubWVzc2FnZXMuc2xpY2UoMCwgbWVzc2FnZUluZGV4ICsgMSk7XG4gICAgICAgIHRoaXMuc3RhdGUucmVwbGFjZU1lc3NhZ2UobWVzc2FnZUluZGV4LCB7XG4gICAgICAgICAgLi4udWlNZXNzYWdlLFxuICAgICAgICAgIGlkOiBtZXNzYWdlLm1lc3NhZ2VJZCxcbiAgICAgICAgICByb2xlOiAoX2IgPSB1aU1lc3NhZ2Uucm9sZSkgIT0gbnVsbCA/IF9iIDogXCJ1c2VyXCIsXG4gICAgICAgICAgbWV0YWRhdGE6IG1lc3NhZ2UubWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlLnB1c2hNZXNzYWdlKHtcbiAgICAgICAgICAuLi51aU1lc3NhZ2UsXG4gICAgICAgICAgaWQ6IChfYyA9IHVpTWVzc2FnZS5pZCkgIT0gbnVsbCA/IF9jIDogdGhpcy5nZW5lcmF0ZUlkKCksXG4gICAgICAgICAgcm9sZTogKF9kID0gdWlNZXNzYWdlLnJvbGUpICE9IG51bGwgPyBfZCA6IFwidXNlclwiLFxuICAgICAgICAgIG1ldGFkYXRhOiBtZXNzYWdlLm1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCh7XG4gICAgICAgIHRyaWdnZXI6IFwic3VibWl0LW1lc3NhZ2VcIixcbiAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlLm1lc3NhZ2VJZCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdlbmVyYXRlIHRoZSBhc3Npc3RhbnQgbWVzc2FnZSB3aXRoIHRoZSBwcm92aWRlZCBtZXNzYWdlIGlkLlxuICAgICAqIElmIG5vIG1lc3NhZ2UgaWQgaXMgcHJvdmlkZWQsIHRoZSBsYXN0IGFzc2lzdGFudCBtZXNzYWdlIHdpbGwgYmUgcmVnZW5lcmF0ZWQuXG4gICAgICovXG4gICAgdGhpcy5yZWdlbmVyYXRlID0gYXN5bmMgKHtcbiAgICAgIG1lc3NhZ2VJZCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9ID0ge30pID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VJbmRleCA9IG1lc3NhZ2VJZCA9PSBudWxsID8gdGhpcy5zdGF0ZS5tZXNzYWdlcy5sZW5ndGggLSAxIDogdGhpcy5zdGF0ZS5tZXNzYWdlcy5maW5kSW5kZXgoKG1lc3NhZ2UpID0+IG1lc3NhZ2UuaWQgPT09IG1lc3NhZ2VJZCk7XG4gICAgICBpZiAobWVzc2FnZUluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1lc3NhZ2UgJHttZXNzYWdlSWR9IG5vdCBmb3VuZGApO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZS5tZXNzYWdlcyA9IHRoaXMuc3RhdGUubWVzc2FnZXMuc2xpY2UoXG4gICAgICAgIDAsXG4gICAgICAgIC8vIGlmIHRoZSBtZXNzYWdlIGlzIGEgdXNlciBtZXNzYWdlLCB3ZSBuZWVkIHRvIGluY2x1ZGUgaXQgaW4gdGhlIHJlcXVlc3Q6XG4gICAgICAgIHRoaXMubWVzc2FnZXNbbWVzc2FnZUluZGV4XS5yb2xlID09PSBcImFzc2lzdGFudFwiID8gbWVzc2FnZUluZGV4IDogbWVzc2FnZUluZGV4ICsgMVxuICAgICAgKTtcbiAgICAgIGF3YWl0IHRoaXMubWFrZVJlcXVlc3Qoe1xuICAgICAgICB0cmlnZ2VyOiBcInJlZ2VuZXJhdGUtbWVzc2FnZVwiLFxuICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byByZXN1bWUgYW4gb25nb2luZyBzdHJlYW1pbmcgcmVzcG9uc2UuXG4gICAgICovXG4gICAgdGhpcy5yZXN1bWVTdHJlYW0gPSBhc3luYyAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KHsgdHJpZ2dlcjogXCJyZXN1bWUtc3RyZWFtXCIsIC4uLm9wdGlvbnMgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgZXJyb3Igc3RhdGUgYW5kIHNldCB0aGUgc3RhdHVzIHRvIHJlYWR5IGlmIHRoZSBjaGF0IGlzIGluIGFuIGVycm9yIHN0YXRlLlxuICAgICAqL1xuICAgIHRoaXMuY2xlYXJFcnJvciA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuZXJyb3IgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcInJlYWR5XCIgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZFRvb2xSZXN1bHQgPSBhc3luYyAoe1xuICAgICAgdG9vbDogdG9vbDMsXG4gICAgICB0b29sQ2FsbElkLFxuICAgICAgb3V0cHV0XG4gICAgfSkgPT4gdGhpcy5qb2JFeGVjdXRvci5ydW4oYXN5bmMgKCkgPT4ge1xuICAgICAgdmFyIF9hMTcsIF9iO1xuICAgICAgY29uc3QgbWVzc2FnZXMgPSB0aGlzLnN0YXRlLm1lc3NhZ2VzO1xuICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgIHRoaXMuc3RhdGUucmVwbGFjZU1lc3NhZ2UobWVzc2FnZXMubGVuZ3RoIC0gMSwge1xuICAgICAgICAuLi5sYXN0TWVzc2FnZSxcbiAgICAgICAgcGFydHM6IGxhc3RNZXNzYWdlLnBhcnRzLm1hcChcbiAgICAgICAgICAocGFydCkgPT4gaXNUb29sT3JEeW5hbWljVG9vbFVJUGFydChwYXJ0KSAmJiBwYXJ0LnRvb2xDYWxsSWQgPT09IHRvb2xDYWxsSWQgPyB7IC4uLnBhcnQsIHN0YXRlOiBcIm91dHB1dC1hdmFpbGFibGVcIiwgb3V0cHV0IH0gOiBwYXJ0XG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuYWN0aXZlUmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLnBhcnRzID0gdGhpcy5hY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLnBhcnRzLm1hcChcbiAgICAgICAgICAocGFydCkgPT4gaXNUb29sT3JEeW5hbWljVG9vbFVJUGFydChwYXJ0KSAmJiBwYXJ0LnRvb2xDYWxsSWQgPT09IHRvb2xDYWxsSWQgPyB7XG4gICAgICAgICAgICAuLi5wYXJ0LFxuICAgICAgICAgICAgc3RhdGU6IFwib3V0cHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgZXJyb3JUZXh0OiB2b2lkIDBcbiAgICAgICAgICB9IDogcGFydFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBcInN0cmVhbWluZ1wiICYmIHRoaXMuc3RhdHVzICE9PSBcInN1Ym1pdHRlZFwiICYmICgoX2ExNyA9IHRoaXMuc2VuZEF1dG9tYXRpY2FsbHlXaGVuKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHRoaXMsIHsgbWVzc2FnZXM6IHRoaXMuc3RhdGUubWVzc2FnZXMgfSkpKSB7XG4gICAgICAgIHRoaXMubWFrZVJlcXVlc3Qoe1xuICAgICAgICAgIHRyaWdnZXI6IFwic3VibWl0LW1lc3NhZ2VcIixcbiAgICAgICAgICBtZXNzYWdlSWQ6IChfYiA9IHRoaXMubGFzdE1lc3NhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYi5pZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBYm9ydCB0aGUgY3VycmVudCByZXF1ZXN0IGltbWVkaWF0ZWx5LCBrZWVwIHRoZSBnZW5lcmF0ZWQgdG9rZW5zIGlmIGFueS5cbiAgICAgKi9cbiAgICB0aGlzLnN0b3AgPSBhc3luYyAoKSA9PiB7XG4gICAgICB2YXIgX2ExNztcbiAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gXCJzdHJlYW1pbmdcIiAmJiB0aGlzLnN0YXR1cyAhPT0gXCJzdWJtaXR0ZWRcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKChfYTE3ID0gdGhpcy5hY3RpdmVSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUmVzcG9uc2UuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5nZW5lcmF0ZUlkID0gZ2VuZXJhdGVJZDM7XG4gICAgdGhpcy5tZXNzYWdlTWV0YWRhdGFTY2hlbWEgPSBtZXNzYWdlTWV0YWRhdGFTY2hlbWE7XG4gICAgdGhpcy5kYXRhUGFydFNjaGVtYXMgPSBkYXRhUGFydFNjaGVtYXM7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMub25FcnJvciA9IG9uRXJyb3I7XG4gICAgdGhpcy5vblRvb2xDYWxsID0gb25Ub29sQ2FsbDtcbiAgICB0aGlzLm9uRmluaXNoID0gb25GaW5pc2g7XG4gICAgdGhpcy5vbkRhdGEgPSBvbkRhdGE7XG4gICAgdGhpcy5zZW5kQXV0b21hdGljYWxseVdoZW4gPSBzZW5kQXV0b21hdGljYWxseVdoZW47XG4gIH1cbiAgLyoqXG4gICAqIEhvb2sgc3RhdHVzOlxuICAgKlxuICAgKiAtIGBzdWJtaXR0ZWRgOiBUaGUgbWVzc2FnZSBoYXMgYmVlbiBzZW50IHRvIHRoZSBBUEkgYW5kIHdlJ3JlIGF3YWl0aW5nIHRoZSBzdGFydCBvZiB0aGUgcmVzcG9uc2Ugc3RyZWFtLlxuICAgKiAtIGBzdHJlYW1pbmdgOiBUaGUgcmVzcG9uc2UgaXMgYWN0aXZlbHkgc3RyZWFtaW5nIGluIGZyb20gdGhlIEFQSSwgcmVjZWl2aW5nIGNodW5rcyBvZiBkYXRhLlxuICAgKiAtIGByZWFkeWA6IFRoZSBmdWxsIHJlc3BvbnNlIGhhcyBiZWVuIHJlY2VpdmVkIGFuZCBwcm9jZXNzZWQ7IGEgbmV3IHVzZXIgbWVzc2FnZSBjYW4gYmUgc3VibWl0dGVkLlxuICAgKiAtIGBlcnJvcmA6IEFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgQVBJIHJlcXVlc3QsIHByZXZlbnRpbmcgc3VjY2Vzc2Z1bCBjb21wbGV0aW9uLlxuICAgKi9cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5zdGF0dXM7XG4gIH1cbiAgc2V0U3RhdHVzKHtcbiAgICBzdGF0dXMsXG4gICAgZXJyb3JcbiAgfSkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gc3RhdHVzKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuc3RhdGUuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdGUuZXJyb3IgPSBlcnJvcjtcbiAgfVxuICBnZXQgZXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3I7XG4gIH1cbiAgZ2V0IG1lc3NhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLm1lc3NhZ2VzO1xuICB9XG4gIGdldCBsYXN0TWVzc2FnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5tZXNzYWdlc1t0aGlzLnN0YXRlLm1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHNldCBtZXNzYWdlcyhtZXNzYWdlcykge1xuICAgIHRoaXMuc3RhdGUubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgfVxuICBhc3luYyBtYWtlUmVxdWVzdCh7XG4gICAgdHJpZ2dlcixcbiAgICBtZXRhZGF0YSxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHksXG4gICAgbWVzc2FnZUlkXG4gIH0pIHtcbiAgICB2YXIgX2ExNywgX2IsIF9jO1xuICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcInN1Ym1pdHRlZFwiLCBlcnJvcjogdm9pZCAwIH0pO1xuICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gdGhpcy5sYXN0TWVzc2FnZTtcbiAgICBsZXQgaXNBYm9ydCA9IGZhbHNlO1xuICAgIGxldCBpc0Rpc2Nvbm5lY3QgPSBmYWxzZTtcbiAgICBsZXQgaXNFcnJvciA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhY3RpdmVSZXNwb25zZSA9IHtcbiAgICAgICAgc3RhdGU6IGNyZWF0ZVN0cmVhbWluZ1VJTWVzc2FnZVN0YXRlKHtcbiAgICAgICAgICBsYXN0TWVzc2FnZTogdGhpcy5zdGF0ZS5zbmFwc2hvdChsYXN0TWVzc2FnZSksXG4gICAgICAgICAgbWVzc2FnZUlkOiB0aGlzLmdlbmVyYXRlSWQoKVxuICAgICAgICB9KSxcbiAgICAgICAgYWJvcnRDb250cm9sbGVyOiBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICAgIH07XG4gICAgICBhY3RpdmVSZXNwb25zZS5hYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgIGlzQWJvcnQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFjdGl2ZVJlc3BvbnNlID0gYWN0aXZlUmVzcG9uc2U7XG4gICAgICBsZXQgc3RyZWFtO1xuICAgICAgaWYgKHRyaWdnZXIgPT09IFwicmVzdW1lLXN0cmVhbVwiKSB7XG4gICAgICAgIGNvbnN0IHJlY29ubmVjdCA9IGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlY29ubmVjdFRvU3RyZWFtKHtcbiAgICAgICAgICBjaGF0SWQ6IHRoaXMuaWQsXG4gICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBib2R5XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVjb25uZWN0ID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnNldFN0YXR1cyh7IHN0YXR1czogXCJyZWFkeVwiIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0gPSByZWNvbm5lY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0gPSBhd2FpdCB0aGlzLnRyYW5zcG9ydC5zZW5kTWVzc2FnZXMoe1xuICAgICAgICAgIGNoYXRJZDogdGhpcy5pZCxcbiAgICAgICAgICBtZXNzYWdlczogdGhpcy5zdGF0ZS5tZXNzYWdlcyxcbiAgICAgICAgICBhYm9ydFNpZ25hbDogYWN0aXZlUmVzcG9uc2UuYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgdHJpZ2dlcixcbiAgICAgICAgICBtZXNzYWdlSWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBydW5VcGRhdGVNZXNzYWdlSm9iID0gKGpvYikgPT4gKFxuICAgICAgICAvLyBzZXJpYWxpemUgdGhlIGpvYiBleGVjdXRpb24gdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zOlxuICAgICAgICB0aGlzLmpvYkV4ZWN1dG9yLnJ1bihcbiAgICAgICAgICAoKSA9PiBqb2Ioe1xuICAgICAgICAgICAgc3RhdGU6IGFjdGl2ZVJlc3BvbnNlLnN0YXRlLFxuICAgICAgICAgICAgd3JpdGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTg7XG4gICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcInN0cmVhbWluZ1wiIH0pO1xuICAgICAgICAgICAgICBjb25zdCByZXBsYWNlTGFzdE1lc3NhZ2UgPSBhY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLmlkID09PSAoKF9hMTggPSB0aGlzLmxhc3RNZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOC5pZCk7XG4gICAgICAgICAgICAgIGlmIChyZXBsYWNlTGFzdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnJlcGxhY2VNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5tZXNzYWdlcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgICAgYWN0aXZlUmVzcG9uc2Uuc3RhdGUubWVzc2FnZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wdXNoTWVzc2FnZShhY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBhd2FpdCBjb25zdW1lU3RyZWFtKHtcbiAgICAgICAgc3RyZWFtOiBwcm9jZXNzVUlNZXNzYWdlU3RyZWFtKHtcbiAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgb25Ub29sQ2FsbDogdGhpcy5vblRvb2xDYWxsLFxuICAgICAgICAgIG9uRGF0YTogdGhpcy5vbkRhdGEsXG4gICAgICAgICAgbWVzc2FnZU1ldGFkYXRhU2NoZW1hOiB0aGlzLm1lc3NhZ2VNZXRhZGF0YVNjaGVtYSxcbiAgICAgICAgICBkYXRhUGFydFNjaGVtYXM6IHRoaXMuZGF0YVBhcnRTY2hlbWFzLFxuICAgICAgICAgIHJ1blVwZGF0ZU1lc3NhZ2VKb2IsXG4gICAgICAgICAgb25FcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBvbkVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNldFN0YXR1cyh7IHN0YXR1czogXCJyZWFkeVwiIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGlzQWJvcnQgfHwgZXJyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgIGlzQWJvcnQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyh7IHN0YXR1czogXCJyZWFkeVwiIH0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlzRXJyb3IgPSB0cnVlO1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiAoZXJyLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImZldGNoXCIpIHx8IGVyci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJuZXR3b3JrXCIpKSkge1xuICAgICAgICBpc0Rpc2Nvbm5lY3QgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub25FcnJvciAmJiBlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcImVycm9yXCIsIGVycm9yOiBlcnIgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIChfYTE3ID0gdGhpcy5vbkZpbmlzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgbWVzc2FnZTogdGhpcy5hY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLFxuICAgICAgICAgIG1lc3NhZ2VzOiB0aGlzLnN0YXRlLm1lc3NhZ2VzLFxuICAgICAgICAgIGlzQWJvcnQsXG4gICAgICAgICAgaXNEaXNjb25uZWN0LFxuICAgICAgICAgIGlzRXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3RpdmVSZXNwb25zZSA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKChfYiA9IHRoaXMuc2VuZEF1dG9tYXRpY2FsbHlXaGVuKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzLCB7IG1lc3NhZ2VzOiB0aGlzLnN0YXRlLm1lc3NhZ2VzIH0pKSB7XG4gICAgICBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KHtcbiAgICAgICAgdHJpZ2dlcjogXCJzdWJtaXQtbWVzc2FnZVwiLFxuICAgICAgICBtZXNzYWdlSWQ6IChfYyA9IHRoaXMubGFzdE1lc3NhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYy5pZCxcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3VpL2xhc3QtYXNzaXN0YW50LW1lc3NhZ2UtaXMtY29tcGxldGUtd2l0aC10b29sLWNhbGxzLnRzXG5mdW5jdGlvbiBsYXN0QXNzaXN0YW50TWVzc2FnZUlzQ29tcGxldGVXaXRoVG9vbENhbGxzKHtcbiAgbWVzc2FnZXNcbn0pIHtcbiAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICBpZiAoIW1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG1lc3NhZ2Uucm9sZSAhPT0gXCJhc3Npc3RhbnRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsYXN0U3RlcFN0YXJ0SW5kZXggPSBtZXNzYWdlLnBhcnRzLnJlZHVjZSgobGFzdEluZGV4LCBwYXJ0LCBpbmRleCkgPT4ge1xuICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwic3RlcC1zdGFydFwiID8gaW5kZXggOiBsYXN0SW5kZXg7XG4gIH0sIC0xKTtcbiAgY29uc3QgbGFzdFN0ZXBUb29sSW52b2NhdGlvbnMgPSBtZXNzYWdlLnBhcnRzLnNsaWNlKGxhc3RTdGVwU3RhcnRJbmRleCArIDEpLmZpbHRlcihpc1Rvb2xPckR5bmFtaWNUb29sVUlQYXJ0KTtcbiAgcmV0dXJuIGxhc3RTdGVwVG9vbEludm9jYXRpb25zLmxlbmd0aCA+IDAgJiYgbGFzdFN0ZXBUb29sSW52b2NhdGlvbnMuZXZlcnkoKHBhcnQpID0+IHBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWF2YWlsYWJsZVwiKTtcbn1cblxuLy8gc3JjL3VpL3RyYW5zZm9ybS10ZXh0LXRvLXVpLW1lc3NhZ2Utc3RyZWFtLnRzXG5mdW5jdGlvbiB0cmFuc2Zvcm1UZXh0VG9VaU1lc3NhZ2VTdHJlYW0oe1xuICBzdHJlYW1cbn0pIHtcbiAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJzdGFydFwiIH0pO1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInN0YXJ0LXN0ZXBcIiB9KTtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0LXN0YXJ0XCIsIGlkOiBcInRleHQtMVwiIH0pO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShwYXJ0LCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1kZWx0YVwiLCBpZDogXCJ0ZXh0LTFcIiwgZGVsdGE6IHBhcnQgfSk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtZW5kXCIsIGlkOiBcInRleHQtMVwiIH0pO1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImZpbmlzaC1zdGVwXCIgfSk7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZmluaXNoXCIgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cblxuLy8gc3JjL3VpL3RleHQtc3RyZWFtLWNoYXQtdHJhbnNwb3J0LnRzXG52YXIgVGV4dFN0cmVhbUNoYXRUcmFuc3BvcnQgPSBjbGFzcyBleHRlbmRzIEh0dHBDaGF0VHJhbnNwb3J0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cbiAgcHJvY2Vzc1Jlc3BvbnNlU3RyZWFtKHN0cmVhbSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1UZXh0VG9VaU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgc3RyZWFtOiBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91aS92YWxpZGF0ZS11aS1tZXNzYWdlcy50c1xuaW1wb3J0IHsgVHlwZVZhbGlkYXRpb25FcnJvciBhcyBUeXBlVmFsaWRhdGlvbkVycm9yNCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICB2YWxpZGF0ZVR5cGVzIGFzIHZhbGlkYXRlVHlwZXMyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB6IGFzIHoxMCB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciB0ZXh0VUlQYXJ0U2NoZW1hID0gejEwLm9iamVjdCh7XG4gIHR5cGU6IHoxMC5saXRlcmFsKFwidGV4dFwiKSxcbiAgdGV4dDogejEwLnN0cmluZygpLFxuICBzdGF0ZTogejEwLmVudW0oW1wic3RyZWFtaW5nXCIsIFwiZG9uZVwiXSkub3B0aW9uYWwoKSxcbiAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciByZWFzb25pbmdVSVBhcnRTY2hlbWEgPSB6MTAub2JqZWN0KHtcbiAgdHlwZTogejEwLmxpdGVyYWwoXCJyZWFzb25pbmdcIiksXG4gIHRleHQ6IHoxMC5zdHJpbmcoKSxcbiAgc3RhdGU6IHoxMC5lbnVtKFtcInN0cmVhbWluZ1wiLCBcImRvbmVcIl0pLm9wdGlvbmFsKCksXG4gIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgc291cmNlVXJsVUlQYXJ0U2NoZW1hID0gejEwLm9iamVjdCh7XG4gIHR5cGU6IHoxMC5saXRlcmFsKFwic291cmNlLXVybFwiKSxcbiAgc291cmNlSWQ6IHoxMC5zdHJpbmcoKSxcbiAgdXJsOiB6MTAuc3RyaW5nKCksXG4gIHRpdGxlOiB6MTAuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBzb3VyY2VEb2N1bWVudFVJUGFydFNjaGVtYSA9IHoxMC5vYmplY3Qoe1xuICB0eXBlOiB6MTAubGl0ZXJhbChcInNvdXJjZS1kb2N1bWVudFwiKSxcbiAgc291cmNlSWQ6IHoxMC5zdHJpbmcoKSxcbiAgbWVkaWFUeXBlOiB6MTAuc3RyaW5nKCksXG4gIHRpdGxlOiB6MTAuc3RyaW5nKCksXG4gIGZpbGVuYW1lOiB6MTAuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBmaWxlVUlQYXJ0U2NoZW1hID0gejEwLm9iamVjdCh7XG4gIHR5cGU6IHoxMC5saXRlcmFsKFwiZmlsZVwiKSxcbiAgbWVkaWFUeXBlOiB6MTAuc3RyaW5nKCksXG4gIGZpbGVuYW1lOiB6MTAuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgdXJsOiB6MTAuc3RyaW5nKCksXG4gIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgc3RlcFN0YXJ0VUlQYXJ0U2NoZW1hID0gejEwLm9iamVjdCh7XG4gIHR5cGU6IHoxMC5saXRlcmFsKFwic3RlcC1zdGFydFwiKVxufSk7XG52YXIgZGF0YVVJUGFydFNjaGVtYSA9IHoxMC5vYmplY3Qoe1xuICB0eXBlOiB6MTAuc3RyaW5nKCkuc3RhcnRzV2l0aChcImRhdGEtXCIpLFxuICBpZDogejEwLnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGRhdGE6IHoxMC51bmtub3duKClcbn0pO1xudmFyIGR5bmFtaWNUb29sVUlQYXJ0U2NoZW1hcyA9IFtcbiAgejEwLm9iamVjdCh7XG4gICAgdHlwZTogejEwLmxpdGVyYWwoXCJkeW5hbWljLXRvb2xcIiksXG4gICAgdG9vbE5hbWU6IHoxMC5zdHJpbmcoKSxcbiAgICB0b29sQ2FsbElkOiB6MTAuc3RyaW5nKCksXG4gICAgc3RhdGU6IHoxMC5saXRlcmFsKFwiaW5wdXQtc3RyZWFtaW5nXCIpLFxuICAgIGlucHV0OiB6MTAudW5rbm93bigpLm9wdGlvbmFsKCksXG4gICAgb3V0cHV0OiB6MTAubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgIGVycm9yVGV4dDogejEwLm5ldmVyKCkub3B0aW9uYWwoKVxuICB9KSxcbiAgejEwLm9iamVjdCh7XG4gICAgdHlwZTogejEwLmxpdGVyYWwoXCJkeW5hbWljLXRvb2xcIiksXG4gICAgdG9vbE5hbWU6IHoxMC5zdHJpbmcoKSxcbiAgICB0b29sQ2FsbElkOiB6MTAuc3RyaW5nKCksXG4gICAgc3RhdGU6IHoxMC5saXRlcmFsKFwiaW5wdXQtYXZhaWxhYmxlXCIpLFxuICAgIGlucHV0OiB6MTAudW5rbm93bigpLFxuICAgIG91dHB1dDogejEwLm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICBlcnJvclRleHQ6IHoxMC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICB9KSxcbiAgejEwLm9iamVjdCh7XG4gICAgdHlwZTogejEwLmxpdGVyYWwoXCJkeW5hbWljLXRvb2xcIiksXG4gICAgdG9vbE5hbWU6IHoxMC5zdHJpbmcoKSxcbiAgICB0b29sQ2FsbElkOiB6MTAuc3RyaW5nKCksXG4gICAgc3RhdGU6IHoxMC5saXRlcmFsKFwib3V0cHV0LWF2YWlsYWJsZVwiKSxcbiAgICBpbnB1dDogejEwLnVua25vd24oKSxcbiAgICBvdXRwdXQ6IHoxMC51bmtub3duKCksXG4gICAgZXJyb3JUZXh0OiB6MTAubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgcHJlbGltaW5hcnk6IHoxMC5ib29sZWFuKCkub3B0aW9uYWwoKVxuICB9KSxcbiAgejEwLm9iamVjdCh7XG4gICAgdHlwZTogejEwLmxpdGVyYWwoXCJkeW5hbWljLXRvb2xcIiksXG4gICAgdG9vbE5hbWU6IHoxMC5zdHJpbmcoKSxcbiAgICB0b29sQ2FsbElkOiB6MTAuc3RyaW5nKCksXG4gICAgc3RhdGU6IHoxMC5saXRlcmFsKFwib3V0cHV0LWVycm9yXCIpLFxuICAgIGlucHV0OiB6MTAudW5rbm93bigpLFxuICAgIG91dHB1dDogejEwLm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICBlcnJvclRleHQ6IHoxMC5zdHJpbmcoKSxcbiAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH0pXG5dO1xudmFyIHRvb2xVSVBhcnRTY2hlbWFzID0gW1xuICB6MTAub2JqZWN0KHtcbiAgICB0eXBlOiB6MTAuc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgIHRvb2xDYWxsSWQ6IHoxMC5zdHJpbmcoKSxcbiAgICBzdGF0ZTogejEwLmxpdGVyYWwoXCJpbnB1dC1zdHJlYW1pbmdcIiksXG4gICAgaW5wdXQ6IHoxMC51bmtub3duKCkub3B0aW9uYWwoKSxcbiAgICBvdXRwdXQ6IHoxMC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgZXJyb3JUZXh0OiB6MTAubmV2ZXIoKS5vcHRpb25hbCgpXG4gIH0pLFxuICB6MTAub2JqZWN0KHtcbiAgICB0eXBlOiB6MTAuc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgIHRvb2xDYWxsSWQ6IHoxMC5zdHJpbmcoKSxcbiAgICBzdGF0ZTogejEwLmxpdGVyYWwoXCJpbnB1dC1hdmFpbGFibGVcIiksXG4gICAgaW5wdXQ6IHoxMC51bmtub3duKCksXG4gICAgb3V0cHV0OiB6MTAubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgIGVycm9yVGV4dDogejEwLm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH0pLFxuICB6MTAub2JqZWN0KHtcbiAgICB0eXBlOiB6MTAuc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgIHRvb2xDYWxsSWQ6IHoxMC5zdHJpbmcoKSxcbiAgICBzdGF0ZTogejEwLmxpdGVyYWwoXCJvdXRwdXQtYXZhaWxhYmxlXCIpLFxuICAgIGlucHV0OiB6MTAudW5rbm93bigpLFxuICAgIG91dHB1dDogejEwLnVua25vd24oKSxcbiAgICBlcnJvclRleHQ6IHoxMC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICBwcmVsaW1pbmFyeTogejEwLmJvb2xlYW4oKS5vcHRpb25hbCgpXG4gIH0pLFxuICB6MTAub2JqZWN0KHtcbiAgICB0eXBlOiB6MTAuc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgIHRvb2xDYWxsSWQ6IHoxMC5zdHJpbmcoKSxcbiAgICBzdGF0ZTogejEwLmxpdGVyYWwoXCJvdXRwdXQtZXJyb3JcIiksXG4gICAgaW5wdXQ6IHoxMC51bmtub3duKCksXG4gICAgb3V0cHV0OiB6MTAubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgIGVycm9yVGV4dDogejEwLnN0cmluZygpLFxuICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgfSlcbl07XG52YXIgdWlNZXNzYWdlU2NoZW1hID0gejEwLm9iamVjdCh7XG4gIGlkOiB6MTAuc3RyaW5nKCksXG4gIHJvbGU6IHoxMC5lbnVtKFtcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIl0pLFxuICBtZXRhZGF0YTogejEwLnVua25vd24oKS5vcHRpb25hbCgpLFxuICBwYXJ0czogejEwLmFycmF5KFxuICAgIHoxMC51bmlvbihbXG4gICAgICB0ZXh0VUlQYXJ0U2NoZW1hLFxuICAgICAgcmVhc29uaW5nVUlQYXJ0U2NoZW1hLFxuICAgICAgc291cmNlVXJsVUlQYXJ0U2NoZW1hLFxuICAgICAgc291cmNlRG9jdW1lbnRVSVBhcnRTY2hlbWEsXG4gICAgICBmaWxlVUlQYXJ0U2NoZW1hLFxuICAgICAgc3RlcFN0YXJ0VUlQYXJ0U2NoZW1hLFxuICAgICAgZGF0YVVJUGFydFNjaGVtYSxcbiAgICAgIC4uLmR5bmFtaWNUb29sVUlQYXJ0U2NoZW1hcyxcbiAgICAgIC4uLnRvb2xVSVBhcnRTY2hlbWFzXG4gICAgXSlcbiAgKVxufSk7XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVVJTWVzc2FnZXMoe1xuICBtZXNzYWdlcyxcbiAgbWV0YWRhdGFTY2hlbWEsXG4gIGRhdGFTY2hlbWFzLFxuICB0b29sc1xufSkge1xuICBpZiAobWVzc2FnZXMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBwYXJhbWV0ZXI6IFwibWVzc2FnZXNcIixcbiAgICAgIHZhbHVlOiBtZXNzYWdlcyxcbiAgICAgIG1lc3NhZ2U6IFwibWVzc2FnZXMgcGFyYW1ldGVyIG11c3QgYmUgcHJvdmlkZWRcIlxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHZhbGlkYXRlZE1lc3NhZ2VzID0gYXdhaXQgdmFsaWRhdGVUeXBlczIoe1xuICAgIHZhbHVlOiBtZXNzYWdlcyxcbiAgICBzY2hlbWE6IHoxMC5hcnJheSh1aU1lc3NhZ2VTY2hlbWEpXG4gIH0pO1xuICBpZiAobWV0YWRhdGFTY2hlbWEpIHtcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgdmFsaWRhdGVkTWVzc2FnZXMpIHtcbiAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgdmFsdWU6IG1lc3NhZ2UubWV0YWRhdGEsXG4gICAgICAgIHNjaGVtYTogbWV0YWRhdGFTY2hlbWFcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoZGF0YVNjaGVtYXMpIHtcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgdmFsaWRhdGVkTWVzc2FnZXMpIHtcbiAgICAgIGNvbnN0IGRhdGFQYXJ0cyA9IG1lc3NhZ2UucGFydHMuZmlsdGVyKFxuICAgICAgICAocGFydCkgPT4gcGFydC50eXBlLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKVxuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3QgZGF0YVBhcnQgb2YgZGF0YVBhcnRzKSB7XG4gICAgICAgIGNvbnN0IGRhdGFOYW1lID0gZGF0YVBhcnQudHlwZS5zbGljZSg1KTtcbiAgICAgICAgY29uc3QgZGF0YVNjaGVtYSA9IGRhdGFTY2hlbWFzW2RhdGFOYW1lXTtcbiAgICAgICAgaWYgKCFkYXRhU2NoZW1hKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3I0KHtcbiAgICAgICAgICAgIHZhbHVlOiBkYXRhUGFydC5kYXRhLFxuICAgICAgICAgICAgY2F1c2U6IGBObyBkYXRhIHNjaGVtYSBmb3VuZCBmb3IgZGF0YSBwYXJ0ICR7ZGF0YU5hbWV9YFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgICB2YWx1ZTogZGF0YVBhcnQuZGF0YSxcbiAgICAgICAgICBzY2hlbWE6IGRhdGFTY2hlbWFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh0b29scykge1xuICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiB2YWxpZGF0ZWRNZXNzYWdlcykge1xuICAgICAgY29uc3QgdG9vbFBhcnRzID0gbWVzc2FnZS5wYXJ0cy5maWx0ZXIoXG4gICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUuc3RhcnRzV2l0aChcInRvb2wtXCIpXG4gICAgICApO1xuICAgICAgZm9yIChjb25zdCB0b29sUGFydCBvZiB0b29sUGFydHMpIHtcbiAgICAgICAgY29uc3QgdG9vbE5hbWUgPSB0b29sUGFydC50eXBlLnNsaWNlKDUpO1xuICAgICAgICBjb25zdCB0b29sMyA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgaWYgKCF0b29sMykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yNCh7XG4gICAgICAgICAgICB2YWx1ZTogdG9vbFBhcnQuaW5wdXQsXG4gICAgICAgICAgICBjYXVzZTogYE5vIHRvb2wgc2NoZW1hIGZvdW5kIGZvciB0b29sIHBhcnQgJHt0b29sTmFtZX1gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvb2xQYXJ0LnN0YXRlID09PSBcImlucHV0LWF2YWlsYWJsZVwiIHx8IHRvb2xQYXJ0LnN0YXRlID09PSBcIm91dHB1dC1hdmFpbGFibGVcIiB8fCB0b29sUGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtZXJyb3JcIikge1xuICAgICAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgICAgIHZhbHVlOiB0b29sUGFydC5pbnB1dCxcbiAgICAgICAgICAgIHNjaGVtYTogdG9vbDMuaW5wdXRTY2hlbWFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9vbFBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWF2YWlsYWJsZVwiICYmIHRvb2wzLm91dHB1dFNjaGVtYSkge1xuICAgICAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgICAgIHZhbHVlOiB0b29sUGFydC5vdXRwdXQsXG4gICAgICAgICAgICBzY2hlbWE6IHRvb2wzLm91dHB1dFNjaGVtYVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxpZGF0ZWRNZXNzYWdlcztcbn1cblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL2NyZWF0ZS11aS1tZXNzYWdlLXN0cmVhbS50c1xuaW1wb3J0IHtcbiAgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkRnVuYzIsXG4gIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2U4XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5mdW5jdGlvbiBjcmVhdGVVSU1lc3NhZ2VTdHJlYW0oe1xuICBleGVjdXRlLFxuICBvbkVycm9yID0gZ2V0RXJyb3JNZXNzYWdlOCxcbiAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgb25GaW5pc2gsXG4gIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gZ2VuZXJhdGVJZEZ1bmMyXG59KSB7XG4gIGxldCBjb250cm9sbGVyO1xuICBjb25zdCBvbmdvaW5nU3RyZWFtUHJvbWlzZXMgPSBbXTtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyQXJnKSB7XG4gICAgICBjb250cm9sbGVyID0gY29udHJvbGxlckFyZztcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBzYWZlRW5xdWV1ZShkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGV4ZWN1dGUoe1xuICAgICAgd3JpdGVyOiB7XG4gICAgICAgIHdyaXRlKHBhcnQpIHtcbiAgICAgICAgICBzYWZlRW5xdWV1ZShwYXJ0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyZ2Uoc3RyZWFtQXJnKSB7XG4gICAgICAgICAgb25nb2luZ1N0cmVhbVByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW1BcmcuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHNhZmVFbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgc2FmZUVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBlcnJvclRleHQ6IG9uRXJyb3IoZXJyb3IpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgb25nb2luZ1N0cmVhbVByb21pc2VzLnB1c2goXG4gICAgICAgIHJlc3VsdC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICBzYWZlRW5xdWV1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICBlcnJvclRleHQ6IG9uRXJyb3IoZXJyb3IpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBzYWZlRW5xdWV1ZSh7XG4gICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICBlcnJvclRleHQ6IG9uRXJyb3IoZXJyb3IpXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgd2FpdEZvclN0cmVhbXMgPSBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZTIpID0+IHtcbiAgICB3aGlsZSAob25nb2luZ1N0cmVhbVByb21pc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGF3YWl0IG9uZ29pbmdTdHJlYW1Qcm9taXNlcy5zaGlmdCgpO1xuICAgIH1cbiAgICByZXNvbHZlMigpO1xuICB9KTtcbiAgd2FpdEZvclN0cmVhbXMuZmluYWxseSgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBoYW5kbGVVSU1lc3NhZ2VTdHJlYW1GaW5pc2goe1xuICAgIHN0cmVhbSxcbiAgICBtZXNzYWdlSWQ6IGdlbmVyYXRlSWQzKCksXG4gICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICBvbkZpbmlzaCxcbiAgICBvbkVycm9yXG4gIH0pO1xufVxuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vcmVhZC11aS1tZXNzYWdlLXN0cmVhbS50c1xuZnVuY3Rpb24gcmVhZFVJTWVzc2FnZVN0cmVhbSh7XG4gIG1lc3NhZ2UsXG4gIHN0cmVhbSxcbiAgb25FcnJvcixcbiAgdGVybWluYXRlT25FcnJvciA9IGZhbHNlXG59KSB7XG4gIHZhciBfYTE3O1xuICBsZXQgY29udHJvbGxlcjtcbiAgbGV0IGhhc0Vycm9yZWQgPSBmYWxzZTtcbiAgY29uc3Qgb3V0cHV0U3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyUGFyYW0pIHtcbiAgICAgIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyUGFyYW07XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc3RhdGUgPSBjcmVhdGVTdHJlYW1pbmdVSU1lc3NhZ2VTdGF0ZSh7XG4gICAgbWVzc2FnZUlkOiAoX2ExNyA9IG1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2UuaWQpICE9IG51bGwgPyBfYTE3IDogXCJcIixcbiAgICBsYXN0TWVzc2FnZTogbWVzc2FnZVxuICB9KTtcbiAgY29uc3QgaGFuZGxlRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICBvbkVycm9yID09IG51bGwgPyB2b2lkIDAgOiBvbkVycm9yKGVycm9yKTtcbiAgICBpZiAoIWhhc0Vycm9yZWQgJiYgdGVybWluYXRlT25FcnJvcikge1xuICAgICAgaGFzRXJyb3JlZCA9IHRydWU7XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH07XG4gIGNvbnN1bWVTdHJlYW0oe1xuICAgIHN0cmVhbTogcHJvY2Vzc1VJTWVzc2FnZVN0cmVhbSh7XG4gICAgICBzdHJlYW0sXG4gICAgICBydW5VcGRhdGVNZXNzYWdlSm9iKGpvYikge1xuICAgICAgICByZXR1cm4gam9iKHtcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB3cml0ZTogKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lbnF1ZXVlKHN0cnVjdHVyZWRDbG9uZShzdGF0ZS5tZXNzYWdlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiBoYW5kbGVFcnJvclxuICAgIH0pLFxuICAgIG9uRXJyb3I6IGhhbmRsZUVycm9yXG4gIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgIGlmICghaGFzRXJyb3JlZCkge1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKG91dHB1dFN0cmVhbSk7XG59XG5leHBvcnQge1xuICBBSVNES0Vycm9yMTcgYXMgQUlTREtFcnJvcixcbiAgQVBJQ2FsbEVycm9yLFxuICBBYnN0cmFjdENoYXQsXG4gIERlZmF1bHRDaGF0VHJhbnNwb3J0LFxuICBEb3dubG9hZEVycm9yLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBBZ2VudCBhcyBFeHBlcmltZW50YWxfQWdlbnQsXG4gIEh0dHBDaGF0VHJhbnNwb3J0LFxuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZERhdGFDb250ZW50RXJyb3IsXG4gIEludmFsaWRNZXNzYWdlUm9sZUVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSW52YWxpZFN0cmVhbVBhcnRFcnJvcixcbiAgSW52YWxpZFRvb2xJbnB1dEVycm9yLFxuICBKU09OUGFyc2VFcnJvcixcbiAgSnNvblRvU3NlVHJhbnNmb3JtU3RyZWFtLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIE1DUENsaWVudEVycm9yLFxuICBNZXNzYWdlQ29udmVyc2lvbkVycm9yLFxuICBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvcixcbiAgTm9JbWFnZUdlbmVyYXRlZEVycm9yLFxuICBOb09iamVjdEdlbmVyYXRlZEVycm9yLFxuICBOb091dHB1dEdlbmVyYXRlZEVycm9yLFxuICBOb091dHB1dFNwZWNpZmllZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBOb1N1Y2hQcm92aWRlckVycm9yLFxuICBOb1N1Y2hUb29sRXJyb3IsXG4gIG91dHB1dF9leHBvcnRzIGFzIE91dHB1dCxcbiAgUmV0cnlFcnJvcixcbiAgU2VyaWFsSm9iRXhlY3V0b3IsXG4gIFRleHRTdHJlYW1DaGF0VHJhbnNwb3J0LFxuICBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yLFxuICBUb29sQ2FsbFJlcGFpckVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVSV9NRVNTQUdFX1NUUkVBTV9IRUFERVJTLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcixcbiAgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvcixcbiAgYXNTY2hlbWE1IGFzIGFzU2NoZW1hLFxuICBhc3Npc3RhbnRNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIGNhbGxDb21wbGV0aW9uQXBpLFxuICBjb25zdW1lU3RyZWFtLFxuICBjb252ZXJ0RmlsZUxpc3RUb0ZpbGVVSVBhcnRzLFxuICBjb252ZXJ0VG9Db3JlTWVzc2FnZXMsXG4gIGNvbnZlcnRUb01vZGVsTWVzc2FnZXMsXG4gIGNvcmVBc3Npc3RhbnRNZXNzYWdlU2NoZW1hLFxuICBjb3JlTWVzc2FnZVNjaGVtYSxcbiAgY29yZVN5c3RlbU1lc3NhZ2VTY2hlbWEsXG4gIGNvcmVUb29sTWVzc2FnZVNjaGVtYSxcbiAgY29yZVVzZXJNZXNzYWdlU2NoZW1hLFxuICBjb3NpbmVTaW1pbGFyaXR5LFxuICBjcmVhdGVHYXRld2F5LFxuICBjcmVhdGVJZEdlbmVyYXRvcjUgYXMgY3JlYXRlSWRHZW5lcmF0b3IsXG4gIGNyZWF0ZVByb3ZpZGVyUmVnaXN0cnksXG4gIGNyZWF0ZVRleHRTdHJlYW1SZXNwb25zZSxcbiAgY3JlYXRlVUlNZXNzYWdlU3RyZWFtLFxuICBjcmVhdGVVSU1lc3NhZ2VTdHJlYW1SZXNwb25zZSxcbiAgY3VzdG9tUHJvdmlkZXIsXG4gIGRlZmF1bHRTZXR0aW5nc01pZGRsZXdhcmUsXG4gIGR5bmFtaWNUb29sMiBhcyBkeW5hbWljVG9vbCxcbiAgZW1iZWQsXG4gIGVtYmVkTWFueSxcbiAgY3JlYXRlTUNQQ2xpZW50IGFzIGV4cGVyaW1lbnRhbF9jcmVhdGVNQ1BDbGllbnQsXG4gIGV4cGVyaW1lbnRhbF9jcmVhdGVQcm92aWRlclJlZ2lzdHJ5LFxuICBleHBlcmltZW50YWxfY3VzdG9tUHJvdmlkZXIsXG4gIGdlbmVyYXRlSW1hZ2UgYXMgZXhwZXJpbWVudGFsX2dlbmVyYXRlSW1hZ2UsXG4gIGdlbmVyYXRlU3BlZWNoIGFzIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZVNwZWVjaCxcbiAgdHJhbnNjcmliZSBhcyBleHBlcmltZW50YWxfdHJhbnNjcmliZSxcbiAgZXh0cmFjdFJlYXNvbmluZ01pZGRsZXdhcmUsXG4gIGdhdGV3YXkyIGFzIGdhdGV3YXksXG4gIGdlbmVyYXRlSWQyIGFzIGdlbmVyYXRlSWQsXG4gIGdlbmVyYXRlT2JqZWN0LFxuICBnZW5lcmF0ZVRleHQsXG4gIGdldFRleHRGcm9tRGF0YVVybCxcbiAgZ2V0VG9vbE5hbWUsXG4gIGdldFRvb2xPckR5bmFtaWNUb29sTmFtZSxcbiAgaGFzVG9vbENhbGwsXG4gIGlzRGVlcEVxdWFsRGF0YSxcbiAgaXNUb29sT3JEeW5hbWljVG9vbFVJUGFydCxcbiAgaXNUb29sVUlQYXJ0LFxuICBqc29uU2NoZW1hMiBhcyBqc29uU2NoZW1hLFxuICBsYXN0QXNzaXN0YW50TWVzc2FnZUlzQ29tcGxldGVXaXRoVG9vbENhbGxzLFxuICBtb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHBhcnNlUGFydGlhbEpzb24sXG4gIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZSxcbiAgcGlwZVVJTWVzc2FnZVN0cmVhbVRvUmVzcG9uc2UsXG4gIHJlYWRVSU1lc3NhZ2VTdHJlYW0sXG4gIHNpbXVsYXRlUmVhZGFibGVTdHJlYW0sXG4gIHNpbXVsYXRlU3RyZWFtaW5nTWlkZGxld2FyZSxcbiAgc21vb3RoU3RyZWFtLFxuICBzdGVwQ291bnRJcyxcbiAgc3RyZWFtT2JqZWN0LFxuICBzdHJlYW1UZXh0LFxuICBzeXN0ZW1Nb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHRvb2wyIGFzIHRvb2wsXG4gIHRvb2xNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHVzZXJNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHZhbGlkYXRlVUlNZXNzYWdlcyxcbiAgd3JhcExhbmd1YWdlTW9kZWwsXG4gIHdyYXBQcm92aWRlcixcbiAgem9kU2NoZW1hXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError),\n/* harmony export */   AbstractChat: () => (/* binding */ AbstractChat),\n/* harmony export */   DefaultChatTransport: () => (/* binding */ DefaultChatTransport),\n/* harmony export */   DownloadError: () => (/* binding */ DownloadError),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError),\n/* harmony export */   Experimental_Agent: () => (/* binding */ Agent),\n/* harmony export */   HttpChatTransport: () => (/* binding */ HttpChatTransport),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* binding */ InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidResponseDataError),\n/* harmony export */   InvalidStreamPartError: () => (/* binding */ InvalidStreamPartError),\n/* harmony export */   InvalidToolInputError: () => (/* binding */ InvalidToolInputError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError),\n/* harmony export */   JsonToSseTransformStream: () => (/* binding */ JsonToSseTransformStream),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError),\n/* harmony export */   MCPClientError: () => (/* binding */ MCPClientError),\n/* harmony export */   MessageConversionError: () => (/* binding */ MessageConversionError),\n/* harmony export */   NoContentGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoContentGeneratedError),\n/* harmony export */   NoImageGeneratedError: () => (/* binding */ NoImageGeneratedError),\n/* harmony export */   NoObjectGeneratedError: () => (/* binding */ NoObjectGeneratedError),\n/* harmony export */   NoOutputGeneratedError: () => (/* binding */ NoOutputGeneratedError),\n/* harmony export */   NoOutputSpecifiedError: () => (/* binding */ NoOutputSpecifiedError),\n/* harmony export */   NoSuchModelError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* binding */ NoSuchToolError),\n/* harmony export */   Output: () => (/* binding */ output_exports),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   SerialJobExecutor: () => (/* binding */ SerialJobExecutor),\n/* harmony export */   TextStreamChatTransport: () => (/* binding */ TextStreamChatTransport),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TooManyEmbeddingValuesForCallError),\n/* harmony export */   ToolCallRepairError: () => (/* binding */ ToolCallRepairError),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError),\n/* harmony export */   UI_MESSAGE_STREAM_HEADERS: () => (/* binding */ UI_MESSAGE_STREAM_HEADERS),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError),\n/* harmony export */   UnsupportedModelVersionError: () => (/* binding */ UnsupportedModelVersionError),\n/* harmony export */   asSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema),\n/* harmony export */   assistantModelMessageSchema: () => (/* binding */ assistantModelMessageSchema),\n/* harmony export */   callCompletionApi: () => (/* binding */ callCompletionApi),\n/* harmony export */   consumeStream: () => (/* binding */ consumeStream),\n/* harmony export */   convertFileListToFileUIParts: () => (/* binding */ convertFileListToFileUIParts),\n/* harmony export */   convertToCoreMessages: () => (/* binding */ convertToCoreMessages),\n/* harmony export */   convertToModelMessages: () => (/* binding */ convertToModelMessages),\n/* harmony export */   coreAssistantMessageSchema: () => (/* binding */ coreAssistantMessageSchema),\n/* harmony export */   coreMessageSchema: () => (/* binding */ coreMessageSchema),\n/* harmony export */   coreSystemMessageSchema: () => (/* binding */ coreSystemMessageSchema),\n/* harmony export */   coreToolMessageSchema: () => (/* binding */ coreToolMessageSchema),\n/* harmony export */   coreUserMessageSchema: () => (/* binding */ coreUserMessageSchema),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createGateway: () => (/* reexport safe */ _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.createGateway),\n/* harmony export */   createIdGenerator: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator),\n/* harmony export */   createProviderRegistry: () => (/* binding */ createProviderRegistry),\n/* harmony export */   createTextStreamResponse: () => (/* binding */ createTextStreamResponse),\n/* harmony export */   createUIMessageStream: () => (/* binding */ createUIMessageStream),\n/* harmony export */   createUIMessageStreamResponse: () => (/* binding */ createUIMessageStreamResponse),\n/* harmony export */   customProvider: () => (/* binding */ customProvider),\n/* harmony export */   defaultSettingsMiddleware: () => (/* binding */ defaultSettingsMiddleware),\n/* harmony export */   dynamicTool: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.dynamicTool),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_createMCPClient: () => (/* binding */ createMCPClient),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_customProvider: () => (/* binding */ experimental_customProvider),\n/* harmony export */   experimental_generateImage: () => (/* binding */ generateImage),\n/* harmony export */   experimental_generateSpeech: () => (/* binding */ generateSpeech),\n/* harmony export */   experimental_transcribe: () => (/* binding */ transcribe),\n/* harmony export */   extractReasoningMiddleware: () => (/* binding */ extractReasoningMiddleware),\n/* harmony export */   gateway: () => (/* reexport safe */ _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.gateway),\n/* harmony export */   generateId: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   getTextFromDataUrl: () => (/* binding */ getTextFromDataUrl),\n/* harmony export */   getToolName: () => (/* binding */ getToolName),\n/* harmony export */   getToolOrDynamicToolName: () => (/* binding */ getToolOrDynamicToolName),\n/* harmony export */   hasToolCall: () => (/* binding */ hasToolCall),\n/* harmony export */   isDeepEqualData: () => (/* binding */ isDeepEqualData),\n/* harmony export */   isToolOrDynamicToolUIPart: () => (/* binding */ isToolOrDynamicToolUIPart),\n/* harmony export */   isToolUIPart: () => (/* binding */ isToolUIPart),\n/* harmony export */   jsonSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.jsonSchema),\n/* harmony export */   lastAssistantMessageIsCompleteWithToolCalls: () => (/* binding */ lastAssistantMessageIsCompleteWithToolCalls),\n/* harmony export */   modelMessageSchema: () => (/* binding */ modelMessageSchema),\n/* harmony export */   parsePartialJson: () => (/* binding */ parsePartialJson),\n/* harmony export */   pipeTextStreamToResponse: () => (/* binding */ pipeTextStreamToResponse),\n/* harmony export */   pipeUIMessageStreamToResponse: () => (/* binding */ pipeUIMessageStreamToResponse),\n/* harmony export */   readUIMessageStream: () => (/* binding */ readUIMessageStream),\n/* harmony export */   simulateReadableStream: () => (/* binding */ simulateReadableStream),\n/* harmony export */   simulateStreamingMiddleware: () => (/* binding */ simulateStreamingMiddleware),\n/* harmony export */   smoothStream: () => (/* binding */ smoothStream),\n/* harmony export */   stepCountIs: () => (/* binding */ stepCountIs),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   systemModelMessageSchema: () => (/* binding */ systemModelMessageSchema),\n/* harmony export */   tool: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.tool),\n/* harmony export */   toolModelMessageSchema: () => (/* binding */ toolModelMessageSchema),\n/* harmony export */   userModelMessageSchema: () => (/* binding */ userModelMessageSchema),\n/* harmony export */   validateUIMessages: () => (/* binding */ validateUIMessages),\n/* harmony export */   wrapLanguageModel: () => (/* binding */ wrapLanguageModel),\n/* harmony export */   wrapProvider: () => (/* binding */ wrapProvider),\n/* harmony export */   zodSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.zodSchema)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/gateway */ \"(ssr)/./node_modules/@ai-sdk/gateway/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(ssr)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(ssr)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var zod_v4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod/v4 */ \"(ssr)/./node_modules/zod/v4/classic/schemas.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/@opentelemetry/api/build/esm/trace-api.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/@opentelemetry/api/build/esm/trace/status.js\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(ssr)/./node_modules/eventsource-parser/dist/stream.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name17 in all)\n    __defProp(target, name17, { get: all[name17], enumerable: true });\n};\n\n// src/index.ts\n\n\n\n// src/generate-text/generate-text.ts\n\n\n// src/error/no-output-specified-error.ts\n\nvar name = \"AI_NoOutputSpecifiedError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar NoOutputSpecifiedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  // used in isInstance\n  constructor({ message = \"No output specified.\" } = {}) {\n    super({ name, message });\n    this[_a] = true;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker);\n  }\n};\n_a = symbol;\n\n// src/logger/log-warnings.ts\nfunction formatWarning(warning) {\n  const prefix = \"AI SDK Warning:\";\n  switch (warning.type) {\n    case \"unsupported-setting\": {\n      let message = `${prefix} The \"${warning.setting}\" setting is not supported by this model`;\n      if (warning.details) {\n        message += ` - ${warning.details}`;\n      }\n      return message;\n    }\n    case \"unsupported-tool\": {\n      const toolName = \"name\" in warning.tool ? warning.tool.name : \"unknown tool\";\n      let message = `${prefix} The tool \"${toolName}\" is not supported by this model`;\n      if (warning.details) {\n        message += ` - ${warning.details}`;\n      }\n      return message;\n    }\n    case \"other\": {\n      return `${prefix} ${warning.message}`;\n    }\n    default: {\n      return `${prefix} ${JSON.stringify(warning, null, 2)}`;\n    }\n  }\n}\nvar FIRST_WARNING_INFO_MESSAGE = \"AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.\";\nvar hasLoggedBefore = false;\nvar logWarnings = (warnings) => {\n  if (warnings.length === 0) {\n    return;\n  }\n  const logger = globalThis.AI_SDK_LOG_WARNINGS;\n  if (logger === false) {\n    return;\n  }\n  if (typeof logger === \"function\") {\n    logger(warnings);\n    return;\n  }\n  if (!hasLoggedBefore) {\n    hasLoggedBefore = true;\n    console.info(FIRST_WARNING_INFO_MESSAGE);\n  }\n  for (const warning of warnings) {\n    console.warn(formatWarning(warning));\n  }\n};\n\n// src/model/resolve-model.ts\n\n\n// src/error/index.ts\n\n\n// src/error/invalid-argument-error.ts\n\nvar name2 = \"AI_InvalidArgumentError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    parameter,\n    value,\n    message\n  }) {\n    super({\n      name: name2,\n      message: `Invalid argument for parameter ${parameter}: ${message}`\n    });\n    this[_a2] = true;\n    this.parameter = parameter;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker2);\n  }\n};\n_a2 = symbol2;\n\n// src/error/invalid-stream-part-error.ts\n\nvar name3 = \"AI_InvalidStreamPartError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidStreamPartError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    chunk,\n    message\n  }) {\n    super({ name: name3, message });\n    this[_a3] = true;\n    this.chunk = chunk;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker3);\n  }\n};\n_a3 = symbol3;\n\n// src/error/invalid-tool-input-error.ts\n\nvar name4 = \"AI_InvalidToolInputError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidToolInputError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolInput,\n    toolName,\n    cause,\n    message = `Invalid input for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(cause)}`\n  }) {\n    super({ name: name4, message, cause });\n    this[_a4] = true;\n    this.toolInput = toolInput;\n    this.toolName = toolName;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\n\n// src/error/mcp-client-error.ts\n\nvar name5 = \"AI_MCPClientError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar MCPClientError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    name: name17 = \"MCPClientError\",\n    message,\n    cause\n  }) {\n    super({ name: name17, message, cause });\n    this[_a5] = true;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker5);\n  }\n};\n_a5 = symbol5;\n\n// src/error/no-image-generated-error.ts\n\nvar name6 = \"AI_NoImageGeneratedError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar NoImageGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message = \"No image generated.\",\n    cause,\n    responses\n  }) {\n    super({ name: name6, message, cause });\n    this[_a6] = true;\n    this.responses = responses;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker6);\n  }\n};\n_a6 = symbol6;\n\n// src/error/no-object-generated-error.ts\n\nvar name7 = \"AI_NoObjectGeneratedError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar NoObjectGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message = \"No object generated.\",\n    cause,\n    text: text2,\n    response,\n    usage,\n    finishReason\n  }) {\n    super({ name: name7, message, cause });\n    this[_a7] = true;\n    this.text = text2;\n    this.response = response;\n    this.usage = usage;\n    this.finishReason = finishReason;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\n\n// src/error/no-output-generated-error.ts\n\nvar name8 = \"AI_NoOutputGeneratedError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar NoOutputGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  // used in isInstance\n  constructor({\n    message = \"No output generated.\",\n    cause\n  } = {}) {\n    super({ name: name8, message, cause });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker8);\n  }\n};\n_a8 = symbol8;\n\n// src/error/no-such-tool-error.ts\n\nvar name9 = \"AI_NoSuchToolError\";\nvar marker9 = `vercel.ai.error.${name9}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolName,\n    availableTools = void 0,\n    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}`\n  }) {\n    super({ name: name9, message });\n    this[_a9] = true;\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker9);\n  }\n};\n_a9 = symbol9;\n\n// src/error/tool-call-repair-error.ts\n\nvar name10 = \"AI_ToolCallRepairError\";\nvar marker10 = `vercel.ai.error.${name10}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar ToolCallRepairError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    cause,\n    originalError,\n    message = `Error repairing tool call: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(cause)}`\n  }) {\n    super({ name: name10, message, cause });\n    this[_a10] = true;\n    this.originalError = originalError;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker10);\n  }\n};\n_a10 = symbol10;\n\n// src/error/unsupported-model-version-error.ts\n\nvar UnsupportedModelVersionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor(options) {\n    super({\n      name: \"AI_UnsupportedModelVersionError\",\n      message: `Unsupported model version ${options.version} for provider \"${options.provider}\" and model \"${options.modelId}\". AI SDK 5 only supports models that implement specification version \"v2\".`\n    });\n    this.version = options.version;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n  }\n};\n\n// src/prompt/invalid-data-content-error.ts\n\nvar name11 = \"AI_InvalidDataContentError\";\nvar marker11 = `vercel.ai.error.${name11}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`\n  }) {\n    super({ name: name11, message, cause });\n    this[_a11] = true;\n    this.content = content;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker11);\n  }\n};\n_a11 = symbol11;\n\n// src/prompt/invalid-message-role-error.ts\n\nvar name12 = \"AI_InvalidMessageRoleError\";\nvar marker12 = `vercel.ai.error.${name12}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`\n  }) {\n    super({ name: name12, message });\n    this[_a12] = true;\n    this.role = role;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker12);\n  }\n};\n_a12 = symbol12;\n\n// src/prompt/message-conversion-error.ts\n\nvar name13 = \"AI_MessageConversionError\";\nvar marker13 = `vercel.ai.error.${name13}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar MessageConversionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    originalMessage,\n    message\n  }) {\n    super({ name: name13, message });\n    this[_a13] = true;\n    this.originalMessage = originalMessage;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker13);\n  }\n};\n_a13 = symbol13;\n\n// src/util/download/download-error.ts\n\nvar name14 = \"AI_DownloadError\";\nvar marker14 = `vercel.ai.error.${name14}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}`\n  }) {\n    super({ name: name14, message, cause });\n    this[_a14] = true;\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker14);\n  }\n};\n_a14 = symbol14;\n\n// src/util/retry-error.ts\n\nvar name15 = \"AI_RetryError\";\nvar marker15 = `vercel.ai.error.${name15}`;\nvar symbol15 = Symbol.for(marker15);\nvar _a15;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message,\n    reason,\n    errors\n  }) {\n    super({ name: name15, message });\n    this[_a15] = true;\n    this.reason = reason;\n    this.errors = errors;\n    this.lastError = errors[errors.length - 1];\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker15);\n  }\n};\n_a15 = symbol15;\n\n// src/model/resolve-model.ts\nfunction resolveLanguageModel(model) {\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v2\") {\n      throw new UnsupportedModelVersionError({\n        version: model.specificationVersion,\n        provider: model.provider,\n        modelId: model.modelId\n      });\n    }\n    return model;\n  }\n  return getGlobalProvider().languageModel(model);\n}\nfunction resolveEmbeddingModel(model) {\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v2\") {\n      throw new UnsupportedModelVersionError({\n        version: model.specificationVersion,\n        provider: model.provider,\n        modelId: model.modelId\n      });\n    }\n    return model;\n  }\n  return getGlobalProvider().textEmbeddingModel(\n    model\n  );\n}\nfunction getGlobalProvider() {\n  var _a17;\n  return (_a17 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a17 : _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.gateway;\n}\n\n// src/prompt/convert-to-language-model-prompt.ts\n\n\n// src/util/detect-media-type.ts\n\nvar imageMediaTypeSignatures = [\n  {\n    mediaType: \"image/gif\",\n    bytesPrefix: [71, 73, 70],\n    base64Prefix: \"R0lG\"\n  },\n  {\n    mediaType: \"image/png\",\n    bytesPrefix: [137, 80, 78, 71],\n    base64Prefix: \"iVBORw\"\n  },\n  {\n    mediaType: \"image/jpeg\",\n    bytesPrefix: [255, 216],\n    base64Prefix: \"/9j/\"\n  },\n  {\n    mediaType: \"image/webp\",\n    bytesPrefix: [82, 73, 70, 70],\n    base64Prefix: \"UklGRg\"\n  },\n  {\n    mediaType: \"image/bmp\",\n    bytesPrefix: [66, 77],\n    base64Prefix: \"Qk\"\n  },\n  {\n    mediaType: \"image/tiff\",\n    bytesPrefix: [73, 73, 42, 0],\n    base64Prefix: \"SUkqAA\"\n  },\n  {\n    mediaType: \"image/tiff\",\n    bytesPrefix: [77, 77, 0, 42],\n    base64Prefix: \"TU0AKg\"\n  },\n  {\n    mediaType: \"image/avif\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      32,\n      102,\n      116,\n      121,\n      112,\n      97,\n      118,\n      105,\n      102\n    ],\n    base64Prefix: \"AAAAIGZ0eXBhdmlm\"\n  },\n  {\n    mediaType: \"image/heic\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      32,\n      102,\n      116,\n      121,\n      112,\n      104,\n      101,\n      105,\n      99\n    ],\n    base64Prefix: \"AAAAIGZ0eXBoZWlj\"\n  }\n];\nvar audioMediaTypeSignatures = [\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 251],\n    base64Prefix: \"//s=\"\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 250],\n    base64Prefix: \"//o=\"\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 243],\n    base64Prefix: \"//M=\"\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 242],\n    base64Prefix: \"//I=\"\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 227],\n    base64Prefix: \"/+M=\"\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 226],\n    base64Prefix: \"/+I=\"\n  },\n  {\n    mediaType: \"audio/wav\",\n    bytesPrefix: [82, 73, 70, 70],\n    base64Prefix: \"UklGR\"\n  },\n  {\n    mediaType: \"audio/ogg\",\n    bytesPrefix: [79, 103, 103, 83],\n    base64Prefix: \"T2dnUw\"\n  },\n  {\n    mediaType: \"audio/flac\",\n    bytesPrefix: [102, 76, 97, 67],\n    base64Prefix: \"ZkxhQw\"\n  },\n  {\n    mediaType: \"audio/aac\",\n    bytesPrefix: [64, 21, 0, 0],\n    base64Prefix: \"QBUA\"\n  },\n  {\n    mediaType: \"audio/mp4\",\n    bytesPrefix: [102, 116, 121, 112],\n    base64Prefix: \"ZnR5cA\"\n  },\n  {\n    mediaType: \"audio/webm\",\n    bytesPrefix: [26, 69, 223, 163],\n    base64Prefix: \"GkXf\"\n  }\n];\nvar stripID3 = (data) => {\n  const bytes = typeof data === \"string\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(data) : data;\n  const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;\n  return bytes.slice(id3Size + 10);\n};\nfunction stripID3TagsIfPresent(data) {\n  const hasId3 = typeof data === \"string\" && data.startsWith(\"SUQz\") || typeof data !== \"string\" && data.length > 10 && data[0] === 73 && // 'I'\n  data[1] === 68 && // 'D'\n  data[2] === 51;\n  return hasId3 ? stripID3(data) : data;\n}\nfunction detectMediaType({\n  data,\n  signatures\n}) {\n  const processedData = stripID3TagsIfPresent(data);\n  for (const signature of signatures) {\n    if (typeof processedData === \"string\" ? processedData.startsWith(signature.base64Prefix) : processedData.length >= signature.bytesPrefix.length && signature.bytesPrefix.every(\n      (byte, index) => processedData[index] === byte\n    )) {\n      return signature.mediaType;\n    }\n  }\n  return void 0;\n}\n\n// src/util/download/download.ts\nvar download = async ({ url }) => {\n  var _a17;\n  const urlText = url.toString();\n  try {\n    const response = await fetch(urlText);\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText\n      });\n    }\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mediaType: (_a17 = response.headers.get(\"content-type\")) != null ? _a17 : void 0\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n};\n\n// src/util/download/download-function.ts\nvar createDefaultDownloadFunction = (download2 = download) => (requestedDownloads) => Promise.all(\n  requestedDownloads.map(\n    async (requestedDownload) => requestedDownload.isUrlSupportedByModel ? null : download2(requestedDownload)\n  )\n);\n\n// src/prompt/data-content.ts\n\n\n\n\n// src/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n  try {\n    const [header, base64Content] = dataUrl.split(\",\");\n    return {\n      mediaType: header.split(\";\")[0].split(\":\")[1],\n      base64Content\n    };\n  } catch (error) {\n    return {\n      mediaType: void 0,\n      base64Content: void 0\n    };\n  }\n}\n\n// src/prompt/data-content.ts\nvar dataContentSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](Uint8Array),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](ArrayBuffer),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value) => {\n      var _a17, _b;\n      return (_b = (_a17 = globalThis.Buffer) == null ? void 0 : _a17.isBuffer(value)) != null ? _b : false;\n    },\n    { message: \"Must be a Buffer\" }\n  )\n]);\nfunction convertToLanguageModelV2DataContent(content) {\n  if (content instanceof Uint8Array) {\n    return { data: content, mediaType: void 0 };\n  }\n  if (content instanceof ArrayBuffer) {\n    return { data: new Uint8Array(content), mediaType: void 0 };\n  }\n  if (typeof content === \"string\") {\n    try {\n      content = new URL(content);\n    } catch (error) {\n    }\n  }\n  if (content instanceof URL && content.protocol === \"data:\") {\n    const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(\n      content.toString()\n    );\n    if (dataUrlMediaType == null || base64Content == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError({\n        name: \"InvalidDataContentError\",\n        message: `Invalid data URL format in content ${content.toString()}`\n      });\n    }\n    return { data: base64Content, mediaType: dataUrlMediaType };\n  }\n  return { data: content, mediaType: void 0 };\n}\nfunction convertDataContentToBase64String(content) {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  if (content instanceof ArrayBuffer) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(new Uint8Array(content));\n  }\n  return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n  if (typeof content === \"string\") {\n    try {\n      return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message: \"Invalid data content. Content string is not a base64-encoded media.\",\n        content,\n        cause: error\n      });\n    }\n  }\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n  throw new InvalidDataContentError({ content });\n}\n\n// src/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({\n  prompt,\n  supportedUrls,\n  download: download2 = createDefaultDownloadFunction()\n}) {\n  const downloadedAssets = await downloadAssets(\n    prompt.messages,\n    download2,\n    supportedUrls\n  );\n  return [\n    ...prompt.system != null ? [{ role: \"system\", content: prompt.system }] : [],\n    ...prompt.messages.map(\n      (message) => convertToLanguageModelMessage({ message, downloadedAssets })\n    )\n  ];\n}\nfunction convertToLanguageModelMessage({\n  message,\n  downloadedAssets\n}) {\n  const role = message.role;\n  switch (role) {\n    case \"system\": {\n      return {\n        role: \"system\",\n        content: message.content,\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"user\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"user\",\n          content: [{ type: \"text\", text: message.content }],\n          providerOptions: message.providerOptions\n        };\n      }\n      return {\n        role: \"user\",\n        content: message.content.map((part) => convertPartToLanguageModelPart(part, downloadedAssets)).filter((part) => part.type !== \"text\" || part.text !== \"\"),\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"assistant\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"assistant\",\n          content: [{ type: \"text\", text: message.content }],\n          providerOptions: message.providerOptions\n        };\n      }\n      return {\n        role: \"assistant\",\n        content: message.content.filter(\n          // remove empty text parts:\n          (part) => part.type !== \"text\" || part.text !== \"\"\n        ).map((part) => {\n          const providerOptions = part.providerOptions;\n          switch (part.type) {\n            case \"file\": {\n              const { data, mediaType } = convertToLanguageModelV2DataContent(\n                part.data\n              );\n              return {\n                type: \"file\",\n                data,\n                filename: part.filename,\n                mediaType: mediaType != null ? mediaType : part.mediaType,\n                providerOptions\n              };\n            }\n            case \"reasoning\": {\n              return {\n                type: \"reasoning\",\n                text: part.text,\n                providerOptions\n              };\n            }\n            case \"text\": {\n              return {\n                type: \"text\",\n                text: part.text,\n                providerOptions\n              };\n            }\n            case \"tool-call\": {\n              return {\n                type: \"tool-call\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                input: part.input,\n                providerExecuted: part.providerExecuted,\n                providerOptions\n              };\n            }\n            case \"tool-result\": {\n              return {\n                type: \"tool-result\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                output: part.output,\n                providerOptions\n              };\n            }\n          }\n        }),\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"tool\": {\n      return {\n        role: \"tool\",\n        content: message.content.map((part) => ({\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          output: part.output,\n          providerOptions: part.providerOptions\n        })),\n        providerOptions: message.providerOptions\n      };\n    }\n    default: {\n      const _exhaustiveCheck = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\nasync function downloadAssets(messages, download2, supportedUrls) {\n  const plannedDownloads = messages.filter((message) => message.role === \"user\").map((message) => message.content).filter(\n    (content) => Array.isArray(content)\n  ).flat().filter(\n    (part) => part.type === \"image\" || part.type === \"file\"\n  ).map((part) => {\n    var _a17;\n    const mediaType = (_a17 = part.mediaType) != null ? _a17 : part.type === \"image\" ? \"image/*\" : void 0;\n    let data = part.type === \"image\" ? part.image : part.data;\n    if (typeof data === \"string\") {\n      try {\n        data = new URL(data);\n      } catch (ignored) {\n      }\n    }\n    return { mediaType, data };\n  }).filter(\n    (part) => part.data instanceof URL\n  ).map((part) => ({\n    url: part.data,\n    isUrlSupportedByModel: part.mediaType != null && (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isUrlSupported)({\n      url: part.data.toString(),\n      mediaType: part.mediaType,\n      supportedUrls\n    })\n  }));\n  const downloadedFiles = await download2(plannedDownloads);\n  return Object.fromEntries(\n    downloadedFiles.filter(\n      (downloadedFile) => (downloadedFile == null ? void 0 : downloadedFile.data) != null\n    ).map(({ data, mediaType }, index) => [\n      plannedDownloads[index].url.toString(),\n      { data, mediaType }\n    ])\n  );\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n  var _a17;\n  if (part.type === \"text\") {\n    return {\n      type: \"text\",\n      text: part.text,\n      providerOptions: part.providerOptions\n    };\n  }\n  let originalData;\n  const type = part.type;\n  switch (type) {\n    case \"image\":\n      originalData = part.image;\n      break;\n    case \"file\":\n      originalData = part.data;\n      break;\n    default:\n      throw new Error(`Unsupported part type: ${type}`);\n  }\n  const { data: convertedData, mediaType: convertedMediaType } = convertToLanguageModelV2DataContent(originalData);\n  let mediaType = convertedMediaType != null ? convertedMediaType : part.mediaType;\n  let data = convertedData;\n  if (data instanceof URL) {\n    const downloadedFile = downloadedAssets[data.toString()];\n    if (downloadedFile) {\n      data = downloadedFile.data;\n      mediaType != null ? mediaType : mediaType = downloadedFile.mediaType;\n    }\n  }\n  switch (type) {\n    case \"image\": {\n      if (data instanceof Uint8Array || typeof data === \"string\") {\n        mediaType = (_a17 = detectMediaType({ data, signatures: imageMediaTypeSignatures })) != null ? _a17 : mediaType;\n      }\n      return {\n        type: \"file\",\n        mediaType: mediaType != null ? mediaType : \"image/*\",\n        // any image\n        filename: void 0,\n        data,\n        providerOptions: part.providerOptions\n      };\n    }\n    case \"file\": {\n      if (mediaType == null) {\n        throw new Error(`Media type is missing for file part`);\n      }\n      return {\n        type: \"file\",\n        mediaType,\n        filename: part.filename,\n        data,\n        providerOptions: part.providerOptions\n      };\n    }\n  }\n}\n\n// src/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({\n  maxOutputTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  seed,\n  stopSequences\n}) {\n  if (maxOutputTokens != null) {\n    if (!Number.isInteger(maxOutputTokens)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxOutputTokens\",\n        value: maxOutputTokens,\n        message: \"maxOutputTokens must be an integer\"\n      });\n    }\n    if (maxOutputTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: \"maxOutputTokens\",\n        value: maxOutputTokens,\n        message: \"maxOutputTokens must be >= 1\"\n      });\n    }\n  }\n  if (temperature != null) {\n    if (typeof temperature !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"temperature\",\n        value: temperature,\n        message: \"temperature must be a number\"\n      });\n    }\n  }\n  if (topP != null) {\n    if (typeof topP !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topP\",\n        value: topP,\n        message: \"topP must be a number\"\n      });\n    }\n  }\n  if (topK != null) {\n    if (typeof topK !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topK\",\n        value: topK,\n        message: \"topK must be a number\"\n      });\n    }\n  }\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"presencePenalty\",\n        value: presencePenalty,\n        message: \"presencePenalty must be a number\"\n      });\n    }\n  }\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"frequencyPenalty\",\n        value: frequencyPenalty,\n        message: \"frequencyPenalty must be a number\"\n      });\n    }\n  }\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: \"seed\",\n        value: seed,\n        message: \"seed must be an integer\"\n      });\n    }\n  }\n  return {\n    maxOutputTokens,\n    temperature,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences,\n    seed\n  };\n}\n\n// src/prompt/prepare-tools-and-tool-choice.ts\n\n\n// src/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object2) {\n  return object2 != null && Object.keys(object2).length > 0;\n}\n\n// src/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({\n  tools,\n  toolChoice,\n  activeTools\n}) {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: void 0,\n      toolChoice: void 0\n    };\n  }\n  const filteredTools = activeTools != null ? Object.entries(tools).filter(\n    ([name17]) => activeTools.includes(name17)\n  ) : Object.entries(tools);\n  return {\n    tools: filteredTools.map(([name17, tool3]) => {\n      const toolType = tool3.type;\n      switch (toolType) {\n        case void 0:\n        case \"dynamic\":\n        case \"function\":\n          return {\n            type: \"function\",\n            name: name17,\n            description: tool3.description,\n            inputSchema: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(tool3.inputSchema).jsonSchema,\n            providerOptions: tool3.providerOptions\n          };\n        case \"provider-defined\":\n          return {\n            type: \"provider-defined\",\n            name: name17,\n            id: tool3.id,\n            args: tool3.args\n          };\n        default: {\n          const exhaustiveCheck = toolType;\n          throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n        }\n      }\n    }),\n    toolChoice: toolChoice == null ? { type: \"auto\" } : typeof toolChoice === \"string\" ? { type: toolChoice } : { type: \"tool\", toolName: toolChoice.toolName }\n  };\n}\n\n// src/prompt/standardize-prompt.ts\n\n\n\n\n// src/prompt/message.ts\n\n\n// src/types/provider-metadata.ts\n\n\n// src/types/json-value.ts\n\nvar jsonValueSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.lazy(\n  () => zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"null\"](),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.number(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), jsonValueSchema),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(jsonValueSchema)\n  ])\n);\n\n// src/types/provider-metadata.ts\nvar providerMetadataSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.record(\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), jsonValueSchema)\n);\n\n// src/prompt/content-part.ts\n\nvar textPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"image\"),\n  image: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([dataContentSchema, zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](URL)]),\n  mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar filePartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file\"),\n  data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([dataContentSchema, zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](URL)]),\n  filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n  mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar reasoningPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning\"),\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-call\"),\n  toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n  providerOptions: providerMetadataSchema.optional(),\n  providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n});\nvar outputSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.discriminatedUnion(\"type\", [\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n    value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"json\"),\n    value: jsonValueSchema\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"error-text\"),\n    value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"error-json\"),\n    value: jsonValueSchema\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"content\"),\n    value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n          type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n          text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n          type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"media\"),\n          data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n          mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n        })\n      ])\n    )\n  })\n]);\nvar toolResultPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-result\"),\n  toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  output: outputSchema,\n  providerOptions: providerMetadataSchema.optional()\n});\n\n// src/prompt/message.ts\nvar systemModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object(\n  {\n    role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"system\"),\n    content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerOptions: providerMetadataSchema.optional()\n  }\n);\nvar coreSystemMessageSchema = systemModelMessageSchema;\nvar userModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"user\"),\n  content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([textPartSchema, imagePartSchema, filePartSchema]))\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar coreUserMessageSchema = userModelMessageSchema;\nvar assistantModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"assistant\"),\n  content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n        textPartSchema,\n        filePartSchema,\n        reasoningPartSchema,\n        toolCallPartSchema,\n        toolResultPartSchema\n      ])\n    )\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar coreAssistantMessageSchema = assistantModelMessageSchema;\nvar toolModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool\"),\n  content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(toolResultPartSchema),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar coreToolMessageSchema = toolModelMessageSchema;\nvar modelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n  systemModelMessageSchema,\n  userModelMessageSchema,\n  assistantModelMessageSchema,\n  toolModelMessageSchema\n]);\nvar coreMessageSchema = modelMessageSchema;\n\n// src/prompt/standardize-prompt.ts\nasync function standardizePrompt(prompt) {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt and messages cannot be defined at the same time\"\n    });\n  }\n  if (prompt.system != null && typeof prompt.system !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"system must be a string\"\n    });\n  }\n  let messages;\n  if (prompt.prompt != null && typeof prompt.prompt === \"string\") {\n    messages = [{ role: \"user\", content: prompt.prompt }];\n  } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {\n    messages = prompt.prompt;\n  } else if (prompt.messages != null) {\n    messages = prompt.messages;\n  } else {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (messages.length === 0) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"messages must not be empty\"\n    });\n  }\n  const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n    value: messages,\n    schema: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(modelMessageSchema)\n  });\n  if (!validationResult.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"The messages must be a ModelMessage[]. If you have passed a UIMessage[], you can use convertToModelMessages to convert them.\",\n      cause: validationResult.error\n    });\n  }\n  return {\n    messages,\n    system: prompt.system\n  };\n}\n\n// src/prompt/wrap-gateway-error.ts\n\n\nfunction wrapGatewayError(error) {\n  if (_ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.GatewayAuthenticationError.isInstance(error) || _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.GatewayModelNotFoundError.isInstance(error)) {\n    return new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError({\n      name: \"GatewayError\",\n      message: \"Vercel AI Gateway access failed. If you want to use AI SDK providers directly, use the providers, e.g. @ai-sdk/openai, or register a different global default provider.\",\n      cause: error\n    });\n  }\n  return error;\n}\n\n// src/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({\n  operationId,\n  telemetry\n}) {\n  return {\n    // standardized operation and resource name:\n    \"operation.name\": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`,\n    \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n    // detailed, AI SDK specific data:\n    \"ai.operationId\": operationId,\n    \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId\n  };\n}\n\n// src/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers\n}) {\n  var _a17;\n  return {\n    \"ai.model.provider\": model.provider,\n    \"ai.model.id\": model.modelId,\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      attributes[`ai.settings.${key}`] = value;\n      return attributes;\n    }, {}),\n    // add metadata as attributes:\n    ...Object.entries((_a17 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a17 : {}).reduce(\n      (attributes, [key, value]) => {\n        attributes[`ai.telemetry.metadata.${key}`] = value;\n        return attributes;\n      },\n      {}\n    ),\n    // request headers\n    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {\n      if (value !== void 0) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {})\n  };\n}\n\n// src/telemetry/get-tracer.ts\n\n\n// src/telemetry/noop-tracer.ts\nvar noopTracer = {\n  startSpan() {\n    return noopSpan;\n  },\n  startActiveSpan(name17, arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === \"function\") {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === \"function\") {\n      return arg3(noopSpan);\n    }\n  }\n};\nvar noopSpan = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  }\n};\nvar noopSpanContext = {\n  traceId: \"\",\n  spanId: \"\",\n  traceFlags: 0\n};\n\n// src/telemetry/get-tracer.ts\nfunction getTracer({\n  isEnabled = false,\n  tracer\n} = {}) {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n  if (tracer) {\n    return tracer;\n  }\n  return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.trace.getTracer(\"ai\");\n}\n\n// src/telemetry/record-span.ts\n\nfunction recordSpan({\n  name: name17,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true\n}) {\n  return tracer.startActiveSpan(name17, { attributes }, async (span) => {\n    try {\n      const result = await fn(span);\n      if (endWhenDone) {\n        span.end();\n      }\n      return result;\n    } catch (error) {\n      try {\n        recordErrorOnSpan(span, error);\n      } finally {\n        span.end();\n      }\n      throw error;\n    }\n  });\n}\nfunction recordErrorOnSpan(span, error) {\n  if (error instanceof Error) {\n    span.recordException({\n      name: error.name,\n      message: error.message,\n      stack: error.stack\n    });\n    span.setStatus({\n      code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_5__.SpanStatusCode.ERROR,\n      message: error.message\n    });\n  } else {\n    span.setStatus({ code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_5__.SpanStatusCode.ERROR });\n  }\n}\n\n// src/telemetry/select-telemetry-attributes.ts\nfunction selectTelemetryAttributes({\n  telemetry,\n  attributes\n}) {\n  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {\n    return {};\n  }\n  return Object.entries(attributes).reduce((attributes2, [key, value]) => {\n    if (value == null) {\n      return attributes2;\n    }\n    if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n        return attributes2;\n      }\n      const result = value.input();\n      return result == null ? attributes2 : { ...attributes2, [key]: result };\n    }\n    if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n        return attributes2;\n      }\n      const result = value.output();\n      return result == null ? attributes2 : { ...attributes2, [key]: result };\n    }\n    return { ...attributes2, [key]: value };\n  }, {});\n}\n\n// src/telemetry/stringify-for-telemetry.ts\nfunction stringifyForTelemetry(prompt) {\n  return JSON.stringify(\n    prompt.map((message) => ({\n      ...message,\n      content: typeof message.content === \"string\" ? message.content : message.content.map(\n        (part) => part.type === \"file\" ? {\n          ...part,\n          data: part.data instanceof Uint8Array ? convertDataContentToBase64String(part.data) : part.data\n        } : part\n      )\n    }))\n  );\n}\n\n// src/types/usage.ts\nfunction addLanguageModelUsage(usage1, usage2) {\n  return {\n    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),\n    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),\n    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),\n    reasoningTokens: addTokenCounts(\n      usage1.reasoningTokens,\n      usage2.reasoningTokens\n    ),\n    cachedInputTokens: addTokenCounts(\n      usage1.cachedInputTokens,\n      usage2.cachedInputTokens\n    )\n  };\n}\nfunction addTokenCounts(tokenCount1, tokenCount2) {\n  return tokenCount1 == null && tokenCount2 == null ? void 0 : (tokenCount1 != null ? tokenCount1 : 0) + (tokenCount2 != null ? tokenCount2 : 0);\n}\n\n// src/util/as-array.ts\nfunction asArray(value) {\n  return value === void 0 ? [] : Array.isArray(value) ? value : [value];\n}\n\n// src/util/retry-with-exponential-backoff.ts\n\n\nfunction getRetryDelayInMs({\n  error,\n  exponentialBackoffDelay\n}) {\n  const headers = error.responseHeaders;\n  if (!headers)\n    return exponentialBackoffDelay;\n  let ms;\n  const retryAfterMs = headers[\"retry-after-ms\"];\n  if (retryAfterMs) {\n    const timeoutMs = parseFloat(retryAfterMs);\n    if (!Number.isNaN(timeoutMs)) {\n      ms = timeoutMs;\n    }\n  }\n  const retryAfter = headers[\"retry-after\"];\n  if (retryAfter && ms === void 0) {\n    const timeoutSeconds = parseFloat(retryAfter);\n    if (!Number.isNaN(timeoutSeconds)) {\n      ms = timeoutSeconds * 1e3;\n    } else {\n      ms = Date.parse(retryAfter) - Date.now();\n    }\n  }\n  if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {\n    return ms;\n  }\n  return exponentialBackoffDelay;\n}\nvar retryWithExponentialBackoffRespectingRetryHeaders = ({\n  maxRetries = 2,\n  initialDelayInMs = 2e3,\n  backoffFactor = 2,\n  abortSignal\n} = {}) => async (f) => _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs: initialDelayInMs,\n  backoffFactor,\n  abortSignal\n});\nasync function _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs,\n  backoffFactor,\n  abortSignal\n}, errors = []) {\n  try {\n    return await f();\n  } catch (error) {\n    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isAbortError)(error)) {\n      throw error;\n    }\n    if (maxRetries === 0) {\n      throw error;\n    }\n    const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: \"maxRetriesExceeded\",\n        errors: newErrors\n      });\n    }\n    if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n      await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay)(\n        getRetryDelayInMs({\n          error,\n          exponentialBackoffDelay: delayInMs\n        }),\n        { abortSignal }\n      );\n      return _retryWithExponentialBackoff(\n        f,\n        {\n          maxRetries,\n          delayInMs: backoffFactor * delayInMs,\n          backoffFactor,\n          abortSignal\n        },\n        newErrors\n      );\n    }\n    if (tryNumber === 1) {\n      throw error;\n    }\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: \"errorNotRetryable\",\n      errors: newErrors\n    });\n  }\n}\n\n// src/util/prepare-retries.ts\nfunction prepareRetries({\n  maxRetries,\n  abortSignal\n}) {\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be an integer\"\n      });\n    }\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be >= 0\"\n      });\n    }\n  }\n  const maxRetriesResult = maxRetries != null ? maxRetries : 2;\n  return {\n    maxRetries: maxRetriesResult,\n    retry: retryWithExponentialBackoffRespectingRetryHeaders({\n      maxRetries: maxRetriesResult,\n      abortSignal\n    })\n  };\n}\n\n// src/generate-text/extract-text-content.ts\nfunction extractTextContent(content) {\n  const parts = content.filter(\n    (content2) => content2.type === \"text\"\n  );\n  if (parts.length === 0) {\n    return void 0;\n  }\n  return parts.map((content2) => content2.text).join(\"\");\n}\n\n// src/generate-text/generated-file.ts\n\nvar DefaultGeneratedFile = class {\n  constructor({\n    data,\n    mediaType\n  }) {\n    const isUint8Array = data instanceof Uint8Array;\n    this.base64Data = isUint8Array ? void 0 : data;\n    this.uint8ArrayData = isUint8Array ? data : void 0;\n    this.mediaType = mediaType;\n  }\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get base64() {\n    if (this.base64Data == null) {\n      this.base64Data = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(this.uint8ArrayData);\n    }\n    return this.base64Data;\n  }\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get uint8Array() {\n    if (this.uint8ArrayData == null) {\n      this.uint8ArrayData = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(this.base64Data);\n    }\n    return this.uint8ArrayData;\n  }\n};\nvar DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {\n  constructor(options) {\n    super(options);\n    this.type = \"file\";\n  }\n};\n\n// src/generate-text/parse-tool-call.ts\n\nasync function parseToolCall({\n  toolCall,\n  tools,\n  repairToolCall,\n  system,\n  messages\n}) {\n  try {\n    if (tools == null) {\n      throw new NoSuchToolError({ toolName: toolCall.toolName });\n    }\n    try {\n      return await doParseToolCall({ toolCall, tools });\n    } catch (error) {\n      if (repairToolCall == null || !(NoSuchToolError.isInstance(error) || InvalidToolInputError.isInstance(error))) {\n        throw error;\n      }\n      let repairedToolCall = null;\n      try {\n        repairedToolCall = await repairToolCall({\n          toolCall,\n          tools,\n          inputSchema: ({ toolName }) => {\n            const { inputSchema } = tools[toolName];\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(inputSchema).jsonSchema;\n          },\n          system,\n          messages,\n          error\n        });\n      } catch (repairError) {\n        throw new ToolCallRepairError({\n          cause: repairError,\n          originalError: error\n        });\n      }\n      if (repairedToolCall == null) {\n        throw error;\n      }\n      return await doParseToolCall({ toolCall: repairedToolCall, tools });\n    }\n  } catch (error) {\n    const parsedInput = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: toolCall.input });\n    const input = parsedInput.success ? parsedInput.value : toolCall.input;\n    return {\n      type: \"tool-call\",\n      toolCallId: toolCall.toolCallId,\n      toolName: toolCall.toolName,\n      input,\n      dynamic: true,\n      invalid: true,\n      error\n    };\n  }\n}\nasync function doParseToolCall({\n  toolCall,\n  tools\n}) {\n  const toolName = toolCall.toolName;\n  const tool3 = tools[toolName];\n  if (tool3 == null) {\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools)\n    });\n  }\n  const schema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(tool3.inputSchema);\n  const parseResult = toolCall.input.trim() === \"\" ? await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: {}, schema }) : await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: toolCall.input, schema });\n  if (parseResult.success === false) {\n    throw new InvalidToolInputError({\n      toolName,\n      toolInput: toolCall.input,\n      cause: parseResult.error\n    });\n  }\n  return tool3.type === \"dynamic\" ? {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    input: parseResult.value,\n    providerExecuted: toolCall.providerExecuted,\n    providerMetadata: toolCall.providerMetadata,\n    dynamic: true\n  } : {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    input: parseResult.value,\n    providerExecuted: toolCall.providerExecuted,\n    providerMetadata: toolCall.providerMetadata\n  };\n}\n\n// src/generate-text/step-result.ts\nvar DefaultStepResult = class {\n  constructor({\n    content,\n    finishReason,\n    usage,\n    warnings,\n    request,\n    response,\n    providerMetadata\n  }) {\n    this.content = content;\n    this.finishReason = finishReason;\n    this.usage = usage;\n    this.warnings = warnings;\n    this.request = request;\n    this.response = response;\n    this.providerMetadata = providerMetadata;\n  }\n  get text() {\n    return this.content.filter((part) => part.type === \"text\").map((part) => part.text).join(\"\");\n  }\n  get reasoning() {\n    return this.content.filter((part) => part.type === \"reasoning\");\n  }\n  get reasoningText() {\n    return this.reasoning.length === 0 ? void 0 : this.reasoning.map((part) => part.text).join(\"\");\n  }\n  get files() {\n    return this.content.filter((part) => part.type === \"file\").map((part) => part.file);\n  }\n  get sources() {\n    return this.content.filter((part) => part.type === \"source\");\n  }\n  get toolCalls() {\n    return this.content.filter((part) => part.type === \"tool-call\");\n  }\n  get staticToolCalls() {\n    return this.toolCalls.filter(\n      (toolCall) => toolCall.dynamic === false\n    );\n  }\n  get dynamicToolCalls() {\n    return this.toolCalls.filter(\n      (toolCall) => toolCall.dynamic === true\n    );\n  }\n  get toolResults() {\n    return this.content.filter((part) => part.type === \"tool-result\");\n  }\n  get staticToolResults() {\n    return this.toolResults.filter(\n      (toolResult) => toolResult.dynamic === false\n    );\n  }\n  get dynamicToolResults() {\n    return this.toolResults.filter(\n      (toolResult) => toolResult.dynamic === true\n    );\n  }\n};\n\n// src/generate-text/stop-condition.ts\nfunction stepCountIs(stepCount) {\n  return ({ steps }) => steps.length === stepCount;\n}\nfunction hasToolCall(toolName) {\n  return ({ steps }) => {\n    var _a17, _b, _c;\n    return (_c = (_b = (_a17 = steps[steps.length - 1]) == null ? void 0 : _a17.toolCalls) == null ? void 0 : _b.some(\n      (toolCall) => toolCall.toolName === toolName\n    )) != null ? _c : false;\n  };\n}\nasync function isStopConditionMet({\n  stopConditions,\n  steps\n}) {\n  return (await Promise.all(stopConditions.map((condition) => condition({ steps })))).some((result) => result);\n}\n\n// src/prompt/create-tool-model-output.ts\n\nfunction createToolModelOutput({\n  output,\n  tool: tool3,\n  errorMode\n}) {\n  if (errorMode === \"text\") {\n    return { type: \"error-text\", value: (0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(output) };\n  } else if (errorMode === \"json\") {\n    return { type: \"error-json\", value: toJSONValue(output) };\n  }\n  if (tool3 == null ? void 0 : tool3.toModelOutput) {\n    return tool3.toModelOutput(output);\n  }\n  return typeof output === \"string\" ? { type: \"text\", value: output } : { type: \"json\", value: toJSONValue(output) };\n}\nfunction toJSONValue(value) {\n  return value === void 0 ? null : value;\n}\n\n// src/generate-text/to-response-messages.ts\nfunction toResponseMessages({\n  content: inputContent,\n  tools\n}) {\n  const responseMessages = [];\n  const content = inputContent.filter((part) => part.type !== \"source\").filter(\n    (part) => (part.type !== \"tool-result\" || part.providerExecuted) && (part.type !== \"tool-error\" || part.providerExecuted)\n  ).filter((part) => part.type !== \"text\" || part.text.length > 0).map((part) => {\n    switch (part.type) {\n      case \"text\":\n        return {\n          type: \"text\",\n          text: part.text,\n          providerOptions: part.providerMetadata\n        };\n      case \"reasoning\":\n        return {\n          type: \"reasoning\",\n          text: part.text,\n          providerOptions: part.providerMetadata\n        };\n      case \"file\":\n        return {\n          type: \"file\",\n          data: part.file.base64,\n          mediaType: part.file.mediaType,\n          providerOptions: part.providerMetadata\n        };\n      case \"tool-call\":\n        return {\n          type: \"tool-call\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          input: part.input,\n          providerExecuted: part.providerExecuted,\n          providerOptions: part.providerMetadata\n        };\n      case \"tool-result\":\n        return {\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          output: createToolModelOutput({\n            tool: tools == null ? void 0 : tools[part.toolName],\n            output: part.output,\n            errorMode: \"none\"\n          }),\n          providerExecuted: true,\n          providerOptions: part.providerMetadata\n        };\n      case \"tool-error\":\n        return {\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          output: createToolModelOutput({\n            tool: tools == null ? void 0 : tools[part.toolName],\n            output: part.error,\n            errorMode: \"json\"\n          }),\n          providerOptions: part.providerMetadata\n        };\n    }\n  });\n  if (content.length > 0) {\n    responseMessages.push({\n      role: \"assistant\",\n      content\n    });\n  }\n  const toolResultContent = inputContent.filter((part) => part.type === \"tool-result\" || part.type === \"tool-error\").filter((part) => !part.providerExecuted).map((toolResult) => ({\n    type: \"tool-result\",\n    toolCallId: toolResult.toolCallId,\n    toolName: toolResult.toolName,\n    output: createToolModelOutput({\n      tool: tools == null ? void 0 : tools[toolResult.toolName],\n      output: toolResult.type === \"tool-result\" ? toolResult.output : toolResult.error,\n      errorMode: toolResult.type === \"tool-error\" ? \"text\" : \"none\"\n    })\n  }));\n  if (toolResultContent.length > 0) {\n    responseMessages.push({\n      role: \"tool\",\n      content: toolResultContent\n    });\n  }\n  return responseMessages;\n}\n\n// src/generate-text/generate-text.ts\nvar originalGenerateId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n  prefix: \"aitxt\",\n  size: 24\n});\nasync function generateText({\n  model: modelArg,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  stopWhen = stepCountIs(1),\n  experimental_output: output,\n  experimental_telemetry: telemetry,\n  providerOptions,\n  experimental_activeTools,\n  activeTools = experimental_activeTools,\n  experimental_prepareStep,\n  prepareStep = experimental_prepareStep,\n  experimental_repairToolCall: repairToolCall,\n  experimental_download: download2,\n  experimental_context,\n  _internal: {\n    generateId: generateId3 = originalGenerateId,\n    currentDate = () => /* @__PURE__ */ new Date()\n  } = {},\n  onStepFinish,\n  ...settings\n}) {\n  const model = resolveLanguageModel(modelArg);\n  const stopConditions = asArray(stopWhen);\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const callSettings = prepareCallSettings(settings);\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...callSettings, maxRetries }\n  });\n  const initialPrompt = await standardizePrompt({\n    system,\n    prompt,\n    messages\n  });\n  const tracer = getTracer(telemetry);\n  try {\n    return await recordSpan({\n      name: \"ai.generateText\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.generateText\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // model:\n          \"ai.model.provider\": model.provider,\n          \"ai.model.id\": model.modelId,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          }\n        }\n      }),\n      tracer,\n      fn: async (span) => {\n        var _a17, _b, _c, _d, _e, _f, _g;\n        const callSettings2 = prepareCallSettings(settings);\n        let currentModelResponse;\n        let clientToolCalls = [];\n        let clientToolOutputs = [];\n        const responseMessages = [];\n        const steps = [];\n        do {\n          const stepInputMessages = [\n            ...initialPrompt.messages,\n            ...responseMessages\n          ];\n          const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n            model,\n            steps,\n            stepNumber: steps.length,\n            messages: stepInputMessages\n          }));\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: {\n              system: (_a17 = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _a17 : initialPrompt.system,\n              messages: (_b = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _b : stepInputMessages\n            },\n            supportedUrls: await model.supportedUrls,\n            download: download2\n          });\n          const stepModel = resolveLanguageModel(\n            (_c = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _c : model\n          );\n          const { toolChoice: stepToolChoice, tools: stepTools } = prepareToolsAndToolChoice({\n            tools,\n            toolChoice: (_d = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _d : toolChoice,\n            activeTools: (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools\n          });\n          currentModelResponse = await retry(\n            () => {\n              var _a18;\n              return recordSpan({\n                name: \"ai.generateText.doGenerate\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.generateText.doGenerate\",\n                      telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // model:\n                    \"ai.model.provider\": stepModel.provider,\n                    \"ai.model.id\": stepModel.modelId,\n                    // prompt:\n                    \"ai.prompt.messages\": {\n                      input: () => stringifyForTelemetry(promptMessages)\n                    },\n                    \"ai.prompt.tools\": {\n                      // convert the language model level tools:\n                      input: () => stepTools == null ? void 0 : stepTools.map((tool3) => JSON.stringify(tool3))\n                    },\n                    \"ai.prompt.toolChoice\": {\n                      input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0\n                    },\n                    // standardized gen-ai llm span attributes:\n                    \"gen_ai.system\": stepModel.provider,\n                    \"gen_ai.request.model\": stepModel.modelId,\n                    \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                    \"gen_ai.request.max_tokens\": settings.maxOutputTokens,\n                    \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                    \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                    \"gen_ai.request.temperature\": (_a18 = settings.temperature) != null ? _a18 : void 0,\n                    \"gen_ai.request.top_k\": settings.topK,\n                    \"gen_ai.request.top_p\": settings.topP\n                  }\n                }),\n                tracer,\n                fn: async (span2) => {\n                  var _a19, _b2, _c2, _d2, _e2, _f2, _g2, _h;\n                  const result = await stepModel.doGenerate({\n                    ...callSettings2,\n                    tools: stepTools,\n                    toolChoice: stepToolChoice,\n                    responseFormat: output == null ? void 0 : output.responseFormat,\n                    prompt: promptMessages,\n                    providerOptions,\n                    abortSignal,\n                    headers\n                  });\n                  const responseData = {\n                    id: (_b2 = (_a19 = result.response) == null ? void 0 : _a19.id) != null ? _b2 : generateId3(),\n                    timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),\n                    modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : stepModel.modelId,\n                    headers: (_g2 = result.response) == null ? void 0 : _g2.headers,\n                    body: (_h = result.response) == null ? void 0 : _h.body\n                  };\n                  span2.setAttributes(\n                    selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        \"ai.response.finishReason\": result.finishReason,\n                        \"ai.response.text\": {\n                          output: () => extractTextContent(result.content)\n                        },\n                        \"ai.response.toolCalls\": {\n                          output: () => {\n                            const toolCalls = asToolCalls(result.content);\n                            return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n                          }\n                        },\n                        \"ai.response.id\": responseData.id,\n                        \"ai.response.model\": responseData.modelId,\n                        \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                        \"ai.response.providerMetadata\": JSON.stringify(\n                          result.providerMetadata\n                        ),\n                        // TODO rename telemetry attributes to inputTokens and outputTokens\n                        \"ai.usage.promptTokens\": result.usage.inputTokens,\n                        \"ai.usage.completionTokens\": result.usage.outputTokens,\n                        // standardized gen-ai llm span attributes:\n                        \"gen_ai.response.finish_reasons\": [result.finishReason],\n                        \"gen_ai.response.id\": responseData.id,\n                        \"gen_ai.response.model\": responseData.modelId,\n                        \"gen_ai.usage.input_tokens\": result.usage.inputTokens,\n                        \"gen_ai.usage.output_tokens\": result.usage.outputTokens\n                      }\n                    })\n                  );\n                  return { ...result, response: responseData };\n                }\n              });\n            }\n          );\n          const stepToolCalls = await Promise.all(\n            currentModelResponse.content.filter(\n              (part) => part.type === \"tool-call\"\n            ).map(\n              (toolCall) => parseToolCall({\n                toolCall,\n                tools,\n                repairToolCall,\n                system,\n                messages: stepInputMessages\n              })\n            )\n          );\n          for (const toolCall of stepToolCalls) {\n            if (toolCall.invalid) {\n              continue;\n            }\n            const tool3 = tools[toolCall.toolName];\n            if ((tool3 == null ? void 0 : tool3.onInputAvailable) != null) {\n              await tool3.onInputAvailable({\n                input: toolCall.input,\n                toolCallId: toolCall.toolCallId,\n                messages: stepInputMessages,\n                abortSignal,\n                experimental_context\n              });\n            }\n          }\n          const invalidToolCalls = stepToolCalls.filter(\n            (toolCall) => toolCall.invalid && toolCall.dynamic\n          );\n          clientToolOutputs = [];\n          for (const toolCall of invalidToolCalls) {\n            clientToolOutputs.push({\n              type: \"tool-error\",\n              toolCallId: toolCall.toolCallId,\n              toolName: toolCall.toolName,\n              input: toolCall.input,\n              error: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(toolCall.error),\n              dynamic: true\n            });\n          }\n          clientToolCalls = stepToolCalls.filter(\n            (toolCall) => !toolCall.providerExecuted\n          );\n          if (tools != null) {\n            clientToolOutputs.push(\n              ...await executeTools({\n                toolCalls: clientToolCalls.filter(\n                  (toolCall) => !toolCall.invalid\n                ),\n                tools,\n                tracer,\n                telemetry,\n                messages: stepInputMessages,\n                abortSignal,\n                experimental_context\n              })\n            );\n          }\n          const stepContent = asContent({\n            content: currentModelResponse.content,\n            toolCalls: stepToolCalls,\n            toolOutputs: clientToolOutputs\n          });\n          responseMessages.push(\n            ...toResponseMessages({\n              content: stepContent,\n              tools\n            })\n          );\n          const currentStepResult = new DefaultStepResult({\n            content: stepContent,\n            finishReason: currentModelResponse.finishReason,\n            usage: currentModelResponse.usage,\n            warnings: currentModelResponse.warnings,\n            providerMetadata: currentModelResponse.providerMetadata,\n            request: (_f = currentModelResponse.request) != null ? _f : {},\n            response: {\n              ...currentModelResponse.response,\n              // deep clone msgs to avoid mutating past messages in multi-step:\n              messages: structuredClone(responseMessages)\n            }\n          });\n          logWarnings((_g = currentModelResponse.warnings) != null ? _g : []);\n          steps.push(currentStepResult);\n          await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n        } while (\n          // there are tool calls:\n          clientToolCalls.length > 0 && // all current tool calls have outputs (incl. execution errors):\n          clientToolOutputs.length === clientToolCalls.length && // continue until a stop condition is met:\n          !await isStopConditionMet({ stopConditions, steps })\n        );\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.response.finishReason\": currentModelResponse.finishReason,\n              \"ai.response.text\": {\n                output: () => extractTextContent(currentModelResponse.content)\n              },\n              \"ai.response.toolCalls\": {\n                output: () => {\n                  const toolCalls = asToolCalls(currentModelResponse.content);\n                  return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n                }\n              },\n              \"ai.response.providerMetadata\": JSON.stringify(\n                currentModelResponse.providerMetadata\n              ),\n              // TODO rename telemetry attributes to inputTokens and outputTokens\n              \"ai.usage.promptTokens\": currentModelResponse.usage.inputTokens,\n              \"ai.usage.completionTokens\": currentModelResponse.usage.outputTokens\n            }\n          })\n        );\n        const lastStep = steps[steps.length - 1];\n        return new DefaultGenerateTextResult({\n          steps,\n          resolvedOutput: await (output == null ? void 0 : output.parseOutput(\n            { text: lastStep.text },\n            {\n              response: lastStep.response,\n              usage: lastStep.usage,\n              finishReason: lastStep.finishReason\n            }\n          ))\n        });\n      }\n    });\n  } catch (error) {\n    throw wrapGatewayError(error);\n  }\n}\nasync function executeTools({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry,\n  messages,\n  abortSignal,\n  experimental_context\n}) {\n  const toolOutputs = await Promise.all(\n    toolCalls.map(async ({ toolCallId, toolName, input }) => {\n      const tool3 = tools[toolName];\n      if ((tool3 == null ? void 0 : tool3.execute) == null) {\n        return void 0;\n      }\n      return recordSpan({\n        name: \"ai.toolCall\",\n        attributes: selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            ...assembleOperationName({\n              operationId: \"ai.toolCall\",\n              telemetry\n            }),\n            \"ai.toolCall.name\": toolName,\n            \"ai.toolCall.id\": toolCallId,\n            \"ai.toolCall.args\": {\n              output: () => JSON.stringify(input)\n            }\n          }\n        }),\n        tracer,\n        fn: async (span) => {\n          try {\n            const stream = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.executeTool)({\n              execute: tool3.execute.bind(tool3),\n              input,\n              options: {\n                toolCallId,\n                messages,\n                abortSignal,\n                experimental_context\n              }\n            });\n            let output;\n            for await (const part of stream) {\n              if (part.type === \"final\") {\n                output = part.output;\n              }\n            }\n            try {\n              span.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.toolCall.result\": {\n                      output: () => JSON.stringify(output)\n                    }\n                  }\n                })\n              );\n            } catch (ignored) {\n            }\n            return {\n              type: \"tool-result\",\n              toolCallId,\n              toolName,\n              input,\n              output,\n              dynamic: tool3.type === \"dynamic\"\n            };\n          } catch (error) {\n            recordErrorOnSpan(span, error);\n            return {\n              type: \"tool-error\",\n              toolCallId,\n              toolName,\n              input,\n              error,\n              dynamic: tool3.type === \"dynamic\"\n            };\n          }\n        }\n      });\n    })\n  );\n  return toolOutputs.filter(\n    (output) => output != null\n  );\n}\nvar DefaultGenerateTextResult = class {\n  constructor(options) {\n    this.steps = options.steps;\n    this.resolvedOutput = options.resolvedOutput;\n  }\n  get finalStep() {\n    return this.steps[this.steps.length - 1];\n  }\n  get content() {\n    return this.finalStep.content;\n  }\n  get text() {\n    return this.finalStep.text;\n  }\n  get files() {\n    return this.finalStep.files;\n  }\n  get reasoningText() {\n    return this.finalStep.reasoningText;\n  }\n  get reasoning() {\n    return this.finalStep.reasoning;\n  }\n  get toolCalls() {\n    return this.finalStep.toolCalls;\n  }\n  get staticToolCalls() {\n    return this.finalStep.staticToolCalls;\n  }\n  get dynamicToolCalls() {\n    return this.finalStep.dynamicToolCalls;\n  }\n  get toolResults() {\n    return this.finalStep.toolResults;\n  }\n  get staticToolResults() {\n    return this.finalStep.staticToolResults;\n  }\n  get dynamicToolResults() {\n    return this.finalStep.dynamicToolResults;\n  }\n  get sources() {\n    return this.finalStep.sources;\n  }\n  get finishReason() {\n    return this.finalStep.finishReason;\n  }\n  get warnings() {\n    return this.finalStep.warnings;\n  }\n  get providerMetadata() {\n    return this.finalStep.providerMetadata;\n  }\n  get response() {\n    return this.finalStep.response;\n  }\n  get request() {\n    return this.finalStep.request;\n  }\n  get usage() {\n    return this.finalStep.usage;\n  }\n  get totalUsage() {\n    return this.steps.reduce(\n      (totalUsage, step) => {\n        return addLanguageModelUsage(totalUsage, step.usage);\n      },\n      {\n        inputTokens: void 0,\n        outputTokens: void 0,\n        totalTokens: void 0,\n        reasoningTokens: void 0,\n        cachedInputTokens: void 0\n      }\n    );\n  }\n  get experimental_output() {\n    if (this.resolvedOutput == null) {\n      throw new NoOutputSpecifiedError();\n    }\n    return this.resolvedOutput;\n  }\n};\nfunction asToolCalls(content) {\n  const parts = content.filter(\n    (part) => part.type === \"tool-call\"\n  );\n  if (parts.length === 0) {\n    return void 0;\n  }\n  return parts.map((toolCall) => ({\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    input: toolCall.input\n  }));\n}\nfunction asContent({\n  content,\n  toolCalls,\n  toolOutputs\n}) {\n  return [\n    ...content.map((part) => {\n      switch (part.type) {\n        case \"text\":\n        case \"reasoning\":\n        case \"source\":\n          return part;\n        case \"file\": {\n          return {\n            type: \"file\",\n            file: new DefaultGeneratedFile(part)\n          };\n        }\n        case \"tool-call\": {\n          return toolCalls.find(\n            (toolCall) => toolCall.toolCallId === part.toolCallId\n          );\n        }\n        case \"tool-result\": {\n          const toolCall = toolCalls.find(\n            (toolCall2) => toolCall2.toolCallId === part.toolCallId\n          );\n          if (toolCall == null) {\n            throw new Error(`Tool call ${part.toolCallId} not found.`);\n          }\n          if (part.isError) {\n            return {\n              type: \"tool-error\",\n              toolCallId: part.toolCallId,\n              toolName: part.toolName,\n              input: toolCall.input,\n              error: part.result,\n              providerExecuted: true,\n              dynamic: toolCall.dynamic\n            };\n          }\n          return {\n            type: \"tool-result\",\n            toolCallId: part.toolCallId,\n            toolName: part.toolName,\n            input: toolCall.input,\n            output: part.result,\n            providerExecuted: true,\n            dynamic: toolCall.dynamic\n          };\n        }\n      }\n    }),\n    ...toolOutputs\n  ];\n}\n\n// src/generate-text/stream-text.ts\n\n\n\n// src/util/prepare-headers.ts\nfunction prepareHeaders(headers, defaultHeaders) {\n  const responseHeaders = new Headers(headers != null ? headers : {});\n  for (const [key, value] of Object.entries(defaultHeaders)) {\n    if (!responseHeaders.has(key)) {\n      responseHeaders.set(key, value);\n    }\n  }\n  return responseHeaders;\n}\n\n// src/text-stream/create-text-stream-response.ts\nfunction createTextStreamResponse({\n  status,\n  statusText,\n  headers,\n  textStream\n}) {\n  return new Response(textStream.pipeThrough(new TextEncoderStream()), {\n    status: status != null ? status : 200,\n    statusText,\n    headers: prepareHeaders(headers, {\n      \"content-type\": \"text/plain; charset=utf-8\"\n    })\n  });\n}\n\n// src/util/write-to-server-response.ts\nfunction writeToServerResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream\n}) {\n  response.writeHead(status != null ? status : 200, statusText, headers);\n  const reader = stream.getReader();\n  const read = async () => {\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done)\n          break;\n        response.write(value);\n      }\n    } catch (error) {\n      throw error;\n    } finally {\n      response.end();\n    }\n  };\n  read();\n}\n\n// src/text-stream/pipe-text-stream-to-response.ts\nfunction pipeTextStreamToResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  textStream\n}) {\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: Object.fromEntries(\n      prepareHeaders(headers, {\n        \"content-type\": \"text/plain; charset=utf-8\"\n      }).entries()\n    ),\n    stream: textStream.pipeThrough(new TextEncoderStream())\n  });\n}\n\n// src/ui-message-stream/json-to-sse-transform-stream.ts\nvar JsonToSseTransformStream = class extends TransformStream {\n  constructor() {\n    super({\n      transform(part, controller) {\n        controller.enqueue(`data: ${JSON.stringify(part)}\n\n`);\n      },\n      flush(controller) {\n        controller.enqueue(\"data: [DONE]\\n\\n\");\n      }\n    });\n  }\n};\n\n// src/ui-message-stream/ui-message-stream-headers.ts\nvar UI_MESSAGE_STREAM_HEADERS = {\n  \"content-type\": \"text/event-stream\",\n  \"cache-control\": \"no-cache\",\n  connection: \"keep-alive\",\n  \"x-vercel-ai-ui-message-stream\": \"v1\",\n  \"x-accel-buffering\": \"no\"\n  // disable nginx buffering\n};\n\n// src/ui-message-stream/create-ui-message-stream-response.ts\nfunction createUIMessageStreamResponse({\n  status,\n  statusText,\n  headers,\n  stream,\n  consumeSseStream\n}) {\n  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n  if (consumeSseStream) {\n    const [stream1, stream2] = sseStream.tee();\n    sseStream = stream1;\n    consumeSseStream({ stream: stream2 });\n  }\n  return new Response(sseStream.pipeThrough(new TextEncoderStream()), {\n    status,\n    statusText,\n    headers: prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS)\n  });\n}\n\n// src/ui-message-stream/get-response-ui-message-id.ts\nfunction getResponseUIMessageId({\n  originalMessages,\n  responseMessageId\n}) {\n  if (originalMessages == null) {\n    return void 0;\n  }\n  const lastMessage = originalMessages[originalMessages.length - 1];\n  return (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\" ? lastMessage.id : typeof responseMessageId === \"function\" ? responseMessageId() : responseMessageId;\n}\n\n// src/ui/process-ui-message-stream.ts\n\n\n// src/ui-message-stream/ui-message-chunks.ts\n\nvar uiMessageChunkSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text-start\"),\n    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text-delta\"),\n    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    delta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text-end\"),\n    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"error\"),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-input-start\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n    dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-input-delta\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    inputTextDelta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-input-available\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n    providerMetadata: providerMetadataSchema.optional(),\n    dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-input-error\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n    providerMetadata: providerMetadataSchema.optional(),\n    dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-output-available\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n    dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n    preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-output-error\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n    dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning\"),\n    text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning-start\"),\n    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning-delta\"),\n    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    delta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning-end\"),\n    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning-part-finish\")\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"source-url\"),\n    sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"source-document\"),\n    sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file\"),\n    url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"data-\"),\n    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n    data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    transient: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"start-step\")\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"finish-step\")\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"start\"),\n    messageId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n    messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"finish\"),\n    messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"abort\")\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"message-metadata\"),\n    messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown()\n  })\n]);\nfunction isDataUIMessageChunk(chunk) {\n  return chunk.type.startsWith(\"data-\");\n}\n\n// src/util/merge-objects.ts\nfunction mergeObjects(base, overrides) {\n  if (base === void 0 && overrides === void 0) {\n    return void 0;\n  }\n  if (base === void 0) {\n    return overrides;\n  }\n  if (overrides === void 0) {\n    return base;\n  }\n  const result = { ...base };\n  for (const key in overrides) {\n    if (Object.prototype.hasOwnProperty.call(overrides, key)) {\n      const overridesValue = overrides[key];\n      if (overridesValue === void 0)\n        continue;\n      const baseValue = key in base ? base[key] : void 0;\n      const isSourceObject = overridesValue !== null && typeof overridesValue === \"object\" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);\n      const isTargetObject = baseValue !== null && baseValue !== void 0 && typeof baseValue === \"object\" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);\n      if (isSourceObject && isTargetObject) {\n        result[key] = mergeObjects(\n          baseValue,\n          overridesValue\n        );\n      } else {\n        result[key] = overridesValue;\n      }\n    }\n  }\n  return result;\n}\n\n// src/util/parse-partial-json.ts\n\n\n// src/util/fix-json.ts\nfunction fixJson(input) {\n  const stack = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i, swapState) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_STRING\");\n          break;\n        }\n        case \"f\":\n        case \"t\":\n        case \"n\": {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_LITERAL\");\n          break;\n        }\n        case \"-\": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"{\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_OBJECT_START\");\n          break;\n        }\n        case \"[\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_ARRAY_START\");\n          break;\n        }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n        break;\n      }\n      case \"}\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  function processAfterArrayValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n        break;\n      }\n      case \"]\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n      case \"INSIDE_OBJECT_START\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n          case \"}\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_COMMA\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_KEY\": {\n        switch (char) {\n          case \":\": {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_BEFORE_VALUE\": {\n        processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        processAfterObjectValue(char, i);\n        break;\n      }\n      case \"INSIDE_STRING\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n          case \"\\\\\": {\n            stack.push(\"INSIDE_STRING_ESCAPE\");\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_START\": {\n        switch (char) {\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        switch (char) {\n          case \",\": {\n            stack.pop();\n            stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n            break;\n          }\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_COMMA\": {\n        processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_STRING_ESCAPE\": {\n        stack.pop();\n        lastValidIndex = i;\n        break;\n      }\n      case \"INSIDE_NUMBER\": {\n        switch (char) {\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\": {\n            lastValidIndex = i;\n            break;\n          }\n          case \"e\":\n          case \"E\":\n          case \"-\":\n          case \".\": {\n            break;\n          }\n          case \",\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"}\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"]\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            break;\n          }\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, i + 1);\n        if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n          stack.pop();\n          if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n        break;\n      }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n    switch (state) {\n      case \"INSIDE_STRING\": {\n        result += '\"';\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        result += \"}\";\n        break;\n      }\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        result += \"]\";\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, input.length);\n        if (\"true\".startsWith(partialLiteral)) {\n          result += \"true\".slice(partialLiteral.length);\n        } else if (\"false\".startsWith(partialLiteral)) {\n          result += \"false\".slice(partialLiteral.length);\n        } else if (\"null\".startsWith(partialLiteral)) {\n          result += \"null\".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// src/util/parse-partial-json.ts\nasync function parsePartialJson(jsonText) {\n  if (jsonText === void 0) {\n    return { value: void 0, state: \"undefined-input\" };\n  }\n  let result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: jsonText });\n  if (result.success) {\n    return { value: result.value, state: \"successful-parse\" };\n  }\n  result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: fixJson(jsonText) });\n  if (result.success) {\n    return { value: result.value, state: \"repaired-parse\" };\n  }\n  return { value: void 0, state: \"failed-parse\" };\n}\n\n// src/ui/ui-messages.ts\nfunction isToolUIPart(part) {\n  return part.type.startsWith(\"tool-\");\n}\nfunction isDynamicToolUIPart(part) {\n  return part.type === \"dynamic-tool\";\n}\nfunction isToolOrDynamicToolUIPart(part) {\n  return isToolUIPart(part) || isDynamicToolUIPart(part);\n}\nfunction getToolName(part) {\n  return part.type.split(\"-\").slice(1).join(\"-\");\n}\nfunction getToolOrDynamicToolName(part) {\n  return isDynamicToolUIPart(part) ? part.toolName : getToolName(part);\n}\n\n// src/ui/process-ui-message-stream.ts\nfunction createStreamingUIMessageState({\n  lastMessage,\n  messageId\n}) {\n  return {\n    message: (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\" ? lastMessage : {\n      id: messageId,\n      metadata: void 0,\n      role: \"assistant\",\n      parts: []\n    },\n    activeTextParts: {},\n    activeReasoningParts: {},\n    partialToolCalls: {}\n  };\n}\nfunction processUIMessageStream({\n  stream,\n  messageMetadataSchema,\n  dataPartSchemas,\n  runUpdateMessageJob,\n  onError,\n  onToolCall,\n  onData\n}) {\n  return stream.pipeThrough(\n    new TransformStream({\n      async transform(chunk, controller) {\n        await runUpdateMessageJob(async ({ state, write }) => {\n          var _a17, _b, _c, _d;\n          function getToolInvocation(toolCallId) {\n            const toolInvocations = state.message.parts.filter(isToolUIPart);\n            const toolInvocation = toolInvocations.find(\n              (invocation) => invocation.toolCallId === toolCallId\n            );\n            if (toolInvocation == null) {\n              throw new Error(\n                \"tool-output-error must be preceded by a tool-input-available\"\n              );\n            }\n            return toolInvocation;\n          }\n          function getDynamicToolInvocation(toolCallId) {\n            const toolInvocations = state.message.parts.filter(\n              (part) => part.type === \"dynamic-tool\"\n            );\n            const toolInvocation = toolInvocations.find(\n              (invocation) => invocation.toolCallId === toolCallId\n            );\n            if (toolInvocation == null) {\n              throw new Error(\n                \"tool-output-error must be preceded by a tool-input-available\"\n              );\n            }\n            return toolInvocation;\n          }\n          function updateToolPart(options) {\n            var _a18;\n            const part = state.message.parts.find(\n              (part2) => isToolUIPart(part2) && part2.toolCallId === options.toolCallId\n            );\n            const anyOptions = options;\n            const anyPart = part;\n            if (part != null) {\n              part.state = options.state;\n              anyPart.input = anyOptions.input;\n              anyPart.output = anyOptions.output;\n              anyPart.errorText = anyOptions.errorText;\n              anyPart.rawInput = anyOptions.rawInput;\n              anyPart.preliminary = anyOptions.preliminary;\n              anyPart.providerExecuted = (_a18 = anyOptions.providerExecuted) != null ? _a18 : part.providerExecuted;\n              if (anyOptions.providerMetadata != null && part.state === \"input-available\") {\n                part.callProviderMetadata = anyOptions.providerMetadata;\n              }\n            } else {\n              state.message.parts.push({\n                type: `tool-${options.toolName}`,\n                toolCallId: options.toolCallId,\n                state: options.state,\n                input: anyOptions.input,\n                output: anyOptions.output,\n                rawInput: anyOptions.rawInput,\n                errorText: anyOptions.errorText,\n                providerExecuted: anyOptions.providerExecuted,\n                preliminary: anyOptions.preliminary,\n                ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}\n              });\n            }\n          }\n          function updateDynamicToolPart(options) {\n            var _a18;\n            const part = state.message.parts.find(\n              (part2) => part2.type === \"dynamic-tool\" && part2.toolCallId === options.toolCallId\n            );\n            const anyOptions = options;\n            const anyPart = part;\n            if (part != null) {\n              part.state = options.state;\n              anyPart.toolName = options.toolName;\n              anyPart.input = anyOptions.input;\n              anyPart.output = anyOptions.output;\n              anyPart.errorText = anyOptions.errorText;\n              anyPart.rawInput = (_a18 = anyOptions.rawInput) != null ? _a18 : anyPart.rawInput;\n              anyPart.preliminary = anyOptions.preliminary;\n              if (anyOptions.providerMetadata != null && part.state === \"input-available\") {\n                part.callProviderMetadata = anyOptions.providerMetadata;\n              }\n            } else {\n              state.message.parts.push({\n                type: \"dynamic-tool\",\n                toolName: options.toolName,\n                toolCallId: options.toolCallId,\n                state: options.state,\n                input: anyOptions.input,\n                output: anyOptions.output,\n                errorText: anyOptions.errorText,\n                preliminary: anyOptions.preliminary,\n                ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}\n              });\n            }\n          }\n          async function updateMessageMetadata(metadata) {\n            if (metadata != null) {\n              const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;\n              if (messageMetadataSchema != null) {\n                await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                  value: mergedMetadata,\n                  schema: messageMetadataSchema\n                });\n              }\n              state.message.metadata = mergedMetadata;\n            }\n          }\n          switch (chunk.type) {\n            case \"text-start\": {\n              const textPart = {\n                type: \"text\",\n                text: \"\",\n                providerMetadata: chunk.providerMetadata,\n                state: \"streaming\"\n              };\n              state.activeTextParts[chunk.id] = textPart;\n              state.message.parts.push(textPart);\n              write();\n              break;\n            }\n            case \"text-delta\": {\n              const textPart = state.activeTextParts[chunk.id];\n              textPart.text += chunk.delta;\n              textPart.providerMetadata = (_a17 = chunk.providerMetadata) != null ? _a17 : textPart.providerMetadata;\n              write();\n              break;\n            }\n            case \"text-end\": {\n              const textPart = state.activeTextParts[chunk.id];\n              textPart.state = \"done\";\n              textPart.providerMetadata = (_b = chunk.providerMetadata) != null ? _b : textPart.providerMetadata;\n              delete state.activeTextParts[chunk.id];\n              write();\n              break;\n            }\n            case \"reasoning-start\": {\n              const reasoningPart = {\n                type: \"reasoning\",\n                text: \"\",\n                providerMetadata: chunk.providerMetadata,\n                state: \"streaming\"\n              };\n              state.activeReasoningParts[chunk.id] = reasoningPart;\n              state.message.parts.push(reasoningPart);\n              write();\n              break;\n            }\n            case \"reasoning-delta\": {\n              const reasoningPart = state.activeReasoningParts[chunk.id];\n              reasoningPart.text += chunk.delta;\n              reasoningPart.providerMetadata = (_c = chunk.providerMetadata) != null ? _c : reasoningPart.providerMetadata;\n              write();\n              break;\n            }\n            case \"reasoning-end\": {\n              const reasoningPart = state.activeReasoningParts[chunk.id];\n              reasoningPart.providerMetadata = (_d = chunk.providerMetadata) != null ? _d : reasoningPart.providerMetadata;\n              reasoningPart.state = \"done\";\n              delete state.activeReasoningParts[chunk.id];\n              write();\n              break;\n            }\n            case \"file\": {\n              state.message.parts.push({\n                type: \"file\",\n                mediaType: chunk.mediaType,\n                url: chunk.url\n              });\n              write();\n              break;\n            }\n            case \"source-url\": {\n              state.message.parts.push({\n                type: \"source-url\",\n                sourceId: chunk.sourceId,\n                url: chunk.url,\n                title: chunk.title,\n                providerMetadata: chunk.providerMetadata\n              });\n              write();\n              break;\n            }\n            case \"source-document\": {\n              state.message.parts.push({\n                type: \"source-document\",\n                sourceId: chunk.sourceId,\n                mediaType: chunk.mediaType,\n                title: chunk.title,\n                filename: chunk.filename,\n                providerMetadata: chunk.providerMetadata\n              });\n              write();\n              break;\n            }\n            case \"tool-input-start\": {\n              const toolInvocations = state.message.parts.filter(isToolUIPart);\n              state.partialToolCalls[chunk.toolCallId] = {\n                text: \"\",\n                toolName: chunk.toolName,\n                index: toolInvocations.length,\n                dynamic: chunk.dynamic\n              };\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-streaming\",\n                  input: void 0\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-streaming\",\n                  input: void 0,\n                  providerExecuted: chunk.providerExecuted\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-input-delta\": {\n              const partialToolCall = state.partialToolCalls[chunk.toolCallId];\n              partialToolCall.text += chunk.inputTextDelta;\n              const { value: partialArgs } = await parsePartialJson(\n                partialToolCall.text\n              );\n              if (partialToolCall.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: partialToolCall.toolName,\n                  state: \"input-streaming\",\n                  input: partialArgs\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: partialToolCall.toolName,\n                  state: \"input-streaming\",\n                  input: partialArgs\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-input-available\": {\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-available\",\n                  input: chunk.input,\n                  providerMetadata: chunk.providerMetadata\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-available\",\n                  input: chunk.input,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata\n                });\n              }\n              write();\n              if (onToolCall && !chunk.providerExecuted) {\n                await onToolCall({\n                  toolCall: chunk\n                });\n              }\n              break;\n            }\n            case \"tool-input-error\": {\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"output-error\",\n                  input: chunk.input,\n                  errorText: chunk.errorText,\n                  providerMetadata: chunk.providerMetadata\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"output-error\",\n                  input: void 0,\n                  rawInput: chunk.input,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-output-available\": {\n              if (chunk.dynamic) {\n                const toolInvocation = getDynamicToolInvocation(\n                  chunk.toolCallId\n                );\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: toolInvocation.toolName,\n                  state: \"output-available\",\n                  input: toolInvocation.input,\n                  output: chunk.output,\n                  preliminary: chunk.preliminary\n                });\n              } else {\n                const toolInvocation = getToolInvocation(chunk.toolCallId);\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: getToolName(toolInvocation),\n                  state: \"output-available\",\n                  input: toolInvocation.input,\n                  output: chunk.output,\n                  providerExecuted: chunk.providerExecuted,\n                  preliminary: chunk.preliminary\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-output-error\": {\n              if (chunk.dynamic) {\n                const toolInvocation = getDynamicToolInvocation(\n                  chunk.toolCallId\n                );\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: toolInvocation.toolName,\n                  state: \"output-error\",\n                  input: toolInvocation.input,\n                  errorText: chunk.errorText\n                });\n              } else {\n                const toolInvocation = getToolInvocation(chunk.toolCallId);\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: getToolName(toolInvocation),\n                  state: \"output-error\",\n                  input: toolInvocation.input,\n                  rawInput: toolInvocation.rawInput,\n                  errorText: chunk.errorText\n                });\n              }\n              write();\n              break;\n            }\n            case \"start-step\": {\n              state.message.parts.push({ type: \"step-start\" });\n              break;\n            }\n            case \"finish-step\": {\n              state.activeTextParts = {};\n              state.activeReasoningParts = {};\n              break;\n            }\n            case \"start\": {\n              if (chunk.messageId != null) {\n                state.message.id = chunk.messageId;\n              }\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageId != null || chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"finish\": {\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"message-metadata\": {\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"error\": {\n              onError == null ? void 0 : onError(new Error(chunk.errorText));\n              break;\n            }\n            default: {\n              if (isDataUIMessageChunk(chunk)) {\n                if ((dataPartSchemas == null ? void 0 : dataPartSchemas[chunk.type]) != null) {\n                  await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                    value: chunk.data,\n                    schema: dataPartSchemas[chunk.type]\n                  });\n                }\n                const dataChunk = chunk;\n                if (dataChunk.transient) {\n                  onData == null ? void 0 : onData(dataChunk);\n                  break;\n                }\n                const existingUIPart = dataChunk.id != null ? state.message.parts.find(\n                  (chunkArg) => dataChunk.type === chunkArg.type && dataChunk.id === chunkArg.id\n                ) : void 0;\n                if (existingUIPart != null) {\n                  existingUIPart.data = dataChunk.data;\n                } else {\n                  state.message.parts.push(dataChunk);\n                }\n                onData == null ? void 0 : onData(dataChunk);\n                write();\n              }\n            }\n          }\n          controller.enqueue(chunk);\n        });\n      }\n    })\n  );\n}\n\n// src/ui-message-stream/handle-ui-message-stream-finish.ts\nfunction handleUIMessageStreamFinish({\n  messageId,\n  originalMessages = [],\n  onFinish,\n  onError,\n  stream\n}) {\n  let lastMessage = originalMessages == null ? void 0 : originalMessages[originalMessages.length - 1];\n  if ((lastMessage == null ? void 0 : lastMessage.role) !== \"assistant\") {\n    lastMessage = void 0;\n  } else {\n    messageId = lastMessage.id;\n  }\n  let isAborted = false;\n  const idInjectedStream = stream.pipeThrough(\n    new TransformStream({\n      transform(chunk, controller) {\n        if (chunk.type === \"start\") {\n          const startChunk = chunk;\n          if (startChunk.messageId == null && messageId != null) {\n            startChunk.messageId = messageId;\n          }\n        }\n        if (chunk.type === \"abort\") {\n          isAborted = true;\n        }\n        controller.enqueue(chunk);\n      }\n    })\n  );\n  if (onFinish == null) {\n    return idInjectedStream;\n  }\n  const state = createStreamingUIMessageState({\n    lastMessage: lastMessage ? structuredClone(lastMessage) : void 0,\n    messageId: messageId != null ? messageId : \"\"\n    // will be overridden by the stream\n  });\n  const runUpdateMessageJob = async (job) => {\n    await job({ state, write: () => {\n    } });\n  };\n  let finishCalled = false;\n  const callOnFinish = async () => {\n    if (finishCalled || !onFinish) {\n      return;\n    }\n    finishCalled = true;\n    const isContinuation = state.message.id === (lastMessage == null ? void 0 : lastMessage.id);\n    await onFinish({\n      isAborted,\n      isContinuation,\n      responseMessage: state.message,\n      messages: [\n        ...isContinuation ? originalMessages.slice(0, -1) : originalMessages,\n        state.message\n      ]\n    });\n  };\n  return processUIMessageStream({\n    stream: idInjectedStream,\n    runUpdateMessageJob,\n    onError\n  }).pipeThrough(\n    new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      },\n      // @ts-expect-error cancel is still new and missing from types https://developer.mozilla.org/en-US/docs/Web/API/TransformStream#browser_compatibility\n      async cancel() {\n        await callOnFinish();\n      },\n      async flush() {\n        await callOnFinish();\n      }\n    })\n  );\n}\n\n// src/ui-message-stream/pipe-ui-message-stream-to-response.ts\nfunction pipeUIMessageStreamToResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream,\n  consumeSseStream\n}) {\n  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n  if (consumeSseStream) {\n    const [stream1, stream2] = sseStream.tee();\n    sseStream = stream1;\n    consumeSseStream({ stream: stream2 });\n  }\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: Object.fromEntries(\n      prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS).entries()\n    ),\n    stream: sseStream.pipeThrough(new TextEncoderStream())\n  });\n}\n\n// src/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source) {\n  const stream = source.pipeThrough(new TransformStream());\n  stream[Symbol.asyncIterator] = function() {\n    const reader = this.getReader();\n    let finished = false;\n    async function cleanup(cancelStream) {\n      var _a17;\n      finished = true;\n      try {\n        if (cancelStream) {\n          await ((_a17 = reader.cancel) == null ? void 0 : _a17.call(reader));\n        }\n      } finally {\n        try {\n          reader.releaseLock();\n        } catch (e) {\n        }\n      }\n    }\n    return {\n      /**\n       * Reads the next chunk from the stream.\n       * @returns A promise resolving to the next IteratorResult.\n       */\n      async next() {\n        if (finished) {\n          return { done: true, value: void 0 };\n        }\n        const { done, value } = await reader.read();\n        if (done) {\n          await cleanup(true);\n          return { done: true, value: void 0 };\n        }\n        return { done: false, value };\n      },\n      /**\n       * Called on early exit (e.g., break from for-await).\n       * Ensures the stream is cancelled and resources are released.\n       * @returns A promise resolving to a completed IteratorResult.\n       */\n      async return() {\n        await cleanup(true);\n        return { done: true, value: void 0 };\n      },\n      /**\n       * Called on early exit with error.\n       * Ensures the stream is cancelled and resources are released, then rethrows the error.\n       * @param err The error to throw.\n       * @returns A promise that rejects with the provided error.\n       */\n      async throw(err) {\n        await cleanup(true);\n        throw err;\n      }\n    };\n  };\n  return stream;\n}\n\n// src/util/consume-stream.ts\nasync function consumeStream({\n  stream,\n  onError\n}) {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { done } = await reader.read();\n      if (done)\n        break;\n    }\n  } catch (error) {\n    onError == null ? void 0 : onError(error);\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// src/util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n  let resolve2;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve2 = res;\n    reject = rej;\n  });\n  return {\n    promise,\n    resolve: resolve2,\n    reject\n  };\n}\n\n// src/util/create-stitchable-stream.ts\nfunction createStitchableStream() {\n  let innerStreamReaders = [];\n  let controller = null;\n  let isClosed = false;\n  let waitForNewStream = createResolvablePromise();\n  const terminate = () => {\n    isClosed = true;\n    waitForNewStream.resolve();\n    innerStreamReaders.forEach((reader) => reader.cancel());\n    innerStreamReaders = [];\n    controller == null ? void 0 : controller.close();\n  };\n  const processPull = async () => {\n    if (isClosed && innerStreamReaders.length === 0) {\n      controller == null ? void 0 : controller.close();\n      return;\n    }\n    if (innerStreamReaders.length === 0) {\n      waitForNewStream = createResolvablePromise();\n      await waitForNewStream.promise;\n      return processPull();\n    }\n    try {\n      const { value, done } = await innerStreamReaders[0].read();\n      if (done) {\n        innerStreamReaders.shift();\n        if (innerStreamReaders.length > 0) {\n          await processPull();\n        } else if (isClosed) {\n          controller == null ? void 0 : controller.close();\n        }\n      } else {\n        controller == null ? void 0 : controller.enqueue(value);\n      }\n    } catch (error) {\n      controller == null ? void 0 : controller.error(error);\n      innerStreamReaders.shift();\n      terminate();\n    }\n  };\n  return {\n    stream: new ReadableStream({\n      start(controllerParam) {\n        controller = controllerParam;\n      },\n      pull: processPull,\n      async cancel() {\n        for (const reader of innerStreamReaders) {\n          await reader.cancel();\n        }\n        innerStreamReaders = [];\n        isClosed = true;\n      }\n    }),\n    addStream: (innerStream) => {\n      if (isClosed) {\n        throw new Error(\"Cannot add inner stream: outer stream is closed\");\n      }\n      innerStreamReaders.push(innerStream.getReader());\n      waitForNewStream.resolve();\n    },\n    /**\n     * Gracefully close the outer stream. This will let the inner streams\n     * finish processing and then close the outer stream.\n     */\n    close: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n      if (innerStreamReaders.length === 0) {\n        controller == null ? void 0 : controller.close();\n      }\n    },\n    /**\n     * Immediately close the outer stream. This will cancel all inner streams\n     * and close the outer stream.\n     */\n    terminate\n  };\n}\n\n// src/util/delayed-promise.ts\nvar DelayedPromise = class {\n  constructor() {\n    this.status = { type: \"pending\" };\n    this._resolve = void 0;\n    this._reject = void 0;\n  }\n  get promise() {\n    if (this._promise) {\n      return this._promise;\n    }\n    this._promise = new Promise((resolve2, reject) => {\n      if (this.status.type === \"resolved\") {\n        resolve2(this.status.value);\n      } else if (this.status.type === \"rejected\") {\n        reject(this.status.error);\n      }\n      this._resolve = resolve2;\n      this._reject = reject;\n    });\n    return this._promise;\n  }\n  resolve(value) {\n    var _a17;\n    this.status = { type: \"resolved\", value };\n    if (this._promise) {\n      (_a17 = this._resolve) == null ? void 0 : _a17.call(this, value);\n    }\n  }\n  reject(error) {\n    var _a17;\n    this.status = { type: \"rejected\", error };\n    if (this._promise) {\n      (_a17 = this._reject) == null ? void 0 : _a17.call(this, error);\n    }\n  }\n};\n\n// src/util/now.ts\nfunction now() {\n  var _a17, _b;\n  return (_b = (_a17 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a17.now()) != null ? _b : Date.now();\n}\n\n// src/generate-text/run-tools-transformation.ts\n\nfunction runToolsTransformation({\n  tools,\n  generatorStream,\n  tracer,\n  telemetry,\n  system,\n  messages,\n  abortSignal,\n  repairToolCall,\n  experimental_context\n}) {\n  let toolResultsStreamController = null;\n  const toolResultsStream = new ReadableStream({\n    start(controller) {\n      toolResultsStreamController = controller;\n    }\n  });\n  const outstandingToolResults = /* @__PURE__ */ new Set();\n  const toolInputs = /* @__PURE__ */ new Map();\n  let canClose = false;\n  let finishChunk = void 0;\n  function attemptClose() {\n    if (canClose && outstandingToolResults.size === 0) {\n      if (finishChunk != null) {\n        toolResultsStreamController.enqueue(finishChunk);\n      }\n      toolResultsStreamController.close();\n    }\n  }\n  const forwardStream = new TransformStream({\n    async transform(chunk, controller) {\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"stream-start\":\n        case \"text-start\":\n        case \"text-delta\":\n        case \"text-end\":\n        case \"reasoning-start\":\n        case \"reasoning-delta\":\n        case \"reasoning-end\":\n        case \"tool-input-start\":\n        case \"tool-input-delta\":\n        case \"tool-input-end\":\n        case \"source\":\n        case \"response-metadata\":\n        case \"error\":\n        case \"raw\": {\n          controller.enqueue(chunk);\n          break;\n        }\n        case \"file\": {\n          controller.enqueue({\n            type: \"file\",\n            file: new DefaultGeneratedFileWithType({\n              data: chunk.data,\n              mediaType: chunk.mediaType\n            })\n          });\n          break;\n        }\n        case \"finish\": {\n          finishChunk = {\n            type: \"finish\",\n            finishReason: chunk.finishReason,\n            usage: chunk.usage,\n            providerMetadata: chunk.providerMetadata\n          };\n          break;\n        }\n        case \"tool-call\": {\n          try {\n            const toolCall = await parseToolCall({\n              toolCall: chunk,\n              tools,\n              repairToolCall,\n              system,\n              messages\n            });\n            controller.enqueue(toolCall);\n            if (toolCall.invalid) {\n              toolResultsStreamController.enqueue({\n                type: \"tool-error\",\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                input: toolCall.input,\n                error: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(toolCall.error),\n                dynamic: true\n              });\n              break;\n            }\n            const tool3 = tools[toolCall.toolName];\n            toolInputs.set(toolCall.toolCallId, toolCall.input);\n            if (tool3.onInputAvailable != null) {\n              await tool3.onInputAvailable({\n                input: toolCall.input,\n                toolCallId: toolCall.toolCallId,\n                messages,\n                abortSignal,\n                experimental_context\n              });\n            }\n            if (tool3.execute != null && toolCall.providerExecuted !== true) {\n              const toolExecutionId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId)();\n              outstandingToolResults.add(toolExecutionId);\n              recordSpan({\n                name: \"ai.toolCall\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.toolCall\",\n                      telemetry\n                    }),\n                    \"ai.toolCall.name\": toolCall.toolName,\n                    \"ai.toolCall.id\": toolCall.toolCallId,\n                    \"ai.toolCall.args\": {\n                      output: () => JSON.stringify(toolCall.input)\n                    }\n                  }\n                }),\n                tracer,\n                fn: async (span) => {\n                  let output;\n                  try {\n                    const stream = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.executeTool)({\n                      execute: tool3.execute.bind(tool3),\n                      input: toolCall.input,\n                      options: {\n                        toolCallId: toolCall.toolCallId,\n                        messages,\n                        abortSignal,\n                        experimental_context\n                      }\n                    });\n                    for await (const part of stream) {\n                      toolResultsStreamController.enqueue({\n                        ...toolCall,\n                        type: \"tool-result\",\n                        output: part.output,\n                        ...part.type === \"preliminary\" && {\n                          preliminary: true\n                        }\n                      });\n                      if (part.type === \"final\") {\n                        output = part.output;\n                      }\n                    }\n                  } catch (error) {\n                    recordErrorOnSpan(span, error);\n                    toolResultsStreamController.enqueue({\n                      ...toolCall,\n                      type: \"tool-error\",\n                      error\n                    });\n                    outstandingToolResults.delete(toolExecutionId);\n                    attemptClose();\n                    return;\n                  }\n                  outstandingToolResults.delete(toolExecutionId);\n                  attemptClose();\n                  try {\n                    span.setAttributes(\n                      selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                          \"ai.toolCall.result\": {\n                            output: () => JSON.stringify(output)\n                          }\n                        }\n                      })\n                    );\n                  } catch (ignored) {\n                  }\n                }\n              });\n            }\n          } catch (error) {\n            toolResultsStreamController.enqueue({ type: \"error\", error });\n          }\n          break;\n        }\n        case \"tool-result\": {\n          const toolName = chunk.toolName;\n          if (chunk.isError) {\n            toolResultsStreamController.enqueue({\n              type: \"tool-error\",\n              toolCallId: chunk.toolCallId,\n              toolName,\n              input: toolInputs.get(chunk.toolCallId),\n              providerExecuted: chunk.providerExecuted,\n              error: chunk.result\n            });\n          } else {\n            controller.enqueue({\n              type: \"tool-result\",\n              toolCallId: chunk.toolCallId,\n              toolName,\n              input: toolInputs.get(chunk.toolCallId),\n              output: chunk.result,\n              providerExecuted: chunk.providerExecuted\n            });\n          }\n          break;\n        }\n        default: {\n          const _exhaustiveCheck = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    flush() {\n      canClose = true;\n      attemptClose();\n    }\n  });\n  return new ReadableStream({\n    async start(controller) {\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n            }\n          })\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            }\n          })\n        )\n      ]);\n    }\n  });\n}\n\n// src/generate-text/stream-text.ts\nvar originalGenerateId2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n  prefix: \"aitxt\",\n  size: 24\n});\nfunction streamText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  stopWhen = stepCountIs(1),\n  experimental_output: output,\n  experimental_telemetry: telemetry,\n  prepareStep,\n  providerOptions,\n  experimental_activeTools,\n  activeTools = experimental_activeTools,\n  experimental_repairToolCall: repairToolCall,\n  experimental_transform: transform,\n  experimental_download: download2,\n  includeRawChunks = false,\n  onChunk,\n  onError = ({ error }) => {\n    console.error(error);\n  },\n  onFinish,\n  onAbort,\n  onStepFinish,\n  experimental_context,\n  _internal: {\n    now: now2 = now,\n    generateId: generateId3 = originalGenerateId2,\n    currentDate = () => /* @__PURE__ */ new Date()\n  } = {},\n  ...settings\n}) {\n  return new DefaultStreamTextResult({\n    model: resolveLanguageModel(model),\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    transforms: asArray(transform),\n    activeTools,\n    repairToolCall,\n    stopConditions: asArray(stopWhen),\n    output,\n    providerOptions,\n    prepareStep,\n    includeRawChunks,\n    onChunk,\n    onError,\n    onFinish,\n    onAbort,\n    onStepFinish,\n    now: now2,\n    currentDate,\n    generateId: generateId3,\n    experimental_context,\n    download: download2\n  });\n}\nfunction createOutputTransformStream(output) {\n  if (!output) {\n    return new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n      }\n    });\n  }\n  let firstTextChunkId = void 0;\n  let text2 = \"\";\n  let textChunk = \"\";\n  let lastPublishedJson = \"\";\n  function publishTextChunk({\n    controller,\n    partialOutput = void 0\n  }) {\n    controller.enqueue({\n      part: {\n        type: \"text-delta\",\n        id: firstTextChunkId,\n        text: textChunk\n      },\n      partialOutput\n    });\n    textChunk = \"\";\n  }\n  return new TransformStream({\n    async transform(chunk, controller) {\n      if (chunk.type === \"finish-step\" && textChunk.length > 0) {\n        publishTextChunk({ controller });\n      }\n      if (chunk.type !== \"text-delta\" && chunk.type !== \"text-start\" && chunk.type !== \"text-end\") {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      if (firstTextChunkId == null) {\n        firstTextChunkId = chunk.id;\n      } else if (chunk.id !== firstTextChunkId) {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      if (chunk.type === \"text-start\") {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      if (chunk.type === \"text-end\") {\n        if (textChunk.length > 0) {\n          publishTextChunk({ controller });\n        }\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      text2 += chunk.text;\n      textChunk += chunk.text;\n      const result = await output.parsePartial({ text: text2 });\n      if (result != null) {\n        const currentJson = JSON.stringify(result.partial);\n        if (currentJson !== lastPublishedJson) {\n          publishTextChunk({ controller, partialOutput: result.partial });\n          lastPublishedJson = currentJson;\n        }\n      }\n    }\n  });\n}\nvar DefaultStreamTextResult = class {\n  constructor({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    transforms,\n    activeTools,\n    repairToolCall,\n    stopConditions,\n    output,\n    providerOptions,\n    prepareStep,\n    includeRawChunks,\n    now: now2,\n    currentDate,\n    generateId: generateId3,\n    onChunk,\n    onError,\n    onFinish,\n    onAbort,\n    onStepFinish,\n    experimental_context,\n    download: download2\n  }) {\n    this._totalUsage = new DelayedPromise();\n    this._finishReason = new DelayedPromise();\n    this._steps = new DelayedPromise();\n    this.output = output;\n    this.includeRawChunks = includeRawChunks;\n    this.tools = tools;\n    let stepFinish;\n    let recordedContent = [];\n    const recordedResponseMessages = [];\n    let recordedFinishReason = void 0;\n    let recordedTotalUsage = void 0;\n    let recordedRequest = {};\n    let recordedWarnings = [];\n    const recordedSteps = [];\n    let rootSpan;\n    let activeTextContent = {};\n    let activeReasoningContent = {};\n    const eventProcessor = new TransformStream({\n      async transform(chunk, controller) {\n        var _a17, _b, _c;\n        controller.enqueue(chunk);\n        const { part } = chunk;\n        if (part.type === \"text-delta\" || part.type === \"reasoning-delta\" || part.type === \"source\" || part.type === \"tool-call\" || part.type === \"tool-result\" || part.type === \"tool-input-start\" || part.type === \"tool-input-delta\" || part.type === \"raw\") {\n          await (onChunk == null ? void 0 : onChunk({ chunk: part }));\n        }\n        if (part.type === \"error\") {\n          await onError({ error: wrapGatewayError(part.error) });\n        }\n        if (part.type === \"text-start\") {\n          activeTextContent[part.id] = {\n            type: \"text\",\n            text: \"\",\n            providerMetadata: part.providerMetadata\n          };\n          recordedContent.push(activeTextContent[part.id]);\n        }\n        if (part.type === \"text-delta\") {\n          const activeText = activeTextContent[part.id];\n          if (activeText == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `text part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeText.text += part.text;\n          activeText.providerMetadata = (_a17 = part.providerMetadata) != null ? _a17 : activeText.providerMetadata;\n        }\n        if (part.type === \"text-end\") {\n          delete activeTextContent[part.id];\n        }\n        if (part.type === \"reasoning-start\") {\n          activeReasoningContent[part.id] = {\n            type: \"reasoning\",\n            text: \"\",\n            providerMetadata: part.providerMetadata\n          };\n          recordedContent.push(activeReasoningContent[part.id]);\n        }\n        if (part.type === \"reasoning-delta\") {\n          const activeReasoning = activeReasoningContent[part.id];\n          if (activeReasoning == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `reasoning part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeReasoning.text += part.text;\n          activeReasoning.providerMetadata = (_b = part.providerMetadata) != null ? _b : activeReasoning.providerMetadata;\n        }\n        if (part.type === \"reasoning-end\") {\n          const activeReasoning = activeReasoningContent[part.id];\n          if (activeReasoning == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `reasoning part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeReasoning.providerMetadata = (_c = part.providerMetadata) != null ? _c : activeReasoning.providerMetadata;\n          delete activeReasoningContent[part.id];\n        }\n        if (part.type === \"file\") {\n          recordedContent.push({ type: \"file\", file: part.file });\n        }\n        if (part.type === \"source\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-call\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-result\" && !part.preliminary) {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-error\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"start-step\") {\n          recordedRequest = part.request;\n          recordedWarnings = part.warnings;\n        }\n        if (part.type === \"finish-step\") {\n          const stepMessages = toResponseMessages({\n            content: recordedContent,\n            tools\n          });\n          const currentStepResult = new DefaultStepResult({\n            content: recordedContent,\n            finishReason: part.finishReason,\n            usage: part.usage,\n            warnings: recordedWarnings,\n            request: recordedRequest,\n            response: {\n              ...part.response,\n              messages: [...recordedResponseMessages, ...stepMessages]\n            },\n            providerMetadata: part.providerMetadata\n          });\n          await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n          logWarnings(recordedWarnings);\n          recordedSteps.push(currentStepResult);\n          recordedContent = [];\n          activeReasoningContent = {};\n          activeTextContent = {};\n          recordedResponseMessages.push(...stepMessages);\n          stepFinish.resolve();\n        }\n        if (part.type === \"finish\") {\n          recordedTotalUsage = part.totalUsage;\n          recordedFinishReason = part.finishReason;\n        }\n      },\n      async flush(controller) {\n        try {\n          if (recordedSteps.length === 0) {\n            const error = new NoOutputGeneratedError({\n              message: \"No output generated. Check the stream for errors.\"\n            });\n            self._finishReason.reject(error);\n            self._totalUsage.reject(error);\n            self._steps.reject(error);\n            return;\n          }\n          const finishReason = recordedFinishReason != null ? recordedFinishReason : \"unknown\";\n          const totalUsage = recordedTotalUsage != null ? recordedTotalUsage : {\n            inputTokens: void 0,\n            outputTokens: void 0,\n            totalTokens: void 0\n          };\n          self._finishReason.resolve(finishReason);\n          self._totalUsage.resolve(totalUsage);\n          self._steps.resolve(recordedSteps);\n          const finalStep = recordedSteps[recordedSteps.length - 1];\n          await (onFinish == null ? void 0 : onFinish({\n            finishReason,\n            totalUsage,\n            usage: finalStep.usage,\n            content: finalStep.content,\n            text: finalStep.text,\n            reasoningText: finalStep.reasoningText,\n            reasoning: finalStep.reasoning,\n            files: finalStep.files,\n            sources: finalStep.sources,\n            toolCalls: finalStep.toolCalls,\n            staticToolCalls: finalStep.staticToolCalls,\n            dynamicToolCalls: finalStep.dynamicToolCalls,\n            toolResults: finalStep.toolResults,\n            staticToolResults: finalStep.staticToolResults,\n            dynamicToolResults: finalStep.dynamicToolResults,\n            request: finalStep.request,\n            response: finalStep.response,\n            warnings: finalStep.warnings,\n            providerMetadata: finalStep.providerMetadata,\n            steps: recordedSteps\n          }));\n          rootSpan.setAttributes(\n            selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                \"ai.response.finishReason\": finishReason,\n                \"ai.response.text\": { output: () => finalStep.text },\n                \"ai.response.toolCalls\": {\n                  output: () => {\n                    var _a17;\n                    return ((_a17 = finalStep.toolCalls) == null ? void 0 : _a17.length) ? JSON.stringify(finalStep.toolCalls) : void 0;\n                  }\n                },\n                \"ai.response.providerMetadata\": JSON.stringify(\n                  finalStep.providerMetadata\n                ),\n                \"ai.usage.inputTokens\": totalUsage.inputTokens,\n                \"ai.usage.outputTokens\": totalUsage.outputTokens,\n                \"ai.usage.totalTokens\": totalUsage.totalTokens,\n                \"ai.usage.reasoningTokens\": totalUsage.reasoningTokens,\n                \"ai.usage.cachedInputTokens\": totalUsage.cachedInputTokens\n              }\n            })\n          );\n        } catch (error) {\n          controller.error(error);\n        } finally {\n          rootSpan.end();\n        }\n      }\n    });\n    const stitchableStream = createStitchableStream();\n    this.addStream = stitchableStream.addStream;\n    this.closeStream = stitchableStream.close;\n    const reader = stitchableStream.stream.getReader();\n    let stream = new ReadableStream({\n      async start(controller) {\n        controller.enqueue({ type: \"start\" });\n      },\n      async pull(controller) {\n        function abort() {\n          onAbort == null ? void 0 : onAbort({ steps: recordedSteps });\n          controller.enqueue({ type: \"abort\" });\n          controller.close();\n        }\n        try {\n          const { done, value } = await reader.read();\n          if (done) {\n            controller.close();\n            return;\n          }\n          if (abortSignal == null ? void 0 : abortSignal.aborted) {\n            abort();\n            return;\n          }\n          controller.enqueue(value);\n        } catch (error) {\n          if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isAbortError)(error) && (abortSignal == null ? void 0 : abortSignal.aborted)) {\n            abort();\n          } else {\n            controller.error(error);\n          }\n        }\n      },\n      cancel(reason) {\n        return stitchableStream.stream.cancel(reason);\n      }\n    });\n    for (const transform of transforms) {\n      stream = stream.pipeThrough(\n        transform({\n          tools,\n          stopStream() {\n            stitchableStream.terminate();\n          }\n        })\n      );\n    }\n    this.baseStream = stream.pipeThrough(createOutputTransformStream(output)).pipeThrough(eventProcessor);\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n      abortSignal\n    });\n    const tracer = getTracer(telemetry);\n    const callSettings = prepareCallSettings(settings);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...callSettings, maxRetries }\n    });\n    const self = this;\n    recordSpan({\n      name: \"ai.streamText\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({ operationId: \"ai.streamText\", telemetry }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          }\n        }\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async (rootSpanArg) => {\n        rootSpan = rootSpanArg;\n        async function streamStep({\n          currentStep,\n          responseMessages,\n          usage\n        }) {\n          var _a17, _b, _c, _d, _e;\n          const includeRawChunks2 = self.includeRawChunks;\n          stepFinish = new DelayedPromise();\n          const initialPrompt = await standardizePrompt({\n            system,\n            prompt,\n            messages\n          });\n          const stepInputMessages = [\n            ...initialPrompt.messages,\n            ...responseMessages\n          ];\n          const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n            model,\n            steps: recordedSteps,\n            stepNumber: recordedSteps.length,\n            messages: stepInputMessages\n          }));\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: {\n              system: (_a17 = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _a17 : initialPrompt.system,\n              messages: (_b = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _b : stepInputMessages\n            },\n            supportedUrls: await model.supportedUrls,\n            download: download2\n          });\n          const stepModel = resolveLanguageModel(\n            (_c = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _c : model\n          );\n          const { toolChoice: stepToolChoice, tools: stepTools } = prepareToolsAndToolChoice({\n            tools,\n            toolChoice: (_d = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _d : toolChoice,\n            activeTools: (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools\n          });\n          const {\n            result: { stream: stream2, response, request },\n            doStreamSpan,\n            startTimestampMs\n          } = await retry(\n            () => recordSpan({\n              name: \"ai.streamText.doStream\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: \"ai.streamText.doStream\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  // model:\n                  \"ai.model.provider\": stepModel.provider,\n                  \"ai.model.id\": stepModel.modelId,\n                  // prompt:\n                  \"ai.prompt.messages\": {\n                    input: () => stringifyForTelemetry(promptMessages)\n                  },\n                  \"ai.prompt.tools\": {\n                    // convert the language model level tools:\n                    input: () => stepTools == null ? void 0 : stepTools.map((tool3) => JSON.stringify(tool3))\n                  },\n                  \"ai.prompt.toolChoice\": {\n                    input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0\n                  },\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.system\": stepModel.provider,\n                  \"gen_ai.request.model\": stepModel.modelId,\n                  \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                  \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                  \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                  \"gen_ai.request.stop_sequences\": callSettings.stopSequences,\n                  \"gen_ai.request.temperature\": callSettings.temperature,\n                  \"gen_ai.request.top_k\": callSettings.topK,\n                  \"gen_ai.request.top_p\": callSettings.topP\n                }\n              }),\n              tracer,\n              endWhenDone: false,\n              fn: async (doStreamSpan2) => {\n                return {\n                  startTimestampMs: now2(),\n                  // get before the call\n                  doStreamSpan: doStreamSpan2,\n                  result: await stepModel.doStream({\n                    ...callSettings,\n                    tools: stepTools,\n                    toolChoice: stepToolChoice,\n                    responseFormat: output == null ? void 0 : output.responseFormat,\n                    prompt: promptMessages,\n                    providerOptions,\n                    abortSignal,\n                    headers,\n                    includeRawChunks: includeRawChunks2\n                  })\n                };\n              }\n            })\n          );\n          const streamWithToolResults = runToolsTransformation({\n            tools,\n            generatorStream: stream2,\n            tracer,\n            telemetry,\n            system,\n            messages: stepInputMessages,\n            repairToolCall,\n            abortSignal,\n            experimental_context\n          });\n          const stepRequest = request != null ? request : {};\n          const stepToolCalls = [];\n          const stepToolOutputs = [];\n          let warnings;\n          const activeToolCallToolNames = {};\n          let stepFinishReason = \"unknown\";\n          let stepUsage = {\n            inputTokens: void 0,\n            outputTokens: void 0,\n            totalTokens: void 0\n          };\n          let stepProviderMetadata;\n          let stepFirstChunk = true;\n          let stepResponse = {\n            id: generateId3(),\n            timestamp: currentDate(),\n            modelId: model.modelId\n          };\n          let activeText = \"\";\n          self.addStream(\n            streamWithToolResults.pipeThrough(\n              new TransformStream({\n                async transform(chunk, controller) {\n                  var _a18, _b2, _c2, _d2;\n                  if (chunk.type === \"stream-start\") {\n                    warnings = chunk.warnings;\n                    return;\n                  }\n                  if (stepFirstChunk) {\n                    const msToFirstChunk = now2() - startTimestampMs;\n                    stepFirstChunk = false;\n                    doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                      \"ai.response.msToFirstChunk\": msToFirstChunk\n                    });\n                    doStreamSpan.setAttributes({\n                      \"ai.response.msToFirstChunk\": msToFirstChunk\n                    });\n                    controller.enqueue({\n                      type: \"start-step\",\n                      request: stepRequest,\n                      warnings: warnings != null ? warnings : []\n                    });\n                  }\n                  const chunkType = chunk.type;\n                  switch (chunkType) {\n                    case \"text-start\":\n                    case \"text-end\": {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"text-delta\": {\n                      if (chunk.delta.length > 0) {\n                        controller.enqueue({\n                          type: \"text-delta\",\n                          id: chunk.id,\n                          text: chunk.delta,\n                          providerMetadata: chunk.providerMetadata\n                        });\n                        activeText += chunk.delta;\n                      }\n                      break;\n                    }\n                    case \"reasoning-start\":\n                    case \"reasoning-end\": {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"reasoning-delta\": {\n                      controller.enqueue({\n                        type: \"reasoning-delta\",\n                        id: chunk.id,\n                        text: chunk.delta,\n                        providerMetadata: chunk.providerMetadata\n                      });\n                      break;\n                    }\n                    case \"tool-call\": {\n                      controller.enqueue(chunk);\n                      stepToolCalls.push(chunk);\n                      break;\n                    }\n                    case \"tool-result\": {\n                      controller.enqueue(chunk);\n                      if (!chunk.preliminary) {\n                        stepToolOutputs.push(chunk);\n                      }\n                      break;\n                    }\n                    case \"tool-error\": {\n                      controller.enqueue(chunk);\n                      stepToolOutputs.push(chunk);\n                      break;\n                    }\n                    case \"response-metadata\": {\n                      stepResponse = {\n                        id: (_a18 = chunk.id) != null ? _a18 : stepResponse.id,\n                        timestamp: (_b2 = chunk.timestamp) != null ? _b2 : stepResponse.timestamp,\n                        modelId: (_c2 = chunk.modelId) != null ? _c2 : stepResponse.modelId\n                      };\n                      break;\n                    }\n                    case \"finish\": {\n                      stepUsage = chunk.usage;\n                      stepFinishReason = chunk.finishReason;\n                      stepProviderMetadata = chunk.providerMetadata;\n                      const msToFinish = now2() - startTimestampMs;\n                      doStreamSpan.addEvent(\"ai.stream.finish\");\n                      doStreamSpan.setAttributes({\n                        \"ai.response.msToFinish\": msToFinish,\n                        \"ai.response.avgOutputTokensPerSecond\": 1e3 * ((_d2 = stepUsage.outputTokens) != null ? _d2 : 0) / msToFinish\n                      });\n                      break;\n                    }\n                    case \"file\": {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"source\": {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"tool-input-start\": {\n                      activeToolCallToolNames[chunk.id] = chunk.toolName;\n                      const tool3 = tools == null ? void 0 : tools[chunk.toolName];\n                      if ((tool3 == null ? void 0 : tool3.onInputStart) != null) {\n                        await tool3.onInputStart({\n                          toolCallId: chunk.id,\n                          messages: stepInputMessages,\n                          abortSignal,\n                          experimental_context\n                        });\n                      }\n                      controller.enqueue({\n                        ...chunk,\n                        dynamic: (tool3 == null ? void 0 : tool3.type) === \"dynamic\"\n                      });\n                      break;\n                    }\n                    case \"tool-input-end\": {\n                      delete activeToolCallToolNames[chunk.id];\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"tool-input-delta\": {\n                      const toolName = activeToolCallToolNames[chunk.id];\n                      const tool3 = tools == null ? void 0 : tools[toolName];\n                      if ((tool3 == null ? void 0 : tool3.onInputDelta) != null) {\n                        await tool3.onInputDelta({\n                          inputTextDelta: chunk.delta,\n                          toolCallId: chunk.id,\n                          messages: stepInputMessages,\n                          abortSignal,\n                          experimental_context\n                        });\n                      }\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"error\": {\n                      controller.enqueue(chunk);\n                      stepFinishReason = \"error\";\n                      break;\n                    }\n                    case \"raw\": {\n                      if (includeRawChunks2) {\n                        controller.enqueue(chunk);\n                      }\n                      break;\n                    }\n                    default: {\n                      const exhaustiveCheck = chunkType;\n                      throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                    }\n                  }\n                },\n                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                async flush(controller) {\n                  const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;\n                  try {\n                    doStreamSpan.setAttributes(\n                      selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                          \"ai.response.finishReason\": stepFinishReason,\n                          \"ai.response.text\": {\n                            output: () => activeText\n                          },\n                          \"ai.response.toolCalls\": {\n                            output: () => stepToolCallsJson\n                          },\n                          \"ai.response.id\": stepResponse.id,\n                          \"ai.response.model\": stepResponse.modelId,\n                          \"ai.response.timestamp\": stepResponse.timestamp.toISOString(),\n                          \"ai.response.providerMetadata\": JSON.stringify(stepProviderMetadata),\n                          \"ai.usage.inputTokens\": stepUsage.inputTokens,\n                          \"ai.usage.outputTokens\": stepUsage.outputTokens,\n                          \"ai.usage.totalTokens\": stepUsage.totalTokens,\n                          \"ai.usage.reasoningTokens\": stepUsage.reasoningTokens,\n                          \"ai.usage.cachedInputTokens\": stepUsage.cachedInputTokens,\n                          // standardized gen-ai llm span attributes:\n                          \"gen_ai.response.finish_reasons\": [stepFinishReason],\n                          \"gen_ai.response.id\": stepResponse.id,\n                          \"gen_ai.response.model\": stepResponse.modelId,\n                          \"gen_ai.usage.input_tokens\": stepUsage.inputTokens,\n                          \"gen_ai.usage.output_tokens\": stepUsage.outputTokens\n                        }\n                      })\n                    );\n                  } catch (error) {\n                  } finally {\n                    doStreamSpan.end();\n                  }\n                  controller.enqueue({\n                    type: \"finish-step\",\n                    finishReason: stepFinishReason,\n                    usage: stepUsage,\n                    providerMetadata: stepProviderMetadata,\n                    response: {\n                      ...stepResponse,\n                      headers: response == null ? void 0 : response.headers\n                    }\n                  });\n                  const combinedUsage = addLanguageModelUsage(usage, stepUsage);\n                  await stepFinish.promise;\n                  const clientToolCalls = stepToolCalls.filter(\n                    (toolCall) => toolCall.providerExecuted !== true\n                  );\n                  const clientToolOutputs = stepToolOutputs.filter(\n                    (toolOutput) => toolOutput.providerExecuted !== true\n                  );\n                  if (clientToolCalls.length > 0 && // all current tool calls have outputs (incl. execution errors):\n                  clientToolOutputs.length === clientToolCalls.length && // continue until a stop condition is met:\n                  !await isStopConditionMet({\n                    stopConditions,\n                    steps: recordedSteps\n                  })) {\n                    responseMessages.push(\n                      ...toResponseMessages({\n                        content: (\n                          // use transformed content to create the messages for the next step:\n                          recordedSteps[recordedSteps.length - 1].content\n                        ),\n                        tools\n                      })\n                    );\n                    try {\n                      await streamStep({\n                        currentStep: currentStep + 1,\n                        responseMessages,\n                        usage: combinedUsage\n                      });\n                    } catch (error) {\n                      controller.enqueue({\n                        type: \"error\",\n                        error\n                      });\n                      self.closeStream();\n                    }\n                  } else {\n                    controller.enqueue({\n                      type: \"finish\",\n                      finishReason: stepFinishReason,\n                      totalUsage: combinedUsage\n                    });\n                    self.closeStream();\n                  }\n                }\n              })\n            )\n          );\n        }\n        await streamStep({\n          currentStep: 0,\n          responseMessages: [],\n          usage: {\n            inputTokens: void 0,\n            outputTokens: void 0,\n            totalTokens: void 0\n          }\n        });\n      }\n    }).catch((error) => {\n      self.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: \"error\", error });\n            controller.close();\n          }\n        })\n      );\n      self.closeStream();\n    });\n  }\n  get steps() {\n    this.consumeStream();\n    return this._steps.promise;\n  }\n  get finalStep() {\n    return this.steps.then((steps) => steps[steps.length - 1]);\n  }\n  get content() {\n    return this.finalStep.then((step) => step.content);\n  }\n  get warnings() {\n    return this.finalStep.then((step) => step.warnings);\n  }\n  get providerMetadata() {\n    return this.finalStep.then((step) => step.providerMetadata);\n  }\n  get text() {\n    return this.finalStep.then((step) => step.text);\n  }\n  get reasoningText() {\n    return this.finalStep.then((step) => step.reasoningText);\n  }\n  get reasoning() {\n    return this.finalStep.then((step) => step.reasoning);\n  }\n  get sources() {\n    return this.finalStep.then((step) => step.sources);\n  }\n  get files() {\n    return this.finalStep.then((step) => step.files);\n  }\n  get toolCalls() {\n    return this.finalStep.then((step) => step.toolCalls);\n  }\n  get staticToolCalls() {\n    return this.finalStep.then((step) => step.staticToolCalls);\n  }\n  get dynamicToolCalls() {\n    return this.finalStep.then((step) => step.dynamicToolCalls);\n  }\n  get toolResults() {\n    return this.finalStep.then((step) => step.toolResults);\n  }\n  get staticToolResults() {\n    return this.finalStep.then((step) => step.staticToolResults);\n  }\n  get dynamicToolResults() {\n    return this.finalStep.then((step) => step.dynamicToolResults);\n  }\n  get usage() {\n    return this.finalStep.then((step) => step.usage);\n  }\n  get request() {\n    return this.finalStep.then((step) => step.request);\n  }\n  get response() {\n    return this.finalStep.then((step) => step.response);\n  }\n  get totalUsage() {\n    this.consumeStream();\n    return this._totalUsage.promise;\n  }\n  get finishReason() {\n    this.consumeStream();\n    return this._finishReason.promise;\n  }\n  /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */\n  teeStream() {\n    const [stream1, stream2] = this.baseStream.tee();\n    this.baseStream = stream2;\n    return stream1;\n  }\n  get textStream() {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ part }, controller) {\n            if (part.type === \"text-delta\") {\n              controller.enqueue(part.text);\n            }\n          }\n        })\n      )\n    );\n  }\n  get fullStream() {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ part }, controller) {\n            controller.enqueue(part);\n          }\n        })\n      )\n    );\n  }\n  async consumeStream(options) {\n    var _a17;\n    try {\n      await consumeStream({\n        stream: this.fullStream,\n        onError: options == null ? void 0 : options.onError\n      });\n    } catch (error) {\n      (_a17 = options == null ? void 0 : options.onError) == null ? void 0 : _a17.call(options, error);\n    }\n  }\n  get experimental_partialOutputStream() {\n    if (this.output == null) {\n      throw new NoOutputSpecifiedError();\n    }\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ partialOutput }, controller) {\n            if (partialOutput != null) {\n              controller.enqueue(partialOutput);\n            }\n          }\n        })\n      )\n    );\n  }\n  toUIMessageStream({\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning = true,\n    sendSources = false,\n    sendStart = true,\n    sendFinish = true,\n    onError = _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage\n  } = {}) {\n    const responseMessageId = generateMessageId != null ? getResponseUIMessageId({\n      originalMessages,\n      responseMessageId: generateMessageId\n    }) : void 0;\n    const toolNamesByCallId = {};\n    const isDynamic = (toolCallId) => {\n      var _a17, _b;\n      const toolName = toolNamesByCallId[toolCallId];\n      const dynamic = ((_b = (_a17 = this.tools) == null ? void 0 : _a17[toolName]) == null ? void 0 : _b.type) === \"dynamic\";\n      return dynamic ? true : void 0;\n    };\n    const baseStream = this.fullStream.pipeThrough(\n      new TransformStream({\n        transform: async (part, controller) => {\n          const messageMetadataValue = messageMetadata == null ? void 0 : messageMetadata({ part });\n          const partType = part.type;\n          switch (partType) {\n            case \"text-start\": {\n              controller.enqueue({\n                type: \"text-start\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"text-delta\": {\n              controller.enqueue({\n                type: \"text-delta\",\n                id: part.id,\n                delta: part.text,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"text-end\": {\n              controller.enqueue({\n                type: \"text-end\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"reasoning-start\": {\n              controller.enqueue({\n                type: \"reasoning-start\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"reasoning-delta\": {\n              if (sendReasoning) {\n                controller.enqueue({\n                  type: \"reasoning-delta\",\n                  id: part.id,\n                  delta: part.text,\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n                });\n              }\n              break;\n            }\n            case \"reasoning-end\": {\n              controller.enqueue({\n                type: \"reasoning-end\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"file\": {\n              controller.enqueue({\n                type: \"file\",\n                mediaType: part.file.mediaType,\n                url: `data:${part.file.mediaType};base64,${part.file.base64}`\n              });\n              break;\n            }\n            case \"source\": {\n              if (sendSources && part.sourceType === \"url\") {\n                controller.enqueue({\n                  type: \"source-url\",\n                  sourceId: part.id,\n                  url: part.url,\n                  title: part.title,\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n                });\n              }\n              if (sendSources && part.sourceType === \"document\") {\n                controller.enqueue({\n                  type: \"source-document\",\n                  sourceId: part.id,\n                  mediaType: part.mediaType,\n                  title: part.title,\n                  filename: part.filename,\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n                });\n              }\n              break;\n            }\n            case \"tool-input-start\": {\n              toolNamesByCallId[part.id] = part.toolName;\n              const dynamic = isDynamic(part.id);\n              controller.enqueue({\n                type: \"tool-input-start\",\n                toolCallId: part.id,\n                toolName: part.toolName,\n                ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                ...dynamic != null ? { dynamic } : {}\n              });\n              break;\n            }\n            case \"tool-input-delta\": {\n              controller.enqueue({\n                type: \"tool-input-delta\",\n                toolCallId: part.id,\n                inputTextDelta: part.delta\n              });\n              break;\n            }\n            case \"tool-call\": {\n              toolNamesByCallId[part.toolCallId] = part.toolName;\n              const dynamic = isDynamic(part.toolCallId);\n              if (part.invalid) {\n                controller.enqueue({\n                  type: \"tool-input-error\",\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  input: part.input,\n                  ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},\n                  ...dynamic != null ? { dynamic } : {},\n                  errorText: onError(part.error)\n                });\n              } else {\n                controller.enqueue({\n                  type: \"tool-input-available\",\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  input: part.input,\n                  ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},\n                  ...dynamic != null ? { dynamic } : {}\n                });\n              }\n              break;\n            }\n            case \"tool-result\": {\n              const dynamic = isDynamic(part.toolCallId);\n              controller.enqueue({\n                type: \"tool-output-available\",\n                toolCallId: part.toolCallId,\n                output: part.output,\n                ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                ...part.preliminary != null ? { preliminary: part.preliminary } : {},\n                ...dynamic != null ? { dynamic } : {}\n              });\n              break;\n            }\n            case \"tool-error\": {\n              const dynamic = isDynamic(part.toolCallId);\n              controller.enqueue({\n                type: \"tool-output-error\",\n                toolCallId: part.toolCallId,\n                errorText: onError(part.error),\n                ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                ...dynamic != null ? { dynamic } : {}\n              });\n              break;\n            }\n            case \"error\": {\n              controller.enqueue({\n                type: \"error\",\n                errorText: onError(part.error)\n              });\n              break;\n            }\n            case \"start-step\": {\n              controller.enqueue({ type: \"start-step\" });\n              break;\n            }\n            case \"finish-step\": {\n              controller.enqueue({ type: \"finish-step\" });\n              break;\n            }\n            case \"start\": {\n              if (sendStart) {\n                controller.enqueue({\n                  type: \"start\",\n                  ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {},\n                  ...responseMessageId != null ? { messageId: responseMessageId } : {}\n                });\n              }\n              break;\n            }\n            case \"finish\": {\n              if (sendFinish) {\n                controller.enqueue({\n                  type: \"finish\",\n                  ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {}\n                });\n              }\n              break;\n            }\n            case \"abort\": {\n              controller.enqueue(part);\n              break;\n            }\n            case \"tool-input-end\": {\n              break;\n            }\n            case \"raw\": {\n              break;\n            }\n            default: {\n              const exhaustiveCheck = partType;\n              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n            }\n          }\n          if (messageMetadataValue != null && partType !== \"start\" && partType !== \"finish\") {\n            controller.enqueue({\n              type: \"message-metadata\",\n              messageMetadata: messageMetadataValue\n            });\n          }\n        }\n      })\n    );\n    return createAsyncIterableStream(\n      handleUIMessageStreamFinish({\n        stream: baseStream,\n        messageId: responseMessageId != null ? responseMessageId : generateMessageId == null ? void 0 : generateMessageId(),\n        originalMessages,\n        onFinish,\n        onError\n      })\n    );\n  }\n  pipeUIMessageStreamToResponse(response, {\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning,\n    sendSources,\n    sendFinish,\n    sendStart,\n    onError,\n    ...init\n  } = {}) {\n    pipeUIMessageStreamToResponse({\n      response,\n      stream: this.toUIMessageStream({\n        originalMessages,\n        generateMessageId,\n        onFinish,\n        messageMetadata,\n        sendReasoning,\n        sendSources,\n        sendFinish,\n        sendStart,\n        onError\n      }),\n      ...init\n    });\n  }\n  pipeTextStreamToResponse(response, init) {\n    pipeTextStreamToResponse({\n      response,\n      textStream: this.textStream,\n      ...init\n    });\n  }\n  toUIMessageStreamResponse({\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning,\n    sendSources,\n    sendFinish,\n    sendStart,\n    onError,\n    ...init\n  } = {}) {\n    return createUIMessageStreamResponse({\n      stream: this.toUIMessageStream({\n        originalMessages,\n        generateMessageId,\n        onFinish,\n        messageMetadata,\n        sendReasoning,\n        sendSources,\n        sendFinish,\n        sendStart,\n        onError\n      }),\n      ...init\n    });\n  }\n  toTextStreamResponse(init) {\n    return createTextStreamResponse({\n      textStream: this.textStream,\n      ...init\n    });\n  }\n};\n\n// src/ui/convert-to-model-messages.ts\nfunction convertToModelMessages(messages, options) {\n  const modelMessages = [];\n  if (options == null ? void 0 : options.ignoreIncompleteToolCalls) {\n    messages = messages.map((message) => ({\n      ...message,\n      parts: message.parts.filter(\n        (part) => !isToolOrDynamicToolUIPart(part) || part.state !== \"input-streaming\" && part.state !== \"input-available\"\n      )\n    }));\n  }\n  for (const message of messages) {\n    switch (message.role) {\n      case \"system\": {\n        const textParts = message.parts.filter((part) => part.type === \"text\");\n        const providerMetadata = textParts.reduce((acc, part) => {\n          if (part.providerMetadata != null) {\n            return { ...acc, ...part.providerMetadata };\n          }\n          return acc;\n        }, {});\n        modelMessages.push({\n          role: \"system\",\n          content: textParts.map((part) => part.text).join(\"\"),\n          ...Object.keys(providerMetadata).length > 0 ? { providerOptions: providerMetadata } : {}\n        });\n        break;\n      }\n      case \"user\": {\n        modelMessages.push({\n          role: \"user\",\n          content: message.parts.filter(\n            (part) => part.type === \"text\" || part.type === \"file\"\n          ).map((part) => {\n            switch (part.type) {\n              case \"text\":\n                return {\n                  type: \"text\",\n                  text: part.text,\n                  ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n                };\n              case \"file\":\n                return {\n                  type: \"file\",\n                  mediaType: part.mediaType,\n                  filename: part.filename,\n                  data: part.url,\n                  ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n                };\n              default:\n                return part;\n            }\n          })\n        });\n        break;\n      }\n      case \"assistant\": {\n        if (message.parts != null) {\n          let processBlock2 = function() {\n            var _a17, _b;\n            if (block.length === 0) {\n              return;\n            }\n            const content = [];\n            for (const part of block) {\n              if (part.type === \"text\") {\n                content.push({\n                  type: \"text\",\n                  text: part.text,\n                  ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n                });\n              } else if (part.type === \"file\") {\n                content.push({\n                  type: \"file\",\n                  mediaType: part.mediaType,\n                  filename: part.filename,\n                  data: part.url\n                });\n              } else if (part.type === \"reasoning\") {\n                content.push({\n                  type: \"reasoning\",\n                  text: part.text,\n                  providerOptions: part.providerMetadata\n                });\n              } else if (part.type === \"dynamic-tool\") {\n                const toolName = part.toolName;\n                if (part.state !== \"input-streaming\") {\n                  content.push({\n                    type: \"tool-call\",\n                    toolCallId: part.toolCallId,\n                    toolName,\n                    input: part.input,\n                    ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}\n                  });\n                }\n              } else if (isToolUIPart(part)) {\n                const toolName = getToolName(part);\n                if (part.state !== \"input-streaming\") {\n                  content.push({\n                    type: \"tool-call\",\n                    toolCallId: part.toolCallId,\n                    toolName,\n                    input: part.state === \"output-error\" ? (_a17 = part.input) != null ? _a17 : part.rawInput : part.input,\n                    providerExecuted: part.providerExecuted,\n                    ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}\n                  });\n                  if (part.providerExecuted === true && (part.state === \"output-available\" || part.state === \"output-error\")) {\n                    content.push({\n                      type: \"tool-result\",\n                      toolCallId: part.toolCallId,\n                      toolName,\n                      output: createToolModelOutput({\n                        output: part.state === \"output-error\" ? part.errorText : part.output,\n                        tool: (_b = options == null ? void 0 : options.tools) == null ? void 0 : _b[toolName],\n                        errorMode: part.state === \"output-error\" ? \"json\" : \"none\"\n                      })\n                    });\n                  }\n                }\n              } else {\n                const _exhaustiveCheck = part;\n                throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n              }\n            }\n            modelMessages.push({\n              role: \"assistant\",\n              content\n            });\n            const toolParts = block.filter(\n              (part) => isToolUIPart(part) && part.providerExecuted !== true || part.type === \"dynamic-tool\"\n            );\n            if (toolParts.length > 0) {\n              modelMessages.push({\n                role: \"tool\",\n                content: toolParts.map((toolPart) => {\n                  var _a18;\n                  switch (toolPart.state) {\n                    case \"output-error\":\n                    case \"output-available\": {\n                      const toolName = toolPart.type === \"dynamic-tool\" ? toolPart.toolName : getToolName(toolPart);\n                      return {\n                        type: \"tool-result\",\n                        toolCallId: toolPart.toolCallId,\n                        toolName,\n                        output: createToolModelOutput({\n                          output: toolPart.state === \"output-error\" ? toolPart.errorText : toolPart.output,\n                          tool: (_a18 = options == null ? void 0 : options.tools) == null ? void 0 : _a18[toolName],\n                          errorMode: toolPart.state === \"output-error\" ? \"text\" : \"none\"\n                        })\n                      };\n                    }\n                    default: {\n                      return null;\n                    }\n                  }\n                }).filter(\n                  (output) => output != null\n                )\n              });\n            }\n            block = [];\n          };\n          var processBlock = processBlock2;\n          let block = [];\n          for (const part of message.parts) {\n            if (part.type === \"text\" || part.type === \"reasoning\" || part.type === \"file\" || part.type === \"dynamic-tool\" || isToolUIPart(part)) {\n              block.push(part);\n            } else if (part.type === \"step-start\") {\n              processBlock2();\n            }\n          }\n          processBlock2();\n          break;\n        }\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = message.role;\n        throw new MessageConversionError({\n          originalMessage: message,\n          message: `Unsupported role: ${_exhaustiveCheck}`\n        });\n      }\n    }\n  }\n  return modelMessages;\n}\nvar convertToCoreMessages = convertToModelMessages;\n\n// src/agent/agent.ts\nvar Agent = class {\n  constructor(settings) {\n    this.settings = settings;\n  }\n  get tools() {\n    return this.settings.tools;\n  }\n  async generate(options) {\n    return generateText({ ...this.settings, ...options });\n  }\n  stream(options) {\n    return streamText({ ...this.settings, ...options });\n  }\n  /**\n   * Creates a response object that streams UI messages to the client.\n   */\n  respond(options) {\n    return this.stream({\n      prompt: convertToModelMessages(options.messages)\n    }).toUIMessageStreamResponse();\n  }\n};\n\n// src/embed/embed.ts\nasync function embed({\n  model: modelArg,\n  value,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry\n}) {\n  const model = resolveEmbeddingModel(modelArg);\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.embed\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embed\", telemetry }),\n        ...baseTelemetryAttributes,\n        \"ai.value\": { input: () => JSON.stringify(value) }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const { embedding, usage, response, providerMetadata } = await retry(\n        () => (\n          // nested spans to align with the embedMany telemetry data:\n          recordSpan({\n            name: \"ai.embed.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embed.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": { input: () => [JSON.stringify(value)] }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a17;\n              const modelResponse = await model.doEmbed({\n                values: [value],\n                abortSignal,\n                headers,\n                providerOptions\n              });\n              const embedding2 = modelResponse.embeddings[0];\n              const usage2 = (_a17 = modelResponse.usage) != null ? _a17 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => modelResponse.embeddings.map(\n                        (embedding3) => JSON.stringify(embedding3)\n                      )\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return {\n                embedding: embedding2,\n                usage: usage2,\n                providerMetadata: modelResponse.providerMetadata,\n                response: modelResponse.response\n              };\n            }\n          })\n        )\n      );\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embedding\": { output: () => JSON.stringify(embedding) },\n            \"ai.usage.tokens\": usage.tokens\n          }\n        })\n      );\n      return new DefaultEmbedResult({\n        value,\n        embedding,\n        usage,\n        providerMetadata,\n        response\n      });\n    }\n  });\n}\nvar DefaultEmbedResult = class {\n  constructor(options) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.usage = options.usage;\n    this.providerMetadata = options.providerMetadata;\n    this.response = options.response;\n  }\n};\n\n// src/util/split-array.ts\nfunction splitArray(array, chunkSize) {\n  if (chunkSize <= 0) {\n    throw new Error(\"chunkSize must be greater than 0\");\n  }\n  const result = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n  return result;\n}\n\n// src/embed/embed-many.ts\nasync function embedMany({\n  model: modelArg,\n  values,\n  maxParallelCalls = Infinity,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  providerOptions,\n  experimental_telemetry: telemetry\n}) {\n  const model = resolveEmbeddingModel(modelArg);\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.embedMany\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embedMany\", telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.values\": {\n          input: () => values.map((value) => JSON.stringify(value))\n        }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      var _a17;\n      const [maxEmbeddingsPerCall, supportsParallelCalls] = await Promise.all([\n        model.maxEmbeddingsPerCall,\n        model.supportsParallelCalls\n      ]);\n      if (maxEmbeddingsPerCall == null || maxEmbeddingsPerCall === Infinity) {\n        const { embeddings: embeddings2, usage, response, providerMetadata: providerMetadata2 } = await retry(\n          () => {\n            return recordSpan({\n              name: \"ai.embedMany.doEmbed\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: \"ai.embedMany.doEmbed\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  // specific settings that only make sense on the outer level:\n                  \"ai.values\": {\n                    input: () => values.map((value) => JSON.stringify(value))\n                  }\n                }\n              }),\n              tracer,\n              fn: async (doEmbedSpan) => {\n                var _a18;\n                const modelResponse = await model.doEmbed({\n                  values,\n                  abortSignal,\n                  headers,\n                  providerOptions\n                });\n                const embeddings3 = modelResponse.embeddings;\n                const usage2 = (_a18 = modelResponse.usage) != null ? _a18 : { tokens: NaN };\n                doEmbedSpan.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.embeddings\": {\n                        output: () => embeddings3.map(\n                          (embedding) => JSON.stringify(embedding)\n                        )\n                      },\n                      \"ai.usage.tokens\": usage2.tokens\n                    }\n                  })\n                );\n                return {\n                  embeddings: embeddings3,\n                  usage: usage2,\n                  providerMetadata: modelResponse.providerMetadata,\n                  response: modelResponse.response\n                };\n              }\n            });\n          }\n        );\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.embeddings\": {\n                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))\n              },\n              \"ai.usage.tokens\": usage.tokens\n            }\n          })\n        );\n        return new DefaultEmbedManyResult({\n          values,\n          embeddings: embeddings2,\n          usage,\n          providerMetadata: providerMetadata2,\n          responses: [response]\n        });\n      }\n      const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n      const embeddings = [];\n      const responses = [];\n      let tokens = 0;\n      let providerMetadata;\n      const parallelChunks = splitArray(\n        valueChunks,\n        supportsParallelCalls ? maxParallelCalls : 1\n      );\n      for (const parallelChunk of parallelChunks) {\n        const results = await Promise.all(\n          parallelChunk.map((chunk) => {\n            return retry(() => {\n              return recordSpan({\n                name: \"ai.embedMany.doEmbed\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.embedMany.doEmbed\",\n                      telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.values\": {\n                      input: () => chunk.map((value) => JSON.stringify(value))\n                    }\n                  }\n                }),\n                tracer,\n                fn: async (doEmbedSpan) => {\n                  var _a18;\n                  const modelResponse = await model.doEmbed({\n                    values: chunk,\n                    abortSignal,\n                    headers,\n                    providerOptions\n                  });\n                  const embeddings2 = modelResponse.embeddings;\n                  const usage = (_a18 = modelResponse.usage) != null ? _a18 : { tokens: NaN };\n                  doEmbedSpan.setAttributes(\n                    selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        \"ai.embeddings\": {\n                          output: () => embeddings2.map(\n                            (embedding) => JSON.stringify(embedding)\n                          )\n                        },\n                        \"ai.usage.tokens\": usage.tokens\n                      }\n                    })\n                  );\n                  return {\n                    embeddings: embeddings2,\n                    usage,\n                    providerMetadata: modelResponse.providerMetadata,\n                    response: modelResponse.response\n                  };\n                }\n              });\n            });\n          })\n        );\n        for (const result of results) {\n          embeddings.push(...result.embeddings);\n          responses.push(result.response);\n          tokens += result.usage.tokens;\n          if (result.providerMetadata) {\n            if (!providerMetadata) {\n              providerMetadata = { ...result.providerMetadata };\n            } else {\n              for (const [providerName, metadata] of Object.entries(\n                result.providerMetadata\n              )) {\n                providerMetadata[providerName] = {\n                  ...(_a17 = providerMetadata[providerName]) != null ? _a17 : {},\n                  ...metadata\n                };\n              }\n            }\n          }\n        }\n      }\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embeddings\": {\n              output: () => embeddings.map((embedding) => JSON.stringify(embedding))\n            },\n            \"ai.usage.tokens\": tokens\n          }\n        })\n      );\n      return new DefaultEmbedManyResult({\n        values,\n        embeddings,\n        usage: { tokens },\n        providerMetadata,\n        responses\n      });\n    }\n  });\n}\nvar DefaultEmbedManyResult = class {\n  constructor(options) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n    this.usage = options.usage;\n    this.providerMetadata = options.providerMetadata;\n    this.responses = options.responses;\n  }\n};\n\n// src/generate-image/generate-image.ts\nasync function generateImage({\n  model,\n  prompt,\n  n = 1,\n  maxImagesPerCall,\n  size,\n  aspectRatio,\n  seed,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  var _a17, _b;\n  if (model.specificationVersion !== \"v2\") {\n    throw new UnsupportedModelVersionError({\n      version: model.specificationVersion,\n      provider: model.provider,\n      modelId: model.modelId\n    });\n  }\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const maxImagesPerCallWithDefault = (_a17 = maxImagesPerCall != null ? maxImagesPerCall : await invokeModelMaxImagesPerCall(model)) != null ? _a17 : 1;\n  const callCount = Math.ceil(n / maxImagesPerCallWithDefault);\n  const callImageCounts = Array.from({ length: callCount }, (_, i) => {\n    if (i < callCount - 1) {\n      return maxImagesPerCallWithDefault;\n    }\n    const remainder = n % maxImagesPerCallWithDefault;\n    return remainder === 0 ? maxImagesPerCallWithDefault : remainder;\n  });\n  const results = await Promise.all(\n    callImageCounts.map(\n      async (callImageCount) => retry(\n        () => model.doGenerate({\n          prompt,\n          n: callImageCount,\n          abortSignal,\n          headers,\n          size,\n          aspectRatio,\n          seed,\n          providerOptions: providerOptions != null ? providerOptions : {}\n        })\n      )\n    )\n  );\n  const images = [];\n  const warnings = [];\n  const responses = [];\n  const providerMetadata = {};\n  for (const result of results) {\n    images.push(\n      ...result.images.map(\n        (image) => {\n          var _a18;\n          return new DefaultGeneratedFile({\n            data: image,\n            mediaType: (_a18 = detectMediaType({\n              data: image,\n              signatures: imageMediaTypeSignatures\n            })) != null ? _a18 : \"image/png\"\n          });\n        }\n      )\n    );\n    warnings.push(...result.warnings);\n    if (result.providerMetadata) {\n      for (const [providerName, metadata] of Object.entries(result.providerMetadata)) {\n        (_b = providerMetadata[providerName]) != null ? _b : providerMetadata[providerName] = { images: [] };\n        providerMetadata[providerName].images.push(\n          ...result.providerMetadata[providerName].images\n        );\n      }\n    }\n    responses.push(result.response);\n  }\n  logWarnings(warnings);\n  if (!images.length) {\n    throw new NoImageGeneratedError({ responses });\n  }\n  return new DefaultGenerateImageResult({\n    images,\n    warnings,\n    responses,\n    providerMetadata\n  });\n}\nvar DefaultGenerateImageResult = class {\n  constructor(options) {\n    this.images = options.images;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = options.providerMetadata;\n  }\n  get image() {\n    return this.images[0];\n  }\n};\nasync function invokeModelMaxImagesPerCall(model) {\n  const isFunction = model.maxImagesPerCall instanceof Function;\n  if (!isFunction) {\n    return model.maxImagesPerCall;\n  }\n  return model.maxImagesPerCall({\n    modelId: model.modelId\n  });\n}\n\n// src/generate-object/generate-object.ts\n\n\n// src/generate-text/extract-reasoning-content.ts\nfunction extractReasoningContent(content) {\n  const parts = content.filter(\n    (content2) => content2.type === \"reasoning\"\n  );\n  return parts.length === 0 ? void 0 : parts.map((content2) => content2.text).join(\"\\n\");\n}\n\n// src/generate-object/output-strategy.ts\n\n\nvar noSchemaOutputStrategy = {\n  type: \"no-schema\",\n  jsonSchema: void 0,\n  async validatePartialResult({ value, textDelta }) {\n    return { success: true, value: { partial: value, textDelta } };\n  },\n  async validateFinalResult(value, context) {\n    return value === void 0 ? {\n      success: false,\n      error: new NoObjectGeneratedError({\n        message: \"No object generated: response did not match schema.\",\n        text: context.text,\n        response: context.response,\n        usage: context.usage,\n        finishReason: context.finishReason\n      })\n    } : { success: true, value };\n  },\n  createElementStream() {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n      functionality: \"element streams in no-schema mode\"\n    });\n  }\n};\nvar objectOutputStrategy = (schema) => ({\n  type: \"object\",\n  jsonSchema: schema.jsonSchema,\n  async validatePartialResult({ value, textDelta }) {\n    return {\n      success: true,\n      value: {\n        // Note: currently no validation of partial results:\n        partial: value,\n        textDelta\n      }\n    };\n  },\n  async validateFinalResult(value) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value, schema });\n  },\n  createElementStream() {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n      functionality: \"element streams in object mode\"\n    });\n  }\n});\nvar arrayOutputStrategy = (schema) => {\n  const { $schema, ...itemSchema } = schema.jsonSchema;\n  return {\n    type: \"enum\",\n    // wrap in object that contains array of elements, since most LLMs will not\n    // be able to generate an array directly:\n    // possible future optimization: use arrays directly when model supports grammar-guided generation\n    jsonSchema: {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        elements: { type: \"array\", items: itemSchema }\n      },\n      required: [\"elements\"],\n      additionalProperties: false\n    },\n    async validatePartialResult({\n      value,\n      latestObject,\n      isFirstDelta,\n      isFinalDelta\n    }) {\n      var _a17;\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      const resultArray = [];\n      for (let i = 0; i < inputArray.length; i++) {\n        const element = inputArray[i];\n        const result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: element, schema });\n        if (i === inputArray.length - 1 && !isFinalDelta) {\n          continue;\n        }\n        if (!result.success) {\n          return result;\n        }\n        resultArray.push(result.value);\n      }\n      const publishedElementCount = (_a17 = latestObject == null ? void 0 : latestObject.length) != null ? _a17 : 0;\n      let textDelta = \"\";\n      if (isFirstDelta) {\n        textDelta += \"[\";\n      }\n      if (publishedElementCount > 0) {\n        textDelta += \",\";\n      }\n      textDelta += resultArray.slice(publishedElementCount).map((element) => JSON.stringify(element)).join(\",\");\n      if (isFinalDelta) {\n        textDelta += \"]\";\n      }\n      return {\n        success: true,\n        value: {\n          partial: resultArray,\n          textDelta\n        }\n      };\n    },\n    async validateFinalResult(value) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      for (const element of inputArray) {\n        const result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: element, schema });\n        if (!result.success) {\n          return result;\n        }\n      }\n      return { success: true, value: inputArray };\n    },\n    createElementStream(originalStream) {\n      let publishedElements = 0;\n      return createAsyncIterableStream(\n        originalStream.pipeThrough(\n          new TransformStream({\n            transform(chunk, controller) {\n              switch (chunk.type) {\n                case \"object\": {\n                  const array = chunk.object;\n                  for (; publishedElements < array.length; publishedElements++) {\n                    controller.enqueue(array[publishedElements]);\n                  }\n                  break;\n                }\n                case \"text-delta\":\n                case \"finish\":\n                case \"error\":\n                  break;\n                default: {\n                  const _exhaustiveCheck = chunk;\n                  throw new Error(\n                    `Unsupported chunk type: ${_exhaustiveCheck}`\n                  );\n                }\n              }\n            }\n          })\n        )\n      );\n    }\n  };\n};\nvar enumOutputStrategy = (enumValues) => {\n  return {\n    type: \"enum\",\n    // wrap in object that contains result, since most LLMs will not\n    // be able to generate an enum value directly:\n    // possible future optimization: use enums directly when model supports top-level enums\n    jsonSchema: {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        result: { type: \"string\", enum: enumValues }\n      },\n      required: [\"result\"],\n      additionalProperties: false\n    },\n    async validateFinalResult(value) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: 'value must be an object that contains a string in the \"result\" property.'\n          })\n        };\n      }\n      const result = value.result;\n      return enumValues.includes(result) ? { success: true, value: result } : {\n        success: false,\n        error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n          value,\n          cause: \"value must be a string in the enum\"\n        })\n      };\n    },\n    async validatePartialResult({ value, textDelta }) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: 'value must be an object that contains a string in the \"result\" property.'\n          })\n        };\n      }\n      const result = value.result;\n      const possibleEnumValues = enumValues.filter(\n        (enumValue) => enumValue.startsWith(result)\n      );\n      if (value.result.length === 0 || possibleEnumValues.length === 0) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be a string in the enum\"\n          })\n        };\n      }\n      return {\n        success: true,\n        value: {\n          partial: possibleEnumValues.length > 1 ? result : possibleEnumValues[0],\n          textDelta\n        }\n      };\n    },\n    createElementStream() {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n        functionality: \"element streams in enum mode\"\n      });\n    }\n  };\n};\nfunction getOutputStrategy({\n  output,\n  schema,\n  enumValues\n}) {\n  switch (output) {\n    case \"object\":\n      return objectOutputStrategy((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(schema));\n    case \"array\":\n      return arrayOutputStrategy((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(schema));\n    case \"enum\":\n      return enumOutputStrategy(enumValues);\n    case \"no-schema\":\n      return noSchemaOutputStrategy;\n    default: {\n      const _exhaustiveCheck = output;\n      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n    }\n  }\n}\n\n// src/generate-object/parse-and-validate-object-result.ts\n\n\nasync function parseAndValidateObjectResult(result, outputStrategy, context) {\n  const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: result });\n  if (!parseResult.success) {\n    throw new NoObjectGeneratedError({\n      message: \"No object generated: could not parse the response.\",\n      cause: parseResult.error,\n      text: result,\n      response: context.response,\n      usage: context.usage,\n      finishReason: context.finishReason\n    });\n  }\n  const validationResult = await outputStrategy.validateFinalResult(\n    parseResult.value,\n    {\n      text: result,\n      response: context.response,\n      usage: context.usage\n    }\n  );\n  if (!validationResult.success) {\n    throw new NoObjectGeneratedError({\n      message: \"No object generated: response did not match schema.\",\n      cause: validationResult.error,\n      text: result,\n      response: context.response,\n      usage: context.usage,\n      finishReason: context.finishReason\n    });\n  }\n  return validationResult.value;\n}\nasync function parseAndValidateObjectResultWithRepair(result, outputStrategy, repairText, context) {\n  try {\n    return await parseAndValidateObjectResult(result, outputStrategy, context);\n  } catch (error) {\n    if (repairText != null && NoObjectGeneratedError.isInstance(error) && (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError.isInstance(error.cause) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.isInstance(error.cause))) {\n      const repairedText = await repairText({\n        text: result,\n        error: error.cause\n      });\n      if (repairedText === null) {\n        throw error;\n      }\n      return await parseAndValidateObjectResult(\n        repairedText,\n        outputStrategy,\n        context\n      );\n    }\n    throw error;\n  }\n}\n\n// src/generate-object/validate-object-generation-input.ts\nfunction validateObjectGenerationInput({\n  output,\n  schema,\n  schemaName,\n  schemaDescription,\n  enumValues\n}) {\n  if (output != null && output !== \"object\" && output !== \"array\" && output !== \"enum\" && output !== \"no-schema\") {\n    throw new InvalidArgumentError({\n      parameter: \"output\",\n      value: output,\n      message: \"Invalid output type.\"\n    });\n  }\n  if (output === \"no-schema\") {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for no-schema output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for no-schema output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for no-schema output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for no-schema output.\"\n      });\n    }\n  }\n  if (output === \"object\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is required for object output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for object output.\"\n      });\n    }\n  }\n  if (output === \"array\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Element schema is required for array output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for array output.\"\n      });\n    }\n  }\n  if (output === \"enum\") {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for enum output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for enum output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for enum output.\"\n      });\n    }\n    if (enumValues == null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are required for enum output.\"\n      });\n    }\n    for (const value of enumValues) {\n      if (typeof value !== \"string\") {\n        throw new InvalidArgumentError({\n          parameter: \"enumValues\",\n          value,\n          message: \"Enum values must be strings.\"\n        });\n      }\n    }\n  }\n}\n\n// src/generate-object/generate-object.ts\nvar originalGenerateId3 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({ prefix: \"aiobj\", size: 24 });\nasync function generateObject(options) {\n  const {\n    model: modelArg,\n    output = \"object\",\n    system,\n    prompt,\n    messages,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    headers,\n    experimental_repairText: repairText,\n    experimental_telemetry: telemetry,\n    experimental_download: download2,\n    providerOptions,\n    _internal: {\n      generateId: generateId3 = originalGenerateId3,\n      currentDate = () => /* @__PURE__ */ new Date()\n    } = {},\n    ...settings\n  } = options;\n  const model = resolveLanguageModel(modelArg);\n  const enumValues = \"enum\" in options ? options.enum : void 0;\n  const {\n    schema: inputSchema,\n    schemaDescription,\n    schemaName\n  } = \"schema\" in options ? options : {};\n  validateObjectGenerationInput({\n    output,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues\n  });\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues\n  });\n  const callSettings = prepareCallSettings(settings);\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...callSettings, maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  try {\n    return await recordSpan({\n      name: \"ai.generateObject\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.generateObject\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          },\n          \"ai.schema\": outputStrategy.jsonSchema != null ? { input: () => JSON.stringify(outputStrategy.jsonSchema) } : void 0,\n          \"ai.schema.name\": schemaName,\n          \"ai.schema.description\": schemaDescription,\n          \"ai.settings.output\": outputStrategy.type\n        }\n      }),\n      tracer,\n      fn: async (span) => {\n        var _a17;\n        let result;\n        let finishReason;\n        let usage;\n        let warnings;\n        let response;\n        let request;\n        let resultProviderMetadata;\n        let reasoning;\n        const standardizedPrompt = await standardizePrompt({\n          system,\n          prompt,\n          messages\n        });\n        const promptMessages = await convertToLanguageModelPrompt({\n          prompt: standardizedPrompt,\n          supportedUrls: await model.supportedUrls,\n          download: download2\n        });\n        const generateResult = await retry(\n          () => recordSpan({\n            name: \"ai.generateObject.doGenerate\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.generateObject.doGenerate\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.messages\": {\n                  input: () => stringifyForTelemetry(promptMessages)\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                \"gen_ai.request.temperature\": callSettings.temperature,\n                \"gen_ai.request.top_k\": callSettings.topK,\n                \"gen_ai.request.top_p\": callSettings.topP\n              }\n            }),\n            tracer,\n            fn: async (span2) => {\n              var _a18, _b, _c, _d, _e, _f, _g, _h;\n              const result2 = await model.doGenerate({\n                responseFormat: {\n                  type: \"json\",\n                  schema: outputStrategy.jsonSchema,\n                  name: schemaName,\n                  description: schemaDescription\n                },\n                ...prepareCallSettings(settings),\n                prompt: promptMessages,\n                providerOptions,\n                abortSignal,\n                headers\n              });\n              const responseData = {\n                id: (_b = (_a18 = result2.response) == null ? void 0 : _a18.id) != null ? _b : generateId3(),\n                timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),\n                modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId,\n                headers: (_g = result2.response) == null ? void 0 : _g.headers,\n                body: (_h = result2.response) == null ? void 0 : _h.body\n              };\n              const text2 = extractTextContent(result2.content);\n              const reasoning2 = extractReasoningContent(result2.content);\n              if (text2 === void 0) {\n                throw new NoObjectGeneratedError({\n                  message: \"No object generated: the model did not return a response.\",\n                  response: responseData,\n                  usage: result2.usage,\n                  finishReason: result2.finishReason\n                });\n              }\n              span2.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.response.finishReason\": result2.finishReason,\n                    \"ai.response.object\": { output: () => text2 },\n                    \"ai.response.id\": responseData.id,\n                    \"ai.response.model\": responseData.modelId,\n                    \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                    \"ai.response.providerMetadata\": JSON.stringify(\n                      result2.providerMetadata\n                    ),\n                    // TODO rename telemetry attributes to inputTokens and outputTokens\n                    \"ai.usage.promptTokens\": result2.usage.inputTokens,\n                    \"ai.usage.completionTokens\": result2.usage.outputTokens,\n                    // standardized gen-ai llm span attributes:\n                    \"gen_ai.response.finish_reasons\": [result2.finishReason],\n                    \"gen_ai.response.id\": responseData.id,\n                    \"gen_ai.response.model\": responseData.modelId,\n                    \"gen_ai.usage.input_tokens\": result2.usage.inputTokens,\n                    \"gen_ai.usage.output_tokens\": result2.usage.outputTokens\n                  }\n                })\n              );\n              return {\n                ...result2,\n                objectText: text2,\n                reasoning: reasoning2,\n                responseData\n              };\n            }\n          })\n        );\n        result = generateResult.objectText;\n        finishReason = generateResult.finishReason;\n        usage = generateResult.usage;\n        warnings = generateResult.warnings;\n        resultProviderMetadata = generateResult.providerMetadata;\n        request = (_a17 = generateResult.request) != null ? _a17 : {};\n        response = generateResult.responseData;\n        reasoning = generateResult.reasoning;\n        logWarnings(warnings);\n        const object2 = await parseAndValidateObjectResultWithRepair(\n          result,\n          outputStrategy,\n          repairText,\n          {\n            response,\n            usage,\n            finishReason\n          }\n        );\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.response.finishReason\": finishReason,\n              \"ai.response.object\": {\n                output: () => JSON.stringify(object2)\n              },\n              \"ai.response.providerMetadata\": JSON.stringify(\n                resultProviderMetadata\n              ),\n              // TODO rename telemetry attributes to inputTokens and outputTokens\n              \"ai.usage.promptTokens\": usage.inputTokens,\n              \"ai.usage.completionTokens\": usage.outputTokens\n            }\n          })\n        );\n        return new DefaultGenerateObjectResult({\n          object: object2,\n          reasoning,\n          finishReason,\n          usage,\n          warnings,\n          request,\n          response,\n          providerMetadata: resultProviderMetadata\n        });\n      }\n    });\n  } catch (error) {\n    throw wrapGatewayError(error);\n  }\n}\nvar DefaultGenerateObjectResult = class {\n  constructor(options) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.response = options.response;\n    this.request = options.request;\n    this.reasoning = options.reasoning;\n  }\n  toJsonResponse(init) {\n    var _a17;\n    return new Response(JSON.stringify(this.object), {\n      status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,\n      headers: prepareHeaders(init == null ? void 0 : init.headers, {\n        \"content-type\": \"application/json; charset=utf-8\"\n      })\n    });\n  }\n};\n\n// src/generate-object/stream-object.ts\n\n\n// src/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2) {\n  if (vector1.length !== vector2.length) {\n    throw new InvalidArgumentError({\n      parameter: \"vector1,vector2\",\n      value: { vector1Length: vector1.length, vector2Length: vector2.length },\n      message: `Vectors must have the same length`\n    });\n  }\n  const n = vector1.length;\n  if (n === 0) {\n    return 0;\n  }\n  let magnitudeSquared1 = 0;\n  let magnitudeSquared2 = 0;\n  let dotProduct = 0;\n  for (let i = 0; i < n; i++) {\n    const value1 = vector1[i];\n    const value2 = vector2[i];\n    magnitudeSquared1 += value1 * value1;\n    magnitudeSquared2 += value2 * value2;\n    dotProduct += value1 * value2;\n  }\n  return magnitudeSquared1 === 0 || magnitudeSquared2 === 0 ? 0 : dotProduct / (Math.sqrt(magnitudeSquared1) * Math.sqrt(magnitudeSquared2));\n}\n\n// src/util/data-url.ts\nfunction getTextFromDataUrl(dataUrl) {\n  const [header, base64Content] = dataUrl.split(\",\");\n  const mediaType = header.split(\";\")[0].split(\":\")[1];\n  if (mediaType == null || base64Content == null) {\n    throw new Error(\"Invalid data URL format\");\n  }\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n\n// src/util/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n  if (obj1 === obj2)\n    return true;\n  if (obj1 == null || obj2 == null)\n    return false;\n  if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\")\n    return obj1 === obj2;\n  if (obj1.constructor !== obj2.constructor)\n    return false;\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length)\n      return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i]))\n        return false;\n    }\n    return true;\n  }\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length)\n    return false;\n  for (const key of keys1) {\n    if (!keys2.includes(key))\n      return false;\n    if (!isDeepEqualData(obj1[key], obj2[key]))\n      return false;\n  }\n  return true;\n}\n\n// src/util/serial-job-executor.ts\nvar SerialJobExecutor = class {\n  constructor() {\n    this.queue = [];\n    this.isProcessing = false;\n  }\n  async processQueue() {\n    if (this.isProcessing) {\n      return;\n    }\n    this.isProcessing = true;\n    while (this.queue.length > 0) {\n      await this.queue[0]();\n      this.queue.shift();\n    }\n    this.isProcessing = false;\n  }\n  async run(job) {\n    return new Promise((resolve2, reject) => {\n      this.queue.push(async () => {\n        try {\n          await job();\n          resolve2();\n        } catch (error) {\n          reject(error);\n        }\n      });\n      void this.processQueue();\n    });\n  }\n};\n\n// src/util/simulate-readable-stream.ts\n\nfunction simulateReadableStream({\n  chunks,\n  initialDelayInMs = 0,\n  chunkDelayInMs = 0,\n  _internal\n}) {\n  var _a17;\n  const delay2 = (_a17 = _internal == null ? void 0 : _internal.delay) != null ? _a17 : _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay;\n  let index = 0;\n  return new ReadableStream({\n    async pull(controller) {\n      if (index < chunks.length) {\n        await delay2(index === 0 ? initialDelayInMs : chunkDelayInMs);\n        controller.enqueue(chunks[index++]);\n      } else {\n        controller.close();\n      }\n    }\n  });\n}\n\n// src/generate-object/stream-object.ts\nvar originalGenerateId4 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({ prefix: \"aiobj\", size: 24 });\nfunction streamObject(options) {\n  const {\n    model,\n    output = \"object\",\n    system,\n    prompt,\n    messages,\n    maxRetries,\n    abortSignal,\n    headers,\n    experimental_repairText: repairText,\n    experimental_telemetry: telemetry,\n    experimental_download: download2,\n    providerOptions,\n    onError = ({ error }) => {\n      console.error(error);\n    },\n    onFinish,\n    _internal: {\n      generateId: generateId3 = originalGenerateId4,\n      currentDate = () => /* @__PURE__ */ new Date(),\n      now: now2 = now\n    } = {},\n    ...settings\n  } = options;\n  const enumValues = \"enum\" in options && options.enum ? options.enum : void 0;\n  const {\n    schema: inputSchema,\n    schemaDescription,\n    schemaName\n  } = \"schema\" in options ? options : {};\n  validateObjectGenerationInput({\n    output,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues\n  });\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues\n  });\n  return new DefaultStreamObjectResult({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    repairText,\n    onError,\n    onFinish,\n    download: download2,\n    generateId: generateId3,\n    currentDate,\n    now: now2\n  });\n}\nvar DefaultStreamObjectResult = class {\n  constructor({\n    model: modelArg,\n    headers,\n    telemetry,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    repairText,\n    onError,\n    onFinish,\n    download: download2,\n    generateId: generateId3,\n    currentDate,\n    now: now2\n  }) {\n    this._object = new DelayedPromise();\n    this._usage = new DelayedPromise();\n    this._providerMetadata = new DelayedPromise();\n    this._warnings = new DelayedPromise();\n    this._request = new DelayedPromise();\n    this._response = new DelayedPromise();\n    this._finishReason = new DelayedPromise();\n    const model = resolveLanguageModel(modelArg);\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n      abortSignal\n    });\n    const callSettings = prepareCallSettings(settings);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...callSettings, maxRetries }\n    });\n    const tracer = getTracer(telemetry);\n    const self = this;\n    const stitchableStream = createStitchableStream();\n    const eventProcessor = new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n        if (chunk.type === \"error\") {\n          onError({ error: wrapGatewayError(chunk.error) });\n        }\n      }\n    });\n    this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);\n    recordSpan({\n      name: \"ai.streamObject\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.streamObject\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          },\n          \"ai.schema\": outputStrategy.jsonSchema != null ? { input: () => JSON.stringify(outputStrategy.jsonSchema) } : void 0,\n          \"ai.schema.name\": schemaName,\n          \"ai.schema.description\": schemaDescription,\n          \"ai.settings.output\": outputStrategy.type\n        }\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async (rootSpan) => {\n        const standardizedPrompt = await standardizePrompt({\n          system,\n          prompt,\n          messages\n        });\n        const callOptions = {\n          responseFormat: {\n            type: \"json\",\n            schema: outputStrategy.jsonSchema,\n            name: schemaName,\n            description: schemaDescription\n          },\n          ...prepareCallSettings(settings),\n          prompt: await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            supportedUrls: await model.supportedUrls,\n            download: download2\n          }),\n          providerOptions,\n          abortSignal,\n          headers,\n          includeRawChunks: false\n        };\n        const transformer = {\n          transform: (chunk, controller) => {\n            switch (chunk.type) {\n              case \"text-delta\":\n                controller.enqueue(chunk.delta);\n                break;\n              case \"response-metadata\":\n              case \"finish\":\n              case \"error\":\n              case \"stream-start\":\n                controller.enqueue(chunk);\n                break;\n            }\n          }\n        };\n        const {\n          result: { stream, response, request },\n          doStreamSpan,\n          startTimestampMs\n        } = await retry(\n          () => recordSpan({\n            name: \"ai.streamObject.doStream\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.streamObject.doStream\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.messages\": {\n                  input: () => stringifyForTelemetry(callOptions.prompt)\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                \"gen_ai.request.temperature\": callSettings.temperature,\n                \"gen_ai.request.top_k\": callSettings.topK,\n                \"gen_ai.request.top_p\": callSettings.topP\n              }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async (doStreamSpan2) => ({\n              startTimestampMs: now2(),\n              doStreamSpan: doStreamSpan2,\n              result: await model.doStream(callOptions)\n            })\n          })\n        );\n        self._request.resolve(request != null ? request : {});\n        let warnings;\n        let usage = {\n          inputTokens: void 0,\n          outputTokens: void 0,\n          totalTokens: void 0\n        };\n        let finishReason;\n        let providerMetadata;\n        let object2;\n        let error;\n        let accumulatedText = \"\";\n        let textDelta = \"\";\n        let fullResponse = {\n          id: generateId3(),\n          timestamp: currentDate(),\n          modelId: model.modelId\n        };\n        let latestObjectJson = void 0;\n        let latestObject = void 0;\n        let isFirstChunk = true;\n        let isFirstDelta = true;\n        const transformedStream = stream.pipeThrough(new TransformStream(transformer)).pipeThrough(\n          new TransformStream({\n            async transform(chunk, controller) {\n              var _a17, _b, _c;\n              if (typeof chunk === \"object\" && chunk.type === \"stream-start\") {\n                warnings = chunk.warnings;\n                return;\n              }\n              if (isFirstChunk) {\n                const msToFirstChunk = now2() - startTimestampMs;\n                isFirstChunk = false;\n                doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n                doStreamSpan.setAttributes({\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n              }\n              if (typeof chunk === \"string\") {\n                accumulatedText += chunk;\n                textDelta += chunk;\n                const { value: currentObjectJson, state: parseState } = await parsePartialJson(accumulatedText);\n                if (currentObjectJson !== void 0 && !isDeepEqualData(latestObjectJson, currentObjectJson)) {\n                  const validationResult = await outputStrategy.validatePartialResult({\n                    value: currentObjectJson,\n                    textDelta,\n                    latestObject,\n                    isFirstDelta,\n                    isFinalDelta: parseState === \"successful-parse\"\n                  });\n                  if (validationResult.success && !isDeepEqualData(\n                    latestObject,\n                    validationResult.value.partial\n                  )) {\n                    latestObjectJson = currentObjectJson;\n                    latestObject = validationResult.value.partial;\n                    controller.enqueue({\n                      type: \"object\",\n                      object: latestObject\n                    });\n                    controller.enqueue({\n                      type: \"text-delta\",\n                      textDelta: validationResult.value.textDelta\n                    });\n                    textDelta = \"\";\n                    isFirstDelta = false;\n                  }\n                }\n                return;\n              }\n              switch (chunk.type) {\n                case \"response-metadata\": {\n                  fullResponse = {\n                    id: (_a17 = chunk.id) != null ? _a17 : fullResponse.id,\n                    timestamp: (_b = chunk.timestamp) != null ? _b : fullResponse.timestamp,\n                    modelId: (_c = chunk.modelId) != null ? _c : fullResponse.modelId\n                  };\n                  break;\n                }\n                case \"finish\": {\n                  if (textDelta !== \"\") {\n                    controller.enqueue({ type: \"text-delta\", textDelta });\n                  }\n                  finishReason = chunk.finishReason;\n                  usage = chunk.usage;\n                  providerMetadata = chunk.providerMetadata;\n                  controller.enqueue({\n                    ...chunk,\n                    usage,\n                    response: fullResponse\n                  });\n                  logWarnings(warnings != null ? warnings : []);\n                  self._usage.resolve(usage);\n                  self._providerMetadata.resolve(providerMetadata);\n                  self._warnings.resolve(warnings);\n                  self._response.resolve({\n                    ...fullResponse,\n                    headers: response == null ? void 0 : response.headers\n                  });\n                  self._finishReason.resolve(finishReason != null ? finishReason : \"unknown\");\n                  try {\n                    object2 = await parseAndValidateObjectResultWithRepair(\n                      accumulatedText,\n                      outputStrategy,\n                      repairText,\n                      {\n                        response: fullResponse,\n                        usage,\n                        finishReason\n                      }\n                    );\n                    self._object.resolve(object2);\n                  } catch (e) {\n                    error = e;\n                    self._object.reject(e);\n                  }\n                  break;\n                }\n                default: {\n                  controller.enqueue(chunk);\n                  break;\n                }\n              }\n            },\n            // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n            async flush(controller) {\n              try {\n                const finalUsage = usage != null ? usage : {\n                  promptTokens: NaN,\n                  completionTokens: NaN,\n                  totalTokens: NaN\n                };\n                doStreamSpan.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": finishReason,\n                      \"ai.response.object\": {\n                        output: () => JSON.stringify(object2)\n                      },\n                      \"ai.response.id\": fullResponse.id,\n                      \"ai.response.model\": fullResponse.modelId,\n                      \"ai.response.timestamp\": fullResponse.timestamp.toISOString(),\n                      \"ai.response.providerMetadata\": JSON.stringify(providerMetadata),\n                      \"ai.usage.inputTokens\": finalUsage.inputTokens,\n                      \"ai.usage.outputTokens\": finalUsage.outputTokens,\n                      \"ai.usage.totalTokens\": finalUsage.totalTokens,\n                      \"ai.usage.reasoningTokens\": finalUsage.reasoningTokens,\n                      \"ai.usage.cachedInputTokens\": finalUsage.cachedInputTokens,\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [finishReason],\n                      \"gen_ai.response.id\": fullResponse.id,\n                      \"gen_ai.response.model\": fullResponse.modelId,\n                      \"gen_ai.usage.input_tokens\": finalUsage.inputTokens,\n                      \"gen_ai.usage.output_tokens\": finalUsage.outputTokens\n                    }\n                  })\n                );\n                doStreamSpan.end();\n                rootSpan.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.usage.inputTokens\": finalUsage.inputTokens,\n                      \"ai.usage.outputTokens\": finalUsage.outputTokens,\n                      \"ai.usage.totalTokens\": finalUsage.totalTokens,\n                      \"ai.usage.reasoningTokens\": finalUsage.reasoningTokens,\n                      \"ai.usage.cachedInputTokens\": finalUsage.cachedInputTokens,\n                      \"ai.response.object\": {\n                        output: () => JSON.stringify(object2)\n                      },\n                      \"ai.response.providerMetadata\": JSON.stringify(providerMetadata)\n                    }\n                  })\n                );\n                await (onFinish == null ? void 0 : onFinish({\n                  usage: finalUsage,\n                  object: object2,\n                  error,\n                  response: {\n                    ...fullResponse,\n                    headers: response == null ? void 0 : response.headers\n                  },\n                  warnings,\n                  providerMetadata\n                }));\n              } catch (error2) {\n                controller.enqueue({ type: \"error\", error: error2 });\n              } finally {\n                rootSpan.end();\n              }\n            }\n          })\n        );\n        stitchableStream.addStream(transformedStream);\n      }\n    }).catch((error) => {\n      stitchableStream.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: \"error\", error });\n            controller.close();\n          }\n        })\n      );\n    }).finally(() => {\n      stitchableStream.close();\n    });\n    this.outputStrategy = outputStrategy;\n  }\n  get object() {\n    return this._object.promise;\n  }\n  get usage() {\n    return this._usage.promise;\n  }\n  get providerMetadata() {\n    return this._providerMetadata.promise;\n  }\n  get warnings() {\n    return this._warnings.promise;\n  }\n  get request() {\n    return this._request.promise;\n  }\n  get response() {\n    return this._response.promise;\n  }\n  get finishReason() {\n    return this._finishReason.promise;\n  }\n  get partialObjectStream() {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case \"object\":\n                controller.enqueue(chunk.object);\n                break;\n              case \"text-delta\":\n              case \"finish\":\n              case \"error\":\n                break;\n              default: {\n                const _exhaustiveCheck = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          }\n        })\n      )\n    );\n  }\n  get elementStream() {\n    return this.outputStrategy.createElementStream(this.baseStream);\n  }\n  get textStream() {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case \"text-delta\":\n                controller.enqueue(chunk.textDelta);\n                break;\n              case \"object\":\n              case \"finish\":\n              case \"error\":\n                break;\n              default: {\n                const _exhaustiveCheck = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          }\n        })\n      )\n    );\n  }\n  get fullStream() {\n    return createAsyncIterableStream(this.baseStream);\n  }\n  pipeTextStreamToResponse(response, init) {\n    pipeTextStreamToResponse({\n      response,\n      textStream: this.textStream,\n      ...init\n    });\n  }\n  toTextStreamResponse(init) {\n    return createTextStreamResponse({\n      textStream: this.textStream,\n      ...init\n    });\n  }\n};\n\n// src/error/no-speech-generated-error.ts\n\nvar NoSpeechGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor(options) {\n    super({\n      name: \"AI_NoSpeechGeneratedError\",\n      message: \"No speech audio generated.\"\n    });\n    this.responses = options.responses;\n  }\n};\n\n// src/generate-speech/generated-audio-file.ts\nvar DefaultGeneratedAudioFile = class extends DefaultGeneratedFile {\n  constructor({\n    data,\n    mediaType\n  }) {\n    super({ data, mediaType });\n    let format = \"mp3\";\n    if (mediaType) {\n      const mediaTypeParts = mediaType.split(\"/\");\n      if (mediaTypeParts.length === 2) {\n        if (mediaType !== \"audio/mpeg\") {\n          format = mediaTypeParts[1];\n        }\n      }\n    }\n    if (!format) {\n      throw new Error(\n        \"Audio format must be provided or determinable from media type\"\n      );\n    }\n    this.format = format;\n  }\n};\n\n// src/generate-speech/generate-speech.ts\nasync function generateSpeech({\n  model,\n  text: text2,\n  voice,\n  outputFormat,\n  instructions,\n  speed,\n  language,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  var _a17;\n  if (model.specificationVersion !== \"v2\") {\n    throw new UnsupportedModelVersionError({\n      version: model.specificationVersion,\n      provider: model.provider,\n      modelId: model.modelId\n    });\n  }\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const result = await retry(\n    () => model.doGenerate({\n      text: text2,\n      voice,\n      outputFormat,\n      instructions,\n      speed,\n      language,\n      abortSignal,\n      headers,\n      providerOptions\n    })\n  );\n  if (!result.audio || result.audio.length === 0) {\n    throw new NoSpeechGeneratedError({ responses: [result.response] });\n  }\n  logWarnings(result.warnings);\n  return new DefaultSpeechResult({\n    audio: new DefaultGeneratedAudioFile({\n      data: result.audio,\n      mediaType: (_a17 = detectMediaType({\n        data: result.audio,\n        signatures: audioMediaTypeSignatures\n      })) != null ? _a17 : \"audio/mp3\"\n    }),\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata\n  });\n}\nvar DefaultSpeechResult = class {\n  constructor(options) {\n    var _a17;\n    this.audio = options.audio;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = (_a17 = options.providerMetadata) != null ? _a17 : {};\n  }\n};\n\n// src/generate-text/output.ts\nvar output_exports = {};\n__export(output_exports, {\n  object: () => object,\n  text: () => text\n});\n\nvar text = () => ({\n  type: \"text\",\n  responseFormat: { type: \"text\" },\n  async parsePartial({ text: text2 }) {\n    return { partial: text2 };\n  },\n  async parseOutput({ text: text2 }) {\n    return text2;\n  }\n});\nvar object = ({\n  schema: inputSchema\n}) => {\n  const schema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(inputSchema);\n  return {\n    type: \"object\",\n    responseFormat: {\n      type: \"json\",\n      schema: schema.jsonSchema\n    },\n    async parsePartial({ text: text2 }) {\n      const result = await parsePartialJson(text2);\n      switch (result.state) {\n        case \"failed-parse\":\n        case \"undefined-input\":\n          return void 0;\n        case \"repaired-parse\":\n        case \"successful-parse\":\n          return {\n            // Note: currently no validation of partial results:\n            partial: result.value\n          };\n        default: {\n          const _exhaustiveCheck = result.state;\n          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    async parseOutput({ text: text2 }, context) {\n      const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: text2 });\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: could not parse the response.\",\n          cause: parseResult.error,\n          text: text2,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason\n        });\n      }\n      const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n        value: parseResult.value,\n        schema\n      });\n      if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: response did not match schema.\",\n          cause: validationResult.error,\n          text: text2,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason\n        });\n      }\n      return validationResult.value;\n    }\n  };\n};\n\n// src/generate-text/smooth-stream.ts\n\n\nvar CHUNKING_REGEXPS = {\n  word: /\\S+\\s+/m,\n  line: /\\n+/m\n};\nfunction smoothStream({\n  delayInMs = 10,\n  chunking = \"word\",\n  _internal: { delay: delay2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay } = {}\n} = {}) {\n  let detectChunk;\n  if (typeof chunking === \"function\") {\n    detectChunk = (buffer) => {\n      const match = chunking(buffer);\n      if (match == null) {\n        return null;\n      }\n      if (!match.length) {\n        throw new Error(`Chunking function must return a non-empty string.`);\n      }\n      if (!buffer.startsWith(match)) {\n        throw new Error(\n          `Chunking function must return a match that is a prefix of the buffer. Received: \"${match}\" expected to start with \"${buffer}\"`\n        );\n      }\n      return match;\n    };\n  } else {\n    const chunkingRegex = typeof chunking === \"string\" ? CHUNKING_REGEXPS[chunking] : chunking;\n    if (chunkingRegex == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError({\n        argument: \"chunking\",\n        message: `Chunking must be \"word\" or \"line\" or a RegExp. Received: ${chunking}`\n      });\n    }\n    detectChunk = (buffer) => {\n      const match = chunkingRegex.exec(buffer);\n      if (!match) {\n        return null;\n      }\n      return buffer.slice(0, match.index) + (match == null ? void 0 : match[0]);\n    };\n  }\n  return () => {\n    let buffer = \"\";\n    let id = \"\";\n    return new TransformStream({\n      async transform(chunk, controller) {\n        if (chunk.type !== \"text-delta\") {\n          if (buffer.length > 0) {\n            controller.enqueue({ type: \"text-delta\", text: buffer, id });\n            buffer = \"\";\n          }\n          controller.enqueue(chunk);\n          return;\n        }\n        if (chunk.id !== id && buffer.length > 0) {\n          controller.enqueue({ type: \"text-delta\", text: buffer, id });\n          buffer = \"\";\n        }\n        buffer += chunk.text;\n        id = chunk.id;\n        let match;\n        while ((match = detectChunk(buffer)) != null) {\n          controller.enqueue({ type: \"text-delta\", text: match, id });\n          buffer = buffer.slice(match.length);\n          await delay2(delayInMs);\n        }\n      }\n    });\n  };\n}\n\n// src/middleware/default-settings-middleware.ts\nfunction defaultSettingsMiddleware({\n  settings\n}) {\n  return {\n    middlewareVersion: \"v2\",\n    transformParams: async ({ params }) => {\n      return mergeObjects(settings, params);\n    }\n  };\n}\n\n// src/util/get-potential-start-index.ts\nfunction getPotentialStartIndex(text2, searchedText) {\n  if (searchedText.length === 0) {\n    return null;\n  }\n  const directIndex = text2.indexOf(searchedText);\n  if (directIndex !== -1) {\n    return directIndex;\n  }\n  for (let i = text2.length - 1; i >= 0; i--) {\n    const suffix = text2.substring(i);\n    if (searchedText.startsWith(suffix)) {\n      return i;\n    }\n  }\n  return null;\n}\n\n// src/middleware/extract-reasoning-middleware.ts\nfunction extractReasoningMiddleware({\n  tagName,\n  separator = \"\\n\",\n  startWithReasoning = false\n}) {\n  const openingTag = `<${tagName}>`;\n  const closingTag = `</${tagName}>`;\n  return {\n    middlewareVersion: \"v2\",\n    wrapGenerate: async ({ doGenerate }) => {\n      const { content, ...rest } = await doGenerate();\n      const transformedContent = [];\n      for (const part of content) {\n        if (part.type !== \"text\") {\n          transformedContent.push(part);\n          continue;\n        }\n        const text2 = startWithReasoning ? openingTag + part.text : part.text;\n        const regexp = new RegExp(`${openingTag}(.*?)${closingTag}`, \"gs\");\n        const matches = Array.from(text2.matchAll(regexp));\n        if (!matches.length) {\n          transformedContent.push(part);\n          continue;\n        }\n        const reasoningText = matches.map((match) => match[1]).join(separator);\n        let textWithoutReasoning = text2;\n        for (let i = matches.length - 1; i >= 0; i--) {\n          const match = matches[i];\n          const beforeMatch = textWithoutReasoning.slice(0, match.index);\n          const afterMatch = textWithoutReasoning.slice(\n            match.index + match[0].length\n          );\n          textWithoutReasoning = beforeMatch + (beforeMatch.length > 0 && afterMatch.length > 0 ? separator : \"\") + afterMatch;\n        }\n        transformedContent.push({\n          type: \"reasoning\",\n          text: reasoningText\n        });\n        transformedContent.push({\n          type: \"text\",\n          text: textWithoutReasoning\n        });\n      }\n      return { content: transformedContent, ...rest };\n    },\n    wrapStream: async ({ doStream }) => {\n      const { stream, ...rest } = await doStream();\n      const reasoningExtractions = {};\n      let delayedTextStart;\n      return {\n        stream: stream.pipeThrough(\n          new TransformStream({\n            transform: (chunk, controller) => {\n              if (chunk.type === \"text-start\") {\n                delayedTextStart = chunk;\n                return;\n              }\n              if (chunk.type === \"text-end\" && delayedTextStart) {\n                controller.enqueue(delayedTextStart);\n                delayedTextStart = void 0;\n              }\n              if (chunk.type !== \"text-delta\") {\n                controller.enqueue(chunk);\n                return;\n              }\n              if (reasoningExtractions[chunk.id] == null) {\n                reasoningExtractions[chunk.id] = {\n                  isFirstReasoning: true,\n                  isFirstText: true,\n                  afterSwitch: false,\n                  isReasoning: startWithReasoning,\n                  buffer: \"\",\n                  idCounter: 0,\n                  textId: chunk.id\n                };\n              }\n              const activeExtraction = reasoningExtractions[chunk.id];\n              activeExtraction.buffer += chunk.delta;\n              function publish(text2) {\n                if (text2.length > 0) {\n                  const prefix = activeExtraction.afterSwitch && (activeExtraction.isReasoning ? !activeExtraction.isFirstReasoning : !activeExtraction.isFirstText) ? separator : \"\";\n                  if (activeExtraction.isReasoning && (activeExtraction.afterSwitch || activeExtraction.isFirstReasoning)) {\n                    controller.enqueue({\n                      type: \"reasoning-start\",\n                      id: `reasoning-${activeExtraction.idCounter}`\n                    });\n                  }\n                  if (activeExtraction.isReasoning) {\n                    controller.enqueue({\n                      type: \"reasoning-delta\",\n                      delta: prefix + text2,\n                      id: `reasoning-${activeExtraction.idCounter}`\n                    });\n                  } else {\n                    if (delayedTextStart) {\n                      controller.enqueue(delayedTextStart);\n                      delayedTextStart = void 0;\n                    }\n                    controller.enqueue({\n                      type: \"text-delta\",\n                      delta: prefix + text2,\n                      id: activeExtraction.textId\n                    });\n                  }\n                  activeExtraction.afterSwitch = false;\n                  if (activeExtraction.isReasoning) {\n                    activeExtraction.isFirstReasoning = false;\n                  } else {\n                    activeExtraction.isFirstText = false;\n                  }\n                }\n              }\n              do {\n                const nextTag = activeExtraction.isReasoning ? closingTag : openingTag;\n                const startIndex = getPotentialStartIndex(\n                  activeExtraction.buffer,\n                  nextTag\n                );\n                if (startIndex == null) {\n                  publish(activeExtraction.buffer);\n                  activeExtraction.buffer = \"\";\n                  break;\n                }\n                publish(activeExtraction.buffer.slice(0, startIndex));\n                const foundFullMatch = startIndex + nextTag.length <= activeExtraction.buffer.length;\n                if (foundFullMatch) {\n                  activeExtraction.buffer = activeExtraction.buffer.slice(\n                    startIndex + nextTag.length\n                  );\n                  if (activeExtraction.isReasoning) {\n                    controller.enqueue({\n                      type: \"reasoning-end\",\n                      id: `reasoning-${activeExtraction.idCounter++}`\n                    });\n                  }\n                  activeExtraction.isReasoning = !activeExtraction.isReasoning;\n                  activeExtraction.afterSwitch = true;\n                } else {\n                  activeExtraction.buffer = activeExtraction.buffer.slice(startIndex);\n                  break;\n                }\n              } while (true);\n            }\n          })\n        ),\n        ...rest\n      };\n    }\n  };\n}\n\n// src/middleware/simulate-streaming-middleware.ts\nfunction simulateStreamingMiddleware() {\n  return {\n    middlewareVersion: \"v2\",\n    wrapStream: async ({ doGenerate }) => {\n      const result = await doGenerate();\n      let id = 0;\n      const simulatedStream = new ReadableStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"stream-start\",\n            warnings: result.warnings\n          });\n          controller.enqueue({ type: \"response-metadata\", ...result.response });\n          for (const part of result.content) {\n            switch (part.type) {\n              case \"text\": {\n                if (part.text.length > 0) {\n                  controller.enqueue({ type: \"text-start\", id: String(id) });\n                  controller.enqueue({\n                    type: \"text-delta\",\n                    id: String(id),\n                    delta: part.text\n                  });\n                  controller.enqueue({ type: \"text-end\", id: String(id) });\n                  id++;\n                }\n                break;\n              }\n              case \"reasoning\": {\n                controller.enqueue({\n                  type: \"reasoning-start\",\n                  id: String(id),\n                  providerMetadata: part.providerMetadata\n                });\n                controller.enqueue({\n                  type: \"reasoning-delta\",\n                  id: String(id),\n                  delta: part.text\n                });\n                controller.enqueue({ type: \"reasoning-end\", id: String(id) });\n                id++;\n                break;\n              }\n              default: {\n                controller.enqueue(part);\n                break;\n              }\n            }\n          }\n          controller.enqueue({\n            type: \"finish\",\n            finishReason: result.finishReason,\n            usage: result.usage,\n            providerMetadata: result.providerMetadata\n          });\n          controller.close();\n        }\n      });\n      return {\n        stream: simulatedStream,\n        request: result.request,\n        response: result.response\n      };\n    }\n  };\n}\n\n// src/middleware/wrap-language-model.ts\nvar wrapLanguageModel = ({\n  model,\n  middleware: middlewareArg,\n  modelId,\n  providerId\n}) => {\n  return asArray(middlewareArg).reverse().reduce((wrappedModel, middleware) => {\n    return doWrap({ model: wrappedModel, middleware, modelId, providerId });\n  }, model);\n};\nvar doWrap = ({\n  model,\n  middleware: {\n    transformParams,\n    wrapGenerate,\n    wrapStream,\n    overrideProvider,\n    overrideModelId,\n    overrideSupportedUrls\n  },\n  modelId,\n  providerId\n}) => {\n  var _a17, _b, _c;\n  async function doTransform({\n    params,\n    type\n  }) {\n    return transformParams ? await transformParams({ params, type, model }) : params;\n  }\n  return {\n    specificationVersion: \"v2\",\n    provider: (_a17 = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({ model })) != null ? _a17 : model.provider,\n    modelId: (_b = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({ model })) != null ? _b : model.modelId,\n    supportedUrls: (_c = overrideSupportedUrls == null ? void 0 : overrideSupportedUrls({ model })) != null ? _c : model.supportedUrls,\n    async doGenerate(params) {\n      const transformedParams = await doTransform({ params, type: \"generate\" });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapGenerate ? wrapGenerate({\n        doGenerate,\n        doStream,\n        params: transformedParams,\n        model\n      }) : doGenerate();\n    },\n    async doStream(params) {\n      const transformedParams = await doTransform({ params, type: \"stream\" });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapStream ? wrapStream({ doGenerate, doStream, params: transformedParams, model }) : doStream();\n    }\n  };\n};\n\n// src/middleware/wrap-provider.ts\nfunction wrapProvider({\n  provider,\n  languageModelMiddleware\n}) {\n  const wrappedProvider = {\n    languageModel(modelId) {\n      let model = provider.languageModel(modelId);\n      model = wrapLanguageModel({\n        model,\n        middleware: languageModelMiddleware\n      });\n      return model;\n    },\n    textEmbeddingModel: provider.textEmbeddingModel,\n    imageModel: provider.imageModel,\n    transcriptionModel: provider.transcriptionModel,\n    speechModel: provider.speechModel\n  };\n  return wrappedProvider;\n}\n\n// src/registry/custom-provider.ts\n\nfunction customProvider({\n  languageModels,\n  textEmbeddingModels,\n  imageModels,\n  transcriptionModels,\n  speechModels,\n  fallbackProvider\n}) {\n  return {\n    languageModel(modelId) {\n      if (languageModels != null && modelId in languageModels) {\n        return languageModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.languageModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"languageModel\" });\n    },\n    textEmbeddingModel(modelId) {\n      if (textEmbeddingModels != null && modelId in textEmbeddingModels) {\n        return textEmbeddingModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.textEmbeddingModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"textEmbeddingModel\" });\n    },\n    imageModel(modelId) {\n      if (imageModels != null && modelId in imageModels) {\n        return imageModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.imageModel) {\n        return fallbackProvider.imageModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"imageModel\" });\n    },\n    transcriptionModel(modelId) {\n      if (transcriptionModels != null && modelId in transcriptionModels) {\n        return transcriptionModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.transcriptionModel) {\n        return fallbackProvider.transcriptionModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"transcriptionModel\" });\n    },\n    speechModel(modelId) {\n      if (speechModels != null && modelId in speechModels) {\n        return speechModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.speechModel) {\n        return fallbackProvider.speechModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"speechModel\" });\n    }\n  };\n}\nvar experimental_customProvider = customProvider;\n\n// src/registry/no-such-provider-error.ts\n\nvar name16 = \"AI_NoSuchProviderError\";\nvar marker16 = `vercel.ai.error.${name16}`;\nvar symbol16 = Symbol.for(marker16);\nvar _a16;\nvar NoSuchProviderError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError {\n  constructor({\n    modelId,\n    modelType,\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`\n  }) {\n    super({ errorName: name16, modelId, modelType, message });\n    this[_a16] = true;\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker16);\n  }\n};\n_a16 = symbol16;\n\n// src/registry/provider-registry.ts\n\nfunction createProviderRegistry(providers, {\n  separator = \":\",\n  languageModelMiddleware\n} = {}) {\n  const registry = new DefaultProviderRegistry({\n    separator,\n    languageModelMiddleware\n  });\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider });\n  }\n  return registry;\n}\nvar experimental_createProviderRegistry = createProviderRegistry;\nvar DefaultProviderRegistry = class {\n  constructor({\n    separator,\n    languageModelMiddleware\n  }) {\n    this.providers = {};\n    this.separator = separator;\n    this.languageModelMiddleware = languageModelMiddleware;\n  }\n  registerProvider({\n    id,\n    provider\n  }) {\n    this.providers[id] = provider;\n  }\n  getProvider(id, modelType) {\n    const provider = this.providers[id];\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        modelId: id,\n        modelType,\n        providerId: id,\n        availableProviders: Object.keys(this.providers)\n      });\n    }\n    return provider;\n  }\n  splitId(id, modelType) {\n    const index = id.indexOf(this.separator);\n    if (index === -1) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType,\n        message: `Invalid ${modelType} id for registry: ${id} (must be in the format \"providerId${this.separator}modelId\")`\n      });\n    }\n    return [id.slice(0, index), id.slice(index + this.separator.length)];\n  }\n  languageModel(id) {\n    var _a17, _b;\n    const [providerId, modelId] = this.splitId(id, \"languageModel\");\n    let model = (_b = (_a17 = this.getProvider(providerId, \"languageModel\")).languageModel) == null ? void 0 : _b.call(\n      _a17,\n      modelId\n    );\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"languageModel\" });\n    }\n    if (this.languageModelMiddleware != null) {\n      model = wrapLanguageModel({\n        model,\n        middleware: this.languageModelMiddleware\n      });\n    }\n    return model;\n  }\n  textEmbeddingModel(id) {\n    var _a17;\n    const [providerId, modelId] = this.splitId(id, \"textEmbeddingModel\");\n    const provider = this.getProvider(providerId, \"textEmbeddingModel\");\n    const model = (_a17 = provider.textEmbeddingModel) == null ? void 0 : _a17.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType: \"textEmbeddingModel\"\n      });\n    }\n    return model;\n  }\n  imageModel(id) {\n    var _a17;\n    const [providerId, modelId] = this.splitId(id, \"imageModel\");\n    const provider = this.getProvider(providerId, \"imageModel\");\n    const model = (_a17 = provider.imageModel) == null ? void 0 : _a17.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"imageModel\" });\n    }\n    return model;\n  }\n  transcriptionModel(id) {\n    var _a17;\n    const [providerId, modelId] = this.splitId(id, \"transcriptionModel\");\n    const provider = this.getProvider(providerId, \"transcriptionModel\");\n    const model = (_a17 = provider.transcriptionModel) == null ? void 0 : _a17.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType: \"transcriptionModel\"\n      });\n    }\n    return model;\n  }\n  speechModel(id) {\n    var _a17;\n    const [providerId, modelId] = this.splitId(id, \"speechModel\");\n    const provider = this.getProvider(providerId, \"speechModel\");\n    const model = (_a17 = provider.speechModel) == null ? void 0 : _a17.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"speechModel\" });\n    }\n    return model;\n  }\n};\n\n// src/tool/mcp/mcp-client.ts\n\n\n// src/tool/mcp/mcp-sse-transport.ts\n\n\n// src/tool/mcp/json-rpc-message.ts\n\n\n// src/tool/mcp/types.ts\n\nvar LATEST_PROTOCOL_VERSION = \"2025-06-18\";\nvar SUPPORTED_PROTOCOL_VERSIONS = [\n  LATEST_PROTOCOL_VERSION,\n  \"2025-03-26\",\n  \"2024-11-05\"\n];\nvar ClientOrServerImplementationSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.looseObject({\n  name: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  version: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n});\nvar BaseParamsSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.looseObject({\n  _meta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({}).loose())\n});\nvar ResultSchema = BaseParamsSchema;\nvar RequestSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  method: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  params: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(BaseParamsSchema)\n});\nvar ServerCapabilitiesSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.looseObject({\n  experimental: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({}).loose()),\n  logging: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({}).loose()),\n  prompts: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.looseObject({\n      listChanged: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean())\n    })\n  ),\n  resources: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.looseObject({\n      subscribe: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean()),\n      listChanged: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean())\n    })\n  ),\n  tools: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.looseObject({\n      listChanged: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean())\n    })\n  )\n});\nvar InitializeResultSchema = ResultSchema.extend({\n  protocolVersion: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  capabilities: ServerCapabilitiesSchema,\n  serverInfo: ClientOrServerImplementationSchema,\n  instructions: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string())\n});\nvar PaginatedResultSchema = ResultSchema.extend({\n  nextCursor: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string())\n});\nvar ToolSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  name: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  description: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()),\n  inputSchema: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"object\"),\n    properties: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({}).loose())\n  }).loose()\n}).loose();\nvar ListToolsResultSchema = PaginatedResultSchema.extend({\n  tools: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(ToolSchema)\n});\nvar TextContentSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n}).loose();\nvar ImageContentSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"image\"),\n  data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.base64(),\n  mimeType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n}).loose();\nvar ResourceContentsSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  /**\n   * The URI of this resource.\n   */\n  uri: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  /**\n   * The MIME type of this resource, if known.\n   */\n  mimeType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string())\n}).loose();\nvar TextResourceContentsSchema = ResourceContentsSchema.extend({\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n});\nvar BlobResourceContentsSchema = ResourceContentsSchema.extend({\n  blob: zod_v4__WEBPACK_IMPORTED_MODULE_3__.base64()\n});\nvar EmbeddedResourceSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"resource\"),\n  resource: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([TextResourceContentsSchema, BlobResourceContentsSchema])\n}).loose();\nvar CallToolResultSchema = ResultSchema.extend({\n  content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema])\n  ),\n  isError: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().default(false).optional()\n}).or(\n  ResultSchema.extend({\n    toolResult: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown()\n  })\n);\n\n// src/tool/mcp/json-rpc-message.ts\nvar JSONRPC_VERSION = \"2.0\";\nvar JSONRPCRequestSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  jsonrpc: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(JSONRPC_VERSION),\n  id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.number().int()])\n}).merge(RequestSchema).strict();\nvar JSONRPCResponseSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  jsonrpc: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(JSONRPC_VERSION),\n  id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.number().int()]),\n  result: ResultSchema\n}).strict();\nvar JSONRPCErrorSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  jsonrpc: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(JSONRPC_VERSION),\n  id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.number().int()]),\n  error: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    code: zod_v4__WEBPACK_IMPORTED_MODULE_3__.number().int(),\n    message: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown())\n  })\n}).strict();\nvar JSONRPCNotificationSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  jsonrpc: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(JSONRPC_VERSION)\n}).merge(\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    method: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    params: zod_v4__WEBPACK_IMPORTED_MODULE_3__.optional(BaseParamsSchema)\n  })\n).strict();\nvar JSONRPCMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n  JSONRPCRequestSchema,\n  JSONRPCNotificationSchema,\n  JSONRPCResponseSchema,\n  JSONRPCErrorSchema\n]);\n\n// src/tool/mcp/mcp-sse-transport.ts\nvar SseMCPTransport = class {\n  constructor({\n    url,\n    headers\n  }) {\n    this.connected = false;\n    this.url = new URL(url);\n    this.headers = headers;\n  }\n  async start() {\n    return new Promise((resolve2, reject) => {\n      if (this.connected) {\n        return resolve2();\n      }\n      this.abortController = new AbortController();\n      const establishConnection = async () => {\n        var _a17, _b, _c;\n        try {\n          const headers = new Headers(this.headers);\n          headers.set(\"Accept\", \"text/event-stream\");\n          const response = await fetch(this.url.href, {\n            headers,\n            signal: (_a17 = this.abortController) == null ? void 0 : _a17.signal\n          });\n          if (!response.ok || !response.body) {\n            const error = new MCPClientError({\n              message: `MCP SSE Transport Error: ${response.status} ${response.statusText}`\n            });\n            (_b = this.onerror) == null ? void 0 : _b.call(this, error);\n            return reject(error);\n          }\n          const stream = response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_6__.EventSourceParserStream());\n          const reader = stream.getReader();\n          const processEvents = async () => {\n            var _a18, _b2, _c2;\n            try {\n              while (true) {\n                const { done, value } = await reader.read();\n                if (done) {\n                  if (this.connected) {\n                    this.connected = false;\n                    throw new MCPClientError({\n                      message: \"MCP SSE Transport Error: Connection closed unexpectedly\"\n                    });\n                  }\n                  return;\n                }\n                const { event, data } = value;\n                if (event === \"endpoint\") {\n                  this.endpoint = new URL(data, this.url);\n                  if (this.endpoint.origin !== this.url.origin) {\n                    throw new MCPClientError({\n                      message: `MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`\n                    });\n                  }\n                  this.connected = true;\n                  resolve2();\n                } else if (event === \"message\") {\n                  try {\n                    const message = JSONRPCMessageSchema.parse(\n                      JSON.parse(data)\n                    );\n                    (_a18 = this.onmessage) == null ? void 0 : _a18.call(this, message);\n                  } catch (error) {\n                    const e = new MCPClientError({\n                      message: \"MCP SSE Transport Error: Failed to parse message\",\n                      cause: error\n                    });\n                    (_b2 = this.onerror) == null ? void 0 : _b2.call(this, e);\n                  }\n                }\n              }\n            } catch (error) {\n              if (error instanceof Error && error.name === \"AbortError\") {\n                return;\n              }\n              (_c2 = this.onerror) == null ? void 0 : _c2.call(this, error);\n              reject(error);\n            }\n          };\n          this.sseConnection = {\n            close: () => reader.cancel()\n          };\n          processEvents();\n        } catch (error) {\n          if (error instanceof Error && error.name === \"AbortError\") {\n            return;\n          }\n          (_c = this.onerror) == null ? void 0 : _c.call(this, error);\n          reject(error);\n        }\n      };\n      establishConnection();\n    });\n  }\n  async close() {\n    var _a17, _b, _c;\n    this.connected = false;\n    (_a17 = this.sseConnection) == null ? void 0 : _a17.close();\n    (_b = this.abortController) == null ? void 0 : _b.abort();\n    (_c = this.onclose) == null ? void 0 : _c.call(this);\n  }\n  async send(message) {\n    var _a17, _b, _c;\n    if (!this.endpoint || !this.connected) {\n      throw new MCPClientError({\n        message: \"MCP SSE Transport Error: Not connected\"\n      });\n    }\n    try {\n      const headers = new Headers(this.headers);\n      headers.set(\"Content-Type\", \"application/json\");\n      const init = {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(message),\n        signal: (_a17 = this.abortController) == null ? void 0 : _a17.signal\n      };\n      const response = await fetch(this.endpoint, init);\n      if (!response.ok) {\n        const text2 = await response.text().catch(() => null);\n        const error = new MCPClientError({\n          message: `MCP SSE Transport Error: POSTing to endpoint (HTTP ${response.status}): ${text2}`\n        });\n        (_b = this.onerror) == null ? void 0 : _b.call(this, error);\n        return;\n      }\n    } catch (error) {\n      (_c = this.onerror) == null ? void 0 : _c.call(this, error);\n      return;\n    }\n  }\n};\n\n// src/tool/mcp/mcp-transport.ts\nfunction createMcpTransport(config) {\n  if (config.type !== \"sse\") {\n    throw new MCPClientError({\n      message: \"Unsupported or invalid transport configuration. If you are using a custom transport, make sure it implements the MCPTransport interface.\"\n    });\n  }\n  return new SseMCPTransport(config);\n}\nfunction isCustomMcpTransport(transport) {\n  return \"start\" in transport && typeof transport.start === \"function\" && \"send\" in transport && typeof transport.send === \"function\" && \"close\" in transport && typeof transport.close === \"function\";\n}\n\n// src/tool/mcp/mcp-client.ts\nvar CLIENT_VERSION = \"1.0.0\";\nasync function createMCPClient(config) {\n  const client = new DefaultMCPClient(config);\n  await client.init();\n  return client;\n}\nvar DefaultMCPClient = class {\n  constructor({\n    transport: transportConfig,\n    name: name17 = \"ai-sdk-mcp-client\",\n    onUncaughtError\n  }) {\n    this.requestMessageId = 0;\n    this.responseHandlers = /* @__PURE__ */ new Map();\n    this.serverCapabilities = {};\n    this.isClosed = true;\n    this.onUncaughtError = onUncaughtError;\n    if (isCustomMcpTransport(transportConfig)) {\n      this.transport = transportConfig;\n    } else {\n      this.transport = createMcpTransport(transportConfig);\n    }\n    this.transport.onclose = () => this.onClose();\n    this.transport.onerror = (error) => this.onError(error);\n    this.transport.onmessage = (message) => {\n      if (\"method\" in message) {\n        this.onError(\n          new MCPClientError({\n            message: \"Unsupported message type\"\n          })\n        );\n        return;\n      }\n      this.onResponse(message);\n    };\n    this.clientInfo = {\n      name: name17,\n      version: CLIENT_VERSION\n    };\n  }\n  async init() {\n    try {\n      await this.transport.start();\n      this.isClosed = false;\n      const result = await this.request({\n        request: {\n          method: \"initialize\",\n          params: {\n            protocolVersion: LATEST_PROTOCOL_VERSION,\n            capabilities: {},\n            clientInfo: this.clientInfo\n          }\n        },\n        resultSchema: InitializeResultSchema\n      });\n      if (result === void 0) {\n        throw new MCPClientError({\n          message: \"Server sent invalid initialize result\"\n        });\n      }\n      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {\n        throw new MCPClientError({\n          message: `Server's protocol version is not supported: ${result.protocolVersion}`\n        });\n      }\n      this.serverCapabilities = result.capabilities;\n      await this.notification({\n        method: \"notifications/initialized\"\n      });\n      return this;\n    } catch (error) {\n      await this.close();\n      throw error;\n    }\n  }\n  async close() {\n    var _a17;\n    if (this.isClosed)\n      return;\n    await ((_a17 = this.transport) == null ? void 0 : _a17.close());\n    this.onClose();\n  }\n  assertCapability(method) {\n    switch (method) {\n      case \"initialize\":\n        break;\n      case \"tools/list\":\n      case \"tools/call\":\n        if (!this.serverCapabilities.tools) {\n          throw new MCPClientError({\n            message: `Server does not support tools`\n          });\n        }\n        break;\n      default:\n        throw new MCPClientError({\n          message: `Unsupported method: ${method}`\n        });\n    }\n  }\n  async request({\n    request,\n    resultSchema,\n    options\n  }) {\n    return new Promise((resolve2, reject) => {\n      if (this.isClosed) {\n        return reject(\n          new MCPClientError({\n            message: \"Attempted to send a request from a closed client\"\n          })\n        );\n      }\n      this.assertCapability(request.method);\n      const signal = options == null ? void 0 : options.signal;\n      signal == null ? void 0 : signal.throwIfAborted();\n      const messageId = this.requestMessageId++;\n      const jsonrpcRequest = {\n        ...request,\n        jsonrpc: \"2.0\",\n        id: messageId\n      };\n      const cleanup = () => {\n        this.responseHandlers.delete(messageId);\n      };\n      this.responseHandlers.set(messageId, (response) => {\n        if (signal == null ? void 0 : signal.aborted) {\n          return reject(\n            new MCPClientError({\n              message: \"Request was aborted\",\n              cause: signal.reason\n            })\n          );\n        }\n        if (response instanceof Error) {\n          return reject(response);\n        }\n        try {\n          const result = resultSchema.parse(response.result);\n          resolve2(result);\n        } catch (error) {\n          const parseError = new MCPClientError({\n            message: \"Failed to parse server response\",\n            cause: error\n          });\n          reject(parseError);\n        }\n      });\n      this.transport.send(jsonrpcRequest).catch((error) => {\n        cleanup();\n        reject(error);\n      });\n    });\n  }\n  async listTools({\n    params,\n    options\n  } = {}) {\n    try {\n      return this.request({\n        request: { method: \"tools/list\", params },\n        resultSchema: ListToolsResultSchema,\n        options\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n  async callTool({\n    name: name17,\n    args,\n    options\n  }) {\n    try {\n      return this.request({\n        request: { method: \"tools/call\", params: { name: name17, arguments: args } },\n        resultSchema: CallToolResultSchema,\n        options: {\n          signal: options == null ? void 0 : options.abortSignal\n        }\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n  async notification(notification) {\n    const jsonrpcNotification = {\n      ...notification,\n      jsonrpc: \"2.0\"\n    };\n    await this.transport.send(jsonrpcNotification);\n  }\n  /**\n   * Returns a set of AI SDK tools from the MCP server\n   * @returns A record of tool names to their implementations\n   */\n  async tools({\n    schemas = \"automatic\"\n  } = {}) {\n    var _a17;\n    const tools = {};\n    try {\n      const listToolsResult = await this.listTools();\n      for (const { name: name17, description, inputSchema } of listToolsResult.tools) {\n        if (schemas !== \"automatic\" && !(name17 in schemas)) {\n          continue;\n        }\n        const self = this;\n        const execute = async (args, options) => {\n          var _a18;\n          (_a18 = options == null ? void 0 : options.abortSignal) == null ? void 0 : _a18.throwIfAborted();\n          return self.callTool({ name: name17, args, options });\n        };\n        const toolWithExecute = schemas === \"automatic\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.dynamicTool)({\n          description,\n          inputSchema: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.jsonSchema)({\n            ...inputSchema,\n            properties: (_a17 = inputSchema.properties) != null ? _a17 : {},\n            additionalProperties: false\n          }),\n          execute\n        }) : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.tool)({\n          description,\n          inputSchema: schemas[name17].inputSchema,\n          execute\n        });\n        tools[name17] = toolWithExecute;\n      }\n      return tools;\n    } catch (error) {\n      throw error;\n    }\n  }\n  onClose() {\n    if (this.isClosed)\n      return;\n    this.isClosed = true;\n    const error = new MCPClientError({\n      message: \"Connection closed\"\n    });\n    for (const handler of this.responseHandlers.values()) {\n      handler(error);\n    }\n    this.responseHandlers.clear();\n  }\n  onError(error) {\n    if (this.onUncaughtError) {\n      this.onUncaughtError(error);\n    }\n  }\n  onResponse(response) {\n    const messageId = Number(response.id);\n    const handler = this.responseHandlers.get(messageId);\n    if (handler === void 0) {\n      throw new MCPClientError({\n        message: `Protocol error: Received a response for an unknown message ID: ${JSON.stringify(\n          response\n        )}`\n      });\n    }\n    this.responseHandlers.delete(messageId);\n    handler(\n      \"result\" in response ? response : new MCPClientError({\n        message: response.error.message,\n        cause: response.error\n      })\n    );\n  }\n};\n\n// src/error/no-transcript-generated-error.ts\n\nvar NoTranscriptGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor(options) {\n    super({\n      name: \"AI_NoTranscriptGeneratedError\",\n      message: \"No transcript generated.\"\n    });\n    this.responses = options.responses;\n  }\n};\n\n// src/transcribe/transcribe.ts\nasync function transcribe({\n  model,\n  audio,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  if (model.specificationVersion !== \"v2\") {\n    throw new UnsupportedModelVersionError({\n      version: model.specificationVersion,\n      provider: model.provider,\n      modelId: model.modelId\n    });\n  }\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const audioData = audio instanceof URL ? (await download({ url: audio })).data : convertDataContentToUint8Array(audio);\n  const result = await retry(\n    () => {\n      var _a17;\n      return model.doGenerate({\n        audio: audioData,\n        abortSignal,\n        headers,\n        providerOptions,\n        mediaType: (_a17 = detectMediaType({\n          data: audioData,\n          signatures: audioMediaTypeSignatures\n        })) != null ? _a17 : \"audio/wav\"\n      });\n    }\n  );\n  logWarnings(result.warnings);\n  if (!result.text) {\n    throw new NoTranscriptGeneratedError({ responses: [result.response] });\n  }\n  return new DefaultTranscriptionResult({\n    text: result.text,\n    segments: result.segments,\n    language: result.language,\n    durationInSeconds: result.durationInSeconds,\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata\n  });\n}\nvar DefaultTranscriptionResult = class {\n  constructor(options) {\n    var _a17;\n    this.text = options.text;\n    this.segments = options.segments;\n    this.language = options.language;\n    this.durationInSeconds = options.durationInSeconds;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = (_a17 = options.providerMetadata) != null ? _a17 : {};\n  }\n};\n\n// src/ui/call-completion-api.ts\n\n\n// src/ui/process-text-stream.ts\nasync function processTextStream({\n  stream,\n  onTextPart\n}) {\n  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    await onTextPart(value);\n  }\n}\n\n// src/ui/call-completion-api.ts\nvar getOriginalFetch = () => fetch;\nasync function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = \"data\",\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onFinish,\n  onError,\n  fetch: fetch2 = getOriginalFetch()\n}) {\n  var _a17;\n  try {\n    setLoading(true);\n    setError(void 0);\n    const abortController = new AbortController();\n    setAbortController(abortController);\n    setCompletion(\"\");\n    const response = await fetch2(api, {\n      method: \"POST\",\n      body: JSON.stringify({\n        prompt,\n        ...body\n      }),\n      credentials,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      signal: abortController.signal\n    }).catch((err) => {\n      throw err;\n    });\n    if (!response.ok) {\n      throw new Error(\n        (_a17 = await response.text()) != null ? _a17 : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    let result = \"\";\n    switch (streamProtocol) {\n      case \"text\": {\n        await processTextStream({\n          stream: response.body,\n          onTextPart: (chunk) => {\n            result += chunk;\n            setCompletion(result);\n          }\n        });\n        break;\n      }\n      case \"data\": {\n        await consumeStream({\n          stream: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream)({\n            stream: response.body,\n            schema: uiMessageChunkSchema\n          }).pipeThrough(\n            new TransformStream({\n              async transform(part) {\n                if (!part.success) {\n                  throw part.error;\n                }\n                const streamPart = part.value;\n                if (streamPart.type === \"text-delta\") {\n                  result += streamPart.delta;\n                  setCompletion(result);\n                } else if (streamPart.type === \"error\") {\n                  throw new Error(streamPart.errorText);\n                }\n              }\n            })\n          ),\n          onError: (error) => {\n            throw error;\n          }\n        });\n        break;\n      }\n      default: {\n        const exhaustiveCheck = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n    }\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    if (err.name === \"AbortError\") {\n      setAbortController(null);\n      return null;\n    }\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n    setError(err);\n  } finally {\n    setLoading(false);\n  }\n}\n\n// src/ui/chat.ts\n\n\n// src/ui/convert-file-list-to-file-ui-parts.ts\nasync function convertFileListToFileUIParts(files) {\n  if (files == null) {\n    return [];\n  }\n  if (!globalThis.FileList || !(files instanceof globalThis.FileList)) {\n    throw new Error(\"FileList is not supported in the current environment\");\n  }\n  return Promise.all(\n    Array.from(files).map(async (file) => {\n      const { name: name17, type } = file;\n      const dataUrl = await new Promise((resolve2, reject) => {\n        const reader = new FileReader();\n        reader.onload = (readerEvent) => {\n          var _a17;\n          resolve2((_a17 = readerEvent.target) == null ? void 0 : _a17.result);\n        };\n        reader.onerror = (error) => reject(error);\n        reader.readAsDataURL(file);\n      });\n      return {\n        type: \"file\",\n        mediaType: type,\n        filename: name17,\n        url: dataUrl\n      };\n    })\n  );\n}\n\n// src/ui/default-chat-transport.ts\n\n\n// src/ui/http-chat-transport.ts\n\nvar HttpChatTransport = class {\n  constructor({\n    api = \"/api/chat\",\n    credentials,\n    headers,\n    body,\n    fetch: fetch2,\n    prepareSendMessagesRequest,\n    prepareReconnectToStreamRequest\n  }) {\n    this.api = api;\n    this.credentials = credentials;\n    this.headers = headers;\n    this.body = body;\n    this.fetch = fetch2;\n    this.prepareSendMessagesRequest = prepareSendMessagesRequest;\n    this.prepareReconnectToStreamRequest = prepareReconnectToStreamRequest;\n  }\n  async sendMessages({\n    abortSignal,\n    ...options\n  }) {\n    var _a17, _b, _c, _d, _e;\n    const resolvedBody = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.body);\n    const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.headers);\n    const resolvedCredentials = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.credentials);\n    const preparedRequest = await ((_a17 = this.prepareSendMessagesRequest) == null ? void 0 : _a17.call(this, {\n      api: this.api,\n      id: options.chatId,\n      messages: options.messages,\n      body: { ...resolvedBody, ...options.body },\n      headers: { ...resolvedHeaders, ...options.headers },\n      credentials: resolvedCredentials,\n      requestMetadata: options.metadata,\n      trigger: options.trigger,\n      messageId: options.messageId\n    }));\n    const api = (_b = preparedRequest == null ? void 0 : preparedRequest.api) != null ? _b : this.api;\n    const headers = (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? preparedRequest.headers : { ...resolvedHeaders, ...options.headers };\n    const body = (preparedRequest == null ? void 0 : preparedRequest.body) !== void 0 ? preparedRequest.body : {\n      ...resolvedBody,\n      ...options.body,\n      id: options.chatId,\n      messages: options.messages,\n      trigger: options.trigger,\n      messageId: options.messageId\n    };\n    const credentials = (_c = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _c : resolvedCredentials;\n    const fetch2 = (_d = this.fetch) != null ? _d : globalThis.fetch;\n    const response = await fetch2(api, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      body: JSON.stringify(body),\n      credentials,\n      signal: abortSignal\n    });\n    if (!response.ok) {\n      throw new Error(\n        (_e = await response.text()) != null ? _e : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    return this.processResponseStream(response.body);\n  }\n  async reconnectToStream(options) {\n    var _a17, _b, _c, _d, _e;\n    const resolvedBody = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.body);\n    const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.headers);\n    const resolvedCredentials = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.credentials);\n    const preparedRequest = await ((_a17 = this.prepareReconnectToStreamRequest) == null ? void 0 : _a17.call(this, {\n      api: this.api,\n      id: options.chatId,\n      body: { ...resolvedBody, ...options.body },\n      headers: { ...resolvedHeaders, ...options.headers },\n      credentials: resolvedCredentials,\n      requestMetadata: options.metadata\n    }));\n    const api = (_b = preparedRequest == null ? void 0 : preparedRequest.api) != null ? _b : `${this.api}/${options.chatId}/stream`;\n    const headers = (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? preparedRequest.headers : { ...resolvedHeaders, ...options.headers };\n    const credentials = (_c = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _c : resolvedCredentials;\n    const fetch2 = (_d = this.fetch) != null ? _d : globalThis.fetch;\n    const response = await fetch2(api, {\n      method: \"GET\",\n      headers,\n      credentials\n    });\n    if (response.status === 204) {\n      return null;\n    }\n    if (!response.ok) {\n      throw new Error(\n        (_e = await response.text()) != null ? _e : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    return this.processResponseStream(response.body);\n  }\n};\n\n// src/ui/default-chat-transport.ts\nvar DefaultChatTransport = class extends HttpChatTransport {\n  constructor(options = {}) {\n    super(options);\n  }\n  processResponseStream(stream) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream)({\n      stream,\n      schema: uiMessageChunkSchema\n    }).pipeThrough(\n      new TransformStream({\n        async transform(chunk, controller) {\n          if (!chunk.success) {\n            throw chunk.error;\n          }\n          controller.enqueue(chunk.value);\n        }\n      })\n    );\n  }\n};\n\n// src/ui/chat.ts\nvar AbstractChat = class {\n  constructor({\n    generateId: generateId3 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId,\n    id = generateId3(),\n    transport = new DefaultChatTransport(),\n    messageMetadataSchema,\n    dataPartSchemas,\n    state,\n    onError,\n    onToolCall,\n    onFinish,\n    onData,\n    sendAutomaticallyWhen\n  }) {\n    this.activeResponse = void 0;\n    this.jobExecutor = new SerialJobExecutor();\n    /**\n     * Appends or replaces a user message to the chat list. This triggers the API call to fetch\n     * the assistant's response.\n     *\n     * If a messageId is provided, the message will be replaced.\n     */\n    this.sendMessage = async (message, options) => {\n      var _a17, _b, _c, _d;\n      if (message == null) {\n        await this.makeRequest({\n          trigger: \"submit-message\",\n          messageId: (_a17 = this.lastMessage) == null ? void 0 : _a17.id,\n          ...options\n        });\n        return;\n      }\n      let uiMessage;\n      if (\"text\" in message || \"files\" in message) {\n        const fileParts = Array.isArray(message.files) ? message.files : await convertFileListToFileUIParts(message.files);\n        uiMessage = {\n          parts: [\n            ...fileParts,\n            ...\"text\" in message && message.text != null ? [{ type: \"text\", text: message.text }] : []\n          ]\n        };\n      } else {\n        uiMessage = message;\n      }\n      if (message.messageId != null) {\n        const messageIndex = this.state.messages.findIndex(\n          (m) => m.id === message.messageId\n        );\n        if (messageIndex === -1) {\n          throw new Error(`message with id ${message.messageId} not found`);\n        }\n        if (this.state.messages[messageIndex].role !== \"user\") {\n          throw new Error(\n            `message with id ${message.messageId} is not a user message`\n          );\n        }\n        this.state.messages = this.state.messages.slice(0, messageIndex + 1);\n        this.state.replaceMessage(messageIndex, {\n          ...uiMessage,\n          id: message.messageId,\n          role: (_b = uiMessage.role) != null ? _b : \"user\",\n          metadata: message.metadata\n        });\n      } else {\n        this.state.pushMessage({\n          ...uiMessage,\n          id: (_c = uiMessage.id) != null ? _c : this.generateId(),\n          role: (_d = uiMessage.role) != null ? _d : \"user\",\n          metadata: message.metadata\n        });\n      }\n      await this.makeRequest({\n        trigger: \"submit-message\",\n        messageId: message.messageId,\n        ...options\n      });\n    };\n    /**\n     * Regenerate the assistant message with the provided message id.\n     * If no message id is provided, the last assistant message will be regenerated.\n     */\n    this.regenerate = async ({\n      messageId,\n      ...options\n    } = {}) => {\n      const messageIndex = messageId == null ? this.state.messages.length - 1 : this.state.messages.findIndex((message) => message.id === messageId);\n      if (messageIndex === -1) {\n        throw new Error(`message ${messageId} not found`);\n      }\n      this.state.messages = this.state.messages.slice(\n        0,\n        // if the message is a user message, we need to include it in the request:\n        this.messages[messageIndex].role === \"assistant\" ? messageIndex : messageIndex + 1\n      );\n      await this.makeRequest({\n        trigger: \"regenerate-message\",\n        messageId,\n        ...options\n      });\n    };\n    /**\n     * Attempt to resume an ongoing streaming response.\n     */\n    this.resumeStream = async (options = {}) => {\n      await this.makeRequest({ trigger: \"resume-stream\", ...options });\n    };\n    /**\n     * Clear the error state and set the status to ready if the chat is in an error state.\n     */\n    this.clearError = () => {\n      if (this.status === \"error\") {\n        this.state.error = void 0;\n        this.setStatus({ status: \"ready\" });\n      }\n    };\n    this.addToolResult = async ({\n      tool: tool3,\n      toolCallId,\n      output\n    }) => this.jobExecutor.run(async () => {\n      var _a17, _b;\n      const messages = this.state.messages;\n      const lastMessage = messages[messages.length - 1];\n      this.state.replaceMessage(messages.length - 1, {\n        ...lastMessage,\n        parts: lastMessage.parts.map(\n          (part) => isToolOrDynamicToolUIPart(part) && part.toolCallId === toolCallId ? { ...part, state: \"output-available\", output } : part\n        )\n      });\n      if (this.activeResponse) {\n        this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(\n          (part) => isToolOrDynamicToolUIPart(part) && part.toolCallId === toolCallId ? {\n            ...part,\n            state: \"output-available\",\n            output,\n            errorText: void 0\n          } : part\n        );\n      }\n      if (this.status !== \"streaming\" && this.status !== \"submitted\" && ((_a17 = this.sendAutomaticallyWhen) == null ? void 0 : _a17.call(this, { messages: this.state.messages }))) {\n        this.makeRequest({\n          trigger: \"submit-message\",\n          messageId: (_b = this.lastMessage) == null ? void 0 : _b.id\n        });\n      }\n    });\n    /**\n     * Abort the current request immediately, keep the generated tokens if any.\n     */\n    this.stop = async () => {\n      var _a17;\n      if (this.status !== \"streaming\" && this.status !== \"submitted\")\n        return;\n      if ((_a17 = this.activeResponse) == null ? void 0 : _a17.abortController) {\n        this.activeResponse.abortController.abort();\n      }\n    };\n    this.id = id;\n    this.transport = transport;\n    this.generateId = generateId3;\n    this.messageMetadataSchema = messageMetadataSchema;\n    this.dataPartSchemas = dataPartSchemas;\n    this.state = state;\n    this.onError = onError;\n    this.onToolCall = onToolCall;\n    this.onFinish = onFinish;\n    this.onData = onData;\n    this.sendAutomaticallyWhen = sendAutomaticallyWhen;\n  }\n  /**\n   * Hook status:\n   *\n   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.\n   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.\n   * - `ready`: The full response has been received and processed; a new user message can be submitted.\n   * - `error`: An error occurred during the API request, preventing successful completion.\n   */\n  get status() {\n    return this.state.status;\n  }\n  setStatus({\n    status,\n    error\n  }) {\n    if (this.status === status)\n      return;\n    this.state.status = status;\n    this.state.error = error;\n  }\n  get error() {\n    return this.state.error;\n  }\n  get messages() {\n    return this.state.messages;\n  }\n  get lastMessage() {\n    return this.state.messages[this.state.messages.length - 1];\n  }\n  set messages(messages) {\n    this.state.messages = messages;\n  }\n  async makeRequest({\n    trigger,\n    metadata,\n    headers,\n    body,\n    messageId\n  }) {\n    var _a17, _b, _c;\n    this.setStatus({ status: \"submitted\", error: void 0 });\n    const lastMessage = this.lastMessage;\n    let isAbort = false;\n    let isDisconnect = false;\n    let isError = false;\n    try {\n      const activeResponse = {\n        state: createStreamingUIMessageState({\n          lastMessage: this.state.snapshot(lastMessage),\n          messageId: this.generateId()\n        }),\n        abortController: new AbortController()\n      };\n      activeResponse.abortController.signal.addEventListener(\"abort\", () => {\n        isAbort = true;\n      });\n      this.activeResponse = activeResponse;\n      let stream;\n      if (trigger === \"resume-stream\") {\n        const reconnect = await this.transport.reconnectToStream({\n          chatId: this.id,\n          metadata,\n          headers,\n          body\n        });\n        if (reconnect == null) {\n          this.setStatus({ status: \"ready\" });\n          return;\n        }\n        stream = reconnect;\n      } else {\n        stream = await this.transport.sendMessages({\n          chatId: this.id,\n          messages: this.state.messages,\n          abortSignal: activeResponse.abortController.signal,\n          metadata,\n          headers,\n          body,\n          trigger,\n          messageId\n        });\n      }\n      const runUpdateMessageJob = (job) => (\n        // serialize the job execution to avoid race conditions:\n        this.jobExecutor.run(\n          () => job({\n            state: activeResponse.state,\n            write: () => {\n              var _a18;\n              this.setStatus({ status: \"streaming\" });\n              const replaceLastMessage = activeResponse.state.message.id === ((_a18 = this.lastMessage) == null ? void 0 : _a18.id);\n              if (replaceLastMessage) {\n                this.state.replaceMessage(\n                  this.state.messages.length - 1,\n                  activeResponse.state.message\n                );\n              } else {\n                this.state.pushMessage(activeResponse.state.message);\n              }\n            }\n          })\n        )\n      );\n      await consumeStream({\n        stream: processUIMessageStream({\n          stream,\n          onToolCall: this.onToolCall,\n          onData: this.onData,\n          messageMetadataSchema: this.messageMetadataSchema,\n          dataPartSchemas: this.dataPartSchemas,\n          runUpdateMessageJob,\n          onError: (error) => {\n            throw error;\n          }\n        }),\n        onError: (error) => {\n          throw error;\n        }\n      });\n      this.setStatus({ status: \"ready\" });\n    } catch (err) {\n      if (isAbort || err.name === \"AbortError\") {\n        isAbort = true;\n        this.setStatus({ status: \"ready\" });\n        return null;\n      }\n      isError = true;\n      if (err instanceof TypeError && (err.message.toLowerCase().includes(\"fetch\") || err.message.toLowerCase().includes(\"network\"))) {\n        isDisconnect = true;\n      }\n      if (this.onError && err instanceof Error) {\n        this.onError(err);\n      }\n      this.setStatus({ status: \"error\", error: err });\n    } finally {\n      try {\n        (_a17 = this.onFinish) == null ? void 0 : _a17.call(this, {\n          message: this.activeResponse.state.message,\n          messages: this.state.messages,\n          isAbort,\n          isDisconnect,\n          isError\n        });\n      } catch (err) {\n        console.error(err);\n      }\n      this.activeResponse = void 0;\n    }\n    if ((_b = this.sendAutomaticallyWhen) == null ? void 0 : _b.call(this, { messages: this.state.messages })) {\n      await this.makeRequest({\n        trigger: \"submit-message\",\n        messageId: (_c = this.lastMessage) == null ? void 0 : _c.id,\n        metadata,\n        headers,\n        body\n      });\n    }\n  }\n};\n\n// src/ui/last-assistant-message-is-complete-with-tool-calls.ts\nfunction lastAssistantMessageIsCompleteWithToolCalls({\n  messages\n}) {\n  const message = messages[messages.length - 1];\n  if (!message) {\n    return false;\n  }\n  if (message.role !== \"assistant\") {\n    return false;\n  }\n  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {\n    return part.type === \"step-start\" ? index : lastIndex;\n  }, -1);\n  const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter(isToolOrDynamicToolUIPart);\n  return lastStepToolInvocations.length > 0 && lastStepToolInvocations.every((part) => part.state === \"output-available\");\n}\n\n// src/ui/transform-text-to-ui-message-stream.ts\nfunction transformTextToUiMessageStream({\n  stream\n}) {\n  return stream.pipeThrough(\n    new TransformStream({\n      start(controller) {\n        controller.enqueue({ type: \"start\" });\n        controller.enqueue({ type: \"start-step\" });\n        controller.enqueue({ type: \"text-start\", id: \"text-1\" });\n      },\n      async transform(part, controller) {\n        controller.enqueue({ type: \"text-delta\", id: \"text-1\", delta: part });\n      },\n      async flush(controller) {\n        controller.enqueue({ type: \"text-end\", id: \"text-1\" });\n        controller.enqueue({ type: \"finish-step\" });\n        controller.enqueue({ type: \"finish\" });\n      }\n    })\n  );\n}\n\n// src/ui/text-stream-chat-transport.ts\nvar TextStreamChatTransport = class extends HttpChatTransport {\n  constructor(options = {}) {\n    super(options);\n  }\n  processResponseStream(stream) {\n    return transformTextToUiMessageStream({\n      stream: stream.pipeThrough(new TextDecoderStream())\n    });\n  }\n};\n\n// src/ui/validate-ui-messages.ts\n\n\n\nvar textUIPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  state: zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\"streaming\", \"done\"]).optional(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar reasoningUIPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning\"),\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  state: zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\"streaming\", \"done\"]).optional(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar sourceUrlUIPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"source-url\"),\n  sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar sourceDocumentUIPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"source-document\"),\n  sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar fileUIPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file\"),\n  mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n  url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar stepStartUIPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"step-start\")\n});\nvar dataUIPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"data-\"),\n  id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n  data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown()\n});\nvar dynamicToolUIPartSchemas = [\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"input-streaming\"),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"input-available\"),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    callProviderMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-available\"),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    callProviderMetadata: providerMetadataSchema.optional(),\n    preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-error\"),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    callProviderMetadata: providerMetadataSchema.optional()\n  })\n];\nvar toolUIPartSchemas = [\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"input-streaming\"),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"input-available\"),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    callProviderMetadata: providerMetadataSchema.optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-available\"),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    callProviderMetadata: providerMetadataSchema.optional(),\n    preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n  }),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-error\"),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n    errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    callProviderMetadata: providerMetadataSchema.optional()\n  })\n];\nvar uiMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n  id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n  role: zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\"system\", \"user\", \"assistant\"]),\n  metadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional(),\n  parts: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n      textUIPartSchema,\n      reasoningUIPartSchema,\n      sourceUrlUIPartSchema,\n      sourceDocumentUIPartSchema,\n      fileUIPartSchema,\n      stepStartUIPartSchema,\n      dataUIPartSchema,\n      ...dynamicToolUIPartSchemas,\n      ...toolUIPartSchemas\n    ])\n  )\n});\nasync function validateUIMessages({\n  messages,\n  metadataSchema,\n  dataSchemas,\n  tools\n}) {\n  if (messages == null) {\n    throw new InvalidArgumentError({\n      parameter: \"messages\",\n      value: messages,\n      message: \"messages parameter must be provided\"\n    });\n  }\n  const validatedMessages = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n    value: messages,\n    schema: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(uiMessageSchema)\n  });\n  if (metadataSchema) {\n    for (const message of validatedMessages) {\n      await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n        value: message.metadata,\n        schema: metadataSchema\n      });\n    }\n  }\n  if (dataSchemas) {\n    for (const message of validatedMessages) {\n      const dataParts = message.parts.filter(\n        (part) => part.type.startsWith(\"data-\")\n      );\n      for (const dataPart of dataParts) {\n        const dataName = dataPart.type.slice(5);\n        const dataSchema = dataSchemas[dataName];\n        if (!dataSchema) {\n          throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value: dataPart.data,\n            cause: `No data schema found for data part ${dataName}`\n          });\n        }\n        await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n          value: dataPart.data,\n          schema: dataSchema\n        });\n      }\n    }\n  }\n  if (tools) {\n    for (const message of validatedMessages) {\n      const toolParts = message.parts.filter(\n        (part) => part.type.startsWith(\"tool-\")\n      );\n      for (const toolPart of toolParts) {\n        const toolName = toolPart.type.slice(5);\n        const tool3 = tools[toolName];\n        if (!tool3) {\n          throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value: toolPart.input,\n            cause: `No tool schema found for tool part ${toolName}`\n          });\n        }\n        if (toolPart.state === \"input-available\" || toolPart.state === \"output-available\" || toolPart.state === \"output-error\") {\n          await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n            value: toolPart.input,\n            schema: tool3.inputSchema\n          });\n        }\n        if (toolPart.state === \"output-available\" && tool3.outputSchema) {\n          await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n            value: toolPart.output,\n            schema: tool3.outputSchema\n          });\n        }\n      }\n    }\n  }\n  return validatedMessages;\n}\n\n// src/ui-message-stream/create-ui-message-stream.ts\n\nfunction createUIMessageStream({\n  execute,\n  onError = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage,\n  originalMessages,\n  onFinish,\n  generateId: generateId3 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId\n}) {\n  let controller;\n  const ongoingStreamPromises = [];\n  const stream = new ReadableStream({\n    start(controllerArg) {\n      controller = controllerArg;\n    }\n  });\n  function safeEnqueue(data) {\n    try {\n      controller.enqueue(data);\n    } catch (error) {\n    }\n  }\n  try {\n    const result = execute({\n      writer: {\n        write(part) {\n          safeEnqueue(part);\n        },\n        merge(streamArg) {\n          ongoingStreamPromises.push(\n            (async () => {\n              const reader = streamArg.getReader();\n              while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                  break;\n                safeEnqueue(value);\n              }\n            })().catch((error) => {\n              safeEnqueue({\n                type: \"error\",\n                errorText: onError(error)\n              });\n            })\n          );\n        },\n        onError\n      }\n    });\n    if (result) {\n      ongoingStreamPromises.push(\n        result.catch((error) => {\n          safeEnqueue({\n            type: \"error\",\n            errorText: onError(error)\n          });\n        })\n      );\n    }\n  } catch (error) {\n    safeEnqueue({\n      type: \"error\",\n      errorText: onError(error)\n    });\n  }\n  const waitForStreams = new Promise(async (resolve2) => {\n    while (ongoingStreamPromises.length > 0) {\n      await ongoingStreamPromises.shift();\n    }\n    resolve2();\n  });\n  waitForStreams.finally(() => {\n    try {\n      controller.close();\n    } catch (error) {\n    }\n  });\n  return handleUIMessageStreamFinish({\n    stream,\n    messageId: generateId3(),\n    originalMessages,\n    onFinish,\n    onError\n  });\n}\n\n// src/ui-message-stream/read-ui-message-stream.ts\nfunction readUIMessageStream({\n  message,\n  stream,\n  onError,\n  terminateOnError = false\n}) {\n  var _a17;\n  let controller;\n  let hasErrored = false;\n  const outputStream = new ReadableStream({\n    start(controllerParam) {\n      controller = controllerParam;\n    }\n  });\n  const state = createStreamingUIMessageState({\n    messageId: (_a17 = message == null ? void 0 : message.id) != null ? _a17 : \"\",\n    lastMessage: message\n  });\n  const handleError = (error) => {\n    onError == null ? void 0 : onError(error);\n    if (!hasErrored && terminateOnError) {\n      hasErrored = true;\n      controller == null ? void 0 : controller.error(error);\n    }\n  };\n  consumeStream({\n    stream: processUIMessageStream({\n      stream,\n      runUpdateMessageJob(job) {\n        return job({\n          state,\n          write: () => {\n            controller == null ? void 0 : controller.enqueue(structuredClone(state.message));\n          }\n        });\n      },\n      onError: handleError\n    }),\n    onError: handleError\n  }).finally(() => {\n    if (!hasErrored) {\n      controller == null ? void 0 : controller.close();\n    }\n  });\n  return createAsyncIterableStream(outputStream);\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9DQUFvQztBQUNwRTs7QUFFQTtBQUNxRTtBQVNyQzs7QUFFaEM7QUFLZ0M7O0FBRWhDO0FBQzhDO0FBQzlDO0FBQ0EsZ0NBQWdDLEtBQUs7QUFDckM7QUFDQTtBQUNBLDJDQUEyQyx3REFBVTtBQUNyRDtBQUNBLGdCQUFnQixtQ0FBbUMsSUFBSTtBQUN2RCxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3REFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRLE9BQU8sZ0JBQWdCO0FBQ3REO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVEsWUFBWSxTQUFTO0FBQ3BEO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRLEVBQUUsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUSxFQUFFLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMwQzs7QUFFMUM7QUFjMEI7O0FBRTFCO0FBQzZEO0FBQzdEO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBLHlDQUF5Qyx3REFBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usb0RBQU87QUFDN0U7O0FBRUE7QUFHZ0M7O0FBRWhDO0FBQ21FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUZBQXlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw0QkFBNEI7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEQ7QUFJOUI7QUFDTDs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qix5Q0FBTztBQUMvQixFQUFFLDBDQUFRO0FBQ1YsRUFBRSxpREFBWTtBQUNkLEVBQUUsaURBQVk7QUFDZCxFQUFFLDBDQUFRO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsWUFBWSw2Q0FBNkM7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFZO0FBQzVCO0FBQ0EsdURBQXVELG1CQUFtQjtBQUMxRSxPQUFPO0FBQ1A7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpRkFBeUI7QUFDcEM7QUFDQSxTQUFTLGlGQUF5QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUZBQTBCO0FBQ3ZDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0NBQXdDO0FBQzFFO0FBQ0EsbURBQW1ELDJCQUEyQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFDQUFxQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0JBQXdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsc0VBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQ7QUFDQSxVQUFVLHFEQUFxRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsNENBQTRDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2tEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0VBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBLEtBQUs7QUFDTCx1Q0FBdUMsZUFBZSxxQ0FBcUMsbUJBQW1CLElBQUk7QUFDbEg7QUFDQTs7QUFFQTtBQUM2RTtBQUNsQjtBQUMxQjs7QUFFakM7QUFDaUM7O0FBRWpDO0FBQ2lDOztBQUVqQztBQUNpQztBQUNqQyxzQkFBc0Isd0NBQU87QUFDN0IsUUFBUSx5Q0FBUTtBQUNoQixJQUFJLDJDQUFPO0FBQ1gsSUFBSSwwQ0FBUztBQUNiLElBQUksMENBQVM7QUFDYixJQUFJLDJDQUFVO0FBQ2QsSUFBSSwwQ0FBUyxDQUFDLDBDQUFTO0FBQ3ZCLElBQUkseUNBQVE7QUFDWjtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLDBDQUFTO0FBQ3RDLEVBQUUsMENBQVM7QUFDWCxFQUFFLDBDQUFTLENBQUMsMENBQVM7QUFDckI7O0FBRUE7QUFDaUM7QUFDakMscUJBQXFCLDBDQUFTO0FBQzlCLFFBQVEsMkNBQVU7QUFDbEIsUUFBUSwwQ0FBUztBQUNqQjtBQUNBLENBQUM7QUFDRCxzQkFBc0IsMENBQVM7QUFDL0IsUUFBUSwyQ0FBVTtBQUNsQixTQUFTLHlDQUFRLHFCQUFxQixpREFBYTtBQUNuRCxhQUFhLDBDQUFTO0FBQ3RCO0FBQ0EsQ0FBQztBQUNELHFCQUFxQiwwQ0FBUztBQUM5QixRQUFRLDJDQUFVO0FBQ2xCLFFBQVEseUNBQVEscUJBQXFCLGlEQUFhO0FBQ2xELFlBQVksMENBQVM7QUFDckIsYUFBYSwwQ0FBUztBQUN0QjtBQUNBLENBQUM7QUFDRCwwQkFBMEIsMENBQVM7QUFDbkMsUUFBUSwyQ0FBVTtBQUNsQixRQUFRLDBDQUFTO0FBQ2pCO0FBQ0EsQ0FBQztBQUNELHlCQUF5QiwwQ0FBUztBQUNsQyxRQUFRLDJDQUFVO0FBQ2xCLGNBQWMsMENBQVM7QUFDdkIsWUFBWSwwQ0FBUztBQUNyQixTQUFTLDJDQUFVO0FBQ25CO0FBQ0Esb0JBQW9CLDJDQUFVO0FBQzlCLENBQUM7QUFDRCxtQkFBbUIsc0RBQXFCO0FBQ3hDLEVBQUUsMENBQVM7QUFDWCxVQUFVLDJDQUFVO0FBQ3BCLFdBQVcsMENBQVM7QUFDcEIsR0FBRztBQUNILEVBQUUsMENBQVM7QUFDWCxVQUFVLDJDQUFVO0FBQ3BCO0FBQ0EsR0FBRztBQUNILEVBQUUsMENBQVM7QUFDWCxVQUFVLDJDQUFVO0FBQ3BCLFdBQVcsMENBQVM7QUFDcEIsR0FBRztBQUNILEVBQUUsMENBQVM7QUFDWCxVQUFVLDJDQUFVO0FBQ3BCO0FBQ0EsR0FBRztBQUNILEVBQUUsMENBQVM7QUFDWCxVQUFVLDJDQUFVO0FBQ3BCLFdBQVcseUNBQVE7QUFDbkIsTUFBTSx5Q0FBUTtBQUNkLFFBQVEsMENBQVM7QUFDakIsZ0JBQWdCLDJDQUFVO0FBQzFCLGdCQUFnQiwwQ0FBUztBQUN6QixTQUFTO0FBQ1QsUUFBUSwwQ0FBUztBQUNqQixnQkFBZ0IsMkNBQVU7QUFDMUIsZ0JBQWdCLDBDQUFTO0FBQ3pCLHFCQUFxQiwwQ0FBUztBQUM5QixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDJCQUEyQiwwQ0FBUztBQUNwQyxRQUFRLDJDQUFVO0FBQ2xCLGNBQWMsMENBQVM7QUFDdkIsWUFBWSwwQ0FBUztBQUNyQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLCtCQUErQiwwQ0FBUztBQUN4QztBQUNBLFVBQVUsMkNBQVU7QUFDcEIsYUFBYSwwQ0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwwQ0FBUztBQUN0QyxRQUFRLDJDQUFVO0FBQ2xCLFdBQVcseUNBQVE7QUFDbkIsSUFBSSwwQ0FBUztBQUNiLElBQUkseUNBQVEsQ0FBQyx5Q0FBUTtBQUNyQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0NBQWtDLDBDQUFTO0FBQzNDLFFBQVEsMkNBQVU7QUFDbEIsV0FBVyx5Q0FBUTtBQUNuQixJQUFJLDBDQUFTO0FBQ2IsSUFBSSx5Q0FBUTtBQUNaLE1BQU0seUNBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw2QkFBNkIsMENBQVM7QUFDdEMsUUFBUSwyQ0FBVTtBQUNsQixXQUFXLHlDQUFRO0FBQ25CO0FBQ0EsQ0FBQztBQUNEO0FBQ0EseUJBQXlCLHlDQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdFQUFtQjtBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLGdFQUFtQjtBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLGdFQUFtQjtBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQ0FBc0M7QUFDeEQsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLGNBQWMsZ0VBQW1CO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsZ0VBQW1CO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQ0FBaUMseUVBQWlCO0FBQ2xEO0FBQ0EsWUFBWSx5Q0FBUTtBQUNwQixHQUFHO0FBQ0g7QUFDQSxjQUFjLGdFQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSXlCO0FBQ3FDO0FBQzlEO0FBQ0EsTUFBTSx1RUFBMEIsc0JBQXNCLHNFQUF5QjtBQUMvRSxlQUFlLHdEQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHlCQUF5QixZQUFZLEVBQUUsa0VBQWtFLHFCQUFxQixPQUFPO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBLGtHQUFrRztBQUNsRztBQUNBLDRDQUE0QyxJQUFJO0FBQ2hEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBOztBQUVBO0FBQzJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxREFBSztBQUNkOztBQUVBO0FBQ29EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFlBQVksOERBQWM7QUFDMUI7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKLHFCQUFxQixNQUFNLDhEQUFjLFFBQVE7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsYUFBYTtBQUNiLEdBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2lFO0FBQ2lDO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLElBQUk7QUFDSixRQUFRLG9FQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUVBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVcsd0JBQXdCLGFBQWE7QUFDakY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGtDQUFrQywwREFBYTtBQUMvQyxZQUFZLDZEQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXLHNDQUFzQyxhQUFhO0FBQzdGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUlnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlGQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUZBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBS2dDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0NBQWtDLDZCQUE2QjtBQUMvRDtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDLG9CQUFvQixjQUFjO0FBQ2xDLG1CQUFtQixnRUFBUztBQUM1QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUNBQW1DO0FBQ3hFO0FBQ0EsSUFBSTtBQUNKLDhCQUE4QixxRUFBYSxHQUFHLHNCQUFzQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUJBQWlCLGdFQUFTO0FBQzFCLDJEQUEyRCx5RUFBa0IsR0FBRyxTQUFTLFVBQVUsVUFBVSxxRUFBYSxHQUFHLDhCQUE4QjtBQUMzSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwwRUFBMEUsT0FBTztBQUNqRjs7QUFFQTtBQUcwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGFBQWEsMkJBQTJCLGlFQUFnQjtBQUN4RCxJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDhCQUE4QixJQUFJO0FBQzFFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLHlFQUFpQjtBQUMxQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDBCQUEwQjtBQUNwRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtDQUErQztBQUNqRTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVFQUFnQjtBQUNyQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVCQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDJCQUEyQiw2QkFBNkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUVBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpQkFBaUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFHMEI7QUFJTTs7QUFFaEM7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3lFOztBQUV6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkVBQTJFLDREQUFlLDRCQUE0QixpRUFBb0I7QUFDMUk7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUF1R0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyaWFuc3Byb3VsZS9jb2RlLWV4cGxhaW5lci9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lMTcgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUxNywgeyBnZXQ6IGFsbFtuYW1lMTddLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBnYXRld2F5IGFzIGdhdGV3YXkyLCBjcmVhdGVHYXRld2F5IH0gZnJvbSBcIkBhaS1zZGsvZ2F0ZXdheVwiO1xuaW1wb3J0IHtcbiAgYXNTY2hlbWEgYXMgYXNTY2hlbWE1LFxuICBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjUsXG4gIGR5bmFtaWNUb29sIGFzIGR5bmFtaWNUb29sMixcbiAgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkMixcbiAganNvblNjaGVtYSBhcyBqc29uU2NoZW1hMixcbiAgdG9vbCBhcyB0b29sMixcbiAgem9kU2NoZW1hXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L2dlbmVyYXRlLXRleHQudHNcbmltcG9ydCB7XG4gIGNyZWF0ZUlkR2VuZXJhdG9yLFxuICBleGVjdXRlVG9vbCxcbiAgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTVcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL2Vycm9yL25vLW91dHB1dC1zcGVjaWZpZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUgPSBcIkFJX05vT3V0cHV0U3BlY2lmaWVkRXJyb3JcIjtcbnZhciBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBOb091dHB1dFNwZWNpZmllZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSA9IFwiTm8gb3V0cHV0IHNwZWNpZmllZC5cIiB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYV0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG59O1xuX2EgPSBzeW1ib2w7XG5cbi8vIHNyYy9sb2dnZXIvbG9nLXdhcm5pbmdzLnRzXG5mdW5jdGlvbiBmb3JtYXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgY29uc3QgcHJlZml4ID0gXCJBSSBTREsgV2FybmluZzpcIjtcbiAgc3dpdGNoICh3YXJuaW5nLnR5cGUpIHtcbiAgICBjYXNlIFwidW5zdXBwb3J0ZWQtc2V0dGluZ1wiOiB7XG4gICAgICBsZXQgbWVzc2FnZSA9IGAke3ByZWZpeH0gVGhlIFwiJHt3YXJuaW5nLnNldHRpbmd9XCIgc2V0dGluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgbW9kZWxgO1xuICAgICAgaWYgKHdhcm5pbmcuZGV0YWlscykge1xuICAgICAgICBtZXNzYWdlICs9IGAgLSAke3dhcm5pbmcuZGV0YWlsc31gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGNhc2UgXCJ1bnN1cHBvcnRlZC10b29sXCI6IHtcbiAgICAgIGNvbnN0IHRvb2xOYW1lID0gXCJuYW1lXCIgaW4gd2FybmluZy50b29sID8gd2FybmluZy50b29sLm5hbWUgOiBcInVua25vd24gdG9vbFwiO1xuICAgICAgbGV0IG1lc3NhZ2UgPSBgJHtwcmVmaXh9IFRoZSB0b29sIFwiJHt0b29sTmFtZX1cIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgbW9kZWxgO1xuICAgICAgaWYgKHdhcm5pbmcuZGV0YWlscykge1xuICAgICAgICBtZXNzYWdlICs9IGAgLSAke3dhcm5pbmcuZGV0YWlsc31gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGNhc2UgXCJvdGhlclwiOiB7XG4gICAgICByZXR1cm4gYCR7cHJlZml4fSAke3dhcm5pbmcubWVzc2FnZX1gO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gYCR7cHJlZml4fSAke0pTT04uc3RyaW5naWZ5KHdhcm5pbmcsIG51bGwsIDIpfWA7XG4gICAgfVxuICB9XG59XG52YXIgRklSU1RfV0FSTklOR19JTkZPX01FU1NBR0UgPSBcIkFJIFNESyBXYXJuaW5nIFN5c3RlbTogVG8gdHVybiBvZmYgd2FybmluZyBsb2dnaW5nLCBzZXQgdGhlIEFJX1NES19MT0dfV0FSTklOR1MgZ2xvYmFsIHRvIGZhbHNlLlwiO1xudmFyIGhhc0xvZ2dlZEJlZm9yZSA9IGZhbHNlO1xudmFyIGxvZ1dhcm5pbmdzID0gKHdhcm5pbmdzKSA9PiB7XG4gIGlmICh3YXJuaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbG9nZ2VyID0gZ2xvYmFsVGhpcy5BSV9TREtfTE9HX1dBUk5JTkdTO1xuICBpZiAobG9nZ2VyID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGxvZ2dlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgbG9nZ2VyKHdhcm5pbmdzKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFoYXNMb2dnZWRCZWZvcmUpIHtcbiAgICBoYXNMb2dnZWRCZWZvcmUgPSB0cnVlO1xuICAgIGNvbnNvbGUuaW5mbyhGSVJTVF9XQVJOSU5HX0lORk9fTUVTU0FHRSk7XG4gIH1cbiAgZm9yIChjb25zdCB3YXJuaW5nIG9mIHdhcm5pbmdzKSB7XG4gICAgY29uc29sZS53YXJuKGZvcm1hdFdhcm5pbmcod2FybmluZykpO1xuICB9XG59O1xuXG4vLyBzcmMvbW9kZWwvcmVzb2x2ZS1tb2RlbC50c1xuaW1wb3J0IHsgZ2F0ZXdheSB9IGZyb20gXCJAYWktc2RrL2dhdGV3YXlcIjtcblxuLy8gc3JjL2Vycm9yL2luZGV4LnRzXG5pbXBvcnQge1xuICBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxNyxcbiAgQVBJQ2FsbEVycm9yLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIHNyYy9lcnJvci9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMiA9IFwiQUlfSW52YWxpZEFyZ3VtZW50RXJyb3JcIjtcbnZhciBtYXJrZXIyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUyfWA7XG52YXIgc3ltYm9sMiA9IFN5bWJvbC5mb3IobWFya2VyMik7XG52YXIgX2EyO1xudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXJhbWV0ZXIsXG4gICAgdmFsdWUsXG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTIsXG4gICAgICBtZXNzYWdlOiBgSW52YWxpZCBhcmd1bWVudCBmb3IgcGFyYW1ldGVyICR7cGFyYW1ldGVyfTogJHttZXNzYWdlfWBcbiAgICB9KTtcbiAgICB0aGlzW19hMl0gPSB0cnVlO1xuICAgIHRoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMi5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjIpO1xuICB9XG59O1xuX2EyID0gc3ltYm9sMjtcblxuLy8gc3JjL2Vycm9yL2ludmFsaWQtc3RyZWFtLXBhcnQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUzID0gXCJBSV9JbnZhbGlkU3RyZWFtUGFydEVycm9yXCI7XG52YXIgbWFya2VyMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDMgPSBTeW1ib2wuZm9yKG1hcmtlcjMpO1xudmFyIF9hMztcbnZhciBJbnZhbGlkU3RyZWFtUGFydEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjaHVuayxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUzLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2EzXSA9IHRydWU7XG4gICAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IzLmhhc01hcmtlcihlcnJvciwgbWFya2VyMyk7XG4gIH1cbn07XG5fYTMgPSBzeW1ib2wzO1xuXG4vLyBzcmMvZXJyb3IvaW52YWxpZC10b29sLWlucHV0LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I0LCBnZXRFcnJvck1lc3NhZ2UgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU0ID0gXCJBSV9JbnZhbGlkVG9vbElucHV0RXJyb3JcIjtcbnZhciBtYXJrZXI0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU0fWA7XG52YXIgc3ltYm9sNCA9IFN5bWJvbC5mb3IobWFya2VyNCk7XG52YXIgX2E0O1xudmFyIEludmFsaWRUb29sSW5wdXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbElucHV0LFxuICAgIHRvb2xOYW1lLFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dCBmb3IgdG9vbCAke3Rvb2xOYW1lfTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTQsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E0XSA9IHRydWU7XG4gICAgdGhpcy50b29sSW5wdXQgPSB0b29sSW5wdXQ7XG4gICAgdGhpcy50b29sTmFtZSA9IHRvb2xOYW1lO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I0Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNCk7XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBzcmMvZXJyb3IvbWNwLWNsaWVudC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTUgPSBcIkFJX01DUENsaWVudEVycm9yXCI7XG52YXIgbWFya2VyNSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNX1gO1xudmFyIHN5bWJvbDUgPSBTeW1ib2wuZm9yKG1hcmtlcjUpO1xudmFyIF9hNTtcbnZhciBNQ1BDbGllbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbmFtZTogbmFtZTE3ID0gXCJNQ1BDbGllbnRFcnJvclwiLFxuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTE3LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I1Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNSk7XG4gIH1cbn07XG5fYTUgPSBzeW1ib2w1O1xuXG4vLyBzcmMvZXJyb3Ivbm8taW1hZ2UtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I2IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNiA9IFwiQUlfTm9JbWFnZUdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyNiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNn1gO1xudmFyIHN5bWJvbDYgPSBTeW1ib2wuZm9yKG1hcmtlcjYpO1xudmFyIF9hNjtcbnZhciBOb0ltYWdlR2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I2IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UgPSBcIk5vIGltYWdlIGdlbmVyYXRlZC5cIixcbiAgICBjYXVzZSxcbiAgICByZXNwb25zZXNcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTYsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E2XSA9IHRydWU7XG4gICAgdGhpcy5yZXNwb25zZXMgPSByZXNwb25zZXM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjYuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxufTtcbl9hNiA9IHN5bWJvbDY7XG5cbi8vIHNyYy9lcnJvci9uby1vYmplY3QtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I3IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNyA9IFwiQUlfTm9PYmplY3RHZW5lcmF0ZWRFcnJvclwiO1xudmFyIG1hcmtlcjcgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTd9YDtcbnZhciBzeW1ib2w3ID0gU3ltYm9sLmZvcihtYXJrZXI3KTtcbnZhciBfYTc7XG52YXIgTm9PYmplY3RHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjcge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gb2JqZWN0IGdlbmVyYXRlZC5cIixcbiAgICBjYXVzZSxcbiAgICB0ZXh0OiB0ZXh0MixcbiAgICByZXNwb25zZSxcbiAgICB1c2FnZSxcbiAgICBmaW5pc2hSZWFzb25cbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTcsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E3XSA9IHRydWU7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDI7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMudXNhZ2UgPSB1c2FnZTtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IGZpbmlzaFJlYXNvbjtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNy5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjcpO1xuICB9XG59O1xuX2E3ID0gc3ltYm9sNztcblxuLy8gc3JjL2Vycm9yL25vLW91dHB1dC1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjggfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU4ID0gXCJBSV9Ob091dHB1dEdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyOCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOH1gO1xudmFyIHN5bWJvbDggPSBTeW1ib2wuZm9yKG1hcmtlcjgpO1xudmFyIF9hODtcbnZhciBOb091dHB1dEdlbmVyYXRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yOCB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gb3V0cHV0IGdlbmVyYXRlZC5cIixcbiAgICBjYXVzZVxuICB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU4LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hOF0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I4Lmhhc01hcmtlcihlcnJvciwgbWFya2VyOCk7XG4gIH1cbn07XG5fYTggPSBzeW1ib2w4O1xuXG4vLyBzcmMvZXJyb3Ivbm8tc3VjaC10b29sLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lOSA9IFwiQUlfTm9TdWNoVG9vbEVycm9yXCI7XG52YXIgbWFya2VyOSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOX1gO1xudmFyIHN5bWJvbDkgPSBTeW1ib2wuZm9yKG1hcmtlcjkpO1xudmFyIF9hOTtcbnZhciBOb1N1Y2hUb29sRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRvb2xOYW1lLFxuICAgIGF2YWlsYWJsZVRvb2xzID0gdm9pZCAwLFxuICAgIG1lc3NhZ2UgPSBgTW9kZWwgdHJpZWQgdG8gY2FsbCB1bmF2YWlsYWJsZSB0b29sICcke3Rvb2xOYW1lfScuICR7YXZhaWxhYmxlVG9vbHMgPT09IHZvaWQgMCA/IFwiTm8gdG9vbHMgYXJlIGF2YWlsYWJsZS5cIiA6IGBBdmFpbGFibGUgdG9vbHM6ICR7YXZhaWxhYmxlVG9vbHMuam9pbihcIiwgXCIpfS5gfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTksIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTldID0gdHJ1ZTtcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gICAgdGhpcy5hdmFpbGFibGVUb29scyA9IGF2YWlsYWJsZVRvb2xzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I5Lmhhc01hcmtlcihlcnJvciwgbWFya2VyOSk7XG4gIH1cbn07XG5fYTkgPSBzeW1ib2w5O1xuXG4vLyBzcmMvZXJyb3IvdG9vbC1jYWxsLXJlcGFpci1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTAsIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2UyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTAgPSBcIkFJX1Rvb2xDYWxsUmVwYWlyRXJyb3JcIjtcbnZhciBtYXJrZXIxMCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTB9YDtcbnZhciBzeW1ib2wxMCA9IFN5bWJvbC5mb3IobWFya2VyMTApO1xudmFyIF9hMTA7XG52YXIgVG9vbENhbGxSZXBhaXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjEwIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNhdXNlLFxuICAgIG9yaWdpbmFsRXJyb3IsXG4gICAgbWVzc2FnZSA9IGBFcnJvciByZXBhaXJpbmcgdG9vbCBjYWxsOiAke2dldEVycm9yTWVzc2FnZTIoY2F1c2UpfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTEwLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMTBdID0gdHJ1ZTtcbiAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEwKTtcbiAgfVxufTtcbl9hMTAgPSBzeW1ib2wxMDtcblxuLy8gc3JjL2Vycm9yL3Vuc3VwcG9ydGVkLW1vZGVsLXZlcnNpb24tZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjExIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBVbnN1cHBvcnRlZE1vZGVsVmVyc2lvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTEge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJBSV9VbnN1cHBvcnRlZE1vZGVsVmVyc2lvbkVycm9yXCIsXG4gICAgICBtZXNzYWdlOiBgVW5zdXBwb3J0ZWQgbW9kZWwgdmVyc2lvbiAke29wdGlvbnMudmVyc2lvbn0gZm9yIHByb3ZpZGVyIFwiJHtvcHRpb25zLnByb3ZpZGVyfVwiIGFuZCBtb2RlbCBcIiR7b3B0aW9ucy5tb2RlbElkfVwiLiBBSSBTREsgNSBvbmx5IHN1cHBvcnRzIG1vZGVscyB0aGF0IGltcGxlbWVudCBzcGVjaWZpY2F0aW9uIHZlcnNpb24gXCJ2MlwiLmBcbiAgICB9KTtcbiAgICB0aGlzLnZlcnNpb24gPSBvcHRpb25zLnZlcnNpb247XG4gICAgdGhpcy5wcm92aWRlciA9IG9wdGlvbnMucHJvdmlkZXI7XG4gICAgdGhpcy5tb2RlbElkID0gb3B0aW9ucy5tb2RlbElkO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvbXB0L2ludmFsaWQtZGF0YS1jb250ZW50LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTExID0gXCJBSV9JbnZhbGlkRGF0YUNvbnRlbnRFcnJvclwiO1xudmFyIG1hcmtlcjExID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMX1gO1xudmFyIHN5bWJvbDExID0gU3ltYm9sLmZvcihtYXJrZXIxMSk7XG52YXIgX2ExMTtcbnZhciBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjEyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRlbnQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGEgY29udGVudC4gRXhwZWN0ZWQgYSBiYXNlNjQgc3RyaW5nLCBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciwgb3IgQnVmZmVyLCBidXQgZ290ICR7dHlwZW9mIGNvbnRlbnR9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTExLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMTFdID0gdHJ1ZTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMi5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjExKTtcbiAgfVxufTtcbl9hMTEgPSBzeW1ib2wxMTtcblxuLy8gc3JjL3Byb21wdC9pbnZhbGlkLW1lc3NhZ2Utcm9sZS1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxMiA9IFwiQUlfSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3JcIjtcbnZhciBtYXJrZXIxMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTJ9YDtcbnZhciBzeW1ib2wxMiA9IFN5bWJvbC5mb3IobWFya2VyMTIpO1xudmFyIF9hMTI7XG52YXIgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxMyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByb2xlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBtZXNzYWdlIHJvbGU6ICcke3JvbGV9Jy4gTXVzdCBiZSBvbmUgb2Y6IFwic3lzdGVtXCIsIFwidXNlclwiLCBcImFzc2lzdGFudFwiLCBcInRvb2xcIi5gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxMiwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTJdID0gdHJ1ZTtcbiAgICB0aGlzLnJvbGUgPSByb2xlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMy5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEyKTtcbiAgfVxufTtcbl9hMTIgPSBzeW1ib2wxMjtcblxuLy8gc3JjL3Byb21wdC9tZXNzYWdlLWNvbnZlcnNpb24tZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE0IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTMgPSBcIkFJX01lc3NhZ2VDb252ZXJzaW9uRXJyb3JcIjtcbnZhciBtYXJrZXIxMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTN9YDtcbnZhciBzeW1ib2wxMyA9IFN5bWJvbC5mb3IobWFya2VyMTMpO1xudmFyIF9hMTM7XG52YXIgTWVzc2FnZUNvbnZlcnNpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjE0IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG9yaWdpbmFsTWVzc2FnZSxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxMywgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTNdID0gdHJ1ZTtcbiAgICB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IG9yaWdpbmFsTWVzc2FnZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTQuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMyk7XG4gIH1cbn07XG5fYTEzID0gc3ltYm9sMTM7XG5cbi8vIHNyYy91dGlsL2Rvd25sb2FkL2Rvd25sb2FkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxNSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTE0ID0gXCJBSV9Eb3dubG9hZEVycm9yXCI7XG52YXIgbWFya2VyMTQgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTE0fWA7XG52YXIgc3ltYm9sMTQgPSBTeW1ib2wuZm9yKG1hcmtlcjE0KTtcbnZhciBfYTE0O1xudmFyIERvd25sb2FkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxNSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgc3RhdHVzQ29kZSxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBjYXVzZSA9PSBudWxsID8gYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH06ICR7c3RhdHVzQ29kZX0gJHtzdGF0dXNUZXh0fWAgOiBgRmFpbGVkIHRvIGRvd25sb2FkICR7dXJsfTogJHtjYXVzZX1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxNCwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTE0XSA9IHRydWU7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxNS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE0KTtcbiAgfVxufTtcbl9hMTQgPSBzeW1ib2wxNDtcblxuLy8gc3JjL3V0aWwvcmV0cnktZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE2IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTUgPSBcIkFJX1JldHJ5RXJyb3JcIjtcbnZhciBtYXJrZXIxNSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTV9YDtcbnZhciBzeW1ib2wxNSA9IFN5bWJvbC5mb3IobWFya2VyMTUpO1xudmFyIF9hMTU7XG52YXIgUmV0cnlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjE2IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgcmVhc29uLFxuICAgIGVycm9yc1xuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE1XSA9IHRydWU7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5sYXN0RXJyb3IgPSBlcnJvcnNbZXJyb3JzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxNi5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE1KTtcbiAgfVxufTtcbl9hMTUgPSBzeW1ib2wxNTtcblxuLy8gc3JjL21vZGVsL3Jlc29sdmUtbW9kZWwudHNcbmZ1bmN0aW9uIHJlc29sdmVMYW5ndWFnZU1vZGVsKG1vZGVsKSB7XG4gIGlmICh0eXBlb2YgbW9kZWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjJcIikge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3Ioe1xuICAgICAgICB2ZXJzaW9uOiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbixcbiAgICAgICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHJldHVybiBnZXRHbG9iYWxQcm92aWRlcigpLmxhbmd1YWdlTW9kZWwobW9kZWwpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVtYmVkZGluZ01vZGVsKG1vZGVsKSB7XG4gIGlmICh0eXBlb2YgbW9kZWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjJcIikge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3Ioe1xuICAgICAgICB2ZXJzaW9uOiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbixcbiAgICAgICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHJldHVybiBnZXRHbG9iYWxQcm92aWRlcigpLnRleHRFbWJlZGRpbmdNb2RlbChcbiAgICBtb2RlbFxuICApO1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsUHJvdmlkZXIoKSB7XG4gIHZhciBfYTE3O1xuICByZXR1cm4gKF9hMTcgPSBnbG9iYWxUaGlzLkFJX1NES19ERUZBVUxUX1BST1ZJREVSKSAhPSBudWxsID8gX2ExNyA6IGdhdGV3YXk7XG59XG5cbi8vIHNyYy9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQudHNcbmltcG9ydCB7XG4gIGlzVXJsU3VwcG9ydGVkXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91dGlsL2RldGVjdC1tZWRpYS10eXBlLnRzXG5pbXBvcnQgeyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbnZhciBpbWFnZU1lZGlhVHlwZVNpZ25hdHVyZXMgPSBbXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvZ2lmXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs3MSwgNzMsIDcwXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiUjBsR1wiXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvcG5nXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsxMzcsIDgwLCA3OCwgNzFdLFxuICAgIGJhc2U2NFByZWZpeDogXCJpVkJPUndcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2pwZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjE2XSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiLzlqL1wiXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2Uvd2VicFwiLFxuICAgIGJ5dGVzUHJlZml4OiBbODIsIDczLCA3MCwgNzBdLFxuICAgIGJhc2U2NFByZWZpeDogXCJVa2xHUmdcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2JtcFwiLFxuICAgIGJ5dGVzUHJlZml4OiBbNjYsIDc3XSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiUWtcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL3RpZmZcIixcbiAgICBieXRlc1ByZWZpeDogWzczLCA3MywgNDIsIDBdLFxuICAgIGJhc2U2NFByZWZpeDogXCJTVWtxQUFcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL3RpZmZcIixcbiAgICBieXRlc1ByZWZpeDogWzc3LCA3NywgMCwgNDJdLFxuICAgIGJhc2U2NFByZWZpeDogXCJUVTBBS2dcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2F2aWZcIixcbiAgICBieXRlc1ByZWZpeDogW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMzIsXG4gICAgICAxMDIsXG4gICAgICAxMTYsXG4gICAgICAxMjEsXG4gICAgICAxMTIsXG4gICAgICA5NyxcbiAgICAgIDExOCxcbiAgICAgIDEwNSxcbiAgICAgIDEwMlxuICAgIF0sXG4gICAgYmFzZTY0UHJlZml4OiBcIkFBQUFJR1owZVhCaGRtbG1cIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2hlaWNcIixcbiAgICBieXRlc1ByZWZpeDogW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMzIsXG4gICAgICAxMDIsXG4gICAgICAxMTYsXG4gICAgICAxMjEsXG4gICAgICAxMTIsXG4gICAgICAxMDQsXG4gICAgICAxMDEsXG4gICAgICAxMDUsXG4gICAgICA5OVxuICAgIF0sXG4gICAgYmFzZTY0UHJlZml4OiBcIkFBQUFJR1owZVhCb1pXbGpcIlxuICB9XG5dO1xudmFyIGF1ZGlvTWVkaWFUeXBlU2lnbmF0dXJlcyA9IFtcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9tcGVnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNTUsIDI1MV0sXG4gICAgYmFzZTY0UHJlZml4OiBcIi8vcz1cIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjUwXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiLy9vPVwiXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vbXBlZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMjU1LCAyNDNdLFxuICAgIGJhc2U2NFByZWZpeDogXCIvL009XCJcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9tcGVnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNTUsIDI0Ml0sXG4gICAgYmFzZTY0UHJlZml4OiBcIi8vST1cIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjI3XSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiLytNPVwiXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vbXBlZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMjU1LCAyMjZdLFxuICAgIGJhc2U2NFByZWZpeDogXCIvK0k9XCJcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby93YXZcIixcbiAgICBieXRlc1ByZWZpeDogWzgyLCA3MywgNzAsIDcwXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiVWtsR1JcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL29nZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbNzksIDEwMywgMTAzLCA4M10sXG4gICAgYmFzZTY0UHJlZml4OiBcIlQyZG5Vd1wiXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vZmxhY1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMTAyLCA3NiwgOTcsIDY3XSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiWmt4aFF3XCJcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9hYWNcIixcbiAgICBieXRlc1ByZWZpeDogWzY0LCAyMSwgMCwgMF0sXG4gICAgYmFzZTY0UHJlZml4OiBcIlFCVUFcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wNFwiLFxuICAgIGJ5dGVzUHJlZml4OiBbMTAyLCAxMTYsIDEyMSwgMTEyXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiWm5SNWNBXCJcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby93ZWJtXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNiwgNjksIDIyMywgMTYzXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiR2tYZlwiXG4gIH1cbl07XG52YXIgc3RyaXBJRDMgPSAoZGF0YSkgPT4ge1xuICBjb25zdCBieXRlcyA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gY29udmVydEJhc2U2NFRvVWludDhBcnJheShkYXRhKSA6IGRhdGE7XG4gIGNvbnN0IGlkM1NpemUgPSAoYnl0ZXNbNl0gJiAxMjcpIDw8IDIxIHwgKGJ5dGVzWzddICYgMTI3KSA8PCAxNCB8IChieXRlc1s4XSAmIDEyNykgPDwgNyB8IGJ5dGVzWzldICYgMTI3O1xuICByZXR1cm4gYnl0ZXMuc2xpY2UoaWQzU2l6ZSArIDEwKTtcbn07XG5mdW5jdGlvbiBzdHJpcElEM1RhZ3NJZlByZXNlbnQoZGF0YSkge1xuICBjb25zdCBoYXNJZDMgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhLnN0YXJ0c1dpdGgoXCJTVVF6XCIpIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICYmIGRhdGEubGVuZ3RoID4gMTAgJiYgZGF0YVswXSA9PT0gNzMgJiYgLy8gJ0knXG4gIGRhdGFbMV0gPT09IDY4ICYmIC8vICdEJ1xuICBkYXRhWzJdID09PSA1MTtcbiAgcmV0dXJuIGhhc0lkMyA/IHN0cmlwSUQzKGRhdGEpIDogZGF0YTtcbn1cbmZ1bmN0aW9uIGRldGVjdE1lZGlhVHlwZSh7XG4gIGRhdGEsXG4gIHNpZ25hdHVyZXNcbn0pIHtcbiAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHN0cmlwSUQzVGFnc0lmUHJlc2VudChkYXRhKTtcbiAgZm9yIChjb25zdCBzaWduYXR1cmUgb2Ygc2lnbmF0dXJlcykge1xuICAgIGlmICh0eXBlb2YgcHJvY2Vzc2VkRGF0YSA9PT0gXCJzdHJpbmdcIiA/IHByb2Nlc3NlZERhdGEuc3RhcnRzV2l0aChzaWduYXR1cmUuYmFzZTY0UHJlZml4KSA6IHByb2Nlc3NlZERhdGEubGVuZ3RoID49IHNpZ25hdHVyZS5ieXRlc1ByZWZpeC5sZW5ndGggJiYgc2lnbmF0dXJlLmJ5dGVzUHJlZml4LmV2ZXJ5KFxuICAgICAgKGJ5dGUsIGluZGV4KSA9PiBwcm9jZXNzZWREYXRhW2luZGV4XSA9PT0gYnl0ZVxuICAgICkpIHtcbiAgICAgIHJldHVybiBzaWduYXR1cmUubWVkaWFUeXBlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBzcmMvdXRpbC9kb3dubG9hZC9kb3dubG9hZC50c1xudmFyIGRvd25sb2FkID0gYXN5bmMgKHsgdXJsIH0pID0+IHtcbiAgdmFyIF9hMTc7XG4gIGNvbnN0IHVybFRleHQgPSB1cmwudG9TdHJpbmcoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybFRleHQpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBEb3dubG9hZEVycm9yKHtcbiAgICAgICAgdXJsOiB1cmxUZXh0LFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogbmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSksXG4gICAgICBtZWRpYVR5cGU6IChfYTE3ID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikpICE9IG51bGwgPyBfYTE3IDogdm9pZCAwXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoRG93bmxvYWRFcnJvci5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBEb3dubG9hZEVycm9yKHsgdXJsOiB1cmxUZXh0LCBjYXVzZTogZXJyb3IgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlsL2Rvd25sb2FkL2Rvd25sb2FkLWZ1bmN0aW9uLnRzXG52YXIgY3JlYXRlRGVmYXVsdERvd25sb2FkRnVuY3Rpb24gPSAoZG93bmxvYWQyID0gZG93bmxvYWQpID0+IChyZXF1ZXN0ZWREb3dubG9hZHMpID0+IFByb21pc2UuYWxsKFxuICByZXF1ZXN0ZWREb3dubG9hZHMubWFwKFxuICAgIGFzeW5jIChyZXF1ZXN0ZWREb3dubG9hZCkgPT4gcmVxdWVzdGVkRG93bmxvYWQuaXNVcmxTdXBwb3J0ZWRCeU1vZGVsID8gbnVsbCA6IGRvd25sb2FkMihyZXF1ZXN0ZWREb3dubG9hZClcbiAgKVxuKTtcblxuLy8gc3JjL3Byb21wdC9kYXRhLWNvbnRlbnQudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE4IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkgYXMgY29udmVydEJhc2U2NFRvVWludDhBcnJheTIsXG4gIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kL3Y0XCI7XG5cbi8vIHNyYy9wcm9tcHQvc3BsaXQtZGF0YS11cmwudHNcbmZ1bmN0aW9uIHNwbGl0RGF0YVVybChkYXRhVXJsKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBkYXRhVXJsLnNwbGl0KFwiLFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWVkaWFUeXBlOiBoZWFkZXIuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiOlwiKVsxXSxcbiAgICAgIGJhc2U2NENvbnRlbnRcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBtZWRpYVR5cGU6IHZvaWQgMCxcbiAgICAgIGJhc2U2NENvbnRlbnQ6IHZvaWQgMFxuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3Byb21wdC9kYXRhLWNvbnRlbnQudHNcbnZhciBkYXRhQ29udGVudFNjaGVtYSA9IHoudW5pb24oW1xuICB6LnN0cmluZygpLFxuICB6Lmluc3RhbmNlb2YoVWludDhBcnJheSksXG4gIHouaW5zdGFuY2VvZihBcnJheUJ1ZmZlciksXG4gIHouY3VzdG9tKFxuICAgIC8vIEJ1ZmZlciBtaWdodCBub3QgYmUgYXZhaWxhYmxlIGluIHNvbWUgZW52aXJvbm1lbnRzIHN1Y2ggYXMgQ2xvdWRGbGFyZTpcbiAgICAodmFsdWUpID0+IHtcbiAgICAgIHZhciBfYTE3LCBfYjtcbiAgICAgIHJldHVybiAoX2IgPSAoX2ExNyA9IGdsb2JhbFRoaXMuQnVmZmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5pc0J1ZmZlcih2YWx1ZSkpICE9IG51bGwgPyBfYiA6IGZhbHNlO1xuICAgIH0sXG4gICAgeyBtZXNzYWdlOiBcIk11c3QgYmUgYSBCdWZmZXJcIiB9XG4gIClcbl0pO1xuZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFYyRGF0YUNvbnRlbnQoY29udGVudCkge1xuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4geyBkYXRhOiBjb250ZW50LCBtZWRpYVR5cGU6IHZvaWQgMCB9O1xuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4geyBkYXRhOiBuZXcgVWludDhBcnJheShjb250ZW50KSwgbWVkaWFUeXBlOiB2b2lkIDAgfTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgY29udGVudCA9IG5ldyBVUkwoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVUkwgJiYgY29udGVudC5wcm90b2NvbCA9PT0gXCJkYXRhOlwiKSB7XG4gICAgY29uc3QgeyBtZWRpYVR5cGU6IGRhdGFVcmxNZWRpYVR5cGUsIGJhc2U2NENvbnRlbnQgfSA9IHNwbGl0RGF0YVVybChcbiAgICAgIGNvbnRlbnQudG9TdHJpbmcoKVxuICAgICk7XG4gICAgaWYgKGRhdGFVcmxNZWRpYVR5cGUgPT0gbnVsbCB8fCBiYXNlNjRDb250ZW50ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBBSVNES0Vycm9yMTgoe1xuICAgICAgICBuYW1lOiBcIkludmFsaWREYXRhQ29udGVudEVycm9yXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdCBpbiBjb250ZW50ICR7Y29udGVudC50b1N0cmluZygpfWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXRhOiBiYXNlNjRDb250ZW50LCBtZWRpYVR5cGU6IGRhdGFVcmxNZWRpYVR5cGUgfTtcbiAgfVxuICByZXR1cm4geyBkYXRhOiBjb250ZW50LCBtZWRpYVR5cGU6IHZvaWQgMCB9O1xufVxuZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmcoY29udGVudCkge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQobmV3IFVpbnQ4QXJyYXkoY29udGVudCkpO1xuICB9XG4gIHJldHVybiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5Mihjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIGRhdGEgY29udGVudC4gQ29udGVudCBzdHJpbmcgaXMgbm90IGEgYmFzZTY0LWVuY29kZWQgbWVkaWEuXCIsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY29udGVudCk7XG4gIH1cbiAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHsgY29udGVudCB9KTtcbn1cblxuLy8gc3JjL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50c1xuYXN5bmMgZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gIHByb21wdCxcbiAgc3VwcG9ydGVkVXJscyxcbiAgZG93bmxvYWQ6IGRvd25sb2FkMiA9IGNyZWF0ZURlZmF1bHREb3dubG9hZEZ1bmN0aW9uKClcbn0pIHtcbiAgY29uc3QgZG93bmxvYWRlZEFzc2V0cyA9IGF3YWl0IGRvd25sb2FkQXNzZXRzKFxuICAgIHByb21wdC5tZXNzYWdlcyxcbiAgICBkb3dubG9hZDIsXG4gICAgc3VwcG9ydGVkVXJsc1xuICApO1xuICByZXR1cm4gW1xuICAgIC4uLnByb21wdC5zeXN0ZW0gIT0gbnVsbCA/IFt7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IHByb21wdC5zeXN0ZW0gfV0gOiBbXSxcbiAgICAuLi5wcm9tcHQubWVzc2FnZXMubWFwKFxuICAgICAgKG1lc3NhZ2UpID0+IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKHsgbWVzc2FnZSwgZG93bmxvYWRlZEFzc2V0cyB9KVxuICAgIClcbiAgXTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKHtcbiAgbWVzc2FnZSxcbiAgZG93bmxvYWRlZEFzc2V0c1xufSkge1xuICBjb25zdCByb2xlID0gbWVzc2FnZS5yb2xlO1xuICBzd2l0Y2ggKHJvbGUpIHtcbiAgICBjYXNlIFwic3lzdGVtXCI6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBtZXNzYWdlLnByb3ZpZGVyT3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogbWVzc2FnZS5wcm92aWRlck9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQubWFwKChwYXJ0KSA9PiBjb252ZXJ0UGFydFRvTGFuZ3VhZ2VNb2RlbFBhcnQocGFydCwgZG93bmxvYWRlZEFzc2V0cykpLmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlICE9PSBcInRleHRcIiB8fCBwYXJ0LnRleHQgIT09IFwiXCIpLFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogbWVzc2FnZS5wcm92aWRlck9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5maWx0ZXIoXG4gICAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IHRleHQgcGFydHM6XG4gICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJ0ZXh0XCIgfHwgcGFydC50ZXh0ICE9PSBcIlwiXG4gICAgICAgICkubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgY29uc3QgcHJvdmlkZXJPcHRpb25zID0gcGFydC5wcm92aWRlck9wdGlvbnM7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBtZWRpYVR5cGUgfSA9IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxWMkRhdGFDb250ZW50KFxuICAgICAgICAgICAgICAgIHBhcnQuZGF0YVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHBhcnQuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgbWVkaWFUeXBlOiBtZWRpYVR5cGUgIT0gbnVsbCA/IG1lZGlhVHlwZSA6IHBhcnQubWVkaWFUeXBlLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZ1wiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnQuaW5wdXQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogcGFydC5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIG91dHB1dDogcGFydC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBtZXNzYWdlLnByb3ZpZGVyT3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoKHBhcnQpID0+ICh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICBvdXRwdXQ6IHBhcnQub3V0cHV0LFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck9wdGlvbnNcbiAgICAgICAgfSkpLFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcm9sZTtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcih7IHJvbGU6IF9leGhhdXN0aXZlQ2hlY2sgfSk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEFzc2V0cyhtZXNzYWdlcywgZG93bmxvYWQyLCBzdXBwb3J0ZWRVcmxzKSB7XG4gIGNvbnN0IHBsYW5uZWREb3dubG9hZHMgPSBtZXNzYWdlcy5maWx0ZXIoKG1lc3NhZ2UpID0+IG1lc3NhZ2Uucm9sZSA9PT0gXCJ1c2VyXCIpLm1hcCgobWVzc2FnZSkgPT4gbWVzc2FnZS5jb250ZW50KS5maWx0ZXIoXG4gICAgKGNvbnRlbnQpID0+IEFycmF5LmlzQXJyYXkoY29udGVudClcbiAgKS5mbGF0KCkuZmlsdGVyKFxuICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiB8fCBwYXJ0LnR5cGUgPT09IFwiZmlsZVwiXG4gICkubWFwKChwYXJ0KSA9PiB7XG4gICAgdmFyIF9hMTc7XG4gICAgY29uc3QgbWVkaWFUeXBlID0gKF9hMTcgPSBwYXJ0Lm1lZGlhVHlwZSkgIT0gbnVsbCA/IF9hMTcgOiBwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiA/IFwiaW1hZ2UvKlwiIDogdm9pZCAwO1xuICAgIGxldCBkYXRhID0gcGFydC50eXBlID09PSBcImltYWdlXCIgPyBwYXJ0LmltYWdlIDogcGFydC5kYXRhO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IG5ldyBVUkwoZGF0YSk7XG4gICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1lZGlhVHlwZSwgZGF0YSB9O1xuICB9KS5maWx0ZXIoXG4gICAgKHBhcnQpID0+IHBhcnQuZGF0YSBpbnN0YW5jZW9mIFVSTFxuICApLm1hcCgocGFydCkgPT4gKHtcbiAgICB1cmw6IHBhcnQuZGF0YSxcbiAgICBpc1VybFN1cHBvcnRlZEJ5TW9kZWw6IHBhcnQubWVkaWFUeXBlICE9IG51bGwgJiYgaXNVcmxTdXBwb3J0ZWQoe1xuICAgICAgdXJsOiBwYXJ0LmRhdGEudG9TdHJpbmcoKSxcbiAgICAgIG1lZGlhVHlwZTogcGFydC5tZWRpYVR5cGUsXG4gICAgICBzdXBwb3J0ZWRVcmxzXG4gICAgfSlcbiAgfSkpO1xuICBjb25zdCBkb3dubG9hZGVkRmlsZXMgPSBhd2FpdCBkb3dubG9hZDIocGxhbm5lZERvd25sb2Fkcyk7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgZG93bmxvYWRlZEZpbGVzLmZpbHRlcihcbiAgICAgIChkb3dubG9hZGVkRmlsZSkgPT4gKGRvd25sb2FkZWRGaWxlID09IG51bGwgPyB2b2lkIDAgOiBkb3dubG9hZGVkRmlsZS5kYXRhKSAhPSBudWxsXG4gICAgKS5tYXAoKHsgZGF0YSwgbWVkaWFUeXBlIH0sIGluZGV4KSA9PiBbXG4gICAgICBwbGFubmVkRG93bmxvYWRzW2luZGV4XS51cmwudG9TdHJpbmcoKSxcbiAgICAgIHsgZGF0YSwgbWVkaWFUeXBlIH1cbiAgICBdKVxuICApO1xufVxuZnVuY3Rpb24gY29udmVydFBhcnRUb0xhbmd1YWdlTW9kZWxQYXJ0KHBhcnQsIGRvd25sb2FkZWRBc3NldHMpIHtcbiAgdmFyIF9hMTc7XG4gIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyT3B0aW9uc1xuICAgIH07XG4gIH1cbiAgbGV0IG9yaWdpbmFsRGF0YTtcbiAgY29uc3QgdHlwZSA9IHBhcnQudHlwZTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImltYWdlXCI6XG4gICAgICBvcmlnaW5hbERhdGEgPSBwYXJ0LmltYWdlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZpbGVcIjpcbiAgICAgIG9yaWdpbmFsRGF0YSA9IHBhcnQuZGF0YTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhcnQgdHlwZTogJHt0eXBlfWApO1xuICB9XG4gIGNvbnN0IHsgZGF0YTogY29udmVydGVkRGF0YSwgbWVkaWFUeXBlOiBjb252ZXJ0ZWRNZWRpYVR5cGUgfSA9IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxWMkRhdGFDb250ZW50KG9yaWdpbmFsRGF0YSk7XG4gIGxldCBtZWRpYVR5cGUgPSBjb252ZXJ0ZWRNZWRpYVR5cGUgIT0gbnVsbCA/IGNvbnZlcnRlZE1lZGlhVHlwZSA6IHBhcnQubWVkaWFUeXBlO1xuICBsZXQgZGF0YSA9IGNvbnZlcnRlZERhdGE7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgY29uc3QgZG93bmxvYWRlZEZpbGUgPSBkb3dubG9hZGVkQXNzZXRzW2RhdGEudG9TdHJpbmcoKV07XG4gICAgaWYgKGRvd25sb2FkZWRGaWxlKSB7XG4gICAgICBkYXRhID0gZG93bmxvYWRlZEZpbGUuZGF0YTtcbiAgICAgIG1lZGlhVHlwZSAhPSBudWxsID8gbWVkaWFUeXBlIDogbWVkaWFUeXBlID0gZG93bmxvYWRlZEZpbGUubWVkaWFUeXBlO1xuICAgIH1cbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiaW1hZ2VcIjoge1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lZGlhVHlwZSA9IChfYTE3ID0gZGV0ZWN0TWVkaWFUeXBlKHsgZGF0YSwgc2lnbmF0dXJlczogaW1hZ2VNZWRpYVR5cGVTaWduYXR1cmVzIH0pKSAhPSBudWxsID8gX2ExNyA6IG1lZGlhVHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICBtZWRpYVR5cGU6IG1lZGlhVHlwZSAhPSBudWxsID8gbWVkaWFUeXBlIDogXCJpbWFnZS8qXCIsXG4gICAgICAgIC8vIGFueSBpbWFnZVxuICAgICAgICBmaWxlbmFtZTogdm9pZCAwLFxuICAgICAgICBkYXRhLFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICBpZiAobWVkaWFUeXBlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZWRpYSB0eXBlIGlzIG1pc3NpbmcgZm9yIGZpbGUgcGFydGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIG1lZGlhVHlwZSxcbiAgICAgICAgZmlsZW5hbWU6IHBhcnQuZmlsZW5hbWUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9wcm9tcHQvcHJlcGFyZS1jYWxsLXNldHRpbmdzLnRzXG5mdW5jdGlvbiBwcmVwYXJlQ2FsbFNldHRpbmdzKHtcbiAgbWF4T3V0cHV0VG9rZW5zLFxuICB0ZW1wZXJhdHVyZSxcbiAgdG9wUCxcbiAgdG9wSyxcbiAgcHJlc2VuY2VQZW5hbHR5LFxuICBmcmVxdWVuY3lQZW5hbHR5LFxuICBzZWVkLFxuICBzdG9wU2VxdWVuY2VzXG59KSB7XG4gIGlmIChtYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhPdXRwdXRUb2tlbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4T3V0cHV0VG9rZW5zXCIsXG4gICAgICAgIHZhbHVlOiBtYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4T3V0cHV0VG9rZW5zIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1heE91dHB1dFRva2VucyA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhPdXRwdXRUb2tlbnNcIixcbiAgICAgICAgdmFsdWU6IG1heE91dHB1dFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhPdXRwdXRUb2tlbnMgbXVzdCBiZSA+PSAxXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdGVtcGVyYXR1cmUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0ZW1wZXJhdHVyZVwiLFxuICAgICAgICB2YWx1ZTogdGVtcGVyYXR1cmUsXG4gICAgICAgIG1lc3NhZ2U6IFwidGVtcGVyYXR1cmUgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRvcFAgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdG9wUCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRvcFBcIixcbiAgICAgICAgdmFsdWU6IHRvcFAsXG4gICAgICAgIG1lc3NhZ2U6IFwidG9wUCBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodG9wSyAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BLICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidG9wS1wiLFxuICAgICAgICB2YWx1ZTogdG9wSyxcbiAgICAgICAgbWVzc2FnZTogXCJ0b3BLIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChwcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcHJlc2VuY2VQZW5hbHR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwicHJlc2VuY2VQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBwcmVzZW5jZVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwicHJlc2VuY2VQZW5hbHR5IG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChmcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGZyZXF1ZW5jeVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJmcmVxdWVuY3lQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiBcImZyZXF1ZW5jeVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHNlZWQgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzZWVkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNlZWRcIixcbiAgICAgICAgdmFsdWU6IHNlZWQsXG4gICAgICAgIG1lc3NhZ2U6IFwic2VlZCBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbWF4T3V0cHV0VG9rZW5zLFxuICAgIHRlbXBlcmF0dXJlLFxuICAgIHRvcFAsXG4gICAgdG9wSyxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBzdG9wU2VxdWVuY2VzLFxuICAgIHNlZWRcbiAgfTtcbn1cblxuLy8gc3JjL3Byb21wdC9wcmVwYXJlLXRvb2xzLWFuZC10b29sLWNob2ljZS50c1xuaW1wb3J0IHsgYXNTY2hlbWEgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9pcy1ub24tZW1wdHktb2JqZWN0LnRzXG5mdW5jdGlvbiBpc05vbkVtcHR5T2JqZWN0KG9iamVjdDIpIHtcbiAgcmV0dXJuIG9iamVjdDIgIT0gbnVsbCAmJiBPYmplY3Qua2V5cyhvYmplY3QyKS5sZW5ndGggPiAwO1xufVxuXG4vLyBzcmMvcHJvbXB0L3ByZXBhcmUtdG9vbHMtYW5kLXRvb2wtY2hvaWNlLnRzXG5mdW5jdGlvbiBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHtcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIGFjdGl2ZVRvb2xzXG59KSB7XG4gIGlmICghaXNOb25FbXB0eU9iamVjdCh0b29scykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbHM6IHZvaWQgMCxcbiAgICAgIHRvb2xDaG9pY2U6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgY29uc3QgZmlsdGVyZWRUb29scyA9IGFjdGl2ZVRvb2xzICE9IG51bGwgPyBPYmplY3QuZW50cmllcyh0b29scykuZmlsdGVyKFxuICAgIChbbmFtZTE3XSkgPT4gYWN0aXZlVG9vbHMuaW5jbHVkZXMobmFtZTE3KVxuICApIDogT2JqZWN0LmVudHJpZXModG9vbHMpO1xuICByZXR1cm4ge1xuICAgIHRvb2xzOiBmaWx0ZXJlZFRvb2xzLm1hcCgoW25hbWUxNywgdG9vbDNdKSA9PiB7XG4gICAgICBjb25zdCB0b29sVHlwZSA9IHRvb2wzLnR5cGU7XG4gICAgICBzd2l0Y2ggKHRvb2xUeXBlKSB7XG4gICAgICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgICBjYXNlIFwiZHluYW1pY1wiOlxuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgbmFtZTogbmFtZTE3LFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRvb2wzLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgaW5wdXRTY2hlbWE6IGFzU2NoZW1hKHRvb2wzLmlucHV0U2NoZW1hKS5qc29uU2NoZW1hLFxuICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiB0b29sMy5wcm92aWRlck9wdGlvbnNcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwicHJvdmlkZXItZGVmaW5lZFwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInByb3ZpZGVyLWRlZmluZWRcIixcbiAgICAgICAgICAgIG5hbWU6IG5hbWUxNyxcbiAgICAgICAgICAgIGlkOiB0b29sMy5pZCxcbiAgICAgICAgICAgIGFyZ3M6IHRvb2wzLmFyZ3NcbiAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gdG9vbFR5cGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0b29sIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdG9vbENob2ljZTogdG9vbENob2ljZSA9PSBudWxsID8geyB0eXBlOiBcImF1dG9cIiB9IDogdHlwZW9mIHRvb2xDaG9pY2UgPT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IHRvb2xDaG9pY2UgfSA6IHsgdHlwZTogXCJ0b29sXCIsIHRvb2xOYW1lOiB0b29sQ2hvaWNlLnRvb2xOYW1lIH1cbiAgfTtcbn1cblxuLy8gc3JjL3Byb21wdC9zdGFuZGFyZGl6ZS1wcm9tcHQudHNcbmltcG9ydCB7IEludmFsaWRQcm9tcHRFcnJvciBhcyBJbnZhbGlkUHJvbXB0RXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNhZmVWYWxpZGF0ZVR5cGVzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejYgfSBmcm9tIFwiem9kL3Y0XCI7XG5cbi8vIHNyYy9wcm9tcHQvbWVzc2FnZS50c1xuaW1wb3J0IHsgeiBhcyB6NSB9IGZyb20gXCJ6b2QvdjRcIjtcblxuLy8gc3JjL3R5cGVzL3Byb3ZpZGVyLW1ldGFkYXRhLnRzXG5pbXBvcnQgeyB6IGFzIHozIH0gZnJvbSBcInpvZC92NFwiO1xuXG4vLyBzcmMvdHlwZXMvanNvbi12YWx1ZS50c1xuaW1wb3J0IHsgeiBhcyB6MiB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciBqc29uVmFsdWVTY2hlbWEgPSB6Mi5sYXp5KFxuICAoKSA9PiB6Mi51bmlvbihbXG4gICAgejIubnVsbCgpLFxuICAgIHoyLnN0cmluZygpLFxuICAgIHoyLm51bWJlcigpLFxuICAgIHoyLmJvb2xlYW4oKSxcbiAgICB6Mi5yZWNvcmQoejIuc3RyaW5nKCksIGpzb25WYWx1ZVNjaGVtYSksXG4gICAgejIuYXJyYXkoanNvblZhbHVlU2NoZW1hKVxuICBdKVxuKTtcblxuLy8gc3JjL3R5cGVzL3Byb3ZpZGVyLW1ldGFkYXRhLnRzXG52YXIgcHJvdmlkZXJNZXRhZGF0YVNjaGVtYSA9IHozLnJlY29yZChcbiAgejMuc3RyaW5nKCksXG4gIHozLnJlY29yZCh6My5zdHJpbmcoKSwganNvblZhbHVlU2NoZW1hKVxuKTtcblxuLy8gc3JjL3Byb21wdC9jb250ZW50LXBhcnQudHNcbmltcG9ydCB7IHogYXMgejQgfSBmcm9tIFwiem9kL3Y0XCI7XG52YXIgdGV4dFBhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwidGV4dFwiKSxcbiAgdGV4dDogejQuc3RyaW5nKCksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBpbWFnZVBhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwiaW1hZ2VcIiksXG4gIGltYWdlOiB6NC51bmlvbihbZGF0YUNvbnRlbnRTY2hlbWEsIHo0Lmluc3RhbmNlb2YoVVJMKV0pLFxuICBtZWRpYVR5cGU6IHo0LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBmaWxlUGFydFNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJmaWxlXCIpLFxuICBkYXRhOiB6NC51bmlvbihbZGF0YUNvbnRlbnRTY2hlbWEsIHo0Lmluc3RhbmNlb2YoVVJMKV0pLFxuICBmaWxlbmFtZTogejQuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgbWVkaWFUeXBlOiB6NC5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIHJlYXNvbmluZ1BhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwicmVhc29uaW5nXCIpLFxuICB0ZXh0OiB6NC5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIHRvb2xDYWxsUGFydFNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJ0b29sLWNhbGxcIiksXG4gIHRvb2xDYWxsSWQ6IHo0LnN0cmluZygpLFxuICB0b29sTmFtZTogejQuc3RyaW5nKCksXG4gIGlucHV0OiB6NC51bmtub3duKCksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICBwcm92aWRlckV4ZWN1dGVkOiB6NC5ib29sZWFuKCkub3B0aW9uYWwoKVxufSk7XG52YXIgb3V0cHV0U2NoZW1hID0gejQuZGlzY3JpbWluYXRlZFVuaW9uKFwidHlwZVwiLCBbXG4gIHo0Lm9iamVjdCh7XG4gICAgdHlwZTogejQubGl0ZXJhbChcInRleHRcIiksXG4gICAgdmFsdWU6IHo0LnN0cmluZygpXG4gIH0pLFxuICB6NC5vYmplY3Qoe1xuICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJqc29uXCIpLFxuICAgIHZhbHVlOiBqc29uVmFsdWVTY2hlbWFcbiAgfSksXG4gIHo0Lm9iamVjdCh7XG4gICAgdHlwZTogejQubGl0ZXJhbChcImVycm9yLXRleHRcIiksXG4gICAgdmFsdWU6IHo0LnN0cmluZygpXG4gIH0pLFxuICB6NC5vYmplY3Qoe1xuICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJlcnJvci1qc29uXCIpLFxuICAgIHZhbHVlOiBqc29uVmFsdWVTY2hlbWFcbiAgfSksXG4gIHo0Lm9iamVjdCh7XG4gICAgdHlwZTogejQubGl0ZXJhbChcImNvbnRlbnRcIiksXG4gICAgdmFsdWU6IHo0LmFycmF5KFxuICAgICAgejQudW5pb24oW1xuICAgICAgICB6NC5vYmplY3Qoe1xuICAgICAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJ0ZXh0XCIpLFxuICAgICAgICAgIHRleHQ6IHo0LnN0cmluZygpXG4gICAgICAgIH0pLFxuICAgICAgICB6NC5vYmplY3Qoe1xuICAgICAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJtZWRpYVwiKSxcbiAgICAgICAgICBkYXRhOiB6NC5zdHJpbmcoKSxcbiAgICAgICAgICBtZWRpYVR5cGU6IHo0LnN0cmluZygpXG4gICAgICAgIH0pXG4gICAgICBdKVxuICAgIClcbiAgfSlcbl0pO1xudmFyIHRvb2xSZXN1bHRQYXJ0U2NoZW1hID0gejQub2JqZWN0KHtcbiAgdHlwZTogejQubGl0ZXJhbChcInRvb2wtcmVzdWx0XCIpLFxuICB0b29sQ2FsbElkOiB6NC5zdHJpbmcoKSxcbiAgdG9vbE5hbWU6IHo0LnN0cmluZygpLFxuICBvdXRwdXQ6IG91dHB1dFNjaGVtYSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xuXG4vLyBzcmMvcHJvbXB0L21lc3NhZ2UudHNcbnZhciBzeXN0ZW1Nb2RlbE1lc3NhZ2VTY2hlbWEgPSB6NS5vYmplY3QoXG4gIHtcbiAgICByb2xlOiB6NS5saXRlcmFsKFwic3lzdGVtXCIpLFxuICAgIGNvbnRlbnQ6IHo1LnN0cmluZygpLFxuICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH1cbik7XG52YXIgY29yZVN5c3RlbU1lc3NhZ2VTY2hlbWEgPSBzeXN0ZW1Nb2RlbE1lc3NhZ2VTY2hlbWE7XG52YXIgdXNlck1vZGVsTWVzc2FnZVNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHJvbGU6IHo1LmxpdGVyYWwoXCJ1c2VyXCIpLFxuICBjb250ZW50OiB6NS51bmlvbihbXG4gICAgejUuc3RyaW5nKCksXG4gICAgejUuYXJyYXkoejUudW5pb24oW3RleHRQYXJ0U2NoZW1hLCBpbWFnZVBhcnRTY2hlbWEsIGZpbGVQYXJ0U2NoZW1hXSkpXG4gIF0pLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZVVzZXJNZXNzYWdlU2NoZW1hID0gdXNlck1vZGVsTWVzc2FnZVNjaGVtYTtcbnZhciBhc3Npc3RhbnRNb2RlbE1lc3NhZ2VTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICByb2xlOiB6NS5saXRlcmFsKFwiYXNzaXN0YW50XCIpLFxuICBjb250ZW50OiB6NS51bmlvbihbXG4gICAgejUuc3RyaW5nKCksXG4gICAgejUuYXJyYXkoXG4gICAgICB6NS51bmlvbihbXG4gICAgICAgIHRleHRQYXJ0U2NoZW1hLFxuICAgICAgICBmaWxlUGFydFNjaGVtYSxcbiAgICAgICAgcmVhc29uaW5nUGFydFNjaGVtYSxcbiAgICAgICAgdG9vbENhbGxQYXJ0U2NoZW1hLFxuICAgICAgICB0b29sUmVzdWx0UGFydFNjaGVtYVxuICAgICAgXSlcbiAgICApXG4gIF0pLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZUFzc2lzdGFudE1lc3NhZ2VTY2hlbWEgPSBhc3Npc3RhbnRNb2RlbE1lc3NhZ2VTY2hlbWE7XG52YXIgdG9vbE1vZGVsTWVzc2FnZVNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHJvbGU6IHo1LmxpdGVyYWwoXCJ0b29sXCIpLFxuICBjb250ZW50OiB6NS5hcnJheSh0b29sUmVzdWx0UGFydFNjaGVtYSksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBjb3JlVG9vbE1lc3NhZ2VTY2hlbWEgPSB0b29sTW9kZWxNZXNzYWdlU2NoZW1hO1xudmFyIG1vZGVsTWVzc2FnZVNjaGVtYSA9IHo1LnVuaW9uKFtcbiAgc3lzdGVtTW9kZWxNZXNzYWdlU2NoZW1hLFxuICB1c2VyTW9kZWxNZXNzYWdlU2NoZW1hLFxuICBhc3Npc3RhbnRNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHRvb2xNb2RlbE1lc3NhZ2VTY2hlbWFcbl0pO1xudmFyIGNvcmVNZXNzYWdlU2NoZW1hID0gbW9kZWxNZXNzYWdlU2NoZW1hO1xuXG4vLyBzcmMvcHJvbXB0L3N0YW5kYXJkaXplLXByb21wdC50c1xuYXN5bmMgZnVuY3Rpb24gc3RhbmRhcmRpemVQcm9tcHQocHJvbXB0KSB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBvciBtZXNzYWdlcyBtdXN0IGJlIGRlZmluZWRcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBhbmQgbWVzc2FnZXMgY2Fubm90IGJlIGRlZmluZWQgYXQgdGhlIHNhbWUgdGltZVwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5zeXN0ZW0gIT0gbnVsbCAmJiB0eXBlb2YgcHJvbXB0LnN5c3RlbSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3IyKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwic3lzdGVtIG11c3QgYmUgYSBzdHJpbmdcIlxuICAgIH0pO1xuICB9XG4gIGxldCBtZXNzYWdlcztcbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiB0eXBlb2YgcHJvbXB0LnByb21wdCA9PT0gXCJzdHJpbmdcIikge1xuICAgIG1lc3NhZ2VzID0gW3sgcm9sZTogXCJ1c2VyXCIsIGNvbnRlbnQ6IHByb21wdC5wcm9tcHQgfV07XG4gIH0gZWxzZSBpZiAocHJvbXB0LnByb21wdCAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkocHJvbXB0LnByb21wdCkpIHtcbiAgICBtZXNzYWdlcyA9IHByb21wdC5wcm9tcHQ7XG4gIH0gZWxzZSBpZiAocHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICBtZXNzYWdlcyA9IHByb21wdC5tZXNzYWdlcztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBvciBtZXNzYWdlcyBtdXN0IGJlIGRlZmluZWRcIlxuICAgIH0pO1xuICB9XG4gIGlmIChtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcIm1lc3NhZ2VzIG11c3Qgbm90IGJlIGVtcHR5XCJcbiAgICB9KTtcbiAgfVxuICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMoe1xuICAgIHZhbHVlOiBtZXNzYWdlcyxcbiAgICBzY2hlbWE6IHo2LmFycmF5KG1vZGVsTWVzc2FnZVNjaGVtYSlcbiAgfSk7XG4gIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcjIoe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJUaGUgbWVzc2FnZXMgbXVzdCBiZSBhIE1vZGVsTWVzc2FnZVtdLiBJZiB5b3UgaGF2ZSBwYXNzZWQgYSBVSU1lc3NhZ2VbXSwgeW91IGNhbiB1c2UgY29udmVydFRvTW9kZWxNZXNzYWdlcyB0byBjb252ZXJ0IHRoZW0uXCIsXG4gICAgICBjYXVzZTogdmFsaWRhdGlvblJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXMsXG4gICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtXG4gIH07XG59XG5cbi8vIHNyYy9wcm9tcHQvd3JhcC1nYXRld2F5LWVycm9yLnRzXG5pbXBvcnQge1xuICBHYXRld2F5QXV0aGVudGljYXRpb25FcnJvcixcbiAgR2F0ZXdheU1vZGVsTm90Rm91bmRFcnJvclxufSBmcm9tIFwiQGFpLXNkay9nYXRld2F5XCI7XG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxOSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiB3cmFwR2F0ZXdheUVycm9yKGVycm9yKSB7XG4gIGlmIChHYXRld2F5QXV0aGVudGljYXRpb25FcnJvci5pc0luc3RhbmNlKGVycm9yKSB8fCBHYXRld2F5TW9kZWxOb3RGb3VuZEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgcmV0dXJuIG5ldyBBSVNES0Vycm9yMTkoe1xuICAgICAgbmFtZTogXCJHYXRld2F5RXJyb3JcIixcbiAgICAgIG1lc3NhZ2U6IFwiVmVyY2VsIEFJIEdhdGV3YXkgYWNjZXNzIGZhaWxlZC4gSWYgeW91IHdhbnQgdG8gdXNlIEFJIFNESyBwcm92aWRlcnMgZGlyZWN0bHksIHVzZSB0aGUgcHJvdmlkZXJzLCBlLmcuIEBhaS1zZGsvb3BlbmFpLCBvciByZWdpc3RlciBhIGRpZmZlcmVudCBnbG9iYWwgZGVmYXVsdCBwcm92aWRlci5cIixcbiAgICAgIGNhdXNlOiBlcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cblxuLy8gc3JjL3RlbGVtZXRyeS9hc3NlbWJsZS1vcGVyYXRpb24tbmFtZS50c1xuZnVuY3Rpb24gYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgb3BlcmF0aW9uSWQsXG4gIHRlbGVtZXRyeVxufSkge1xuICByZXR1cm4ge1xuICAgIC8vIHN0YW5kYXJkaXplZCBvcGVyYXRpb24gYW5kIHJlc291cmNlIG5hbWU6XG4gICAgXCJvcGVyYXRpb24ubmFtZVwiOiBgJHtvcGVyYXRpb25JZH0keyh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkKSAhPSBudWxsID8gYCAke3RlbGVtZXRyeS5mdW5jdGlvbklkfWAgOiBcIlwifWAsXG4gICAgXCJyZXNvdXJjZS5uYW1lXCI6IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWQsXG4gICAgLy8gZGV0YWlsZWQsIEFJIFNESyBzcGVjaWZpYyBkYXRhOlxuICAgIFwiYWkub3BlcmF0aW9uSWRcIjogb3BlcmF0aW9uSWQsXG4gICAgXCJhaS50ZWxlbWV0cnkuZnVuY3Rpb25JZFwiOiB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkXG4gIH07XG59XG5cbi8vIHNyYy90ZWxlbWV0cnkvZ2V0LWJhc2UtdGVsZW1ldHJ5LWF0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgbW9kZWwsXG4gIHNldHRpbmdzLFxuICB0ZWxlbWV0cnksXG4gIGhlYWRlcnNcbn0pIHtcbiAgdmFyIF9hMTc7XG4gIHJldHVybiB7XG4gICAgXCJhaS5tb2RlbC5wcm92aWRlclwiOiBtb2RlbC5wcm92aWRlcixcbiAgICBcImFpLm1vZGVsLmlkXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgLy8gc2V0dGluZ3M6XG4gICAgLi4uT2JqZWN0LmVudHJpZXMoc2V0dGluZ3MpLnJlZHVjZSgoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBhdHRyaWJ1dGVzW2BhaS5zZXR0aW5ncy4ke2tleX1gXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfSwge30pLFxuICAgIC8vIGFkZCBtZXRhZGF0YSBhcyBhdHRyaWJ1dGVzOlxuICAgIC4uLk9iamVjdC5lbnRyaWVzKChfYTE3ID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkubWV0YWRhdGEpICE9IG51bGwgPyBfYTE3IDoge30pLnJlZHVjZShcbiAgICAgIChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgYXR0cmlidXRlc1tgYWkudGVsZW1ldHJ5Lm1ldGFkYXRhLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICAvLyByZXF1ZXN0IGhlYWRlcnNcbiAgICAuLi5PYmplY3QuZW50cmllcyhoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30pLnJlZHVjZSgoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBhdHRyaWJ1dGVzW2BhaS5yZXF1ZXN0LmhlYWRlcnMuJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH0sIHt9KVxuICB9O1xufVxuXG4vLyBzcmMvdGVsZW1ldHJ5L2dldC10cmFjZXIudHNcbmltcG9ydCB7IHRyYWNlIH0gZnJvbSBcIkBvcGVudGVsZW1ldHJ5L2FwaVwiO1xuXG4vLyBzcmMvdGVsZW1ldHJ5L25vb3AtdHJhY2VyLnRzXG52YXIgbm9vcFRyYWNlciA9IHtcbiAgc3RhcnRTcGFuKCkge1xuICAgIHJldHVybiBub29wU3BhbjtcbiAgfSxcbiAgc3RhcnRBY3RpdmVTcGFuKG5hbWUxNywgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYXJnMShub29wU3Bhbik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYXJnMihub29wU3Bhbik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXJnMyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYXJnMyhub29wU3Bhbik7XG4gICAgfVxuICB9XG59O1xudmFyIG5vb3BTcGFuID0ge1xuICBzcGFuQ29udGV4dCgpIHtcbiAgICByZXR1cm4gbm9vcFNwYW5Db250ZXh0O1xuICB9LFxuICBzZXRBdHRyaWJ1dGUoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNldEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZEV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRMaW5rKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRMaW5rcygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc2V0U3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICB1cGRhdGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGlzUmVjb3JkaW5nKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgcmVjb3JkRXhjZXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xudmFyIG5vb3BTcGFuQ29udGV4dCA9IHtcbiAgdHJhY2VJZDogXCJcIixcbiAgc3BhbklkOiBcIlwiLFxuICB0cmFjZUZsYWdzOiAwXG59O1xuXG4vLyBzcmMvdGVsZW1ldHJ5L2dldC10cmFjZXIudHNcbmZ1bmN0aW9uIGdldFRyYWNlcih7XG4gIGlzRW5hYmxlZCA9IGZhbHNlLFxuICB0cmFjZXJcbn0gPSB7fSkge1xuICBpZiAoIWlzRW5hYmxlZCkge1xuICAgIHJldHVybiBub29wVHJhY2VyO1xuICB9XG4gIGlmICh0cmFjZXIpIHtcbiAgICByZXR1cm4gdHJhY2VyO1xuICB9XG4gIHJldHVybiB0cmFjZS5nZXRUcmFjZXIoXCJhaVwiKTtcbn1cblxuLy8gc3JjL3RlbGVtZXRyeS9yZWNvcmQtc3Bhbi50c1xuaW1wb3J0IHsgU3BhblN0YXR1c0NvZGUgfSBmcm9tIFwiQG9wZW50ZWxlbWV0cnkvYXBpXCI7XG5mdW5jdGlvbiByZWNvcmRTcGFuKHtcbiAgbmFtZTogbmFtZTE3LFxuICB0cmFjZXIsXG4gIGF0dHJpYnV0ZXMsXG4gIGZuLFxuICBlbmRXaGVuRG9uZSA9IHRydWVcbn0pIHtcbiAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4obmFtZTE3LCB7IGF0dHJpYnV0ZXMgfSwgYXN5bmMgKHNwYW4pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oc3Bhbik7XG4gICAgICBpZiAoZW5kV2hlbkRvbmUpIHtcbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlY29yZEVycm9yT25TcGFuKHNwYW4sIGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVjb3JkRXJyb3JPblNwYW4oc3BhbiwgZXJyb3IpIHtcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBzcGFuLnJlY29yZEV4Y2VwdGlvbih7XG4gICAgICBuYW1lOiBlcnJvci5uYW1lLFxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICAgIH0pO1xuICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgIGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogU3BhblN0YXR1c0NvZGUuRVJST1IgfSk7XG4gIH1cbn1cblxuLy8gc3JjL3RlbGVtZXRyeS9zZWxlY3QtdGVsZW1ldHJ5LWF0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICB0ZWxlbWV0cnksXG4gIGF0dHJpYnV0ZXNcbn0pIHtcbiAgaWYgKCh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5pc0VuYWJsZWQpICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5yZWR1Y2UoKGF0dHJpYnV0ZXMyLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwiaW5wdXRcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuaW5wdXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKCh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5yZWNvcmRJbnB1dHMpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlczI7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5pbnB1dCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PSBudWxsID8gYXR0cmlidXRlczIgOiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogcmVzdWx0IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCJvdXRwdXRcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUub3V0cHV0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICgodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkucmVjb3JkT3V0cHV0cykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLm91dHB1dCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PSBudWxsID8gYXR0cmlidXRlczIgOiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogdmFsdWUgfTtcbiAgfSwge30pO1xufVxuXG4vLyBzcmMvdGVsZW1ldHJ5L3N0cmluZ2lmeS1mb3ItdGVsZW1ldHJ5LnRzXG5mdW5jdGlvbiBzdHJpbmdpZnlGb3JUZWxlbWV0cnkocHJvbXB0KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShcbiAgICBwcm9tcHQubWFwKChtZXNzYWdlKSA9PiAoe1xuICAgICAgLi4ubWVzc2FnZSxcbiAgICAgIGNvbnRlbnQ6IHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlLmNvbnRlbnQgOiBtZXNzYWdlLmNvbnRlbnQubWFwKFxuICAgICAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcImZpbGVcIiA/IHtcbiAgICAgICAgICAuLi5wYXJ0LFxuICAgICAgICAgIGRhdGE6IHBhcnQuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhwYXJ0LmRhdGEpIDogcGFydC5kYXRhXG4gICAgICAgIH0gOiBwYXJ0XG4gICAgICApXG4gICAgfSkpXG4gICk7XG59XG5cbi8vIHNyYy90eXBlcy91c2FnZS50c1xuZnVuY3Rpb24gYWRkTGFuZ3VhZ2VNb2RlbFVzYWdlKHVzYWdlMSwgdXNhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAgaW5wdXRUb2tlbnM6IGFkZFRva2VuQ291bnRzKHVzYWdlMS5pbnB1dFRva2VucywgdXNhZ2UyLmlucHV0VG9rZW5zKSxcbiAgICBvdXRwdXRUb2tlbnM6IGFkZFRva2VuQ291bnRzKHVzYWdlMS5vdXRwdXRUb2tlbnMsIHVzYWdlMi5vdXRwdXRUb2tlbnMpLFxuICAgIHRvdGFsVG9rZW5zOiBhZGRUb2tlbkNvdW50cyh1c2FnZTEudG90YWxUb2tlbnMsIHVzYWdlMi50b3RhbFRva2VucyksXG4gICAgcmVhc29uaW5nVG9rZW5zOiBhZGRUb2tlbkNvdW50cyhcbiAgICAgIHVzYWdlMS5yZWFzb25pbmdUb2tlbnMsXG4gICAgICB1c2FnZTIucmVhc29uaW5nVG9rZW5zXG4gICAgKSxcbiAgICBjYWNoZWRJbnB1dFRva2VuczogYWRkVG9rZW5Db3VudHMoXG4gICAgICB1c2FnZTEuY2FjaGVkSW5wdXRUb2tlbnMsXG4gICAgICB1c2FnZTIuY2FjaGVkSW5wdXRUb2tlbnNcbiAgICApXG4gIH07XG59XG5mdW5jdGlvbiBhZGRUb2tlbkNvdW50cyh0b2tlbkNvdW50MSwgdG9rZW5Db3VudDIpIHtcbiAgcmV0dXJuIHRva2VuQ291bnQxID09IG51bGwgJiYgdG9rZW5Db3VudDIgPT0gbnVsbCA/IHZvaWQgMCA6ICh0b2tlbkNvdW50MSAhPSBudWxsID8gdG9rZW5Db3VudDEgOiAwKSArICh0b2tlbkNvdW50MiAhPSBudWxsID8gdG9rZW5Db3VudDIgOiAwKTtcbn1cblxuLy8gc3JjL3V0aWwvYXMtYXJyYXkudHNcbmZ1bmN0aW9uIGFzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyBbXSA6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuXG4vLyBzcmMvdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IGRlbGF5LCBnZXRFcnJvck1lc3NhZ2UgYXMgZ2V0RXJyb3JNZXNzYWdlMywgaXNBYm9ydEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIGdldFJldHJ5RGVsYXlJbk1zKHtcbiAgZXJyb3IsXG4gIGV4cG9uZW50aWFsQmFja29mZkRlbGF5XG59KSB7XG4gIGNvbnN0IGhlYWRlcnMgPSBlcnJvci5yZXNwb25zZUhlYWRlcnM7XG4gIGlmICghaGVhZGVycylcbiAgICByZXR1cm4gZXhwb25lbnRpYWxCYWNrb2ZmRGVsYXk7XG4gIGxldCBtcztcbiAgY29uc3QgcmV0cnlBZnRlck1zID0gaGVhZGVyc1tcInJldHJ5LWFmdGVyLW1zXCJdO1xuICBpZiAocmV0cnlBZnRlck1zKSB7XG4gICAgY29uc3QgdGltZW91dE1zID0gcGFyc2VGbG9hdChyZXRyeUFmdGVyTXMpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKHRpbWVvdXRNcykpIHtcbiAgICAgIG1zID0gdGltZW91dE1zO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXRyeUFmdGVyID0gaGVhZGVyc1tcInJldHJ5LWFmdGVyXCJdO1xuICBpZiAocmV0cnlBZnRlciAmJiBtcyA9PT0gdm9pZCAwKSB7XG4gICAgY29uc3QgdGltZW91dFNlY29uZHMgPSBwYXJzZUZsb2F0KHJldHJ5QWZ0ZXIpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKHRpbWVvdXRTZWNvbmRzKSkge1xuICAgICAgbXMgPSB0aW1lb3V0U2Vjb25kcyAqIDFlMztcbiAgICB9IGVsc2Uge1xuICAgICAgbXMgPSBEYXRlLnBhcnNlKHJldHJ5QWZ0ZXIpIC0gRGF0ZS5ub3coKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1zICE9IG51bGwgJiYgIU51bWJlci5pc05hTihtcykgJiYgMCA8PSBtcyAmJiAobXMgPCA2MCAqIDFlMyB8fCBtcyA8IGV4cG9uZW50aWFsQmFja29mZkRlbGF5KSkge1xuICAgIHJldHVybiBtcztcbiAgfVxuICByZXR1cm4gZXhwb25lbnRpYWxCYWNrb2ZmRGVsYXk7XG59XG52YXIgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmUmVzcGVjdGluZ1JldHJ5SGVhZGVycyA9ICh7XG4gIG1heFJldHJpZXMgPSAyLFxuICBpbml0aWFsRGVsYXlJbk1zID0gMmUzLFxuICBiYWNrb2ZmRmFjdG9yID0gMixcbiAgYWJvcnRTaWduYWxcbn0gPSB7fSkgPT4gYXN5bmMgKGYpID0+IF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXM6IGluaXRpYWxEZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3IsXG4gIGFib3J0U2lnbmFsXG59KTtcbmFzeW5jIGZ1bmN0aW9uIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3IsXG4gIGFib3J0U2lnbmFsXG59LCBlcnJvcnMgPSBbXSkge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBmKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA9PT0gMCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZTMoZXJyb3IpO1xuICAgIGNvbnN0IG5ld0Vycm9ycyA9IFsuLi5lcnJvcnMsIGVycm9yXTtcbiAgICBjb25zdCB0cnlOdW1iZXIgPSBuZXdFcnJvcnMubGVuZ3RoO1xuICAgIGlmICh0cnlOdW1iZXIgPiBtYXhSZXRyaWVzKSB7XG4gICAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzLiBMYXN0IGVycm9yOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICByZWFzb246IFwibWF4UmV0cmllc0V4Y2VlZGVkXCIsXG4gICAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgQVBJQ2FsbEVycm9yMi5pc0luc3RhbmNlKGVycm9yKSAmJiBlcnJvci5pc1JldHJ5YWJsZSA9PT0gdHJ1ZSAmJiB0cnlOdW1iZXIgPD0gbWF4UmV0cmllcykge1xuICAgICAgYXdhaXQgZGVsYXkoXG4gICAgICAgIGdldFJldHJ5RGVsYXlJbk1zKHtcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBleHBvbmVudGlhbEJhY2tvZmZEZWxheTogZGVsYXlJbk1zXG4gICAgICAgIH0pLFxuICAgICAgICB7IGFib3J0U2lnbmFsIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihcbiAgICAgICAgZixcbiAgICAgICAge1xuICAgICAgICAgIG1heFJldHJpZXMsXG4gICAgICAgICAgZGVsYXlJbk1zOiBiYWNrb2ZmRmFjdG9yICogZGVsYXlJbk1zLFxuICAgICAgICAgIGJhY2tvZmZGYWN0b3IsXG4gICAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgICAgfSxcbiAgICAgICAgbmV3RXJyb3JzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHJ5TnVtYmVyID09PSAxKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMgd2l0aCBub24tcmV0cnlhYmxlIGVycm9yOiAnJHtlcnJvck1lc3NhZ2V9J2AsXG4gICAgICByZWFzb246IFwiZXJyb3JOb3RSZXRyeWFibGVcIixcbiAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWwvcHJlcGFyZS1yZXRyaWVzLnRzXG5mdW5jdGlvbiBwcmVwYXJlUmV0cmllcyh7XG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsXG59KSB7XG4gIGlmIChtYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4UmV0cmllcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSA+PSAwXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBtYXhSZXRyaWVzUmVzdWx0ID0gbWF4UmV0cmllcyAhPSBudWxsID8gbWF4UmV0cmllcyA6IDI7XG4gIHJldHVybiB7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc1Jlc3VsdCxcbiAgICByZXRyeTogcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmUmVzcGVjdGluZ1JldHJ5SGVhZGVycyh7XG4gICAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzUmVzdWx0LFxuICAgICAgYWJvcnRTaWduYWxcbiAgICB9KVxuICB9O1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9leHRyYWN0LXRleHQtY29udGVudC50c1xuZnVuY3Rpb24gZXh0cmFjdFRleHRDb250ZW50KGNvbnRlbnQpIHtcbiAgY29uc3QgcGFydHMgPSBjb250ZW50LmZpbHRlcihcbiAgICAoY29udGVudDIpID0+IGNvbnRlbnQyLnR5cGUgPT09IFwidGV4dFwiXG4gICk7XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBwYXJ0cy5tYXAoKGNvbnRlbnQyKSA9PiBjb250ZW50Mi50ZXh0KS5qb2luKFwiXCIpO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZWQtZmlsZS50c1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSBhcyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5MyxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCBhcyBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0MlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIERlZmF1bHRHZW5lcmF0ZWRGaWxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZGF0YSxcbiAgICBtZWRpYVR5cGVcbiAgfSkge1xuICAgIGNvbnN0IGlzVWludDhBcnJheSA9IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgIHRoaXMuYmFzZTY0RGF0YSA9IGlzVWludDhBcnJheSA/IHZvaWQgMCA6IGRhdGE7XG4gICAgdGhpcy51aW50OEFycmF5RGF0YSA9IGlzVWludDhBcnJheSA/IGRhdGEgOiB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYVR5cGUgPSBtZWRpYVR5cGU7XG4gIH1cbiAgLy8gbGF6eSBjb252ZXJzaW9uIHdpdGggY2FjaGluZyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBjb252ZXJzaW9uIG92ZXJoZWFkOlxuICBnZXQgYmFzZTY0KCkge1xuICAgIGlmICh0aGlzLmJhc2U2NERhdGEgPT0gbnVsbCkge1xuICAgICAgdGhpcy5iYXNlNjREYXRhID0gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NDIodGhpcy51aW50OEFycmF5RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJhc2U2NERhdGE7XG4gIH1cbiAgLy8gbGF6eSBjb252ZXJzaW9uIHdpdGggY2FjaGluZyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBjb252ZXJzaW9uIG92ZXJoZWFkOlxuICBnZXQgdWludDhBcnJheSgpIHtcbiAgICBpZiAodGhpcy51aW50OEFycmF5RGF0YSA9PSBudWxsKSB7XG4gICAgICB0aGlzLnVpbnQ4QXJyYXlEYXRhID0gY29udmVydEJhc2U2NFRvVWludDhBcnJheTModGhpcy5iYXNlNjREYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudWludDhBcnJheURhdGE7XG4gIH1cbn07XG52YXIgRGVmYXVsdEdlbmVyYXRlZEZpbGVXaXRoVHlwZSA9IGNsYXNzIGV4dGVuZHMgRGVmYXVsdEdlbmVyYXRlZEZpbGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy50eXBlID0gXCJmaWxlXCI7XG4gIH1cbn07XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L3BhcnNlLXRvb2wtY2FsbC50c1xuaW1wb3J0IHtcbiAgYXNTY2hlbWEgYXMgYXNTY2hlbWEyLFxuICBzYWZlUGFyc2VKU09OLFxuICBzYWZlVmFsaWRhdGVUeXBlcyBhcyBzYWZlVmFsaWRhdGVUeXBlczJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlVG9vbENhbGwoe1xuICB0b29sQ2FsbCxcbiAgdG9vbHMsXG4gIHJlcGFpclRvb2xDYWxsLFxuICBzeXN0ZW0sXG4gIG1lc3NhZ2VzXG59KSB7XG4gIHRyeSB7XG4gICAgaWYgKHRvb2xzID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3IoeyB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUgfSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgZG9QYXJzZVRvb2xDYWxsKHsgdG9vbENhbGwsIHRvb2xzIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAocmVwYWlyVG9vbENhbGwgPT0gbnVsbCB8fCAhKE5vU3VjaFRvb2xFcnJvci5pc0luc3RhbmNlKGVycm9yKSB8fCBJbnZhbGlkVG9vbElucHV0RXJyb3IuaXNJbnN0YW5jZShlcnJvcikpKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgbGV0IHJlcGFpcmVkVG9vbENhbGwgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVwYWlyZWRUb29sQ2FsbCA9IGF3YWl0IHJlcGFpclRvb2xDYWxsKHtcbiAgICAgICAgICB0b29sQ2FsbCxcbiAgICAgICAgICB0b29scyxcbiAgICAgICAgICBpbnB1dFNjaGVtYTogKHsgdG9vbE5hbWUgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpbnB1dFNjaGVtYSB9ID0gdG9vbHNbdG9vbE5hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIGFzU2NoZW1hMihpbnB1dFNjaGVtYSkuanNvblNjaGVtYTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICBtZXNzYWdlcyxcbiAgICAgICAgICBlcnJvclxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKHJlcGFpckVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBUb29sQ2FsbFJlcGFpckVycm9yKHtcbiAgICAgICAgICBjYXVzZTogcmVwYWlyRXJyb3IsXG4gICAgICAgICAgb3JpZ2luYWxFcnJvcjogZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocmVwYWlyZWRUb29sQ2FsbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IGRvUGFyc2VUb29sQ2FsbCh7IHRvb2xDYWxsOiByZXBhaXJlZFRvb2xDYWxsLCB0b29scyB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgcGFyc2VkSW5wdXQgPSBhd2FpdCBzYWZlUGFyc2VKU09OKHsgdGV4dDogdG9vbENhbGwuaW5wdXQgfSk7XG4gICAgY29uc3QgaW5wdXQgPSBwYXJzZWRJbnB1dC5zdWNjZXNzID8gcGFyc2VkSW5wdXQudmFsdWUgOiB0b29sQ2FsbC5pbnB1dDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICBpbnB1dCxcbiAgICAgIGR5bmFtaWM6IHRydWUsXG4gICAgICBpbnZhbGlkOiB0cnVlLFxuICAgICAgZXJyb3JcbiAgICB9O1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb1BhcnNlVG9vbENhbGwoe1xuICB0b29sQ2FsbCxcbiAgdG9vbHNcbn0pIHtcbiAgY29uc3QgdG9vbE5hbWUgPSB0b29sQ2FsbC50b29sTmFtZTtcbiAgY29uc3QgdG9vbDMgPSB0b29sc1t0b29sTmFtZV07XG4gIGlmICh0b29sMyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7XG4gICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICBhdmFpbGFibGVUb29sczogT2JqZWN0LmtleXModG9vbHMpXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2NoZW1hID0gYXNTY2hlbWEyKHRvb2wzLmlucHV0U2NoZW1hKTtcbiAgY29uc3QgcGFyc2VSZXN1bHQgPSB0b29sQ2FsbC5pbnB1dC50cmltKCkgPT09IFwiXCIgPyBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlczIoeyB2YWx1ZToge30sIHNjaGVtYSB9KSA6IGF3YWl0IHNhZmVQYXJzZUpTT04oeyB0ZXh0OiB0b29sQ2FsbC5pbnB1dCwgc2NoZW1hIH0pO1xuICBpZiAocGFyc2VSZXN1bHQuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRvb2xJbnB1dEVycm9yKHtcbiAgICAgIHRvb2xOYW1lLFxuICAgICAgdG9vbElucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0b29sMy50eXBlID09PSBcImR5bmFtaWNcIiA/IHtcbiAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgIGlucHV0OiBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICBwcm92aWRlckV4ZWN1dGVkOiB0b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHRvb2xDYWxsLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgZHluYW1pYzogdHJ1ZVxuICB9IDoge1xuICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICB0b29sTmFtZSxcbiAgICBpbnB1dDogcGFyc2VSZXN1bHQudmFsdWUsXG4gICAgcHJvdmlkZXJFeGVjdXRlZDogdG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCxcbiAgICBwcm92aWRlck1ldGFkYXRhOiB0b29sQ2FsbC5wcm92aWRlck1ldGFkYXRhXG4gIH07XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L3N0ZXAtcmVzdWx0LnRzXG52YXIgRGVmYXVsdFN0ZXBSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb250ZW50LFxuICAgIGZpbmlzaFJlYXNvbixcbiAgICB1c2FnZSxcbiAgICB3YXJuaW5ncyxcbiAgICByZXF1ZXN0LFxuICAgIHJlc3BvbnNlLFxuICAgIHByb3ZpZGVyTWV0YWRhdGFcbiAgfSkge1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSBmaW5pc2hSZWFzb247XG4gICAgdGhpcy51c2FnZSA9IHVzYWdlO1xuICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBwcm92aWRlck1ldGFkYXRhO1xuICB9XG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidGV4dFwiKS5tYXAoKHBhcnQpID0+IHBhcnQudGV4dCkuam9pbihcIlwiKTtcbiAgfVxuICBnZXQgcmVhc29uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwicmVhc29uaW5nXCIpO1xuICB9XG4gIGdldCByZWFzb25pbmdUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnJlYXNvbmluZy5sZW5ndGggPT09IDAgPyB2b2lkIDAgOiB0aGlzLnJlYXNvbmluZy5tYXAoKHBhcnQpID0+IHBhcnQudGV4dCkuam9pbihcIlwiKTtcbiAgfVxuICBnZXQgZmlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJmaWxlXCIpLm1hcCgocGFydCkgPT4gcGFydC5maWxlKTtcbiAgfVxuICBnZXQgc291cmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcInNvdXJjZVwiKTtcbiAgfVxuICBnZXQgdG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCIpO1xuICB9XG4gIGdldCBzdGF0aWNUb29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbENhbGxzLmZpbHRlcihcbiAgICAgICh0b29sQ2FsbCkgPT4gdG9vbENhbGwuZHluYW1pYyA9PT0gZmFsc2VcbiAgICApO1xuICB9XG4gIGdldCBkeW5hbWljVG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xDYWxscy5maWx0ZXIoXG4gICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLmR5bmFtaWMgPT09IHRydWVcbiAgICApO1xuICB9XG4gIGdldCB0b29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIpO1xuICB9XG4gIGdldCBzdGF0aWNUb29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy50b29sUmVzdWx0cy5maWx0ZXIoXG4gICAgICAodG9vbFJlc3VsdCkgPT4gdG9vbFJlc3VsdC5keW5hbWljID09PSBmYWxzZVxuICAgICk7XG4gIH1cbiAgZ2V0IGR5bmFtaWNUb29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy50b29sUmVzdWx0cy5maWx0ZXIoXG4gICAgICAodG9vbFJlc3VsdCkgPT4gdG9vbFJlc3VsdC5keW5hbWljID09PSB0cnVlXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvc3RvcC1jb25kaXRpb24udHNcbmZ1bmN0aW9uIHN0ZXBDb3VudElzKHN0ZXBDb3VudCkge1xuICByZXR1cm4gKHsgc3RlcHMgfSkgPT4gc3RlcHMubGVuZ3RoID09PSBzdGVwQ291bnQ7XG59XG5mdW5jdGlvbiBoYXNUb29sQ2FsbCh0b29sTmFtZSkge1xuICByZXR1cm4gKHsgc3RlcHMgfSkgPT4ge1xuICAgIHZhciBfYTE3LCBfYiwgX2M7XG4gICAgcmV0dXJuIChfYyA9IChfYiA9IChfYTE3ID0gc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnNvbWUoXG4gICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLnRvb2xOYW1lID09PSB0b29sTmFtZVxuICAgICkpICE9IG51bGwgPyBfYyA6IGZhbHNlO1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gaXNTdG9wQ29uZGl0aW9uTWV0KHtcbiAgc3RvcENvbmRpdGlvbnMsXG4gIHN0ZXBzXG59KSB7XG4gIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoc3RvcENvbmRpdGlvbnMubWFwKChjb25kaXRpb24pID0+IGNvbmRpdGlvbih7IHN0ZXBzIH0pKSkpLnNvbWUoKHJlc3VsdCkgPT4gcmVzdWx0KTtcbn1cblxuLy8gc3JjL3Byb21wdC9jcmVhdGUtdG9vbC1tb2RlbC1vdXRwdXQudHNcbmltcG9ydCB7XG4gIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2U0XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICBvdXRwdXQsXG4gIHRvb2w6IHRvb2wzLFxuICBlcnJvck1vZGVcbn0pIHtcbiAgaWYgKGVycm9yTW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yLXRleHRcIiwgdmFsdWU6IGdldEVycm9yTWVzc2FnZTQob3V0cHV0KSB9O1xuICB9IGVsc2UgaWYgKGVycm9yTW9kZSA9PT0gXCJqc29uXCIpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yLWpzb25cIiwgdmFsdWU6IHRvSlNPTlZhbHVlKG91dHB1dCkgfTtcbiAgfVxuICBpZiAodG9vbDMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wzLnRvTW9kZWxPdXRwdXQpIHtcbiAgICByZXR1cm4gdG9vbDMudG9Nb2RlbE91dHB1dChvdXRwdXQpO1xuICB9XG4gIHJldHVybiB0eXBlb2Ygb3V0cHV0ID09PSBcInN0cmluZ1wiID8geyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IG91dHB1dCB9IDogeyB0eXBlOiBcImpzb25cIiwgdmFsdWU6IHRvSlNPTlZhbHVlKG91dHB1dCkgfTtcbn1cbmZ1bmN0aW9uIHRvSlNPTlZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gbnVsbCA6IHZhbHVlO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC90by1yZXNwb25zZS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gdG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgY29udGVudDogaW5wdXRDb250ZW50LFxuICB0b29sc1xufSkge1xuICBjb25zdCByZXNwb25zZU1lc3NhZ2VzID0gW107XG4gIGNvbnN0IGNvbnRlbnQgPSBpbnB1dENvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwic291cmNlXCIpLmZpbHRlcihcbiAgICAocGFydCkgPT4gKHBhcnQudHlwZSAhPT0gXCJ0b29sLXJlc3VsdFwiIHx8IHBhcnQucHJvdmlkZXJFeGVjdXRlZCkgJiYgKHBhcnQudHlwZSAhPT0gXCJ0b29sLWVycm9yXCIgfHwgcGFydC5wcm92aWRlckV4ZWN1dGVkKVxuICApLmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlICE9PSBcInRleHRcIiB8fCBwYXJ0LnRleHQubGVuZ3RoID4gMCkubWFwKChwYXJ0KSA9PiB7XG4gICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICBjYXNlIFwicmVhc29uaW5nXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgZGF0YTogcGFydC5maWxlLmJhc2U2NCxcbiAgICAgICAgICBtZWRpYVR5cGU6IHBhcnQuZmlsZS5tZWRpYVR5cGUsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICBpbnB1dDogcGFydC5pbnB1dCxcbiAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgb3V0cHV0OiBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgICAgICAgdG9vbDogdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3BhcnQudG9vbE5hbWVdLFxuICAgICAgICAgICAgb3V0cHV0OiBwYXJ0Lm91dHB1dCxcbiAgICAgICAgICAgIGVycm9yTW9kZTogXCJub25lXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB0cnVlLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICBjYXNlIFwidG9vbC1lcnJvclwiOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgb3V0cHV0OiBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgICAgICAgdG9vbDogdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3BhcnQudG9vbE5hbWVdLFxuICAgICAgICAgICAgb3V0cHV0OiBwYXJ0LmVycm9yLFxuICAgICAgICAgICAgZXJyb3JNb2RlOiBcImpzb25cIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgaWYgKGNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaCh7XG4gICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHRvb2xSZXN1bHRDb250ZW50ID0gaW5wdXRDb250ZW50LmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtZXJyb3JcIikuZmlsdGVyKChwYXJ0KSA9PiAhcGFydC5wcm92aWRlckV4ZWN1dGVkKS5tYXAoKHRvb2xSZXN1bHQpID0+ICh7XG4gICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgIHRvb2xDYWxsSWQ6IHRvb2xSZXN1bHQudG9vbENhbGxJZCxcbiAgICB0b29sTmFtZTogdG9vbFJlc3VsdC50b29sTmFtZSxcbiAgICBvdXRwdXQ6IGNyZWF0ZVRvb2xNb2RlbE91dHB1dCh7XG4gICAgICB0b29sOiB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbdG9vbFJlc3VsdC50b29sTmFtZV0sXG4gICAgICBvdXRwdXQ6IHRvb2xSZXN1bHQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiID8gdG9vbFJlc3VsdC5vdXRwdXQgOiB0b29sUmVzdWx0LmVycm9yLFxuICAgICAgZXJyb3JNb2RlOiB0b29sUmVzdWx0LnR5cGUgPT09IFwidG9vbC1lcnJvclwiID8gXCJ0ZXh0XCIgOiBcIm5vbmVcIlxuICAgIH0pXG4gIH0pKTtcbiAgaWYgKHRvb2xSZXN1bHRDb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICBjb250ZW50OiB0b29sUmVzdWx0Q29udGVudFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXNwb25zZU1lc3NhZ2VzO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZS10ZXh0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkID0gY3JlYXRlSWRHZW5lcmF0b3Ioe1xuICBwcmVmaXg6IFwiYWl0eHRcIixcbiAgc2l6ZTogMjRcbn0pO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUZXh0KHtcbiAgbW9kZWw6IG1vZGVsQXJnLFxuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgc3RvcFdoZW4gPSBzdGVwQ291bnRJcygxKSxcbiAgZXhwZXJpbWVudGFsX291dHB1dDogb3V0cHV0LFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gIHByb3ZpZGVyT3B0aW9ucyxcbiAgZXhwZXJpbWVudGFsX2FjdGl2ZVRvb2xzLFxuICBhY3RpdmVUb29scyA9IGV4cGVyaW1lbnRhbF9hY3RpdmVUb29scyxcbiAgZXhwZXJpbWVudGFsX3ByZXBhcmVTdGVwLFxuICBwcmVwYXJlU3RlcCA9IGV4cGVyaW1lbnRhbF9wcmVwYXJlU3RlcCxcbiAgZXhwZXJpbWVudGFsX3JlcGFpclRvb2xDYWxsOiByZXBhaXJUb29sQ2FsbCxcbiAgZXhwZXJpbWVudGFsX2Rvd25sb2FkOiBkb3dubG9hZDIsXG4gIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICBfaW50ZXJuYWw6IHtcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZCxcbiAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gIH0gPSB7fSxcbiAgb25TdGVwRmluaXNoLFxuICAuLi5zZXR0aW5nc1xufSkge1xuICBjb25zdCBtb2RlbCA9IHJlc29sdmVMYW5ndWFnZU1vZGVsKG1vZGVsQXJnKTtcbiAgY29uc3Qgc3RvcENvbmRpdGlvbnMgPSBhc0FycmF5KHN0b3BXaGVuKTtcbiAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWxcbiAgfSk7XG4gIGNvbnN0IGNhbGxTZXR0aW5ncyA9IHByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyAuLi5jYWxsU2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgaW5pdGlhbFByb21wdCA9IGF3YWl0IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzXG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcmVjb3JkU3Bhbih7XG4gICAgICBuYW1lOiBcImFpLmdlbmVyYXRlVGV4dFwiLFxuICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZVRleHRcIixcbiAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgIC8vIG1vZGVsOlxuICAgICAgICAgIFwiYWkubW9kZWwucHJvdmlkZXJcIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgXCJhaS5tb2RlbC5pZFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICBjb25zdCBjYWxsU2V0dGluZ3MyID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgIGxldCBjdXJyZW50TW9kZWxSZXNwb25zZTtcbiAgICAgICAgbGV0IGNsaWVudFRvb2xDYWxscyA9IFtdO1xuICAgICAgICBsZXQgY2xpZW50VG9vbE91dHB1dHMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlcyA9IFtdO1xuICAgICAgICBjb25zdCBzdGVwcyA9IFtdO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgY29uc3Qgc3RlcElucHV0TWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAuLi5pbml0aWFsUHJvbXB0Lm1lc3NhZ2VzLFxuICAgICAgICAgICAgLi4ucmVzcG9uc2VNZXNzYWdlc1xuICAgICAgICAgIF07XG4gICAgICAgICAgY29uc3QgcHJlcGFyZVN0ZXBSZXN1bHQgPSBhd2FpdCAocHJlcGFyZVN0ZXAgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwKHtcbiAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgc3RlcHMsXG4gICAgICAgICAgICBzdGVwTnVtYmVyOiBzdGVwcy5sZW5ndGgsXG4gICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXNcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgIHByb21wdDoge1xuICAgICAgICAgICAgICBzeXN0ZW06IChfYTE3ID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0LnN5c3RlbSkgIT0gbnVsbCA/IF9hMTcgOiBpbml0aWFsUHJvbXB0LnN5c3RlbSxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IChfYiA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5tZXNzYWdlcykgIT0gbnVsbCA/IF9iIDogc3RlcElucHV0TWVzc2FnZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdXBwb3J0ZWRVcmxzOiBhd2FpdCBtb2RlbC5zdXBwb3J0ZWRVcmxzLFxuICAgICAgICAgICAgZG93bmxvYWQ6IGRvd25sb2FkMlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHN0ZXBNb2RlbCA9IHJlc29sdmVMYW5ndWFnZU1vZGVsKFxuICAgICAgICAgICAgKF9jID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0Lm1vZGVsKSAhPSBudWxsID8gX2MgOiBtb2RlbFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgeyB0b29sQ2hvaWNlOiBzdGVwVG9vbENob2ljZSwgdG9vbHM6IHN0ZXBUb29scyB9ID0gcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7XG4gICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgIHRvb2xDaG9pY2U6IChfZCA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC50b29sQ2hvaWNlKSAhPSBudWxsID8gX2QgOiB0b29sQ2hvaWNlLFxuICAgICAgICAgICAgYWN0aXZlVG9vbHM6IChfZSA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5hY3RpdmVUb29scykgIT0gbnVsbCA/IF9lIDogYWN0aXZlVG9vbHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjdXJyZW50TW9kZWxSZXNwb25zZSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZVRleHQuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vZGVsOlxuICAgICAgICAgICAgICAgICAgICBcImFpLm1vZGVsLnByb3ZpZGVyXCI6IHN0ZXBNb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5tb2RlbC5pZFwiOiBzdGVwTW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvbXB0OlxuICAgICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0cmluZ2lmeUZvclRlbGVtZXRyeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQudG9vbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIGxhbmd1YWdlIG1vZGVsIGxldmVsIHRvb2xzOlxuICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdGVwVG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHN0ZXBUb29scy5tYXAoKHRvb2wzKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sMykpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xDaG9pY2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdGVwVG9vbENob2ljZSAhPSBudWxsID8gSlNPTi5zdHJpbmdpZnkoc3RlcFRvb2xDaG9pY2UpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IHN0ZXBNb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBzdGVwTW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4T3V0cHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogc2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnN0b3Bfc2VxdWVuY2VzXCI6IHNldHRpbmdzLnN0b3BTZXF1ZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogKF9hMTggPSBzZXR0aW5ncy50ZW1wZXJhdHVyZSkgIT0gbnVsbCA/IF9hMTggOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogc2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbjIpID0+IHtcbiAgICAgICAgICAgICAgICAgIHZhciBfYTE5LCBfYjIsIF9jMiwgX2QyLCBfZTIsIF9mMiwgX2cyLCBfaDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0ZXBNb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2FsbFNldHRpbmdzMixcbiAgICAgICAgICAgICAgICAgICAgdG9vbHM6IHN0ZXBUb29scyxcbiAgICAgICAgICAgICAgICAgICAgdG9vbENob2ljZTogc3RlcFRvb2xDaG9pY2UsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlRm9ybWF0OiBvdXRwdXQgPT0gbnVsbCA/IHZvaWQgMCA6IG91dHB1dC5yZXNwb25zZUZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAoX2IyID0gKF9hMTkgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE5LmlkKSAhPSBudWxsID8gX2IyIDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2QyID0gKF9jMiA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi50aW1lc3RhbXApICE9IG51bGwgPyBfZDIgOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2YyID0gKF9lMiA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lMi5tb2RlbElkKSAhPSBudWxsID8gX2YyIDogc3RlcE1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IChfZzIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZzIuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogKF9oID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2guYm9keVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIHNwYW4yLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiByZXN1bHQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBleHRyYWN0VGV4dENvbnRlbnQocmVzdWx0LmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBhc1Rvb2xDYWxscyhyZXN1bHQuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xDYWxscyA9PSBudWxsID8gdm9pZCAwIDogSlNPTi5zdHJpbmdpZnkodG9vbENhbGxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlRGF0YS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlbmFtZSB0ZWxlbWV0cnkgYXR0cmlidXRlcyB0byBpbnB1dFRva2VucyBhbmQgb3V0cHV0VG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiByZXN1bHQudXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogcmVzdWx0LnVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtyZXN1bHQuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHJlc3VsdC51c2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0LnVzYWdlLm91dHB1dFRva2Vuc1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQsIHJlc3BvbnNlOiByZXNwb25zZURhdGEgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3Qgc3RlcFRvb2xDYWxscyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudC5maWx0ZXIoXG4gICAgICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCJcbiAgICAgICAgICAgICkubWFwKFxuICAgICAgICAgICAgICAodG9vbENhbGwpID0+IHBhcnNlVG9vbENhbGwoe1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsLFxuICAgICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICAgIHJlcGFpclRvb2xDYWxsLFxuICAgICAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXNcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2Ygc3RlcFRvb2xDYWxscykge1xuICAgICAgICAgICAgaWYgKHRvb2xDYWxsLmludmFsaWQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b29sMyA9IHRvb2xzW3Rvb2xDYWxsLnRvb2xOYW1lXTtcbiAgICAgICAgICAgIGlmICgodG9vbDMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wzLm9uSW5wdXRBdmFpbGFibGUpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgYXdhaXQgdG9vbDMub25JbnB1dEF2YWlsYWJsZSh7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xDYWxsLmlucHV0LFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpbnZhbGlkVG9vbENhbGxzID0gc3RlcFRvb2xDYWxscy5maWx0ZXIoXG4gICAgICAgICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLmludmFsaWQgJiYgdG9vbENhbGwuZHluYW1pY1xuICAgICAgICAgICk7XG4gICAgICAgICAgY2xpZW50VG9vbE91dHB1dHMgPSBbXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIGludmFsaWRUb29sQ2FsbHMpIHtcbiAgICAgICAgICAgIGNsaWVudFRvb2xPdXRwdXRzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtZXJyb3JcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICBpbnB1dDogdG9vbENhbGwuaW5wdXQsXG4gICAgICAgICAgICAgIGVycm9yOiBnZXRFcnJvck1lc3NhZ2U1KHRvb2xDYWxsLmVycm9yKSxcbiAgICAgICAgICAgICAgZHluYW1pYzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsaWVudFRvb2xDYWxscyA9IHN0ZXBUb29sQ2FsbHMuZmlsdGVyKFxuICAgICAgICAgICAgKHRvb2xDYWxsKSA9PiAhdG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsaWVudFRvb2xPdXRwdXRzLnB1c2goXG4gICAgICAgICAgICAgIC4uLmF3YWl0IGV4ZWN1dGVUb29scyh7XG4gICAgICAgICAgICAgICAgdG9vbENhbGxzOiBjbGllbnRUb29sQ2FsbHMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgKHRvb2xDYWxsKSA9PiAhdG9vbENhbGwuaW52YWxpZFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN0ZXBDb250ZW50ID0gYXNDb250ZW50KHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmNvbnRlbnQsXG4gICAgICAgICAgICB0b29sQ2FsbHM6IHN0ZXBUb29sQ2FsbHMsXG4gICAgICAgICAgICB0b29sT3V0cHV0czogY2xpZW50VG9vbE91dHB1dHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goXG4gICAgICAgICAgICAuLi50b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICAgICAgICAgICAgICBjb250ZW50OiBzdGVwQ29udGVudCxcbiAgICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50U3RlcFJlc3VsdCA9IG5ldyBEZWZhdWx0U3RlcFJlc3VsdCh7XG4gICAgICAgICAgICBjb250ZW50OiBzdGVwQ29udGVudCxcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgdXNhZ2U6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlLFxuICAgICAgICAgICAgd2FybmluZ3M6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLndhcm5pbmdzLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY3VycmVudE1vZGVsUmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgIHJlcXVlc3Q6IChfZiA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlcXVlc3QpICE9IG51bGwgPyBfZiA6IHt9LFxuICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgLi4uY3VycmVudE1vZGVsUmVzcG9uc2UucmVzcG9uc2UsXG4gICAgICAgICAgICAgIC8vIGRlZXAgY2xvbmUgbXNncyB0byBhdm9pZCBtdXRhdGluZyBwYXN0IG1lc3NhZ2VzIGluIG11bHRpLXN0ZXA6XG4gICAgICAgICAgICAgIG1lc3NhZ2VzOiBzdHJ1Y3R1cmVkQ2xvbmUocmVzcG9uc2VNZXNzYWdlcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsb2dXYXJuaW5ncygoX2cgPSBjdXJyZW50TW9kZWxSZXNwb25zZS53YXJuaW5ncykgIT0gbnVsbCA/IF9nIDogW10pO1xuICAgICAgICAgIHN0ZXBzLnB1c2goY3VycmVudFN0ZXBSZXN1bHQpO1xuICAgICAgICAgIGF3YWl0IChvblN0ZXBGaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3RlcEZpbmlzaChjdXJyZW50U3RlcFJlc3VsdCkpO1xuICAgICAgICB9IHdoaWxlIChcbiAgICAgICAgICAvLyB0aGVyZSBhcmUgdG9vbCBjYWxsczpcbiAgICAgICAgICBjbGllbnRUb29sQ2FsbHMubGVuZ3RoID4gMCAmJiAvLyBhbGwgY3VycmVudCB0b29sIGNhbGxzIGhhdmUgb3V0cHV0cyAoaW5jbC4gZXhlY3V0aW9uIGVycm9ycyk6XG4gICAgICAgICAgY2xpZW50VG9vbE91dHB1dHMubGVuZ3RoID09PSBjbGllbnRUb29sQ2FsbHMubGVuZ3RoICYmIC8vIGNvbnRpbnVlIHVudGlsIGEgc3RvcCBjb25kaXRpb24gaXMgbWV0OlxuICAgICAgICAgICFhd2FpdCBpc1N0b3BDb25kaXRpb25NZXQoeyBzdG9wQ29uZGl0aW9ucywgc3RlcHMgfSlcbiAgICAgICAgKTtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBleHRyYWN0VGV4dENvbnRlbnQoY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudClcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbENhbGxzID0gYXNUb29sQ2FsbHMoY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdG9vbENhbGxzID09IG51bGwgPyB2b2lkIDAgOiBKU09OLnN0cmluZ2lmeSh0b29sQ2FsbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXCI6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIGN1cnJlbnRNb2RlbFJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgLy8gVE9ETyByZW5hbWUgdGVsZW1ldHJ5IGF0dHJpYnV0ZXMgdG8gaW5wdXRUb2tlbnMgYW5kIG91dHB1dFRva2Vuc1xuICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiBjdXJyZW50TW9kZWxSZXNwb25zZS51c2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlLm91dHB1dFRva2Vuc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGxhc3RTdGVwID0gc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlVGV4dFJlc3VsdCh7XG4gICAgICAgICAgc3RlcHMsXG4gICAgICAgICAgcmVzb2x2ZWRPdXRwdXQ6IGF3YWl0IChvdXRwdXQgPT0gbnVsbCA/IHZvaWQgMCA6IG91dHB1dC5wYXJzZU91dHB1dChcbiAgICAgICAgICAgIHsgdGV4dDogbGFzdFN0ZXAudGV4dCB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXNwb25zZTogbGFzdFN0ZXAucmVzcG9uc2UsXG4gICAgICAgICAgICAgIHVzYWdlOiBsYXN0U3RlcC51c2FnZSxcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBsYXN0U3RlcC5maW5pc2hSZWFzb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyB3cmFwR2F0ZXdheUVycm9yKGVycm9yKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZVRvb2xzKHtcbiAgdG9vbENhbGxzLFxuICB0b29scyxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnksXG4gIG1lc3NhZ2VzLFxuICBhYm9ydFNpZ25hbCxcbiAgZXhwZXJpbWVudGFsX2NvbnRleHRcbn0pIHtcbiAgY29uc3QgdG9vbE91dHB1dHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICB0b29sQ2FsbHMubWFwKGFzeW5jICh7IHRvb2xDYWxsSWQsIHRvb2xOYW1lLCBpbnB1dCB9KSA9PiB7XG4gICAgICBjb25zdCB0b29sMyA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgIGlmICgodG9vbDMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wzLmV4ZWN1dGUpID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICAgICAgbmFtZTogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwubmFtZVwiOiB0b29sTmFtZSxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwuaWRcIjogdG9vbENhbGxJZCxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwuYXJnc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoaW5wdXQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgdHJhY2VyLFxuICAgICAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gZXhlY3V0ZVRvb2woe1xuICAgICAgICAgICAgICBleGVjdXRlOiB0b29sMy5leGVjdXRlLmJpbmQodG9vbDMpLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwYXJ0IG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICBpZiAocGFydC50eXBlID09PSBcImZpbmFsXCIpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBwYXJ0Lm91dHB1dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLnJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvdXRwdXQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgZHluYW1pYzogdG9vbDMudHlwZSA9PT0gXCJkeW5hbWljXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlY29yZEVycm9yT25TcGFuKHNwYW4sIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1lcnJvclwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICBkeW5hbWljOiB0b29sMy50eXBlID09PSBcImR5bmFtaWNcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pXG4gICk7XG4gIHJldHVybiB0b29sT3V0cHV0cy5maWx0ZXIoXG4gICAgKG91dHB1dCkgPT4gb3V0cHV0ICE9IG51bGxcbiAgKTtcbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVUZXh0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5zdGVwcyA9IG9wdGlvbnMuc3RlcHM7XG4gICAgdGhpcy5yZXNvbHZlZE91dHB1dCA9IG9wdGlvbnMucmVzb2x2ZWRPdXRwdXQ7XG4gIH1cbiAgZ2V0IGZpbmFsU3RlcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwc1t0aGlzLnN0ZXBzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGdldCBjb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5jb250ZW50O1xuICB9XG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50ZXh0O1xuICB9XG4gIGdldCBmaWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAuZmlsZXM7XG4gIH1cbiAgZ2V0IHJlYXNvbmluZ1RleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnJlYXNvbmluZ1RleHQ7XG4gIH1cbiAgZ2V0IHJlYXNvbmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAucmVhc29uaW5nO1xuICB9XG4gIGdldCB0b29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRvb2xDYWxscztcbiAgfVxuICBnZXQgc3RhdGljVG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5zdGF0aWNUb29sQ2FsbHM7XG4gIH1cbiAgZ2V0IGR5bmFtaWNUb29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLmR5bmFtaWNUb29sQ2FsbHM7XG4gIH1cbiAgZ2V0IHRvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50b29sUmVzdWx0cztcbiAgfVxuICBnZXQgc3RhdGljVG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnN0YXRpY1Rvb2xSZXN1bHRzO1xuICB9XG4gIGdldCBkeW5hbWljVG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLmR5bmFtaWNUb29sUmVzdWx0cztcbiAgfVxuICBnZXQgc291cmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAuc291cmNlcztcbiAgfVxuICBnZXQgZmluaXNoUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5maW5pc2hSZWFzb247XG4gIH1cbiAgZ2V0IHdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC53YXJuaW5ncztcbiAgfVxuICBnZXQgcHJvdmlkZXJNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAucHJvdmlkZXJNZXRhZGF0YTtcbiAgfVxuICBnZXQgcmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnJlc3BvbnNlO1xuICB9XG4gIGdldCByZXF1ZXN0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5yZXF1ZXN0O1xuICB9XG4gIGdldCB1c2FnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudXNhZ2U7XG4gIH1cbiAgZ2V0IHRvdGFsVXNhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcHMucmVkdWNlKFxuICAgICAgKHRvdGFsVXNhZ2UsIHN0ZXApID0+IHtcbiAgICAgICAgcmV0dXJuIGFkZExhbmd1YWdlTW9kZWxVc2FnZSh0b3RhbFVzYWdlLCBzdGVwLnVzYWdlKTtcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlucHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgICAgIG91dHB1dFRva2Vuczogdm9pZCAwLFxuICAgICAgICB0b3RhbFRva2Vuczogdm9pZCAwLFxuICAgICAgICByZWFzb25pbmdUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgY2FjaGVkSW5wdXRUb2tlbnM6IHZvaWQgMFxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZ2V0IGV4cGVyaW1lbnRhbF9vdXRwdXQoKSB7XG4gICAgaWYgKHRoaXMucmVzb2x2ZWRPdXRwdXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vT3V0cHV0U3BlY2lmaWVkRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRPdXRwdXQ7XG4gIH1cbn07XG5mdW5jdGlvbiBhc1Rvb2xDYWxscyhjb250ZW50KSB7XG4gIGNvbnN0IHBhcnRzID0gY29udGVudC5maWx0ZXIoXG4gICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIlxuICApO1xuICBpZiAocGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gcGFydHMubWFwKCh0b29sQ2FsbCkgPT4gKHtcbiAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICBpbnB1dDogdG9vbENhbGwuaW5wdXRcbiAgfSkpO1xufVxuZnVuY3Rpb24gYXNDb250ZW50KHtcbiAgY29udGVudCxcbiAgdG9vbENhbGxzLFxuICB0b29sT3V0cHV0c1xufSkge1xuICByZXR1cm4gW1xuICAgIC4uLmNvbnRlbnQubWFwKChwYXJ0KSA9PiB7XG4gICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6XG4gICAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgIGZpbGU6IG5ldyBEZWZhdWx0R2VuZXJhdGVkRmlsZShwYXJ0KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgcmV0dXJuIHRvb2xDYWxscy5maW5kKFxuICAgICAgICAgICAgKHRvb2xDYWxsKSA9PiB0b29sQ2FsbC50b29sQ2FsbElkID09PSBwYXJ0LnRvb2xDYWxsSWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgY29uc3QgdG9vbENhbGwgPSB0b29sQ2FsbHMuZmluZChcbiAgICAgICAgICAgICh0b29sQ2FsbDIpID0+IHRvb2xDYWxsMi50b29sQ2FsbElkID09PSBwYXJ0LnRvb2xDYWxsSWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICh0b29sQ2FsbCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvb2wgY2FsbCAke3BhcnQudG9vbENhbGxJZH0gbm90IGZvdW5kLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydC5pc0Vycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtZXJyb3JcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xDYWxsLmlucHV0LFxuICAgICAgICAgICAgICBlcnJvcjogcGFydC5yZXN1bHQsXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIGR5bmFtaWM6IHRvb2xDYWxsLmR5bmFtaWNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgICAgICAgIG91dHB1dDogcGFydC5yZXN1bHQsXG4gICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB0cnVlLFxuICAgICAgICAgICAgZHluYW1pYzogdG9vbENhbGwuZHluYW1pY1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICAuLi50b29sT3V0cHV0c1xuICBdO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9zdHJlYW0tdGV4dC50c1xuaW1wb3J0IHtcbiAgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTdcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yMixcbiAgaXNBYm9ydEVycm9yIGFzIGlzQWJvcnRFcnJvcjJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3V0aWwvcHJlcGFyZS1oZWFkZXJzLnRzXG5mdW5jdGlvbiBwcmVwYXJlSGVhZGVycyhoZWFkZXJzLCBkZWZhdWx0SGVhZGVycykge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBuZXcgSGVhZGVycyhoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30pO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkZWZhdWx0SGVhZGVycykpIHtcbiAgICBpZiAoIXJlc3BvbnNlSGVhZGVycy5oYXMoa2V5KSkge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlSGVhZGVycztcbn1cblxuLy8gc3JjL3RleHQtc3RyZWFtL2NyZWF0ZS10ZXh0LXN0cmVhbS1yZXNwb25zZS50c1xuZnVuY3Rpb24gY3JlYXRlVGV4dFN0cmVhbVJlc3BvbnNlKHtcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBoZWFkZXJzLFxuICB0ZXh0U3RyZWFtXG59KSB7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UodGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSksIHtcbiAgICBzdGF0dXM6IHN0YXR1cyAhPSBudWxsID8gc3RhdHVzIDogMjAwLFxuICAgIHN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogcHJlcGFyZUhlYWRlcnMoaGVhZGVycywge1xuICAgICAgXCJjb250ZW50LXR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9KVxuICB9KTtcbn1cblxuLy8gc3JjL3V0aWwvd3JpdGUtdG8tc2VydmVyLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICByZXNwb25zZSxcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBoZWFkZXJzLFxuICBzdHJlYW1cbn0pIHtcbiAgcmVzcG9uc2Uud3JpdGVIZWFkKHN0YXR1cyAhPSBudWxsID8gc3RhdHVzIDogMjAwLCBzdGF0dXNUZXh0LCBoZWFkZXJzKTtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICBjb25zdCByZWFkID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgcmVzcG9uc2Uud3JpdGUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgfVxuICB9O1xuICByZWFkKCk7XG59XG5cbi8vIHNyYy90ZXh0LXN0cmVhbS9waXBlLXRleHQtc3RyZWFtLXRvLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2Uoe1xuICByZXNwb25zZSxcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBoZWFkZXJzLFxuICB0ZXh0U3RyZWFtXG59KSB7XG4gIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gICAgcmVzcG9uc2UsXG4gICAgc3RhdHVzLFxuICAgIHN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgcHJlcGFyZUhlYWRlcnMoaGVhZGVycywge1xuICAgICAgICBcImNvbnRlbnQtdHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSkuZW50cmllcygpXG4gICAgKSxcbiAgICBzdHJlYW06IHRleHRTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpXG4gIH0pO1xufVxuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vanNvbi10by1zc2UtdHJhbnNmb3JtLXN0cmVhbS50c1xudmFyIEpzb25Ub1NzZVRyYW5zZm9ybVN0cmVhbSA9IGNsYXNzIGV4dGVuZHMgVHJhbnNmb3JtU3RyZWFtIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHJhbnNmb3JtKHBhcnQsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGBkYXRhOiAke0pTT04uc3RyaW5naWZ5KHBhcnQpfVxuXG5gKTtcbiAgICAgIH0sXG4gICAgICBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcImRhdGE6IFtET05FXVxcblxcblwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL3VpLW1lc3NhZ2Utc3RyZWFtLWhlYWRlcnMudHNcbnZhciBVSV9NRVNTQUdFX1NUUkVBTV9IRUFERVJTID0ge1xuICBcImNvbnRlbnQtdHlwZVwiOiBcInRleHQvZXZlbnQtc3RyZWFtXCIsXG4gIFwiY2FjaGUtY29udHJvbFwiOiBcIm5vLWNhY2hlXCIsXG4gIGNvbm5lY3Rpb246IFwia2VlcC1hbGl2ZVwiLFxuICBcIngtdmVyY2VsLWFpLXVpLW1lc3NhZ2Utc3RyZWFtXCI6IFwidjFcIixcbiAgXCJ4LWFjY2VsLWJ1ZmZlcmluZ1wiOiBcIm5vXCJcbiAgLy8gZGlzYWJsZSBuZ2lueCBidWZmZXJpbmdcbn07XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS9jcmVhdGUtdWktbWVzc2FnZS1zdHJlYW0tcmVzcG9uc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZVVJTWVzc2FnZVN0cmVhbVJlc3BvbnNlKHtcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBoZWFkZXJzLFxuICBzdHJlYW0sXG4gIGNvbnN1bWVTc2VTdHJlYW1cbn0pIHtcbiAgbGV0IHNzZVN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChuZXcgSnNvblRvU3NlVHJhbnNmb3JtU3RyZWFtKCkpO1xuICBpZiAoY29uc3VtZVNzZVN0cmVhbSkge1xuICAgIGNvbnN0IFtzdHJlYW0xLCBzdHJlYW0yXSA9IHNzZVN0cmVhbS50ZWUoKTtcbiAgICBzc2VTdHJlYW0gPSBzdHJlYW0xO1xuICAgIGNvbnN1bWVTc2VTdHJlYW0oeyBzdHJlYW06IHN0cmVhbTIgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShzc2VTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpLCB7XG4gICAgc3RhdHVzLFxuICAgIHN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogcHJlcGFyZUhlYWRlcnMoaGVhZGVycywgVUlfTUVTU0FHRV9TVFJFQU1fSEVBREVSUylcbiAgfSk7XG59XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS9nZXQtcmVzcG9uc2UtdWktbWVzc2FnZS1pZC50c1xuZnVuY3Rpb24gZ2V0UmVzcG9uc2VVSU1lc3NhZ2VJZCh7XG4gIG9yaWdpbmFsTWVzc2FnZXMsXG4gIHJlc3BvbnNlTWVzc2FnZUlkXG59KSB7XG4gIGlmIChvcmlnaW5hbE1lc3NhZ2VzID09IG51bGwpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IGxhc3RNZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlc1tvcmlnaW5hbE1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gKGxhc3RNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TWVzc2FnZS5yb2xlKSA9PT0gXCJhc3Npc3RhbnRcIiA/IGxhc3RNZXNzYWdlLmlkIDogdHlwZW9mIHJlc3BvbnNlTWVzc2FnZUlkID09PSBcImZ1bmN0aW9uXCIgPyByZXNwb25zZU1lc3NhZ2VJZCgpIDogcmVzcG9uc2VNZXNzYWdlSWQ7XG59XG5cbi8vIHNyYy91aS9wcm9jZXNzLXVpLW1lc3NhZ2Utc3RyZWFtLnRzXG5pbXBvcnQge1xuICB2YWxpZGF0ZVR5cGVzXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS91aS1tZXNzYWdlLWNodW5rcy50c1xuaW1wb3J0IHsgeiBhcyB6NyB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciB1aU1lc3NhZ2VDaHVua1NjaGVtYSA9IHo3LnVuaW9uKFtcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwidGV4dC1zdGFydFwiKSxcbiAgICBpZDogejcuc3RyaW5nKCksXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH0pLFxuICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0ZXh0LWRlbHRhXCIpLFxuICAgIGlkOiB6Ny5zdHJpbmcoKSxcbiAgICBkZWx0YTogejcuc3RyaW5nKCksXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH0pLFxuICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0ZXh0LWVuZFwiKSxcbiAgICBpZDogejcuc3RyaW5nKCksXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH0pLFxuICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJlcnJvclwiKSxcbiAgICBlcnJvclRleHQ6IHo3LnN0cmluZygpXG4gIH0pLFxuICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0b29sLWlucHV0LXN0YXJ0XCIpLFxuICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpLFxuICAgIHRvb2xOYW1lOiB6Ny5zdHJpbmcoKSxcbiAgICBwcm92aWRlckV4ZWN1dGVkOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICBkeW5hbWljOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwidG9vbC1pbnB1dC1kZWx0YVwiKSxcbiAgICB0b29sQ2FsbElkOiB6Ny5zdHJpbmcoKSxcbiAgICBpbnB1dFRleHREZWx0YTogejcuc3RyaW5nKClcbiAgfSksXG4gIHo3LnN0cmljdE9iamVjdCh7XG4gICAgdHlwZTogejcubGl0ZXJhbChcInRvb2wtaW5wdXQtYXZhaWxhYmxlXCIpLFxuICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpLFxuICAgIHRvb2xOYW1lOiB6Ny5zdHJpbmcoKSxcbiAgICBpbnB1dDogejcudW5rbm93bigpLFxuICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo3LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICBkeW5hbWljOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwidG9vbC1pbnB1dC1lcnJvclwiKSxcbiAgICB0b29sQ2FsbElkOiB6Ny5zdHJpbmcoKSxcbiAgICB0b29sTmFtZTogejcuc3RyaW5nKCksXG4gICAgaW5wdXQ6IHo3LnVua25vd24oKSxcbiAgICBwcm92aWRlckV4ZWN1dGVkOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgZHluYW1pYzogejcuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgZXJyb3JUZXh0OiB6Ny5zdHJpbmcoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwidG9vbC1vdXRwdXQtYXZhaWxhYmxlXCIpLFxuICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpLFxuICAgIG91dHB1dDogejcudW5rbm93bigpLFxuICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo3LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIGR5bmFtaWM6IHo3LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIHByZWxpbWluYXJ5OiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwidG9vbC1vdXRwdXQtZXJyb3JcIiksXG4gICAgdG9vbENhbGxJZDogejcuc3RyaW5nKCksXG4gICAgZXJyb3JUZXh0OiB6Ny5zdHJpbmcoKSxcbiAgICBwcm92aWRlckV4ZWN1dGVkOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICBkeW5hbWljOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwicmVhc29uaW5nXCIpLFxuICAgIHRleHQ6IHo3LnN0cmluZygpLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwicmVhc29uaW5nLXN0YXJ0XCIpLFxuICAgIGlkOiB6Ny5zdHJpbmcoKSxcbiAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgfSksXG4gIHo3LnN0cmljdE9iamVjdCh7XG4gICAgdHlwZTogejcubGl0ZXJhbChcInJlYXNvbmluZy1kZWx0YVwiKSxcbiAgICBpZDogejcuc3RyaW5nKCksXG4gICAgZGVsdGE6IHo3LnN0cmluZygpLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwicmVhc29uaW5nLWVuZFwiKSxcbiAgICBpZDogejcuc3RyaW5nKCksXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH0pLFxuICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJyZWFzb25pbmctcGFydC1maW5pc2hcIilcbiAgfSksXG4gIHo3LnN0cmljdE9iamVjdCh7XG4gICAgdHlwZTogejcubGl0ZXJhbChcInNvdXJjZS11cmxcIiksXG4gICAgc291cmNlSWQ6IHo3LnN0cmluZygpLFxuICAgIHVybDogejcuc3RyaW5nKCksXG4gICAgdGl0bGU6IHo3LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH0pLFxuICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJzb3VyY2UtZG9jdW1lbnRcIiksXG4gICAgc291cmNlSWQ6IHo3LnN0cmluZygpLFxuICAgIG1lZGlhVHlwZTogejcuc3RyaW5nKCksXG4gICAgdGl0bGU6IHo3LnN0cmluZygpLFxuICAgIGZpbGVuYW1lOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwiZmlsZVwiKSxcbiAgICB1cmw6IHo3LnN0cmluZygpLFxuICAgIG1lZGlhVHlwZTogejcuc3RyaW5nKCksXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH0pLFxuICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgIHR5cGU6IHo3LnN0cmluZygpLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKSxcbiAgICBpZDogejcuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBkYXRhOiB6Ny51bmtub3duKCksXG4gICAgdHJhbnNpZW50OiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwic3RhcnQtc3RlcFwiKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwiZmluaXNoLXN0ZXBcIilcbiAgfSksXG4gIHo3LnN0cmljdE9iamVjdCh7XG4gICAgdHlwZTogejcubGl0ZXJhbChcInN0YXJ0XCIpLFxuICAgIG1lc3NhZ2VJZDogejcuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBtZXNzYWdlTWV0YWRhdGE6IHo3LnVua25vd24oKS5vcHRpb25hbCgpXG4gIH0pLFxuICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJmaW5pc2hcIiksXG4gICAgbWVzc2FnZU1ldGFkYXRhOiB6Ny51bmtub3duKCkub3B0aW9uYWwoKVxuICB9KSxcbiAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwiYWJvcnRcIilcbiAgfSksXG4gIHo3LnN0cmljdE9iamVjdCh7XG4gICAgdHlwZTogejcubGl0ZXJhbChcIm1lc3NhZ2UtbWV0YWRhdGFcIiksXG4gICAgbWVzc2FnZU1ldGFkYXRhOiB6Ny51bmtub3duKClcbiAgfSlcbl0pO1xuZnVuY3Rpb24gaXNEYXRhVUlNZXNzYWdlQ2h1bmsoY2h1bmspIHtcbiAgcmV0dXJuIGNodW5rLnR5cGUuc3RhcnRzV2l0aChcImRhdGEtXCIpO1xufVxuXG4vLyBzcmMvdXRpbC9tZXJnZS1vYmplY3RzLnRzXG5mdW5jdGlvbiBtZXJnZU9iamVjdHMoYmFzZSwgb3ZlcnJpZGVzKSB7XG4gIGlmIChiYXNlID09PSB2b2lkIDAgJiYgb3ZlcnJpZGVzID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChiYXNlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVzO1xuICB9XG4gIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHsgLi4uYmFzZSB9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvdmVycmlkZXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG92ZXJyaWRlcywga2V5KSkge1xuICAgICAgY29uc3Qgb3ZlcnJpZGVzVmFsdWUgPSBvdmVycmlkZXNba2V5XTtcbiAgICAgIGlmIChvdmVycmlkZXNWYWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGtleSBpbiBiYXNlID8gYmFzZVtrZXldIDogdm9pZCAwO1xuICAgICAgY29uc3QgaXNTb3VyY2VPYmplY3QgPSBvdmVycmlkZXNWYWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2Ygb3ZlcnJpZGVzVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkob3ZlcnJpZGVzVmFsdWUpICYmICEob3ZlcnJpZGVzVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJiAhKG92ZXJyaWRlc1ZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKTtcbiAgICAgIGNvbnN0IGlzVGFyZ2V0T2JqZWN0ID0gYmFzZVZhbHVlICE9PSBudWxsICYmIGJhc2VWYWx1ZSAhPT0gdm9pZCAwICYmIHR5cGVvZiBiYXNlVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoYmFzZVZhbHVlKSAmJiAhKGJhc2VWYWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmICEoYmFzZVZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKTtcbiAgICAgIGlmIChpc1NvdXJjZU9iamVjdCAmJiBpc1RhcmdldE9iamVjdCkge1xuICAgICAgICByZXN1bHRba2V5XSA9IG1lcmdlT2JqZWN0cyhcbiAgICAgICAgICBiYXNlVmFsdWUsXG4gICAgICAgICAgb3ZlcnJpZGVzVmFsdWVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gb3ZlcnJpZGVzVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy91dGlsL3BhcnNlLXBhcnRpYWwtanNvbi50c1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiBhcyBzYWZlUGFyc2VKU09OMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91dGlsL2ZpeC1qc29uLnRzXG5mdW5jdGlvbiBmaXhKc29uKGlucHV0KSB7XG4gIGNvbnN0IHN0YWNrID0gW1wiUk9PVFwiXTtcbiAgbGV0IGxhc3RWYWxpZEluZGV4ID0gLTE7XG4gIGxldCBsaXRlcmFsU3RhcnQgPSBudWxsO1xuICBmdW5jdGlvbiBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBzd2FwU3RhdGUpIHtcbiAgICB7XG4gICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX1NUUklOR1wiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZlwiOlxuICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICBjYXNlIFwiblwiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIGxpdGVyYWxTdGFydCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTElURVJBTFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiLVwiOiB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTlVNQkVSXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgIGNhc2UgXCIyXCI6XG4gICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgIGNhc2UgXCI1XCI6XG4gICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgIGNhc2UgXCI4XCI6XG4gICAgICAgIGNhc2UgXCI5XCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTlVNQkVSXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ7XCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX1NUQVJUXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJbXCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfU1RBUlRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSkge1xuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIn1cIjoge1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKSB7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gaW5wdXRbaV07XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgc3dpdGNoIChjdXJyZW50U3RhdGUpIHtcbiAgICAgIGNhc2UgXCJST09UXCI6XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiRklOSVNIXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX1NUQVJUXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwifVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0tFWVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiOlwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiOiB7XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXFxcXFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX1NUUklOR19FU0NBUEVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfU1RBUlRcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiOiB7XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HX0VTQ0FQRVwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9OVU1CRVJcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgICAgY2FzZSBcIjVcIjpcbiAgICAgICAgICBjYXNlIFwiNlwiOlxuICAgICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgICAgY2FzZSBcIjhcIjpcbiAgICAgICAgICBjYXNlIFwiOVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImVcIjpcbiAgICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgY2FzZSBcIi5cIjoge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ9XCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9MSVRFUkFMXCI6IHtcbiAgICAgICAgY29uc3QgcGFydGlhbExpdGVyYWwgPSBpbnB1dC5zdWJzdHJpbmcobGl0ZXJhbFN0YXJ0LCBpICsgMSk7XG4gICAgICAgIGlmICghXCJmYWxzZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpICYmICFcInRydWVcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSAmJiAhXCJudWxsXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCByZXN1bHQgPSBpbnB1dC5zbGljZSgwLCBsYXN0VmFsaWRJbmRleCArIDEpO1xuICBmb3IgKGxldCBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0YWNrW2ldO1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9ICdcIic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfS0VZXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9TVEFSVFwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHJlc3VsdCArPSBcIn1cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX1NUQVJUXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfTElURVJBTFwiOiB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxMaXRlcmFsID0gaW5wdXQuc3Vic3RyaW5nKGxpdGVyYWxTdGFydCwgaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgaWYgKFwidHJ1ZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwidHJ1ZVwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJmYWxzZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwiZmFsc2VcIi5zbGljZShwYXJ0aWFsTGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKFwibnVsbFwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwibnVsbFwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3V0aWwvcGFyc2UtcGFydGlhbC1qc29uLnRzXG5hc3luYyBmdW5jdGlvbiBwYXJzZVBhcnRpYWxKc29uKGpzb25UZXh0KSB7XG4gIGlmIChqc29uVGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCwgc3RhdGU6IFwidW5kZWZpbmVkLWlucHV0XCIgfTtcbiAgfVxuICBsZXQgcmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTjIoeyB0ZXh0OiBqc29uVGV4dCB9KTtcbiAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdC52YWx1ZSwgc3RhdGU6IFwic3VjY2Vzc2Z1bC1wYXJzZVwiIH07XG4gIH1cbiAgcmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTjIoeyB0ZXh0OiBmaXhKc29uKGpzb25UZXh0KSB9KTtcbiAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdC52YWx1ZSwgc3RhdGU6IFwicmVwYWlyZWQtcGFyc2VcIiB9O1xuICB9XG4gIHJldHVybiB7IHZhbHVlOiB2b2lkIDAsIHN0YXRlOiBcImZhaWxlZC1wYXJzZVwiIH07XG59XG5cbi8vIHNyYy91aS91aS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gaXNUb29sVUlQYXJ0KHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQudHlwZS5zdGFydHNXaXRoKFwidG9vbC1cIik7XG59XG5mdW5jdGlvbiBpc0R5bmFtaWNUb29sVUlQYXJ0KHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJkeW5hbWljLXRvb2xcIjtcbn1cbmZ1bmN0aW9uIGlzVG9vbE9yRHluYW1pY1Rvb2xVSVBhcnQocGFydCkge1xuICByZXR1cm4gaXNUb29sVUlQYXJ0KHBhcnQpIHx8IGlzRHluYW1pY1Rvb2xVSVBhcnQocGFydCk7XG59XG5mdW5jdGlvbiBnZXRUb29sTmFtZShwYXJ0KSB7XG4gIHJldHVybiBwYXJ0LnR5cGUuc3BsaXQoXCItXCIpLnNsaWNlKDEpLmpvaW4oXCItXCIpO1xufVxuZnVuY3Rpb24gZ2V0VG9vbE9yRHluYW1pY1Rvb2xOYW1lKHBhcnQpIHtcbiAgcmV0dXJuIGlzRHluYW1pY1Rvb2xVSVBhcnQocGFydCkgPyBwYXJ0LnRvb2xOYW1lIDogZ2V0VG9vbE5hbWUocGFydCk7XG59XG5cbi8vIHNyYy91aS9wcm9jZXNzLXVpLW1lc3NhZ2Utc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1pbmdVSU1lc3NhZ2VTdGF0ZSh7XG4gIGxhc3RNZXNzYWdlLFxuICBtZXNzYWdlSWRcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlOiAobGFzdE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RNZXNzYWdlLnJvbGUpID09PSBcImFzc2lzdGFudFwiID8gbGFzdE1lc3NhZ2UgOiB7XG4gICAgICBpZDogbWVzc2FnZUlkLFxuICAgICAgbWV0YWRhdGE6IHZvaWQgMCxcbiAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICBwYXJ0czogW11cbiAgICB9LFxuICAgIGFjdGl2ZVRleHRQYXJ0czoge30sXG4gICAgYWN0aXZlUmVhc29uaW5nUGFydHM6IHt9LFxuICAgIHBhcnRpYWxUb29sQ2FsbHM6IHt9XG4gIH07XG59XG5mdW5jdGlvbiBwcm9jZXNzVUlNZXNzYWdlU3RyZWFtKHtcbiAgc3RyZWFtLFxuICBtZXNzYWdlTWV0YWRhdGFTY2hlbWEsXG4gIGRhdGFQYXJ0U2NoZW1hcyxcbiAgcnVuVXBkYXRlTWVzc2FnZUpvYixcbiAgb25FcnJvcixcbiAgb25Ub29sQ2FsbCxcbiAgb25EYXRhXG59KSB7XG4gIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgYXdhaXQgcnVuVXBkYXRlTWVzc2FnZUpvYihhc3luYyAoeyBzdGF0ZSwgd3JpdGUgfSkgPT4ge1xuICAgICAgICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kO1xuICAgICAgICAgIGZ1bmN0aW9uIGdldFRvb2xJbnZvY2F0aW9uKHRvb2xDYWxsSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9ucyA9IHN0YXRlLm1lc3NhZ2UucGFydHMuZmlsdGVyKGlzVG9vbFVJUGFydCk7XG4gICAgICAgICAgICBjb25zdCB0b29sSW52b2NhdGlvbiA9IHRvb2xJbnZvY2F0aW9ucy5maW5kKFxuICAgICAgICAgICAgICAoaW52b2NhdGlvbikgPT4gaW52b2NhdGlvbi50b29sQ2FsbElkID09PSB0b29sQ2FsbElkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHRvb2xJbnZvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwidG9vbC1vdXRwdXQtZXJyb3IgbXVzdCBiZSBwcmVjZWRlZCBieSBhIHRvb2wtaW5wdXQtYXZhaWxhYmxlXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b29sSW52b2NhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gZ2V0RHluYW1pY1Rvb2xJbnZvY2F0aW9uKHRvb2xDYWxsSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9ucyA9IHN0YXRlLm1lc3NhZ2UucGFydHMuZmlsdGVyKFxuICAgICAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcImR5bmFtaWMtdG9vbFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb24gPSB0b29sSW52b2NhdGlvbnMuZmluZChcbiAgICAgICAgICAgICAgKGludm9jYXRpb24pID0+IGludm9jYXRpb24udG9vbENhbGxJZCA9PT0gdG9vbENhbGxJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh0b29sSW52b2NhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcInRvb2wtb3V0cHV0LWVycm9yIG11c3QgYmUgcHJlY2VkZWQgYnkgYSB0b29sLWlucHV0LWF2YWlsYWJsZVwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9vbEludm9jYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRvb2xQYXJ0KG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHN0YXRlLm1lc3NhZ2UucGFydHMuZmluZChcbiAgICAgICAgICAgICAgKHBhcnQyKSA9PiBpc1Rvb2xVSVBhcnQocGFydDIpICYmIHBhcnQyLnRvb2xDYWxsSWQgPT09IG9wdGlvbnMudG9vbENhbGxJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGFueU9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgYW55UGFydCA9IHBhcnQ7XG4gICAgICAgICAgICBpZiAocGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHBhcnQuc3RhdGUgPSBvcHRpb25zLnN0YXRlO1xuICAgICAgICAgICAgICBhbnlQYXJ0LmlucHV0ID0gYW55T3B0aW9ucy5pbnB1dDtcbiAgICAgICAgICAgICAgYW55UGFydC5vdXRwdXQgPSBhbnlPcHRpb25zLm91dHB1dDtcbiAgICAgICAgICAgICAgYW55UGFydC5lcnJvclRleHQgPSBhbnlPcHRpb25zLmVycm9yVGV4dDtcbiAgICAgICAgICAgICAgYW55UGFydC5yYXdJbnB1dCA9IGFueU9wdGlvbnMucmF3SW5wdXQ7XG4gICAgICAgICAgICAgIGFueVBhcnQucHJlbGltaW5hcnkgPSBhbnlPcHRpb25zLnByZWxpbWluYXJ5O1xuICAgICAgICAgICAgICBhbnlQYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgPSAoX2ExOCA9IGFueU9wdGlvbnMucHJvdmlkZXJFeGVjdXRlZCkgIT0gbnVsbCA/IF9hMTggOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQ7XG4gICAgICAgICAgICAgIGlmIChhbnlPcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCAmJiBwYXJ0LnN0YXRlID09PSBcImlucHV0LWF2YWlsYWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgcGFydC5jYWxsUHJvdmlkZXJNZXRhZGF0YSA9IGFueU9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBgdG9vbC0ke29wdGlvbnMudG9vbE5hbWV9YCxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBvcHRpb25zLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGFueU9wdGlvbnMuaW5wdXQsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBhbnlPcHRpb25zLm91dHB1dCxcbiAgICAgICAgICAgICAgICByYXdJbnB1dDogYW55T3B0aW9ucy5yYXdJbnB1dCxcbiAgICAgICAgICAgICAgICBlcnJvclRleHQ6IGFueU9wdGlvbnMuZXJyb3JUZXh0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGFueU9wdGlvbnMucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICBwcmVsaW1pbmFyeTogYW55T3B0aW9ucy5wcmVsaW1pbmFyeSxcbiAgICAgICAgICAgICAgICAuLi5hbnlPcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IGFueU9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUR5bmFtaWNUb29sUGFydChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBzdGF0ZS5tZXNzYWdlLnBhcnRzLmZpbmQoXG4gICAgICAgICAgICAgIChwYXJ0MikgPT4gcGFydDIudHlwZSA9PT0gXCJkeW5hbWljLXRvb2xcIiAmJiBwYXJ0Mi50b29sQ2FsbElkID09PSBvcHRpb25zLnRvb2xDYWxsSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBhbnlPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGFueVBhcnQgPSBwYXJ0O1xuICAgICAgICAgICAgaWYgKHBhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBwYXJ0LnN0YXRlID0gb3B0aW9ucy5zdGF0ZTtcbiAgICAgICAgICAgICAgYW55UGFydC50b29sTmFtZSA9IG9wdGlvbnMudG9vbE5hbWU7XG4gICAgICAgICAgICAgIGFueVBhcnQuaW5wdXQgPSBhbnlPcHRpb25zLmlucHV0O1xuICAgICAgICAgICAgICBhbnlQYXJ0Lm91dHB1dCA9IGFueU9wdGlvbnMub3V0cHV0O1xuICAgICAgICAgICAgICBhbnlQYXJ0LmVycm9yVGV4dCA9IGFueU9wdGlvbnMuZXJyb3JUZXh0O1xuICAgICAgICAgICAgICBhbnlQYXJ0LnJhd0lucHV0ID0gKF9hMTggPSBhbnlPcHRpb25zLnJhd0lucHV0KSAhPSBudWxsID8gX2ExOCA6IGFueVBhcnQucmF3SW5wdXQ7XG4gICAgICAgICAgICAgIGFueVBhcnQucHJlbGltaW5hcnkgPSBhbnlPcHRpb25zLnByZWxpbWluYXJ5O1xuICAgICAgICAgICAgICBpZiAoYW55T3B0aW9ucy5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgJiYgcGFydC5zdGF0ZSA9PT0gXCJpbnB1dC1hdmFpbGFibGVcIikge1xuICAgICAgICAgICAgICAgIHBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgPSBhbnlPcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJkeW5hbWljLXRvb2xcIixcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogb3B0aW9ucy50b29sTmFtZSxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBvcHRpb25zLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGFueU9wdGlvbnMuaW5wdXQsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBhbnlPcHRpb25zLm91dHB1dCxcbiAgICAgICAgICAgICAgICBlcnJvclRleHQ6IGFueU9wdGlvbnMuZXJyb3JUZXh0LFxuICAgICAgICAgICAgICAgIHByZWxpbWluYXJ5OiBhbnlPcHRpb25zLnByZWxpbWluYXJ5LFxuICAgICAgICAgICAgICAgIC4uLmFueU9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBjYWxsUHJvdmlkZXJNZXRhZGF0YTogYW55T3B0aW9ucy5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXN5bmMgZnVuY3Rpb24gdXBkYXRlTWVzc2FnZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCBtZXJnZWRNZXRhZGF0YSA9IHN0YXRlLm1lc3NhZ2UubWV0YWRhdGEgIT0gbnVsbCA/IG1lcmdlT2JqZWN0cyhzdGF0ZS5tZXNzYWdlLm1ldGFkYXRhLCBtZXRhZGF0YSkgOiBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VNZXRhZGF0YVNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdmFsaWRhdGVUeXBlcyh7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogbWVyZ2VkTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICBzY2hlbWE6IG1lc3NhZ2VNZXRhZGF0YVNjaGVtYVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UubWV0YWRhdGEgPSBtZXJnZWRNZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dC1zdGFydFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRleHRQYXJ0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJzdHJlYW1pbmdcIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0UGFydHNbY2h1bmsuaWRdID0gdGV4dFBhcnQ7XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaCh0ZXh0UGFydCk7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjoge1xuICAgICAgICAgICAgICBjb25zdCB0ZXh0UGFydCA9IHN0YXRlLmFjdGl2ZVRleHRQYXJ0c1tjaHVuay5pZF07XG4gICAgICAgICAgICAgIHRleHRQYXJ0LnRleHQgKz0gY2h1bmsuZGVsdGE7XG4gICAgICAgICAgICAgIHRleHRQYXJ0LnByb3ZpZGVyTWV0YWRhdGEgPSAoX2ExNyA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYTE3IDogdGV4dFBhcnQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGV4dC1lbmRcIjoge1xuICAgICAgICAgICAgICBjb25zdCB0ZXh0UGFydCA9IHN0YXRlLmFjdGl2ZVRleHRQYXJ0c1tjaHVuay5pZF07XG4gICAgICAgICAgICAgIHRleHRQYXJ0LnN0YXRlID0gXCJkb25lXCI7XG4gICAgICAgICAgICAgIHRleHRQYXJ0LnByb3ZpZGVyTWV0YWRhdGEgPSAoX2IgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2IgOiB0ZXh0UGFydC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuYWN0aXZlVGV4dFBhcnRzW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLXN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVhc29uaW5nUGFydCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJzdHJlYW1pbmdcIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0c1tjaHVuay5pZF0gPSByZWFzb25pbmdQYXJ0O1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2gocmVhc29uaW5nUGFydCk7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlYXNvbmluZ1BhcnQgPSBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0c1tjaHVuay5pZF07XG4gICAgICAgICAgICAgIHJlYXNvbmluZ1BhcnQudGV4dCArPSBjaHVuay5kZWx0YTtcbiAgICAgICAgICAgICAgcmVhc29uaW5nUGFydC5wcm92aWRlck1ldGFkYXRhID0gKF9jID0gY2h1bmsucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9jIDogcmVhc29uaW5nUGFydC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmctZW5kXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVhc29uaW5nUGFydCA9IHN0YXRlLmFjdGl2ZVJlYXNvbmluZ1BhcnRzW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgcmVhc29uaW5nUGFydC5wcm92aWRlck1ldGFkYXRhID0gKF9kID0gY2h1bmsucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9kIDogcmVhc29uaW5nUGFydC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICByZWFzb25pbmdQYXJ0LnN0YXRlID0gXCJkb25lXCI7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0c1tjaHVuay5pZF07XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogY2h1bmsubWVkaWFUeXBlLFxuICAgICAgICAgICAgICAgIHVybDogY2h1bmsudXJsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzb3VyY2UtdXJsXCI6IHtcbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNvdXJjZS11cmxcIixcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogY2h1bmsuc291cmNlSWQsXG4gICAgICAgICAgICAgICAgdXJsOiBjaHVuay51cmwsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGNodW5rLnRpdGxlLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInNvdXJjZS1kb2N1bWVudFwiOiB7XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzb3VyY2UtZG9jdW1lbnRcIixcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogY2h1bmsuc291cmNlSWQsXG4gICAgICAgICAgICAgICAgbWVkaWFUeXBlOiBjaHVuay5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGNodW5rLnRpdGxlLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBjaHVuay5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LXN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb25zID0gc3RhdGUubWVzc2FnZS5wYXJ0cy5maWx0ZXIoaXNUb29sVUlQYXJ0KTtcbiAgICAgICAgICAgICAgc3RhdGUucGFydGlhbFRvb2xDYWxsc1tjaHVuay50b29sQ2FsbElkXSA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBpbmRleDogdG9vbEludm9jYXRpb25zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBkeW5hbWljOiBjaHVuay5keW5hbWljXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChjaHVuay5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJpbnB1dC1zdHJlYW1pbmdcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiB2b2lkIDBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiaW5wdXQtc3RyZWFtaW5nXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtZGVsdGFcIjoge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsVG9vbENhbGwgPSBzdGF0ZS5wYXJ0aWFsVG9vbENhbGxzW2NodW5rLnRvb2xDYWxsSWRdO1xuICAgICAgICAgICAgICBwYXJ0aWFsVG9vbENhbGwudGV4dCArPSBjaHVuay5pbnB1dFRleHREZWx0YTtcbiAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZTogcGFydGlhbEFyZ3MgfSA9IGF3YWl0IHBhcnNlUGFydGlhbEpzb24oXG4gICAgICAgICAgICAgICAgcGFydGlhbFRvb2xDYWxsLnRleHRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRpYWxUb29sQ2FsbC5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydGlhbFRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiaW5wdXQtc3RyZWFtaW5nXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogcGFydGlhbEFyZ3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnRpYWxUb29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcImlucHV0LXN0cmVhbWluZ1wiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnRpYWxBcmdzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1hdmFpbGFibGVcIjoge1xuICAgICAgICAgICAgICBpZiAoY2h1bmsuZHluYW1pYykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUR5bmFtaWNUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiaW5wdXQtYXZhaWxhYmxlXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogY2h1bmsuaW5wdXQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcImlucHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IGNodW5rLmlucHV0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBpZiAob25Ub29sQ2FsbCAmJiAhY2h1bmsucHJvdmlkZXJFeGVjdXRlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uVG9vbENhbGwoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGw6IGNodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1lcnJvclwiOiB7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJvdXRwdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBjaHVuay5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIGVycm9yVGV4dDogY2h1bmsuZXJyb3JUZXh0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVRvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJvdXRwdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICByYXdJbnB1dDogY2h1bmsuaW5wdXQsXG4gICAgICAgICAgICAgICAgICBlcnJvclRleHQ6IGNodW5rLmVycm9yVGV4dCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGNodW5rLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1vdXRwdXQtYXZhaWxhYmxlXCI6IHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLmR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sSW52b2NhdGlvbiA9IGdldER5bmFtaWNUb29sSW52b2NhdGlvbihcbiAgICAgICAgICAgICAgICAgIGNodW5rLnRvb2xDYWxsSWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUR5bmFtaWNUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xJbnZvY2F0aW9uLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwib3V0cHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xJbnZvY2F0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgICAgb3V0cHV0OiBjaHVuay5vdXRwdXQsXG4gICAgICAgICAgICAgICAgICBwcmVsaW1pbmFyeTogY2h1bmsucHJlbGltaW5hcnlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sSW52b2NhdGlvbiA9IGdldFRvb2xJbnZvY2F0aW9uKGNodW5rLnRvb2xDYWxsSWQpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVRvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogZ2V0VG9vbE5hbWUodG9vbEludm9jYXRpb24pLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwib3V0cHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xJbnZvY2F0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgICAgb3V0cHV0OiBjaHVuay5vdXRwdXQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBjaHVuay5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgICAgcHJlbGltaW5hcnk6IGNodW5rLnByZWxpbWluYXJ5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1vdXRwdXQtZXJyb3JcIjoge1xuICAgICAgICAgICAgICBpZiAoY2h1bmsuZHluYW1pYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9uID0gZ2V0RHluYW1pY1Rvb2xJbnZvY2F0aW9uKFxuICAgICAgICAgICAgICAgICAgY2h1bmsudG9vbENhbGxJZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbEludm9jYXRpb24udG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJvdXRwdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiB0b29sSW52b2NhdGlvbi5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIGVycm9yVGV4dDogY2h1bmsuZXJyb3JUZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb24gPSBnZXRUb29sSW52b2NhdGlvbihjaHVuay50b29sQ2FsbElkKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGdldFRvb2xOYW1lKHRvb2xJbnZvY2F0aW9uKSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIm91dHB1dC1lcnJvclwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xJbnZvY2F0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgICAgcmF3SW5wdXQ6IHRvb2xJbnZvY2F0aW9uLnJhd0lucHV0LFxuICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBjaHVuay5lcnJvclRleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdGFydC1zdGVwXCI6IHtcbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKHsgdHlwZTogXCJzdGVwLXN0YXJ0XCIgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmlzaC1zdGVwXCI6IHtcbiAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlVGV4dFBhcnRzID0ge307XG4gICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVJlYXNvbmluZ1BhcnRzID0ge307XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLm1lc3NhZ2VJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5pZCA9IGNodW5rLm1lc3NhZ2VJZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVNZXNzYWdlTWV0YWRhdGEoY2h1bmsubWVzc2FnZU1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLm1lc3NhZ2VJZCAhPSBudWxsIHx8IGNodW5rLm1lc3NhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVNZXNzYWdlTWV0YWRhdGEoY2h1bmsubWVzc2FnZU1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLm1lc3NhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlLW1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlTWVzc2FnZU1ldGFkYXRhKGNodW5rLm1lc3NhZ2VNZXRhZGF0YSk7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5tZXNzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgICAgICBvbkVycm9yID09IG51bGwgPyB2b2lkIDAgOiBvbkVycm9yKG5ldyBFcnJvcihjaHVuay5lcnJvclRleHQpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIGlmIChpc0RhdGFVSU1lc3NhZ2VDaHVuayhjaHVuaykpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGRhdGFQYXJ0U2NoZW1hcyA9PSBudWxsID8gdm9pZCAwIDogZGF0YVBhcnRTY2hlbWFzW2NodW5rLnR5cGVdKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBhd2FpdCB2YWxpZGF0ZVR5cGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogZGF0YVBhcnRTY2hlbWFzW2NodW5rLnR5cGVdXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YUNodW5rID0gY2h1bms7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFDaHVuay50cmFuc2llbnQpIHtcbiAgICAgICAgICAgICAgICAgIG9uRGF0YSA9PSBudWxsID8gdm9pZCAwIDogb25EYXRhKGRhdGFDaHVuayk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdVSVBhcnQgPSBkYXRhQ2h1bmsuaWQgIT0gbnVsbCA/IHN0YXRlLm1lc3NhZ2UucGFydHMuZmluZChcbiAgICAgICAgICAgICAgICAgIChjaHVua0FyZykgPT4gZGF0YUNodW5rLnR5cGUgPT09IGNodW5rQXJnLnR5cGUgJiYgZGF0YUNodW5rLmlkID09PSBjaHVua0FyZy5pZFxuICAgICAgICAgICAgICAgICkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVUlQYXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVUlQYXJ0LmRhdGEgPSBkYXRhQ2h1bmsuZGF0YTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKGRhdGFDaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uRGF0YSA9PSBudWxsID8gdm9pZCAwIDogb25EYXRhKGRhdGFDaHVuayk7XG4gICAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vaGFuZGxlLXVpLW1lc3NhZ2Utc3RyZWFtLWZpbmlzaC50c1xuZnVuY3Rpb24gaGFuZGxlVUlNZXNzYWdlU3RyZWFtRmluaXNoKHtcbiAgbWVzc2FnZUlkLFxuICBvcmlnaW5hbE1lc3NhZ2VzID0gW10sXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBzdHJlYW1cbn0pIHtcbiAgbGV0IGxhc3RNZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlcyA9PSBudWxsID8gdm9pZCAwIDogb3JpZ2luYWxNZXNzYWdlc1tvcmlnaW5hbE1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICBpZiAoKGxhc3RNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TWVzc2FnZS5yb2xlKSAhPT0gXCJhc3Npc3RhbnRcIikge1xuICAgIGxhc3RNZXNzYWdlID0gdm9pZCAwO1xuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2VJZCA9IGxhc3RNZXNzYWdlLmlkO1xuICB9XG4gIGxldCBpc0Fib3J0ZWQgPSBmYWxzZTtcbiAgY29uc3QgaWRJbmplY3RlZFN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRDaHVuayA9IGNodW5rO1xuICAgICAgICAgIGlmIChzdGFydENodW5rLm1lc3NhZ2VJZCA9PSBudWxsICYmIG1lc3NhZ2VJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydENodW5rLm1lc3NhZ2VJZCA9IG1lc3NhZ2VJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwiYWJvcnRcIikge1xuICAgICAgICAgIGlzQWJvcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xuICBpZiAob25GaW5pc2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBpZEluamVjdGVkU3RyZWFtO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gY3JlYXRlU3RyZWFtaW5nVUlNZXNzYWdlU3RhdGUoe1xuICAgIGxhc3RNZXNzYWdlOiBsYXN0TWVzc2FnZSA/IHN0cnVjdHVyZWRDbG9uZShsYXN0TWVzc2FnZSkgOiB2b2lkIDAsXG4gICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQgIT0gbnVsbCA/IG1lc3NhZ2VJZCA6IFwiXCJcbiAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHN0cmVhbVxuICB9KTtcbiAgY29uc3QgcnVuVXBkYXRlTWVzc2FnZUpvYiA9IGFzeW5jIChqb2IpID0+IHtcbiAgICBhd2FpdCBqb2IoeyBzdGF0ZSwgd3JpdGU6ICgpID0+IHtcbiAgICB9IH0pO1xuICB9O1xuICBsZXQgZmluaXNoQ2FsbGVkID0gZmFsc2U7XG4gIGNvbnN0IGNhbGxPbkZpbmlzaCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoZmluaXNoQ2FsbGVkIHx8ICFvbkZpbmlzaCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaW5pc2hDYWxsZWQgPSB0cnVlO1xuICAgIGNvbnN0IGlzQ29udGludWF0aW9uID0gc3RhdGUubWVzc2FnZS5pZCA9PT0gKGxhc3RNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TWVzc2FnZS5pZCk7XG4gICAgYXdhaXQgb25GaW5pc2goe1xuICAgICAgaXNBYm9ydGVkLFxuICAgICAgaXNDb250aW51YXRpb24sXG4gICAgICByZXNwb25zZU1lc3NhZ2U6IHN0YXRlLm1lc3NhZ2UsXG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICAuLi5pc0NvbnRpbnVhdGlvbiA/IG9yaWdpbmFsTWVzc2FnZXMuc2xpY2UoMCwgLTEpIDogb3JpZ2luYWxNZXNzYWdlcyxcbiAgICAgICAgc3RhdGUubWVzc2FnZVxuICAgICAgXVxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gcHJvY2Vzc1VJTWVzc2FnZVN0cmVhbSh7XG4gICAgc3RyZWFtOiBpZEluamVjdGVkU3RyZWFtLFxuICAgIHJ1blVwZGF0ZU1lc3NhZ2VKb2IsXG4gICAgb25FcnJvclxuICB9KS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2FuY2VsIGlzIHN0aWxsIG5ldyBhbmQgbWlzc2luZyBmcm9tIHR5cGVzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2Zvcm1TdHJlYW0jYnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gICAgICBhc3luYyBjYW5jZWwoKSB7XG4gICAgICAgIGF3YWl0IGNhbGxPbkZpbmlzaCgpO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKCkge1xuICAgICAgICBhd2FpdCBjYWxsT25GaW5pc2goKTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vcGlwZS11aS1tZXNzYWdlLXN0cmVhbS10by1yZXNwb25zZS50c1xuZnVuY3Rpb24gcGlwZVVJTWVzc2FnZVN0cmVhbVRvUmVzcG9uc2Uoe1xuICByZXNwb25zZSxcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBoZWFkZXJzLFxuICBzdHJlYW0sXG4gIGNvbnN1bWVTc2VTdHJlYW1cbn0pIHtcbiAgbGV0IHNzZVN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChuZXcgSnNvblRvU3NlVHJhbnNmb3JtU3RyZWFtKCkpO1xuICBpZiAoY29uc3VtZVNzZVN0cmVhbSkge1xuICAgIGNvbnN0IFtzdHJlYW0xLCBzdHJlYW0yXSA9IHNzZVN0cmVhbS50ZWUoKTtcbiAgICBzc2VTdHJlYW0gPSBzdHJlYW0xO1xuICAgIGNvbnN1bWVTc2VTdHJlYW0oeyBzdHJlYW06IHN0cmVhbTIgfSk7XG4gIH1cbiAgd3JpdGVUb1NlcnZlclJlc3BvbnNlKHtcbiAgICByZXNwb25zZSxcbiAgICBzdGF0dXMsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBwcmVwYXJlSGVhZGVycyhoZWFkZXJzLCBVSV9NRVNTQUdFX1NUUkVBTV9IRUFERVJTKS5lbnRyaWVzKClcbiAgICApLFxuICAgIHN0cmVhbTogc3NlU3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKVxuICB9KTtcbn1cblxuLy8gc3JjL3V0aWwvYXN5bmMtaXRlcmFibGUtc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHNvdXJjZSkge1xuICBjb25zdCBzdHJlYW0gPSBzb3VyY2UucGlwZVRocm91Z2gobmV3IFRyYW5zZm9ybVN0cmVhbSgpKTtcbiAgc3RyZWFtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMuZ2V0UmVhZGVyKCk7XG4gICAgbGV0IGZpbmlzaGVkID0gZmFsc2U7XG4gICAgYXN5bmMgZnVuY3Rpb24gY2xlYW51cChjYW5jZWxTdHJlYW0pIHtcbiAgICAgIHZhciBfYTE3O1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGNhbmNlbFN0cmVhbSkge1xuICAgICAgICAgIGF3YWl0ICgoX2ExNyA9IHJlYWRlci5jYW5jZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNhbGwocmVhZGVyKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBSZWFkcyB0aGUgbmV4dCBjaHVuayBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBuZXh0IEl0ZXJhdG9yUmVzdWx0LlxuICAgICAgICovXG4gICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdm9pZCAwIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBhd2FpdCBjbGVhbnVwKHRydWUpO1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB2b2lkIDAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWUgfTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCBvbiBlYXJseSBleGl0IChlLmcuLCBicmVhayBmcm9tIGZvci1hd2FpdCkuXG4gICAgICAgKiBFbnN1cmVzIHRoZSBzdHJlYW0gaXMgY2FuY2VsbGVkIGFuZCByZXNvdXJjZXMgYXJlIHJlbGVhc2VkLlxuICAgICAgICogQHJldHVybnMgQSBwcm9taXNlIHJlc29sdmluZyB0byBhIGNvbXBsZXRlZCBJdGVyYXRvclJlc3VsdC5cbiAgICAgICAqL1xuICAgICAgYXN5bmMgcmV0dXJuKCkge1xuICAgICAgICBhd2FpdCBjbGVhbnVwKHRydWUpO1xuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdm9pZCAwIH07XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgb24gZWFybHkgZXhpdCB3aXRoIGVycm9yLlxuICAgICAgICogRW5zdXJlcyB0aGUgc3RyZWFtIGlzIGNhbmNlbGxlZCBhbmQgcmVzb3VyY2VzIGFyZSByZWxlYXNlZCwgdGhlbiByZXRocm93cyB0aGUgZXJyb3IuXG4gICAgICAgKiBAcGFyYW0gZXJyIFRoZSBlcnJvciB0byB0aHJvdy5cbiAgICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2l0aCB0aGUgcHJvdmlkZWQgZXJyb3IuXG4gICAgICAgKi9cbiAgICAgIGFzeW5jIHRocm93KGVycikge1xuICAgICAgICBhd2FpdCBjbGVhbnVwKHRydWUpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuLy8gc3JjL3V0aWwvY29uc3VtZS1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVTdHJlYW0oe1xuICBzdHJlYW0sXG4gIG9uRXJyb3Jcbn0pIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICB0cnkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSlcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIG9uRXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRXJyb3IoZXJyb3IpO1xuICB9IGZpbmFsbHkge1xuICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICB9XG59XG5cbi8vIHNyYy91dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZTI7XG4gIGxldCByZWplY3Q7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlMiA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgcmVzb2x2ZTogcmVzb2x2ZTIsXG4gICAgcmVqZWN0XG4gIH07XG59XG5cbi8vIHNyYy91dGlsL2NyZWF0ZS1zdGl0Y2hhYmxlLXN0cmVhbS50c1xuZnVuY3Rpb24gY3JlYXRlU3RpdGNoYWJsZVN0cmVhbSgpIHtcbiAgbGV0IGlubmVyU3RyZWFtUmVhZGVycyA9IFtdO1xuICBsZXQgY29udHJvbGxlciA9IG51bGw7XG4gIGxldCBpc0Nsb3NlZCA9IGZhbHNlO1xuICBsZXQgd2FpdEZvck5ld1N0cmVhbSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gIGNvbnN0IHRlcm1pbmF0ZSA9ICgpID0+IHtcbiAgICBpc0Nsb3NlZCA9IHRydWU7XG4gICAgd2FpdEZvck5ld1N0cmVhbS5yZXNvbHZlKCk7XG4gICAgaW5uZXJTdHJlYW1SZWFkZXJzLmZvckVhY2goKHJlYWRlcikgPT4gcmVhZGVyLmNhbmNlbCgpKTtcbiAgICBpbm5lclN0cmVhbVJlYWRlcnMgPSBbXTtcbiAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NQdWxsID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0Nsb3NlZCAmJiBpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB3YWl0Rm9yTmV3U3RyZWFtID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICAgIGF3YWl0IHdhaXRGb3JOZXdTdHJlYW0ucHJvbWlzZTtcbiAgICAgIHJldHVybiBwcm9jZXNzUHVsbCgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaW5uZXJTdHJlYW1SZWFkZXJzWzBdLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGlubmVyU3RyZWFtUmVhZGVycy5zaGlmdCgpO1xuICAgICAgICBpZiAoaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhd2FpdCBwcm9jZXNzUHVsbCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ2xvc2VkKSB7XG4gICAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgIGlubmVyU3RyZWFtUmVhZGVycy5zaGlmdCgpO1xuICAgICAgdGVybWluYXRlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHN0cmVhbTogbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0KGNvbnRyb2xsZXJQYXJhbSkge1xuICAgICAgICBjb250cm9sbGVyID0gY29udHJvbGxlclBhcmFtO1xuICAgICAgfSxcbiAgICAgIHB1bGw6IHByb2Nlc3NQdWxsLFxuICAgICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiBpbm5lclN0cmVhbVJlYWRlcnMpIHtcbiAgICAgICAgICBhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzID0gW107XG4gICAgICAgIGlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBhZGRTdHJlYW06IChpbm5lclN0cmVhbSkgPT4ge1xuICAgICAgaWYgKGlzQ2xvc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgaW5uZXIgc3RyZWFtOiBvdXRlciBzdHJlYW0gaXMgY2xvc2VkXCIpO1xuICAgICAgfVxuICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzLnB1c2goaW5uZXJTdHJlYW0uZ2V0UmVhZGVyKCkpO1xuICAgICAgd2FpdEZvck5ld1N0cmVhbS5yZXNvbHZlKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHcmFjZWZ1bGx5IGNsb3NlIHRoZSBvdXRlciBzdHJlYW0uIFRoaXMgd2lsbCBsZXQgdGhlIGlubmVyIHN0cmVhbXNcbiAgICAgKiBmaW5pc2ggcHJvY2Vzc2luZyBhbmQgdGhlbiBjbG9zZSB0aGUgb3V0ZXIgc3RyZWFtLlxuICAgICAqL1xuICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICBpc0Nsb3NlZCA9IHRydWU7XG4gICAgICB3YWl0Rm9yTmV3U3RyZWFtLnJlc29sdmUoKTtcbiAgICAgIGlmIChpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IGNsb3NlIHRoZSBvdXRlciBzdHJlYW0uIFRoaXMgd2lsbCBjYW5jZWwgYWxsIGlubmVyIHN0cmVhbXNcbiAgICAgKiBhbmQgY2xvc2UgdGhlIG91dGVyIHN0cmVhbS5cbiAgICAgKi9cbiAgICB0ZXJtaW5hdGVcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWwvZGVsYXllZC1wcm9taXNlLnRzXG52YXIgRGVsYXllZFByb21pc2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInBlbmRpbmdcIiB9O1xuICAgIHRoaXMuX3Jlc29sdmUgPSB2b2lkIDA7XG4gICAgdGhpcy5fcmVqZWN0ID0gdm9pZCAwO1xuICB9XG4gIGdldCBwcm9taXNlKCkge1xuICAgIGlmICh0aGlzLl9wcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlMiwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0dXMudHlwZSA9PT0gXCJyZXNvbHZlZFwiKSB7XG4gICAgICAgIHJlc29sdmUyKHRoaXMuc3RhdHVzLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMudHlwZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgIHJlamVjdCh0aGlzLnN0YXR1cy5lcnJvcik7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTI7XG4gICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gIH1cbiAgcmVzb2x2ZSh2YWx1ZSkge1xuICAgIHZhciBfYTE3O1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInJlc29sdmVkXCIsIHZhbHVlIH07XG4gICAgaWYgKHRoaXMuX3Byb21pc2UpIHtcbiAgICAgIChfYTE3ID0gdGhpcy5fcmVzb2x2ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJlamVjdChlcnJvcikge1xuICAgIHZhciBfYTE3O1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInJlamVjdGVkXCIsIGVycm9yIH07XG4gICAgaWYgKHRoaXMuX3Byb21pc2UpIHtcbiAgICAgIChfYTE3ID0gdGhpcy5fcmVqZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy91dGlsL25vdy50c1xuZnVuY3Rpb24gbm93KCkge1xuICB2YXIgX2ExNywgX2I7XG4gIHJldHVybiAoX2IgPSAoX2ExNyA9IGdsb2JhbFRoaXMgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMucGVyZm9ybWFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3Lm5vdygpKSAhPSBudWxsID8gX2IgOiBEYXRlLm5vdygpO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9ydW4tdG9vbHMtdHJhbnNmb3JtYXRpb24udHNcbmltcG9ydCB7XG4gIGV4ZWN1dGVUb29sIGFzIGV4ZWN1dGVUb29sMixcbiAgZ2VuZXJhdGVJZCxcbiAgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTZcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICB0b29scyxcbiAgZ2VuZXJhdG9yU3RyZWFtLFxuICB0cmFjZXIsXG4gIHRlbGVtZXRyeSxcbiAgc3lzdGVtLFxuICBtZXNzYWdlcyxcbiAgYWJvcnRTaWduYWwsXG4gIHJlcGFpclRvb2xDYWxsLFxuICBleHBlcmltZW50YWxfY29udGV4dFxufSkge1xuICBsZXQgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyID0gbnVsbDtcbiAgY29uc3QgdG9vbFJlc3VsdHNTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgb3V0c3RhbmRpbmdUb29sUmVzdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHRvb2xJbnB1dHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgbGV0IGZpbmlzaENodW5rID0gdm9pZCAwO1xuICBmdW5jdGlvbiBhdHRlbXB0Q2xvc2UoKSB7XG4gICAgaWYgKGNhbkNsb3NlICYmIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgaWYgKGZpbmlzaENodW5rICE9IG51bGwpIHtcbiAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoZmluaXNoQ2h1bmspO1xuICAgICAgfVxuICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZvcndhcmRTdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rLnR5cGU7XG4gICAgICBzd2l0Y2ggKGNodW5rVHlwZSkge1xuICAgICAgICBjYXNlIFwic3RyZWFtLXN0YXJ0XCI6XG4gICAgICAgIGNhc2UgXCJ0ZXh0LXN0YXJ0XCI6XG4gICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgIGNhc2UgXCJ0ZXh0LWVuZFwiOlxuICAgICAgICBjYXNlIFwicmVhc29uaW5nLXN0YXJ0XCI6XG4gICAgICAgIGNhc2UgXCJyZWFzb25pbmctZGVsdGFcIjpcbiAgICAgICAgY2FzZSBcInJlYXNvbmluZy1lbmRcIjpcbiAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtc3RhcnRcIjpcbiAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtZGVsdGFcIjpcbiAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtZW5kXCI6XG4gICAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6XG4gICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICBjYXNlIFwicmF3XCI6IHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICBmaWxlOiBuZXcgRGVmYXVsdEdlbmVyYXRlZEZpbGVXaXRoVHlwZSh7XG4gICAgICAgICAgICAgIGRhdGE6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICAgIG1lZGlhVHlwZTogY2h1bmsubWVkaWFUeXBlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgIGZpbmlzaENodW5rID0ge1xuICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY2h1bmsuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgdXNhZ2U6IGNodW5rLnVzYWdlLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gYXdhaXQgcGFyc2VUb29sQ2FsbCh7XG4gICAgICAgICAgICAgIHRvb2xDYWxsOiBjaHVuayxcbiAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgIHJlcGFpclRvb2xDYWxsLFxuICAgICAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0b29sQ2FsbCk7XG4gICAgICAgICAgICBpZiAodG9vbENhbGwuaW52YWxpZCkge1xuICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWVycm9yXCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xDYWxsLmlucHV0LFxuICAgICAgICAgICAgICAgIGVycm9yOiBnZXRFcnJvck1lc3NhZ2U2KHRvb2xDYWxsLmVycm9yKSxcbiAgICAgICAgICAgICAgICBkeW5hbWljOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRvb2wzID0gdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdO1xuICAgICAgICAgICAgdG9vbElucHV0cy5zZXQodG9vbENhbGwudG9vbENhbGxJZCwgdG9vbENhbGwuaW5wdXQpO1xuICAgICAgICAgICAgaWYgKHRvb2wzLm9uSW5wdXRBdmFpbGFibGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBhd2FpdCB0b29sMy5vbklucHV0QXZhaWxhYmxlKHtcbiAgICAgICAgICAgICAgICBpbnB1dDogdG9vbENhbGwuaW5wdXQsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlcyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b29sMy5leGVjdXRlICE9IG51bGwgJiYgdG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBjb25zdCB0b29sRXhlY3V0aW9uSWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuYWRkKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5uYW1lXCI6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLmlkXCI6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwuYXJnc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sQ2FsbC5pbnB1dClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBleGVjdXRlVG9vbDIoe1xuICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGU6IHRvb2wzLmV4ZWN1dGUuYmluZCh0b29sMyksXG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xDYWxsLmlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udG9vbENhbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IHBhcnQub3V0cHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucGFydC50eXBlID09PSBcInByZWxpbWluYXJ5XCIgJiYge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVsaW1pbmFyeTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiZmluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gcGFydC5vdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmRFcnJvck9uU3BhbihzcGFuLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi50b29sQ2FsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sUmVzdWx0cy5kZWxldGUodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdENsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuZGVsZXRlKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgICAgICBhdHRlbXB0Q2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob3V0cHV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgY29uc3QgdG9vbE5hbWUgPSBjaHVuay50b29sTmFtZTtcbiAgICAgICAgICBpZiAoY2h1bmsuaXNFcnJvcikge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtZXJyb3JcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgIGlucHV0OiB0b29sSW5wdXRzLmdldChjaHVuay50b29sQ2FsbElkKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgZXJyb3I6IGNodW5rLnJlc3VsdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgIGlucHV0OiB0b29sSW5wdXRzLmdldChjaHVuay50b29sQ2FsbElkKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiBjaHVuay5yZXN1bHQsXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGNodW5rLnByb3ZpZGVyRXhlY3V0ZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rVHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZsdXNoKCkge1xuICAgICAgY2FuQ2xvc2UgPSB0cnVlO1xuICAgICAgYXR0ZW1wdENsb3NlKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2VuZXJhdG9yU3RyZWFtLnBpcGVUaHJvdWdoKGZvcndhcmRTdHJlYW0pLnBpcGVUbyhcbiAgICAgICAgICBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICB0b29sUmVzdWx0c1N0cmVhbS5waXBlVG8oXG4gICAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICBdKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9zdHJlYW0tdGV4dC50c1xudmFyIG9yaWdpbmFsR2VuZXJhdGVJZDIgPSBjcmVhdGVJZEdlbmVyYXRvcjIoe1xuICBwcmVmaXg6IFwiYWl0eHRcIixcbiAgc2l6ZTogMjRcbn0pO1xuZnVuY3Rpb24gc3RyZWFtVGV4dCh7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgc3RvcFdoZW4gPSBzdGVwQ291bnRJcygxKSxcbiAgZXhwZXJpbWVudGFsX291dHB1dDogb3V0cHV0LFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gIHByZXBhcmVTdGVwLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIGV4cGVyaW1lbnRhbF9hY3RpdmVUb29scyxcbiAgYWN0aXZlVG9vbHMgPSBleHBlcmltZW50YWxfYWN0aXZlVG9vbHMsXG4gIGV4cGVyaW1lbnRhbF9yZXBhaXJUb29sQ2FsbDogcmVwYWlyVG9vbENhbGwsXG4gIGV4cGVyaW1lbnRhbF90cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgZXhwZXJpbWVudGFsX2Rvd25sb2FkOiBkb3dubG9hZDIsXG4gIGluY2x1ZGVSYXdDaHVua3MgPSBmYWxzZSxcbiAgb25DaHVuayxcbiAgb25FcnJvciA9ICh7IGVycm9yIH0pID0+IHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgfSxcbiAgb25GaW5pc2gsXG4gIG9uQWJvcnQsXG4gIG9uU3RlcEZpbmlzaCxcbiAgZXhwZXJpbWVudGFsX2NvbnRleHQsXG4gIF9pbnRlcm5hbDoge1xuICAgIG5vdzogbm93MiA9IG5vdyxcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZDIsXG4gICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICB9ID0ge30sXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIHJldHVybiBuZXcgRGVmYXVsdFN0cmVhbVRleHRSZXN1bHQoe1xuICAgIG1vZGVsOiByZXNvbHZlTGFuZ3VhZ2VNb2RlbChtb2RlbCksXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3MsXG4gICAgbWF4UmV0cmllcyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIHRvb2xzLFxuICAgIHRvb2xDaG9pY2UsXG4gICAgdHJhbnNmb3JtczogYXNBcnJheSh0cmFuc2Zvcm0pLFxuICAgIGFjdGl2ZVRvb2xzLFxuICAgIHJlcGFpclRvb2xDYWxsLFxuICAgIHN0b3BDb25kaXRpb25zOiBhc0FycmF5KHN0b3BXaGVuKSxcbiAgICBvdXRwdXQsXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIHByZXBhcmVTdGVwLFxuICAgIGluY2x1ZGVSYXdDaHVua3MsXG4gICAgb25DaHVuayxcbiAgICBvbkVycm9yLFxuICAgIG9uRmluaXNoLFxuICAgIG9uQWJvcnQsXG4gICAgb25TdGVwRmluaXNoLFxuICAgIG5vdzogbm93MixcbiAgICBjdXJyZW50RGF0ZSxcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyxcbiAgICBleHBlcmltZW50YWxfY29udGV4dCxcbiAgICBkb3dubG9hZDogZG93bmxvYWQyXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlT3V0cHV0VHJhbnNmb3JtU3RyZWFtKG91dHB1dCkge1xuICBpZiAoIW91dHB1dCkge1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyBwYXJ0OiBjaHVuaywgcGFydGlhbE91dHB1dDogdm9pZCAwIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGxldCBmaXJzdFRleHRDaHVua0lkID0gdm9pZCAwO1xuICBsZXQgdGV4dDIgPSBcIlwiO1xuICBsZXQgdGV4dENodW5rID0gXCJcIjtcbiAgbGV0IGxhc3RQdWJsaXNoZWRKc29uID0gXCJcIjtcbiAgZnVuY3Rpb24gcHVibGlzaFRleHRDaHVuayh7XG4gICAgY29udHJvbGxlcixcbiAgICBwYXJ0aWFsT3V0cHV0ID0gdm9pZCAwXG4gIH0pIHtcbiAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgcGFydDoge1xuICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgaWQ6IGZpcnN0VGV4dENodW5rSWQsXG4gICAgICAgIHRleHQ6IHRleHRDaHVua1xuICAgICAgfSxcbiAgICAgIHBhcnRpYWxPdXRwdXRcbiAgICB9KTtcbiAgICB0ZXh0Q2h1bmsgPSBcIlwiO1xuICB9XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChjaHVuay50eXBlID09PSBcImZpbmlzaC1zdGVwXCIgJiYgdGV4dENodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcHVibGlzaFRleHRDaHVuayh7IGNvbnRyb2xsZXIgfSk7XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LWRlbHRhXCIgJiYgY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LXN0YXJ0XCIgJiYgY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LWVuZFwiKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHBhcnQ6IGNodW5rLCBwYXJ0aWFsT3V0cHV0OiB2b2lkIDAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdFRleHRDaHVua0lkID09IG51bGwpIHtcbiAgICAgICAgZmlyc3RUZXh0Q2h1bmtJZCA9IGNodW5rLmlkO1xuICAgICAgfSBlbHNlIGlmIChjaHVuay5pZCAhPT0gZmlyc3RUZXh0Q2h1bmtJZCkge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyBwYXJ0OiBjaHVuaywgcGFydGlhbE91dHB1dDogdm9pZCAwIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LXN0YXJ0XCIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgcGFydDogY2h1bmssIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMCB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1lbmRcIikge1xuICAgICAgICBpZiAodGV4dENodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwdWJsaXNoVGV4dENodW5rKHsgY29udHJvbGxlciB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyBwYXJ0OiBjaHVuaywgcGFydGlhbE91dHB1dDogdm9pZCAwIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0ZXh0MiArPSBjaHVuay50ZXh0O1xuICAgICAgdGV4dENodW5rICs9IGNodW5rLnRleHQ7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvdXRwdXQucGFyc2VQYXJ0aWFsKHsgdGV4dDogdGV4dDIgfSk7XG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEpzb24gPSBKU09OLnN0cmluZ2lmeShyZXN1bHQucGFydGlhbCk7XG4gICAgICAgIGlmIChjdXJyZW50SnNvbiAhPT0gbGFzdFB1Ymxpc2hlZEpzb24pIHtcbiAgICAgICAgICBwdWJsaXNoVGV4dENodW5rKHsgY29udHJvbGxlciwgcGFydGlhbE91dHB1dDogcmVzdWx0LnBhcnRpYWwgfSk7XG4gICAgICAgICAgbGFzdFB1Ymxpc2hlZEpzb24gPSBjdXJyZW50SnNvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdFN0cmVhbVRleHRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5ncyxcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsLFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgdG9vbHMsXG4gICAgdG9vbENob2ljZSxcbiAgICB0cmFuc2Zvcm1zLFxuICAgIGFjdGl2ZVRvb2xzLFxuICAgIHJlcGFpclRvb2xDYWxsLFxuICAgIHN0b3BDb25kaXRpb25zLFxuICAgIG91dHB1dCxcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgcHJlcGFyZVN0ZXAsXG4gICAgaW5jbHVkZVJhd0NodW5rcyxcbiAgICBub3c6IG5vdzIsXG4gICAgY3VycmVudERhdGUsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMsXG4gICAgb25DaHVuayxcbiAgICBvbkVycm9yLFxuICAgIG9uRmluaXNoLFxuICAgIG9uQWJvcnQsXG4gICAgb25TdGVwRmluaXNoLFxuICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICAgIGRvd25sb2FkOiBkb3dubG9hZDJcbiAgfSkge1xuICAgIHRoaXMuX3RvdGFsVXNhZ2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLl9maW5pc2hSZWFzb24gPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLl9zdGVwcyA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMub3V0cHV0ID0gb3V0cHV0O1xuICAgIHRoaXMuaW5jbHVkZVJhd0NodW5rcyA9IGluY2x1ZGVSYXdDaHVua3M7XG4gICAgdGhpcy50b29scyA9IHRvb2xzO1xuICAgIGxldCBzdGVwRmluaXNoO1xuICAgIGxldCByZWNvcmRlZENvbnRlbnQgPSBbXTtcbiAgICBjb25zdCByZWNvcmRlZFJlc3BvbnNlTWVzc2FnZXMgPSBbXTtcbiAgICBsZXQgcmVjb3JkZWRGaW5pc2hSZWFzb24gPSB2b2lkIDA7XG4gICAgbGV0IHJlY29yZGVkVG90YWxVc2FnZSA9IHZvaWQgMDtcbiAgICBsZXQgcmVjb3JkZWRSZXF1ZXN0ID0ge307XG4gICAgbGV0IHJlY29yZGVkV2FybmluZ3MgPSBbXTtcbiAgICBjb25zdCByZWNvcmRlZFN0ZXBzID0gW107XG4gICAgbGV0IHJvb3RTcGFuO1xuICAgIGxldCBhY3RpdmVUZXh0Q29udGVudCA9IHt9O1xuICAgIGxldCBhY3RpdmVSZWFzb25pbmdDb250ZW50ID0ge307XG4gICAgY29uc3QgZXZlbnRQcm9jZXNzb3IgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICB2YXIgX2ExNywgX2IsIF9jO1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICBjb25zdCB7IHBhcnQgfSA9IGNodW5rO1xuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRleHQtZGVsdGFcIiB8fCBwYXJ0LnR5cGUgPT09IFwicmVhc29uaW5nLWRlbHRhXCIgfHwgcGFydC50eXBlID09PSBcInNvdXJjZVwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1pbnB1dC1zdGFydFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLWlucHV0LWRlbHRhXCIgfHwgcGFydC50eXBlID09PSBcInJhd1wiKSB7XG4gICAgICAgICAgYXdhaXQgKG9uQ2h1bmsgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2h1bmsoeyBjaHVuazogcGFydCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgYXdhaXQgb25FcnJvcih7IGVycm9yOiB3cmFwR2F0ZXdheUVycm9yKHBhcnQuZXJyb3IpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dC1zdGFydFwiKSB7XG4gICAgICAgICAgYWN0aXZlVGV4dENvbnRlbnRbcGFydC5pZF0gPSB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKGFjdGl2ZVRleHRDb250ZW50W3BhcnQuaWRdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZVRleHQgPSBhY3RpdmVUZXh0Q29udGVudFtwYXJ0LmlkXTtcbiAgICAgICAgICBpZiAoYWN0aXZlVGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICBwYXJ0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgdGV4dCBwYXJ0ICR7cGFydC5pZH0gbm90IGZvdW5kYFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwYXJ0aWFsT3V0cHV0OiB2b2lkIDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY3RpdmVUZXh0LnRleHQgKz0gcGFydC50ZXh0O1xuICAgICAgICAgIGFjdGl2ZVRleHQucHJvdmlkZXJNZXRhZGF0YSA9IChfYTE3ID0gcGFydC5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2ExNyA6IGFjdGl2ZVRleHQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRleHQtZW5kXCIpIHtcbiAgICAgICAgICBkZWxldGUgYWN0aXZlVGV4dENvbnRlbnRbcGFydC5pZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmctc3RhcnRcIikge1xuICAgICAgICAgIGFjdGl2ZVJlYXNvbmluZ0NvbnRlbnRbcGFydC5pZF0gPSB7XG4gICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmVjb3JkZWRDb250ZW50LnB1c2goYWN0aXZlUmVhc29uaW5nQ29udGVudFtwYXJ0LmlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmctZGVsdGFcIikge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZVJlYXNvbmluZyA9IGFjdGl2ZVJlYXNvbmluZ0NvbnRlbnRbcGFydC5pZF07XG4gICAgICAgICAgaWYgKGFjdGl2ZVJlYXNvbmluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICBwYXJ0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgcmVhc29uaW5nIHBhcnQgJHtwYXJ0LmlkfSBub3QgZm91bmRgXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjdGl2ZVJlYXNvbmluZy50ZXh0ICs9IHBhcnQudGV4dDtcbiAgICAgICAgICBhY3RpdmVSZWFzb25pbmcucHJvdmlkZXJNZXRhZGF0YSA9IChfYiA9IHBhcnQucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9iIDogYWN0aXZlUmVhc29uaW5nLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmctZW5kXCIpIHtcbiAgICAgICAgICBjb25zdCBhY3RpdmVSZWFzb25pbmcgPSBhY3RpdmVSZWFzb25pbmdDb250ZW50W3BhcnQuaWRdO1xuICAgICAgICAgIGlmIChhY3RpdmVSZWFzb25pbmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgcGFydDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBlcnJvcjogYHJlYXNvbmluZyBwYXJ0ICR7cGFydC5pZH0gbm90IGZvdW5kYFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwYXJ0aWFsT3V0cHV0OiB2b2lkIDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY3RpdmVSZWFzb25pbmcucHJvdmlkZXJNZXRhZGF0YSA9IChfYyA9IHBhcnQucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9jIDogYWN0aXZlUmVhc29uaW5nLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgZGVsZXRlIGFjdGl2ZVJlYXNvbmluZ0NvbnRlbnRbcGFydC5pZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaCh7IHR5cGU6IFwiZmlsZVwiLCBmaWxlOiBwYXJ0LmZpbGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCIpIHtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgJiYgIXBhcnQucHJlbGltaW5hcnkpIHtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtZXJyb3JcIikge1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwic3RhcnQtc3RlcFwiKSB7XG4gICAgICAgICAgcmVjb3JkZWRSZXF1ZXN0ID0gcGFydC5yZXF1ZXN0O1xuICAgICAgICAgIHJlY29yZGVkV2FybmluZ3MgPSBwYXJ0Lndhcm5pbmdzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiZmluaXNoLXN0ZXBcIikge1xuICAgICAgICAgIGNvbnN0IHN0ZXBNZXNzYWdlcyA9IHRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gICAgICAgICAgICBjb250ZW50OiByZWNvcmRlZENvbnRlbnQsXG4gICAgICAgICAgICB0b29sc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGVwUmVzdWx0ID0gbmV3IERlZmF1bHRTdGVwUmVzdWx0KHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHJlY29yZGVkQ29udGVudCxcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogcGFydC5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICB1c2FnZTogcGFydC51c2FnZSxcbiAgICAgICAgICAgIHdhcm5pbmdzOiByZWNvcmRlZFdhcm5pbmdzLFxuICAgICAgICAgICAgcmVxdWVzdDogcmVjb3JkZWRSZXF1ZXN0LFxuICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgLi4ucGFydC5yZXNwb25zZSxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IFsuLi5yZWNvcmRlZFJlc3BvbnNlTWVzc2FnZXMsIC4uLnN0ZXBNZXNzYWdlc11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhd2FpdCAob25TdGVwRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvblN0ZXBGaW5pc2goY3VycmVudFN0ZXBSZXN1bHQpKTtcbiAgICAgICAgICBsb2dXYXJuaW5ncyhyZWNvcmRlZFdhcm5pbmdzKTtcbiAgICAgICAgICByZWNvcmRlZFN0ZXBzLnB1c2goY3VycmVudFN0ZXBSZXN1bHQpO1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudCA9IFtdO1xuICAgICAgICAgIGFjdGl2ZVJlYXNvbmluZ0NvbnRlbnQgPSB7fTtcbiAgICAgICAgICBhY3RpdmVUZXh0Q29udGVudCA9IHt9O1xuICAgICAgICAgIHJlY29yZGVkUmVzcG9uc2VNZXNzYWdlcy5wdXNoKC4uLnN0ZXBNZXNzYWdlcyk7XG4gICAgICAgICAgc3RlcEZpbmlzaC5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJmaW5pc2hcIikge1xuICAgICAgICAgIHJlY29yZGVkVG90YWxVc2FnZSA9IHBhcnQudG90YWxVc2FnZTtcbiAgICAgICAgICByZWNvcmRlZEZpbmlzaFJlYXNvbiA9IHBhcnQuZmluaXNoUmVhc29uO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChyZWNvcmRlZFN0ZXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTm9PdXRwdXRHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb3V0cHV0IGdlbmVyYXRlZC4gQ2hlY2sgdGhlIHN0cmVhbSBmb3IgZXJyb3JzLlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuX2ZpbmlzaFJlYXNvbi5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgc2VsZi5fdG90YWxVc2FnZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgc2VsZi5fc3RlcHMucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmluaXNoUmVhc29uID0gcmVjb3JkZWRGaW5pc2hSZWFzb24gIT0gbnVsbCA/IHJlY29yZGVkRmluaXNoUmVhc29uIDogXCJ1bmtub3duXCI7XG4gICAgICAgICAgY29uc3QgdG90YWxVc2FnZSA9IHJlY29yZGVkVG90YWxVc2FnZSAhPSBudWxsID8gcmVjb3JkZWRUb3RhbFVzYWdlIDoge1xuICAgICAgICAgICAgaW5wdXRUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgICAgIG91dHB1dFRva2Vuczogdm9pZCAwLFxuICAgICAgICAgICAgdG90YWxUb2tlbnM6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgICAgc2VsZi5fZmluaXNoUmVhc29uLnJlc29sdmUoZmluaXNoUmVhc29uKTtcbiAgICAgICAgICBzZWxmLl90b3RhbFVzYWdlLnJlc29sdmUodG90YWxVc2FnZSk7XG4gICAgICAgICAgc2VsZi5fc3RlcHMucmVzb2x2ZShyZWNvcmRlZFN0ZXBzKTtcbiAgICAgICAgICBjb25zdCBmaW5hbFN0ZXAgPSByZWNvcmRlZFN0ZXBzW3JlY29yZGVkU3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgYXdhaXQgKG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7XG4gICAgICAgICAgICBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICB0b3RhbFVzYWdlLFxuICAgICAgICAgICAgdXNhZ2U6IGZpbmFsU3RlcC51c2FnZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGZpbmFsU3RlcC5jb250ZW50LFxuICAgICAgICAgICAgdGV4dDogZmluYWxTdGVwLnRleHQsXG4gICAgICAgICAgICByZWFzb25pbmdUZXh0OiBmaW5hbFN0ZXAucmVhc29uaW5nVGV4dCxcbiAgICAgICAgICAgIHJlYXNvbmluZzogZmluYWxTdGVwLnJlYXNvbmluZyxcbiAgICAgICAgICAgIGZpbGVzOiBmaW5hbFN0ZXAuZmlsZXMsXG4gICAgICAgICAgICBzb3VyY2VzOiBmaW5hbFN0ZXAuc291cmNlcyxcbiAgICAgICAgICAgIHRvb2xDYWxsczogZmluYWxTdGVwLnRvb2xDYWxscyxcbiAgICAgICAgICAgIHN0YXRpY1Rvb2xDYWxsczogZmluYWxTdGVwLnN0YXRpY1Rvb2xDYWxscyxcbiAgICAgICAgICAgIGR5bmFtaWNUb29sQ2FsbHM6IGZpbmFsU3RlcC5keW5hbWljVG9vbENhbGxzLFxuICAgICAgICAgICAgdG9vbFJlc3VsdHM6IGZpbmFsU3RlcC50b29sUmVzdWx0cyxcbiAgICAgICAgICAgIHN0YXRpY1Rvb2xSZXN1bHRzOiBmaW5hbFN0ZXAuc3RhdGljVG9vbFJlc3VsdHMsXG4gICAgICAgICAgICBkeW5hbWljVG9vbFJlc3VsdHM6IGZpbmFsU3RlcC5keW5hbWljVG9vbFJlc3VsdHMsXG4gICAgICAgICAgICByZXF1ZXN0OiBmaW5hbFN0ZXAucmVxdWVzdCxcbiAgICAgICAgICAgIHJlc3BvbnNlOiBmaW5hbFN0ZXAucmVzcG9uc2UsXG4gICAgICAgICAgICB3YXJuaW5nczogZmluYWxTdGVwLndhcm5pbmdzLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogZmluYWxTdGVwLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICBzdGVwczogcmVjb3JkZWRTdGVwc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByb290U3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjogeyBvdXRwdXQ6ICgpID0+IGZpbmFsU3RlcC50ZXh0IH0sXG4gICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTE3O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChfYTE3ID0gZmluYWxTdGVwLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcubGVuZ3RoKSA/IEpTT04uc3RyaW5naWZ5KGZpbmFsU3RlcC50b29sQ2FsbHMpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXCI6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgZmluYWxTdGVwLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuaW5wdXRUb2tlbnNcIjogdG90YWxVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICBcImFpLnVzYWdlLm91dHB1dFRva2Vuc1wiOiB0b3RhbFVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRvdGFsVG9rZW5zXCI6IHRvdGFsVXNhZ2UudG90YWxUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJhaS51c2FnZS5yZWFzb25pbmdUb2tlbnNcIjogdG90YWxVc2FnZS5yZWFzb25pbmdUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jYWNoZWRJbnB1dFRva2Vuc1wiOiB0b3RhbFVzYWdlLmNhY2hlZElucHV0VG9rZW5zXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICByb290U3Bhbi5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHN0aXRjaGFibGVTdHJlYW0gPSBjcmVhdGVTdGl0Y2hhYmxlU3RyZWFtKCk7XG4gICAgdGhpcy5hZGRTdHJlYW0gPSBzdGl0Y2hhYmxlU3RyZWFtLmFkZFN0cmVhbTtcbiAgICB0aGlzLmNsb3NlU3RyZWFtID0gc3RpdGNoYWJsZVN0cmVhbS5jbG9zZTtcbiAgICBjb25zdCByZWFkZXIgPSBzdGl0Y2hhYmxlU3RyZWFtLnN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICBsZXQgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJzdGFydFwiIH0pO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgICBvbkFib3J0ID09IG51bGwgPyB2b2lkIDAgOiBvbkFib3J0KHsgc3RlcHM6IHJlY29yZGVkU3RlcHMgfSk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJhYm9ydFwiIH0pO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFib3J0U2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydFNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGlmIChpc0Fib3J0RXJyb3IyKGVycm9yKSAmJiAoYWJvcnRTaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLmFib3J0ZWQpKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYW5jZWwocmVhc29uKSB7XG4gICAgICAgIHJldHVybiBzdGl0Y2hhYmxlU3RyZWFtLnN0cmVhbS5jYW5jZWwocmVhc29uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybSBvZiB0cmFuc2Zvcm1zKSB7XG4gICAgICBzdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgIHRyYW5zZm9ybSh7XG4gICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgc3RvcFN0cmVhbSgpIHtcbiAgICAgICAgICAgIHN0aXRjaGFibGVTdHJlYW0udGVybWluYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5iYXNlU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZU91dHB1dFRyYW5zZm9ybVN0cmVhbShvdXRwdXQpKS5waXBlVGhyb3VnaChldmVudFByb2Nlc3Nvcik7XG4gICAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICAgIGFib3J0U2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gICAgY29uc3QgY2FsbFNldHRpbmdzID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICBtb2RlbCxcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzZXR0aW5nczogeyAuLi5jYWxsU2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJlY29yZFNwYW4oe1xuICAgICAgbmFtZTogXCJhaS5zdHJlYW1UZXh0XCIsXG4gICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHsgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtVGV4dFwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB0cmFjZXIsXG4gICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICBmbjogYXN5bmMgKHJvb3RTcGFuQXJnKSA9PiB7XG4gICAgICAgIHJvb3RTcGFuID0gcm9vdFNwYW5Bcmc7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVN0ZXAoe1xuICAgICAgICAgIGN1cnJlbnRTdGVwLFxuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgICAgdXNhZ2VcbiAgICAgICAgfSkge1xuICAgICAgICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICBjb25zdCBpbmNsdWRlUmF3Q2h1bmtzMiA9IHNlbGYuaW5jbHVkZVJhd0NodW5rcztcbiAgICAgICAgICBzdGVwRmluaXNoID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgICAgICAgY29uc3QgaW5pdGlhbFByb21wdCA9IGF3YWl0IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3Qgc3RlcElucHV0TWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAuLi5pbml0aWFsUHJvbXB0Lm1lc3NhZ2VzLFxuICAgICAgICAgICAgLi4ucmVzcG9uc2VNZXNzYWdlc1xuICAgICAgICAgIF07XG4gICAgICAgICAgY29uc3QgcHJlcGFyZVN0ZXBSZXN1bHQgPSBhd2FpdCAocHJlcGFyZVN0ZXAgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwKHtcbiAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgc3RlcHM6IHJlY29yZGVkU3RlcHMsXG4gICAgICAgICAgICBzdGVwTnVtYmVyOiByZWNvcmRlZFN0ZXBzLmxlbmd0aCxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiB7XG4gICAgICAgICAgICAgIHN5c3RlbTogKF9hMTcgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQuc3lzdGVtKSAhPSBudWxsID8gX2ExNyA6IGluaXRpYWxQcm9tcHQuc3lzdGVtLFxuICAgICAgICAgICAgICBtZXNzYWdlczogKF9iID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0Lm1lc3NhZ2VzKSAhPSBudWxsID8gX2IgOiBzdGVwSW5wdXRNZXNzYWdlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1cHBvcnRlZFVybHM6IGF3YWl0IG1vZGVsLnN1cHBvcnRlZFVybHMsXG4gICAgICAgICAgICBkb3dubG9hZDogZG93bmxvYWQyXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3Qgc3RlcE1vZGVsID0gcmVzb2x2ZUxhbmd1YWdlTW9kZWwoXG4gICAgICAgICAgICAoX2MgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQubW9kZWwpICE9IG51bGwgPyBfYyA6IG1vZGVsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCB7IHRvb2xDaG9pY2U6IHN0ZXBUb29sQ2hvaWNlLCB0b29sczogc3RlcFRvb2xzIH0gPSBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHtcbiAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgdG9vbENob2ljZTogKF9kID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0LnRvb2xDaG9pY2UpICE9IG51bGwgPyBfZCA6IHRvb2xDaG9pY2UsXG4gICAgICAgICAgICBhY3RpdmVUb29sczogKF9lID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0LmFjdGl2ZVRvb2xzKSAhPSBudWxsID8gX2UgOiBhY3RpdmVUb29sc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHJlc3VsdDogeyBzdHJlYW06IHN0cmVhbTIsIHJlc3BvbnNlLCByZXF1ZXN0IH0sXG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zXG4gICAgICAgICAgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICAgIG5hbWU6IFwiYWkuc3RyZWFtVGV4dC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtVGV4dC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBtb2RlbDpcbiAgICAgICAgICAgICAgICAgIFwiYWkubW9kZWwucHJvdmlkZXJcIjogc3RlcE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgXCJhaS5tb2RlbC5pZFwiOiBzdGVwTW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgIC8vIHByb21wdDpcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0cmluZ2lmeUZvclRlbGVtZXRyeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIGxhbmd1YWdlIG1vZGVsIGxldmVsIHRvb2xzOlxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gc3RlcFRvb2xzID09IG51bGwgPyB2b2lkIDAgOiBzdGVwVG9vbHMubWFwKCh0b29sMykgPT4gSlNPTi5zdHJpbmdpZnkodG9vbDMpKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xDaG9pY2VcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gc3RlcFRvb2xDaG9pY2UgIT0gbnVsbCA/IEpTT04uc3RyaW5naWZ5KHN0ZXBUb29sQ2hvaWNlKSA6IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBzdGVwTW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IHN0ZXBNb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBjYWxsU2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBjYWxsU2V0dGluZ3MubWF4T3V0cHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IGNhbGxTZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnN0b3Bfc2VxdWVuY2VzXCI6IGNhbGxTZXR0aW5ncy5zdG9wU2VxdWVuY2VzLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBjYWxsU2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IGNhbGxTZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBjYWxsU2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICBmbjogYXN5bmMgKGRvU3RyZWFtU3BhbjIpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogbm93MigpLFxuICAgICAgICAgICAgICAgICAgLy8gZ2V0IGJlZm9yZSB0aGUgY2FsbFxuICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuOiBkb1N0cmVhbVNwYW4yLFxuICAgICAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBzdGVwTW9kZWwuZG9TdHJlYW0oe1xuICAgICAgICAgICAgICAgICAgICAuLi5jYWxsU2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xzOiBzdGVwVG9vbHMsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xDaG9pY2U6IHN0ZXBUb29sQ2hvaWNlLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZUZvcm1hdDogb3V0cHV0ID09IG51bGwgPyB2b2lkIDAgOiBvdXRwdXQucmVzcG9uc2VGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVSYXdDaHVua3M6IGluY2x1ZGVSYXdDaHVua3MyXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBzdHJlYW1XaXRoVG9vbFJlc3VsdHMgPSBydW5Ub29sc1RyYW5zZm9ybWF0aW9uKHtcbiAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgZ2VuZXJhdG9yU3RyZWFtOiBzdHJlYW0yLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgcmVwYWlyVG9vbENhbGwsXG4gICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3Qgc3RlcFJlcXVlc3QgPSByZXF1ZXN0ICE9IG51bGwgPyByZXF1ZXN0IDoge307XG4gICAgICAgICAgY29uc3Qgc3RlcFRvb2xDYWxscyA9IFtdO1xuICAgICAgICAgIGNvbnN0IHN0ZXBUb29sT3V0cHV0cyA9IFtdO1xuICAgICAgICAgIGxldCB3YXJuaW5ncztcbiAgICAgICAgICBjb25zdCBhY3RpdmVUb29sQ2FsbFRvb2xOYW1lcyA9IHt9O1xuICAgICAgICAgIGxldCBzdGVwRmluaXNoUmVhc29uID0gXCJ1bmtub3duXCI7XG4gICAgICAgICAgbGV0IHN0ZXBVc2FnZSA9IHtcbiAgICAgICAgICAgIGlucHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgICAgICAgICBvdXRwdXRUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgICAgIHRvdGFsVG9rZW5zOiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGxldCBzdGVwUHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICBsZXQgc3RlcEZpcnN0Q2h1bmsgPSB0cnVlO1xuICAgICAgICAgIGxldCBzdGVwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICBpZDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogY3VycmVudERhdGUoKSxcbiAgICAgICAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGxldCBhY3RpdmVUZXh0ID0gXCJcIjtcbiAgICAgICAgICBzZWxmLmFkZFN0cmVhbShcbiAgICAgICAgICAgIHN0cmVhbVdpdGhUb29sUmVzdWx0cy5waXBlVGhyb3VnaChcbiAgICAgICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2ExOCwgX2IyLCBfYzIsIF9kMjtcbiAgICAgICAgICAgICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInN0cmVhbS1zdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzID0gY2h1bmsud2FybmluZ3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChzdGVwRmlyc3RDaHVuaykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc1RvRmlyc3RDaHVuayA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wTXM7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maXJzdENodW5rXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVua1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0YXJ0LXN0ZXBcIixcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBzdGVwUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nczogd2FybmluZ3MgIT0gbnVsbCA/IHdhcm5pbmdzIDogW11cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQtc3RhcnRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQtZW5kXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsuZGVsdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjaHVuay5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2h1bmsuZGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlVGV4dCArPSBjaHVuay5kZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1zdGFydFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLWVuZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjaHVuay5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNodW5rLmRlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFRvb2xDYWxscy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaHVuay5wcmVsaW1pbmFyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFRvb2xPdXRwdXRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1lcnJvclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwVG9vbE91dHB1dHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogKF9hMTggPSBjaHVuay5pZCkgIT0gbnVsbCA/IF9hMTggOiBzdGVwUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfYjIgPSBjaHVuay50aW1lc3RhbXApICE9IG51bGwgPyBfYjIgOiBzdGVwUmVzcG9uc2UudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxJZDogKF9jMiA9IGNodW5rLm1vZGVsSWQpICE9IG51bGwgPyBfYzIgOiBzdGVwUmVzcG9uc2UubW9kZWxJZFxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFVzYWdlID0gY2h1bmsudXNhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcEZpbmlzaFJlYXNvbiA9IGNodW5rLmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwUHJvdmlkZXJNZXRhZGF0YSA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNUb0ZpbmlzaCA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wTXM7XG4gICAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmFkZEV2ZW50KFwiYWkuc3RyZWFtLmZpbmlzaFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaW5pc2hcIjogbXNUb0ZpbmlzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuYXZnT3V0cHV0VG9rZW5zUGVyU2Vjb25kXCI6IDFlMyAqICgoX2QyID0gc3RlcFVzYWdlLm91dHB1dFRva2VucykgIT0gbnVsbCA/IF9kMiA6IDApIC8gbXNUb0ZpbmlzaFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzb3VyY2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtc3RhcnRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRvb2xDYWxsVG9vbE5hbWVzW2NodW5rLmlkXSA9IGNodW5rLnRvb2xOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2wzID0gdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW2NodW5rLnRvb2xOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRvb2wzID09IG51bGwgPyB2b2lkIDAgOiB0b29sMy5vbklucHV0U3RhcnQpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRvb2wzLm9uSW5wdXRTdGFydCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWM6ICh0b29sMyA9PSBudWxsID8gdm9pZCAwIDogdG9vbDMudHlwZSkgPT09IFwiZHluYW1pY1wiXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtZW5kXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYWN0aXZlVG9vbENhbGxUb29sTmFtZXNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtZGVsdGFcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gYWN0aXZlVG9vbENhbGxUb29sTmFtZXNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2wzID0gdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRvb2wzID09IG51bGwgPyB2b2lkIDAgOiB0b29sMy5vbklucHV0RGVsdGEpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRvb2wzLm9uSW5wdXREZWx0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VGV4dERlbHRhOiBjaHVuay5kZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcEZpbmlzaFJlYXNvbiA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmF3XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZVJhd0NodW5rczIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBjaHVua1R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNodW5rIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBpbnZva2Ugb25GaW5pc2ggY2FsbGJhY2sgYW5kIHJlc29sdmUgdG9vbFJlc3VsdHMgcHJvbWlzZSB3aGVuIHRoZSBzdHJlYW0gaXMgYWJvdXQgdG8gY2xvc2U6XG4gICAgICAgICAgICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc3RlcFRvb2xDYWxsc0pzb24gPSBzdGVwVG9vbENhbGxzLmxlbmd0aCA+IDAgPyBKU09OLnN0cmluZ2lmeShzdGVwVG9vbENhbGxzKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gYWN0aXZlVGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBzdGVwVG9vbENhbGxzSnNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmlkXCI6IHN0ZXBSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tb2RlbFwiOiBzdGVwUmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogc3RlcFJlc3BvbnNlLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGFcIjogSlNPTi5zdHJpbmdpZnkoc3RlcFByb3ZpZGVyTWV0YWRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmlucHV0VG9rZW5zXCI6IHN0ZXBVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5vdXRwdXRUb2tlbnNcIjogc3RlcFVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b3RhbFRva2Vuc1wiOiBzdGVwVXNhZ2UudG90YWxUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucmVhc29uaW5nVG9rZW5zXCI6IHN0ZXBVc2FnZS5yZWFzb25pbmdUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnNcIjogc3RlcFVzYWdlLmNhY2hlZElucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtzdGVwRmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiBzdGVwUmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHN0ZXBVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2Uub3V0cHV0X3Rva2Vuc1wiOiBzdGVwVXNhZ2Uub3V0cHV0VG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uZW5kKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbmlzaC1zdGVwXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgdXNhZ2U6IHN0ZXBVc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogc3RlcFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uc3RlcFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY29tYmluZWRVc2FnZSA9IGFkZExhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZSwgc3RlcFVzYWdlKTtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHN0ZXBGaW5pc2gucHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFRvb2xDYWxscyA9IHN0ZXBUb29sQ2FsbHMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRUb29sT3V0cHV0cyA9IHN0ZXBUb29sT3V0cHV0cy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICh0b29sT3V0cHV0KSA9PiB0b29sT3V0cHV0LnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2xpZW50VG9vbENhbGxzLmxlbmd0aCA+IDAgJiYgLy8gYWxsIGN1cnJlbnQgdG9vbCBjYWxscyBoYXZlIG91dHB1dHMgKGluY2wuIGV4ZWN1dGlvbiBlcnJvcnMpOlxuICAgICAgICAgICAgICAgICAgY2xpZW50VG9vbE91dHB1dHMubGVuZ3RoID09PSBjbGllbnRUb29sQ2FsbHMubGVuZ3RoICYmIC8vIGNvbnRpbnVlIHVudGlsIGEgc3RvcCBjb25kaXRpb24gaXMgbWV0OlxuICAgICAgICAgICAgICAgICAgIWF3YWl0IGlzU3RvcENvbmRpdGlvbk1ldCh7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BDb25kaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICBzdGVwczogcmVjb3JkZWRTdGVwc1xuICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgIC4uLnRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSB0cmFuc2Zvcm1lZCBjb250ZW50IHRvIGNyZWF0ZSB0aGUgbWVzc2FnZXMgZm9yIHRoZSBuZXh0IHN0ZXA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZGVkU3RlcHNbcmVjb3JkZWRTdGVwcy5sZW5ndGggLSAxXS5jb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0cmVhbVN0ZXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0ZXA6IGN1cnJlbnRTdGVwICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2FnZTogY29tYmluZWRVc2FnZVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2VTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICB0b3RhbFVzYWdlOiBjb21iaW5lZFVzYWdlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlU3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgc3RyZWFtU3RlcCh7XG4gICAgICAgICAgY3VycmVudFN0ZXA6IDAsXG4gICAgICAgICAgcmVzcG9uc2VNZXNzYWdlczogW10sXG4gICAgICAgICAgdXNhZ2U6IHtcbiAgICAgICAgICAgIGlucHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgICAgICAgICBvdXRwdXRUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgICAgIHRvdGFsVG9rZW5zOiB2b2lkIDBcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgc2VsZi5hZGRTdHJlYW0oXG4gICAgICAgIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgc2VsZi5jbG9zZVN0cmVhbSgpO1xuICAgIH0pO1xuICB9XG4gIGdldCBzdGVwcygpIHtcbiAgICB0aGlzLmNvbnN1bWVTdHJlYW0oKTtcbiAgICByZXR1cm4gdGhpcy5fc3RlcHMucHJvbWlzZTtcbiAgfVxuICBnZXQgZmluYWxTdGVwKCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBzLnRoZW4oKHN0ZXBzKSA9PiBzdGVwc1tzdGVwcy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuY29udGVudCk7XG4gIH1cbiAgZ2V0IHdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLndhcm5pbmdzKTtcbiAgfVxuICBnZXQgcHJvdmlkZXJNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5wcm92aWRlck1ldGFkYXRhKTtcbiAgfVxuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC50ZXh0KTtcbiAgfVxuICBnZXQgcmVhc29uaW5nVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5yZWFzb25pbmdUZXh0KTtcbiAgfVxuICBnZXQgcmVhc29uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnJlYXNvbmluZyk7XG4gIH1cbiAgZ2V0IHNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuc291cmNlcyk7XG4gIH1cbiAgZ2V0IGZpbGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLmZpbGVzKTtcbiAgfVxuICBnZXQgdG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnRvb2xDYWxscyk7XG4gIH1cbiAgZ2V0IHN0YXRpY1Rvb2xDYWxscygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5zdGF0aWNUb29sQ2FsbHMpO1xuICB9XG4gIGdldCBkeW5hbWljVG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLmR5bmFtaWNUb29sQ2FsbHMpO1xuICB9XG4gIGdldCB0b29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC50b29sUmVzdWx0cyk7XG4gIH1cbiAgZ2V0IHN0YXRpY1Rvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnN0YXRpY1Rvb2xSZXN1bHRzKTtcbiAgfVxuICBnZXQgZHluYW1pY1Rvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLmR5bmFtaWNUb29sUmVzdWx0cyk7XG4gIH1cbiAgZ2V0IHVzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnVzYWdlKTtcbiAgfVxuICBnZXQgcmVxdWVzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5yZXF1ZXN0KTtcbiAgfVxuICBnZXQgcmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAucmVzcG9uc2UpO1xuICB9XG4gIGdldCB0b3RhbFVzYWdlKCkge1xuICAgIHRoaXMuY29uc3VtZVN0cmVhbSgpO1xuICAgIHJldHVybiB0aGlzLl90b3RhbFVzYWdlLnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbmlzaFJlYXNvbigpIHtcbiAgICB0aGlzLmNvbnN1bWVTdHJlYW0oKTtcbiAgICByZXR1cm4gdGhpcy5fZmluaXNoUmVhc29uLnByb21pc2U7XG4gIH1cbiAgLyoqXG4gIFNwbGl0IG91dCBhIG5ldyBzdHJlYW0gZnJvbSB0aGUgb3JpZ2luYWwgc3RyZWFtLlxuICBUaGUgb3JpZ2luYWwgc3RyZWFtIGlzIHJlcGxhY2VkIHRvIGFsbG93IGZvciBmdXJ0aGVyIHNwbGl0dGluZyxcbiAgc2luY2Ugd2UgZG8gbm90IGtub3cgaG93IG1hbnkgdGltZXMgdGhlIHN0cmVhbSB3aWxsIGJlIHNwbGl0LlxuICBcbiAgTm90ZTogdGhpcyBsZWFkcyB0byBidWZmZXJpbmcgdGhlIHN0cmVhbSBjb250ZW50IG9uIHRoZSBzZXJ2ZXIuXG4gIEhvd2V2ZXIsIHRoZSBMTE0gcmVzdWx0cyBhcmUgZXhwZWN0ZWQgdG8gYmUgc21hbGwgZW5vdWdoIHRvIG5vdCBjYXVzZSBpc3N1ZXMuXG4gICAgICovXG4gIHRlZVN0cmVhbSgpIHtcbiAgICBjb25zdCBbc3RyZWFtMSwgc3RyZWFtMl0gPSB0aGlzLmJhc2VTdHJlYW0udGVlKCk7XG4gICAgdGhpcy5iYXNlU3RyZWFtID0gc3RyZWFtMjtcbiAgICByZXR1cm4gc3RyZWFtMTtcbiAgfVxuICBnZXQgdGV4dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMudGVlU3RyZWFtKCkucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybSh7IHBhcnQgfSwgY29udHJvbGxlcikge1xuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnQudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgZ2V0IGZ1bGxTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICB0aGlzLnRlZVN0cmVhbSgpLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oeyBwYXJ0IH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBhc3luYyBjb25zdW1lU3RyZWFtKG9wdGlvbnMpIHtcbiAgICB2YXIgX2ExNztcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY29uc3VtZVN0cmVhbSh7XG4gICAgICAgIHN0cmVhbTogdGhpcy5mdWxsU3RyZWFtLFxuICAgICAgICBvbkVycm9yOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uRXJyb3JcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAoX2ExNyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25FcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbChvcHRpb25zLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIGdldCBleHBlcmltZW50YWxfcGFydGlhbE91dHB1dFN0cmVhbSgpIHtcbiAgICBpZiAodGhpcy5vdXRwdXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vT3V0cHV0U3BlY2lmaWVkRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICB0aGlzLnRlZVN0cmVhbSgpLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oeyBwYXJ0aWFsT3V0cHV0IH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0aWFsT3V0cHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnRpYWxPdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHRvVUlNZXNzYWdlU3RyZWFtKHtcbiAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgIGdlbmVyYXRlTWVzc2FnZUlkLFxuICAgIG9uRmluaXNoLFxuICAgIG1lc3NhZ2VNZXRhZGF0YSxcbiAgICBzZW5kUmVhc29uaW5nID0gdHJ1ZSxcbiAgICBzZW5kU291cmNlcyA9IGZhbHNlLFxuICAgIHNlbmRTdGFydCA9IHRydWUsXG4gICAgc2VuZEZpbmlzaCA9IHRydWUsXG4gICAgb25FcnJvciA9IGdldEVycm9yTWVzc2FnZTdcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlSWQgPSBnZW5lcmF0ZU1lc3NhZ2VJZCAhPSBudWxsID8gZ2V0UmVzcG9uc2VVSU1lc3NhZ2VJZCh7XG4gICAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgICAgcmVzcG9uc2VNZXNzYWdlSWQ6IGdlbmVyYXRlTWVzc2FnZUlkXG4gICAgfSkgOiB2b2lkIDA7XG4gICAgY29uc3QgdG9vbE5hbWVzQnlDYWxsSWQgPSB7fTtcbiAgICBjb25zdCBpc0R5bmFtaWMgPSAodG9vbENhbGxJZCkgPT4ge1xuICAgICAgdmFyIF9hMTcsIF9iO1xuICAgICAgY29uc3QgdG9vbE5hbWUgPSB0b29sTmFtZXNCeUNhbGxJZFt0b29sQ2FsbElkXTtcbiAgICAgIGNvbnN0IGR5bmFtaWMgPSAoKF9iID0gKF9hMTcgPSB0aGlzLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExN1t0b29sTmFtZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYi50eXBlKSA9PT0gXCJkeW5hbWljXCI7XG4gICAgICByZXR1cm4gZHluYW1pYyA/IHRydWUgOiB2b2lkIDA7XG4gICAgfTtcbiAgICBjb25zdCBiYXNlU3RyZWFtID0gdGhpcy5mdWxsU3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIHRyYW5zZm9ybTogYXN5bmMgKHBhcnQsIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlTWV0YWRhdGFWYWx1ZSA9IG1lc3NhZ2VNZXRhZGF0YSA9PSBudWxsID8gdm9pZCAwIDogbWVzc2FnZU1ldGFkYXRhKHsgcGFydCB9KTtcbiAgICAgICAgICBjb25zdCBwYXJ0VHlwZSA9IHBhcnQudHlwZTtcbiAgICAgICAgICBzd2l0Y2ggKHBhcnRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dC1zdGFydFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIGlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgIGRlbHRhOiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRleHQtZW5kXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZW5kXCIsXG4gICAgICAgICAgICAgICAgaWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1zdGFydFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctc3RhcnRcIixcbiAgICAgICAgICAgICAgICBpZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgaWYgKHNlbmRSZWFzb25pbmcpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgIGlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgICAgZGVsdGE6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLWVuZFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctZW5kXCIsXG4gICAgICAgICAgICAgICAgaWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogcGFydC5maWxlLm1lZGlhVHlwZSxcbiAgICAgICAgICAgICAgICB1cmw6IGBkYXRhOiR7cGFydC5maWxlLm1lZGlhVHlwZX07YmFzZTY0LCR7cGFydC5maWxlLmJhc2U2NH1gXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzb3VyY2VcIjoge1xuICAgICAgICAgICAgICBpZiAoc2VuZFNvdXJjZXMgJiYgcGFydC5zb3VyY2VUeXBlID09PSBcInVybFwiKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwic291cmNlLXVybFwiLFxuICAgICAgICAgICAgICAgICAgc291cmNlSWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgICB1cmw6IHBhcnQudXJsLFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IHBhcnQudGl0bGUsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzZW5kU291cmNlcyAmJiBwYXJ0LnNvdXJjZVR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInNvdXJjZS1kb2N1bWVudFwiLFxuICAgICAgICAgICAgICAgICAgc291cmNlSWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgICBtZWRpYVR5cGU6IHBhcnQubWVkaWFUeXBlLFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IHBhcnQudGl0bGUsXG4gICAgICAgICAgICAgICAgICBmaWxlbmFtZTogcGFydC5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1zdGFydFwiOiB7XG4gICAgICAgICAgICAgIHRvb2xOYW1lc0J5Q2FsbElkW3BhcnQuaWRdID0gcGFydC50b29sTmFtZTtcbiAgICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IGlzRHluYW1pYyhwYXJ0LmlkKTtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtaW5wdXQtc3RhcnRcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJFeGVjdXRlZCAhPSBudWxsID8geyBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgfSA6IHt9LFxuICAgICAgICAgICAgICAgIC4uLmR5bmFtaWMgIT0gbnVsbCA/IHsgZHluYW1pYyB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtZGVsdGFcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1pbnB1dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgaW5wdXRUZXh0RGVsdGE6IHBhcnQuZGVsdGFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgIHRvb2xOYW1lc0J5Q2FsbElkW3BhcnQudG9vbENhbGxJZF0gPSBwYXJ0LnRvb2xOYW1lO1xuICAgICAgICAgICAgICBjb25zdCBkeW5hbWljID0gaXNEeW5hbWljKHBhcnQudG9vbENhbGxJZCk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0LmludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWlucHV0LWVycm9yXCIsXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlckV4ZWN1dGVkICE9IG51bGwgPyB7IHByb3ZpZGVyRXhlY3V0ZWQ6IHBhcnQucHJvdmlkZXJFeGVjdXRlZCB9IDoge30sXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIC4uLmR5bmFtaWMgIT0gbnVsbCA/IHsgZHluYW1pYyB9IDoge30sXG4gICAgICAgICAgICAgICAgICBlcnJvclRleHQ6IG9uRXJyb3IocGFydC5lcnJvcilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWlucHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogcGFydC5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJFeGVjdXRlZCAhPSBudWxsID8geyBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgfSA6IHt9LFxuICAgICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge30sXG4gICAgICAgICAgICAgICAgICAuLi5keW5hbWljICE9IG51bGwgPyB7IGR5bmFtaWMgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgICAgICBjb25zdCBkeW5hbWljID0gaXNEeW5hbWljKHBhcnQudG9vbENhbGxJZCk7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLW91dHB1dC1hdmFpbGFibGVcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBwYXJ0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgIT0gbnVsbCA/IHsgcHJvdmlkZXJFeGVjdXRlZDogcGFydC5wcm92aWRlckV4ZWN1dGVkIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnByZWxpbWluYXJ5ICE9IG51bGwgPyB7IHByZWxpbWluYXJ5OiBwYXJ0LnByZWxpbWluYXJ5IH0gOiB7fSxcbiAgICAgICAgICAgICAgICAuLi5keW5hbWljICE9IG51bGwgPyB7IGR5bmFtaWMgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWVycm9yXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IGlzRHluYW1pYyhwYXJ0LnRvb2xDYWxsSWQpO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1vdXRwdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBvbkVycm9yKHBhcnQuZXJyb3IpLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJFeGVjdXRlZCAhPSBudWxsID8geyBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgfSA6IHt9LFxuICAgICAgICAgICAgICAgIC4uLmR5bmFtaWMgIT0gbnVsbCA/IHsgZHluYW1pYyB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBvbkVycm9yKHBhcnQuZXJyb3IpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdGFydC1zdGVwXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJzdGFydC1zdGVwXCIgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmlzaC1zdGVwXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJmaW5pc2gtc3RlcFwiIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdGFydFwiOiB7XG4gICAgICAgICAgICAgIGlmIChzZW5kU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgLi4ubWVzc2FnZU1ldGFkYXRhVmFsdWUgIT0gbnVsbCA/IHsgbWVzc2FnZU1ldGFkYXRhOiBtZXNzYWdlTWV0YWRhdGFWYWx1ZSB9IDoge30sXG4gICAgICAgICAgICAgICAgICAuLi5yZXNwb25zZU1lc3NhZ2VJZCAhPSBudWxsID8geyBtZXNzYWdlSWQ6IHJlc3BvbnNlTWVzc2FnZUlkIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgIGlmIChzZW5kRmluaXNoKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICAgICAgICAuLi5tZXNzYWdlTWV0YWRhdGFWYWx1ZSAhPSBudWxsID8geyBtZXNzYWdlTWV0YWRhdGE6IG1lc3NhZ2VNZXRhZGF0YVZhbHVlIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImFib3J0XCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWVuZFwiOiB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOiB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBwYXJ0VHlwZTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNodW5rIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZU1ldGFkYXRhVmFsdWUgIT0gbnVsbCAmJiBwYXJ0VHlwZSAhPT0gXCJzdGFydFwiICYmIHBhcnRUeXBlICE9PSBcImZpbmlzaFwiKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcIm1lc3NhZ2UtbWV0YWRhdGFcIixcbiAgICAgICAgICAgICAgbWVzc2FnZU1ldGFkYXRhOiBtZXNzYWdlTWV0YWRhdGFWYWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICBoYW5kbGVVSU1lc3NhZ2VTdHJlYW1GaW5pc2goe1xuICAgICAgICBzdHJlYW06IGJhc2VTdHJlYW0sXG4gICAgICAgIG1lc3NhZ2VJZDogcmVzcG9uc2VNZXNzYWdlSWQgIT0gbnVsbCA/IHJlc3BvbnNlTWVzc2FnZUlkIDogZ2VuZXJhdGVNZXNzYWdlSWQgPT0gbnVsbCA/IHZvaWQgMCA6IGdlbmVyYXRlTWVzc2FnZUlkKCksXG4gICAgICAgIG9yaWdpbmFsTWVzc2FnZXMsXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICBvbkVycm9yXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgcGlwZVVJTWVzc2FnZVN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgIGdlbmVyYXRlTWVzc2FnZUlkLFxuICAgIG9uRmluaXNoLFxuICAgIG1lc3NhZ2VNZXRhZGF0YSxcbiAgICBzZW5kUmVhc29uaW5nLFxuICAgIHNlbmRTb3VyY2VzLFxuICAgIHNlbmRGaW5pc2gsXG4gICAgc2VuZFN0YXJ0LFxuICAgIG9uRXJyb3IsXG4gICAgLi4uaW5pdFxuICB9ID0ge30pIHtcbiAgICBwaXBlVUlNZXNzYWdlU3RyZWFtVG9SZXNwb25zZSh7XG4gICAgICByZXNwb25zZSxcbiAgICAgIHN0cmVhbTogdGhpcy50b1VJTWVzc2FnZVN0cmVhbSh7XG4gICAgICAgIG9yaWdpbmFsTWVzc2FnZXMsXG4gICAgICAgIGdlbmVyYXRlTWVzc2FnZUlkLFxuICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgbWVzc2FnZU1ldGFkYXRhLFxuICAgICAgICBzZW5kUmVhc29uaW5nLFxuICAgICAgICBzZW5kU291cmNlcyxcbiAgICAgICAgc2VuZEZpbmlzaCxcbiAgICAgICAgc2VuZFN0YXJ0LFxuICAgICAgICBvbkVycm9yXG4gICAgICB9KSxcbiAgICAgIC4uLmluaXRcbiAgICB9KTtcbiAgfVxuICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIGluaXQpIHtcbiAgICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICB0ZXh0U3RyZWFtOiB0aGlzLnRleHRTdHJlYW0sXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbiAgdG9VSU1lc3NhZ2VTdHJlYW1SZXNwb25zZSh7XG4gICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICBnZW5lcmF0ZU1lc3NhZ2VJZCxcbiAgICBvbkZpbmlzaCxcbiAgICBtZXNzYWdlTWV0YWRhdGEsXG4gICAgc2VuZFJlYXNvbmluZyxcbiAgICBzZW5kU291cmNlcyxcbiAgICBzZW5kRmluaXNoLFxuICAgIHNlbmRTdGFydCxcbiAgICBvbkVycm9yLFxuICAgIC4uLmluaXRcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVVJTWVzc2FnZVN0cmVhbVJlc3BvbnNlKHtcbiAgICAgIHN0cmVhbTogdGhpcy50b1VJTWVzc2FnZVN0cmVhbSh7XG4gICAgICAgIG9yaWdpbmFsTWVzc2FnZXMsXG4gICAgICAgIGdlbmVyYXRlTWVzc2FnZUlkLFxuICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgbWVzc2FnZU1ldGFkYXRhLFxuICAgICAgICBzZW5kUmVhc29uaW5nLFxuICAgICAgICBzZW5kU291cmNlcyxcbiAgICAgICAgc2VuZEZpbmlzaCxcbiAgICAgICAgc2VuZFN0YXJ0LFxuICAgICAgICBvbkVycm9yXG4gICAgICB9KSxcbiAgICAgIC4uLmluaXRcbiAgICB9KTtcbiAgfVxuICB0b1RleHRTdHJlYW1SZXNwb25zZShpbml0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRleHRTdHJlYW1SZXNwb25zZSh7XG4gICAgICB0ZXh0U3RyZWFtOiB0aGlzLnRleHRTdHJlYW0sXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91aS9jb252ZXJ0LXRvLW1vZGVsLW1lc3NhZ2VzLnRzXG5mdW5jdGlvbiBjb252ZXJ0VG9Nb2RlbE1lc3NhZ2VzKG1lc3NhZ2VzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG1vZGVsTWVzc2FnZXMgPSBbXTtcbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaWdub3JlSW5jb21wbGV0ZVRvb2xDYWxscykge1xuICAgIG1lc3NhZ2VzID0gbWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiAoe1xuICAgICAgLi4ubWVzc2FnZSxcbiAgICAgIHBhcnRzOiBtZXNzYWdlLnBhcnRzLmZpbHRlcihcbiAgICAgICAgKHBhcnQpID0+ICFpc1Rvb2xPckR5bmFtaWNUb29sVUlQYXJ0KHBhcnQpIHx8IHBhcnQuc3RhdGUgIT09IFwiaW5wdXQtc3RyZWFtaW5nXCIgJiYgcGFydC5zdGF0ZSAhPT0gXCJpbnB1dC1hdmFpbGFibGVcIlxuICAgICAgKVxuICAgIH0pKTtcbiAgfVxuICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICBzd2l0Y2ggKG1lc3NhZ2Uucm9sZSkge1xuICAgICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICAgIGNvbnN0IHRleHRQYXJ0cyA9IG1lc3NhZ2UucGFydHMuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidGV4dFwiKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJNZXRhZGF0YSA9IHRleHRQYXJ0cy5yZWR1Y2UoKGFjYywgcGFydCkgPT4ge1xuICAgICAgICAgIGlmIChwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4uYWNjLCAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICBtb2RlbE1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgY29udGVudDogdGV4dFBhcnRzLm1hcCgocGFydCkgPT4gcGFydC50ZXh0KS5qb2luKFwiXCIpLFxuICAgICAgICAgIC4uLk9iamVjdC5rZXlzKHByb3ZpZGVyTWV0YWRhdGEpLmxlbmd0aCA+IDAgPyB7IHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBtb2RlbE1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UucGFydHMuZmlsdGVyKFxuICAgICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIgfHwgcGFydC50eXBlID09PSBcImZpbGVcIlxuICAgICAgICAgICkubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogcGFydC5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgICBmaWxlbmFtZTogcGFydC5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHBhcnQudXJsLFxuICAgICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImFzc2lzdGFudFwiOiB7XG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgICBsZXQgcHJvY2Vzc0Jsb2NrMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9hMTcsIF9iO1xuICAgICAgICAgICAgaWYgKGJsb2NrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgYmxvY2spIHtcbiAgICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydC50eXBlID09PSBcImZpbGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogcGFydC5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgICBmaWxlbmFtZTogcGFydC5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHBhcnQudXJsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydC50eXBlID09PSBcInJlYXNvbmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQudHlwZSA9PT0gXCJkeW5hbWljLXRvb2xcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gcGFydC50b29sTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAocGFydC5zdGF0ZSAhPT0gXCJpbnB1dC1zdHJlYW1pbmdcIikge1xuICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnQuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzVG9vbFVJUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gZ2V0VG9vbE5hbWUocGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQuc3RhdGUgIT09IFwiaW5wdXQtc3RyZWFtaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiID8gKF9hMTcgPSBwYXJ0LmlucHV0KSAhPSBudWxsID8gX2ExNyA6IHBhcnQucmF3SW5wdXQgOiBwYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAocGFydC5wcm92aWRlckV4ZWN1dGVkID09PSB0cnVlICYmIChwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1hdmFpbGFibGVcIiB8fCBwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiID8gcGFydC5lcnJvclRleHQgOiBwYXJ0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2w6IChfYiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYlt0b29sTmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1vZGU6IHBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWVycm9yXCIgPyBcImpzb25cIiA6IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBwYXJ0O1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFydDogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RlbE1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICBjb250ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xQYXJ0cyA9IGJsb2NrLmZpbHRlcihcbiAgICAgICAgICAgICAgKHBhcnQpID0+IGlzVG9vbFVJUGFydChwYXJ0KSAmJiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWUgfHwgcGFydC50eXBlID09PSBcImR5bmFtaWMtdG9vbFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHRvb2xQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIG1vZGVsTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogdG9vbFBhcnRzLm1hcCgodG9vbFBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b29sUGFydC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwib3V0cHV0LWVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvdXRwdXQtYXZhaWxhYmxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IHRvb2xQYXJ0LnR5cGUgPT09IFwiZHluYW1pYy10b29sXCIgPyB0b29sUGFydC50b29sTmFtZSA6IGdldFRvb2xOYW1lKHRvb2xQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbFBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IHRvb2xQYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiID8gdG9vbFBhcnQuZXJyb3JUZXh0IDogdG9vbFBhcnQub3V0cHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sOiAoX2ExOCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTE4W3Rvb2xOYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNb2RlOiB0b29sUGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtZXJyb3JcIiA/IFwidGV4dFwiIDogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAob3V0cHV0KSA9PiBvdXRwdXQgIT0gbnVsbFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jayA9IFtdO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHByb2Nlc3NCbG9jayA9IHByb2Nlc3NCbG9jazI7XG4gICAgICAgICAgbGV0IGJsb2NrID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIG1lc3NhZ2UucGFydHMpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dFwiIHx8IHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmdcIiB8fCBwYXJ0LnR5cGUgPT09IFwiZmlsZVwiIHx8IHBhcnQudHlwZSA9PT0gXCJkeW5hbWljLXRvb2xcIiB8fCBpc1Rvb2xVSVBhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgYmxvY2sucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydC50eXBlID09PSBcInN0ZXAtc3RhcnRcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQmxvY2syKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3NCbG9jazIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1lc3NhZ2Uucm9sZTtcbiAgICAgICAgdGhyb3cgbmV3IE1lc3NhZ2VDb252ZXJzaW9uRXJyb3Ioe1xuICAgICAgICAgIG9yaWdpbmFsTWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICBtZXNzYWdlOiBgVW5zdXBwb3J0ZWQgcm9sZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RlbE1lc3NhZ2VzO1xufVxudmFyIGNvbnZlcnRUb0NvcmVNZXNzYWdlcyA9IGNvbnZlcnRUb01vZGVsTWVzc2FnZXM7XG5cbi8vIHNyYy9hZ2VudC9hZ2VudC50c1xudmFyIEFnZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgfVxuICBnZXQgdG9vbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MudG9vbHM7XG4gIH1cbiAgYXN5bmMgZ2VuZXJhdGUob3B0aW9ucykge1xuICAgIHJldHVybiBnZW5lcmF0ZVRleHQoeyAuLi50aGlzLnNldHRpbmdzLCAuLi5vcHRpb25zIH0pO1xuICB9XG4gIHN0cmVhbShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN0cmVhbVRleHQoeyAuLi50aGlzLnNldHRpbmdzLCAuLi5vcHRpb25zIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVzcG9uc2Ugb2JqZWN0IHRoYXQgc3RyZWFtcyBVSSBtZXNzYWdlcyB0byB0aGUgY2xpZW50LlxuICAgKi9cbiAgcmVzcG9uZChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtKHtcbiAgICAgIHByb21wdDogY29udmVydFRvTW9kZWxNZXNzYWdlcyhvcHRpb25zLm1lc3NhZ2VzKVxuICAgIH0pLnRvVUlNZXNzYWdlU3RyZWFtUmVzcG9uc2UoKTtcbiAgfVxufTtcblxuLy8gc3JjL2VtYmVkL2VtYmVkLnRzXG5hc3luYyBmdW5jdGlvbiBlbWJlZCh7XG4gIG1vZGVsOiBtb2RlbEFyZyxcbiAgdmFsdWUsXG4gIHByb3ZpZGVyT3B0aW9ucyxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICBjb25zdCBtb2RlbCA9IHJlc29sdmVFbWJlZGRpbmdNb2RlbChtb2RlbEFyZyk7XG4gIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5lbWJlZFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5lbWJlZFwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICBcImFpLnZhbHVlXCI6IHsgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgY29uc3QgeyBlbWJlZGRpbmcsIHVzYWdlLCByZXNwb25zZSwgcHJvdmlkZXJNZXRhZGF0YSB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IChcbiAgICAgICAgICAvLyBuZXN0ZWQgc3BhbnMgdG8gYWxpZ24gd2l0aCB0aGUgZW1iZWRNYW55IHRlbGVtZXRyeSBkYXRhOlxuICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZC5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkLmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7IGlucHV0OiAoKSA9PiBbSlNPTi5zdHJpbmdpZnkodmFsdWUpXSB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExNztcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogW3ZhbHVlXSxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nMiA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5nc1swXTtcbiAgICAgICAgICAgICAgY29uc3QgdXNhZ2UyID0gKF9hMTcgPSBtb2RlbFJlc3BvbnNlLnVzYWdlKSAhPSBudWxsID8gX2ExNyA6IHsgdG9rZW5zOiBOYU4gfTtcbiAgICAgICAgICAgICAgZG9FbWJlZFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAoZW1iZWRkaW5nMykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nMylcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlMi50b2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVtYmVkZGluZzogZW1iZWRkaW5nMixcbiAgICAgICAgICAgICAgICB1c2FnZTogdXNhZ2UyLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1vZGVsUmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogbW9kZWxSZXNwb25zZS5yZXNwb25zZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBcImFpLmVtYmVkZGluZ1wiOiB7IG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UudG9rZW5zXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdEVtYmVkUmVzdWx0KHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGVtYmVkZGluZyxcbiAgICAgICAgdXNhZ2UsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgIHJlc3BvbnNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRFbWJlZFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHRoaXMuZW1iZWRkaW5nID0gb3B0aW9ucy5lbWJlZGRpbmc7XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbC9zcGxpdC1hcnJheS50c1xuZnVuY3Rpb24gc3BsaXRBcnJheShhcnJheSwgY2h1bmtTaXplKSB7XG4gIGlmIChjaHVua1NpemUgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICByZXN1bHQucHVzaChhcnJheS5zbGljZShpLCBpICsgY2h1bmtTaXplKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL2VtYmVkL2VtYmVkLW1hbnkudHNcbmFzeW5jIGZ1bmN0aW9uIGVtYmVkTWFueSh7XG4gIG1vZGVsOiBtb2RlbEFyZyxcbiAgdmFsdWVzLFxuICBtYXhQYXJhbGxlbENhbGxzID0gSW5maW5pdHksXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICBjb25zdCBtb2RlbCA9IHJlc29sdmVFbWJlZGRpbmdNb2RlbChtb2RlbEFyZyk7XG4gIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5lbWJlZE1hbnlcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHsgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWRNYW55XCIsIHRlbGVtZXRyeSB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICBjb25zdCBbbWF4RW1iZWRkaW5nc1BlckNhbGwsIHN1cHBvcnRzUGFyYWxsZWxDYWxsc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIG1vZGVsLm1heEVtYmVkZGluZ3NQZXJDYWxsLFxuICAgICAgICBtb2RlbC5zdXBwb3J0c1BhcmFsbGVsQ2FsbHNcbiAgICAgIF0pO1xuICAgICAgaWYgKG1heEVtYmVkZGluZ3NQZXJDYWxsID09IG51bGwgfHwgbWF4RW1iZWRkaW5nc1BlckNhbGwgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGNvbnN0IHsgZW1iZWRkaW5nczogZW1iZWRkaW5nczIsIHVzYWdlLCByZXNwb25zZSwgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YTIgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gdmFsdWVzLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgIGZuOiBhc3luYyAoZG9FbWJlZFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbFJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZG9FbWJlZCh7XG4gICAgICAgICAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmdzMyA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncztcbiAgICAgICAgICAgICAgICBjb25zdCB1c2FnZTIgPSAoX2ExOCA9IG1vZGVsUmVzcG9uc2UudXNhZ2UpICE9IG51bGwgPyBfYTE4IDogeyB0b2tlbnM6IE5hTiB9O1xuICAgICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5nczMubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZTIudG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgZW1iZWRkaW5nczogZW1iZWRkaW5nczMsXG4gICAgICAgICAgICAgICAgICB1c2FnZTogdXNhZ2UyLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmVzcG9uc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MyLm1hcCgoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZS50b2tlbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZE1hbnlSZXN1bHQoe1xuICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMixcbiAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhMixcbiAgICAgICAgICByZXNwb25zZXM6IFtyZXNwb25zZV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZUNodW5rcyA9IHNwbGl0QXJyYXkodmFsdWVzLCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCk7XG4gICAgICBjb25zdCBlbWJlZGRpbmdzID0gW107XG4gICAgICBjb25zdCByZXNwb25zZXMgPSBbXTtcbiAgICAgIGxldCB0b2tlbnMgPSAwO1xuICAgICAgbGV0IHByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICBjb25zdCBwYXJhbGxlbENodW5rcyA9IHNwbGl0QXJyYXkoXG4gICAgICAgIHZhbHVlQ2h1bmtzLFxuICAgICAgICBzdXBwb3J0c1BhcmFsbGVsQ2FsbHMgPyBtYXhQYXJhbGxlbENhbGxzIDogMVxuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3QgcGFyYWxsZWxDaHVuayBvZiBwYXJhbGxlbENodW5rcykge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgcGFyYWxsZWxDaHVuay5tYXAoKGNodW5rKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmV0cnkoKCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IGNodW5rLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgICBmbjogYXN5bmMgKGRvRW1iZWRTcGFuKSA9PiB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmdzMiA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncztcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHVzYWdlID0gKF9hMTggPSBtb2RlbFJlc3BvbnNlLnVzYWdlKSAhPSBudWxsID8gX2ExOCA6IHsgdG9rZW5zOiBOYU4gfTtcbiAgICAgICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MyLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZS50b2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZW1iZWRkaW5nczogZW1iZWRkaW5nczIsXG4gICAgICAgICAgICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtb2RlbFJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBtb2RlbFJlc3BvbnNlLnJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgZW1iZWRkaW5ncy5wdXNoKC4uLnJlc3VsdC5lbWJlZGRpbmdzKTtcbiAgICAgICAgICByZXNwb25zZXMucHVzaChyZXN1bHQucmVzcG9uc2UpO1xuICAgICAgICAgIHRva2VucyArPSByZXN1bHQudXNhZ2UudG9rZW5zO1xuICAgICAgICAgIGlmIChyZXN1bHQucHJvdmlkZXJNZXRhZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFwcm92aWRlck1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEgPSB7IC4uLnJlc3VsdC5wcm92aWRlck1ldGFkYXRhIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtwcm92aWRlck5hbWUsIG1ldGFkYXRhXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICAgICAgICAgICAgICByZXN1bHQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgLi4uKF9hMTcgPSBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0pICE9IG51bGwgPyBfYTE3IDoge30sXG4gICAgICAgICAgICAgICAgICAuLi5tZXRhZGF0YVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5ncy5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB0b2tlbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRNYW55UmVzdWx0KHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICBlbWJlZGRpbmdzLFxuICAgICAgICB1c2FnZTogeyB0b2tlbnMgfSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgcmVzcG9uc2VzXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRFbWJlZE1hbnlSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICAgIHRoaXMuZW1iZWRkaW5ncyA9IG9wdGlvbnMuZW1iZWRkaW5ncztcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgfVxufTtcblxuLy8gc3JjL2dlbmVyYXRlLWltYWdlL2dlbmVyYXRlLWltYWdlLnRzXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUltYWdlKHtcbiAgbW9kZWwsXG4gIHByb21wdCxcbiAgbiA9IDEsXG4gIG1heEltYWdlc1BlckNhbGwsXG4gIHNpemUsXG4gIGFzcGVjdFJhdGlvLFxuICBzZWVkLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzXG59KSB7XG4gIHZhciBfYTE3LCBfYjtcbiAgaWYgKG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uICE9PSBcInYyXCIpIHtcbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvcih7XG4gICAgICB2ZXJzaW9uOiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbixcbiAgICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgICB9KTtcbiAgfVxuICBjb25zdCB7IHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3QgbWF4SW1hZ2VzUGVyQ2FsbFdpdGhEZWZhdWx0ID0gKF9hMTcgPSBtYXhJbWFnZXNQZXJDYWxsICE9IG51bGwgPyBtYXhJbWFnZXNQZXJDYWxsIDogYXdhaXQgaW52b2tlTW9kZWxNYXhJbWFnZXNQZXJDYWxsKG1vZGVsKSkgIT0gbnVsbCA/IF9hMTcgOiAxO1xuICBjb25zdCBjYWxsQ291bnQgPSBNYXRoLmNlaWwobiAvIG1heEltYWdlc1BlckNhbGxXaXRoRGVmYXVsdCk7XG4gIGNvbnN0IGNhbGxJbWFnZUNvdW50cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGNhbGxDb3VudCB9LCAoXywgaSkgPT4ge1xuICAgIGlmIChpIDwgY2FsbENvdW50IC0gMSkge1xuICAgICAgcmV0dXJuIG1heEltYWdlc1BlckNhbGxXaXRoRGVmYXVsdDtcbiAgICB9XG4gICAgY29uc3QgcmVtYWluZGVyID0gbiAlIG1heEltYWdlc1BlckNhbGxXaXRoRGVmYXVsdDtcbiAgICByZXR1cm4gcmVtYWluZGVyID09PSAwID8gbWF4SW1hZ2VzUGVyQ2FsbFdpdGhEZWZhdWx0IDogcmVtYWluZGVyO1xuICB9KTtcbiAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGNhbGxJbWFnZUNvdW50cy5tYXAoXG4gICAgICBhc3luYyAoY2FsbEltYWdlQ291bnQpID0+IHJldHJ5KFxuICAgICAgICAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgbjogY2FsbEltYWdlQ291bnQsXG4gICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIGFzcGVjdFJhdGlvLFxuICAgICAgICAgIHNlZWQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck9wdGlvbnMgIT0gbnVsbCA/IHByb3ZpZGVyT3B0aW9ucyA6IHt9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKVxuICApO1xuICBjb25zdCBpbWFnZXMgPSBbXTtcbiAgY29uc3Qgd2FybmluZ3MgPSBbXTtcbiAgY29uc3QgcmVzcG9uc2VzID0gW107XG4gIGNvbnN0IHByb3ZpZGVyTWV0YWRhdGEgPSB7fTtcbiAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgIGltYWdlcy5wdXNoKFxuICAgICAgLi4ucmVzdWx0LmltYWdlcy5tYXAoXG4gICAgICAgIChpbWFnZSkgPT4ge1xuICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlZEZpbGUoe1xuICAgICAgICAgICAgZGF0YTogaW1hZ2UsXG4gICAgICAgICAgICBtZWRpYVR5cGU6IChfYTE4ID0gZGV0ZWN0TWVkaWFUeXBlKHtcbiAgICAgICAgICAgICAgZGF0YTogaW1hZ2UsXG4gICAgICAgICAgICAgIHNpZ25hdHVyZXM6IGltYWdlTWVkaWFUeXBlU2lnbmF0dXJlc1xuICAgICAgICAgICAgfSkpICE9IG51bGwgPyBfYTE4IDogXCJpbWFnZS9wbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgICB3YXJuaW5ncy5wdXNoKC4uLnJlc3VsdC53YXJuaW5ncyk7XG4gICAgaWYgKHJlc3VsdC5wcm92aWRlck1ldGFkYXRhKSB7XG4gICAgICBmb3IgKGNvbnN0IFtwcm92aWRlck5hbWUsIG1ldGFkYXRhXSBvZiBPYmplY3QuZW50cmllcyhyZXN1bHQucHJvdmlkZXJNZXRhZGF0YSkpIHtcbiAgICAgICAgKF9iID0gcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdKSAhPSBudWxsID8gX2IgOiBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0gPSB7IGltYWdlczogW10gfTtcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdLmltYWdlcy5wdXNoKFxuICAgICAgICAgIC4uLnJlc3VsdC5wcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0uaW1hZ2VzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3BvbnNlcy5wdXNoKHJlc3VsdC5yZXNwb25zZSk7XG4gIH1cbiAgbG9nV2FybmluZ3Mod2FybmluZ3MpO1xuICBpZiAoIWltYWdlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgTm9JbWFnZUdlbmVyYXRlZEVycm9yKHsgcmVzcG9uc2VzIH0pO1xuICB9XG4gIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlSW1hZ2VSZXN1bHQoe1xuICAgIGltYWdlcyxcbiAgICB3YXJuaW5ncyxcbiAgICByZXNwb25zZXMsXG4gICAgcHJvdmlkZXJNZXRhZGF0YVxuICB9KTtcbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVJbWFnZVJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuaW1hZ2VzID0gb3B0aW9ucy5pbWFnZXM7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gIH1cbiAgZ2V0IGltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlc1swXTtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGludm9rZU1vZGVsTWF4SW1hZ2VzUGVyQ2FsbChtb2RlbCkge1xuICBjb25zdCBpc0Z1bmN0aW9uID0gbW9kZWwubWF4SW1hZ2VzUGVyQ2FsbCBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICBpZiAoIWlzRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gbW9kZWwubWF4SW1hZ2VzUGVyQ2FsbDtcbiAgfVxuICByZXR1cm4gbW9kZWwubWF4SW1hZ2VzUGVyQ2FsbCh7XG4gICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICB9KTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC9nZW5lcmF0ZS1vYmplY3QudHNcbmltcG9ydCB7XG4gIGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yM1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9leHRyYWN0LXJlYXNvbmluZy1jb250ZW50LnRzXG5mdW5jdGlvbiBleHRyYWN0UmVhc29uaW5nQ29udGVudChjb250ZW50KSB7XG4gIGNvbnN0IHBhcnRzID0gY29udGVudC5maWx0ZXIoXG4gICAgKGNvbnRlbnQyKSA9PiBjb250ZW50Mi50eXBlID09PSBcInJlYXNvbmluZ1wiXG4gICk7XG4gIHJldHVybiBwYXJ0cy5sZW5ndGggPT09IDAgPyB2b2lkIDAgOiBwYXJ0cy5tYXAoKGNvbnRlbnQyKSA9PiBjb250ZW50Mi50ZXh0KS5qb2luKFwiXFxuXCIpO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtb2JqZWN0L291dHB1dC1zdHJhdGVneS50c1xuaW1wb3J0IHtcbiAgaXNKU09OQXJyYXksXG4gIGlzSlNPTk9iamVjdCxcbiAgVHlwZVZhbGlkYXRpb25FcnJvciBhcyBUeXBlVmFsaWRhdGlvbkVycm9yMixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgYXMgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBhc1NjaGVtYSBhcyBhc1NjaGVtYTMsXG4gIHNhZmVWYWxpZGF0ZVR5cGVzIGFzIHNhZmVWYWxpZGF0ZVR5cGVzM1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIG5vU2NoZW1hT3V0cHV0U3RyYXRlZ3kgPSB7XG4gIHR5cGU6IFwibm8tc2NoZW1hXCIsXG4gIGpzb25TY2hlbWE6IHZvaWQgMCxcbiAgYXN5bmMgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHsgdmFsdWUsIHRleHREZWx0YSB9KSB7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHsgcGFydGlhbDogdmFsdWUsIHRleHREZWx0YSB9IH07XG4gIH0sXG4gIGFzeW5jIHZhbGlkYXRlRmluYWxSZXN1bHQodmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiByZXNwb25zZSBkaWQgbm90IG1hdGNoIHNjaGVtYS5cIixcbiAgICAgICAgdGV4dDogY29udGV4dC50ZXh0LFxuICAgICAgICByZXNwb25zZTogY29udGV4dC5yZXNwb25zZSxcbiAgICAgICAgdXNhZ2U6IGNvbnRleHQudXNhZ2UsXG4gICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dC5maW5pc2hSZWFzb25cbiAgICAgIH0pXG4gICAgfSA6IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWUgfTtcbiAgfSxcbiAgY3JlYXRlRWxlbWVudFN0cmVhbSgpIHtcbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyKHtcbiAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiZWxlbWVudCBzdHJlYW1zIGluIG5vLXNjaGVtYSBtb2RlXCJcbiAgICB9KTtcbiAgfVxufTtcbnZhciBvYmplY3RPdXRwdXRTdHJhdGVneSA9IChzY2hlbWEpID0+ICh7XG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIGpzb25TY2hlbWE6IHNjaGVtYS5qc29uU2NoZW1hLFxuICBhc3luYyB2YWxpZGF0ZVBhcnRpYWxSZXN1bHQoeyB2YWx1ZSwgdGV4dERlbHRhIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIC8vIE5vdGU6IGN1cnJlbnRseSBubyB2YWxpZGF0aW9uIG9mIHBhcnRpYWwgcmVzdWx0czpcbiAgICAgICAgcGFydGlhbDogdmFsdWUsXG4gICAgICAgIHRleHREZWx0YVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFzeW5jIHZhbGlkYXRlRmluYWxSZXN1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gc2FmZVZhbGlkYXRlVHlwZXMzKHsgdmFsdWUsIHNjaGVtYSB9KTtcbiAgfSxcbiAgY3JlYXRlRWxlbWVudFN0cmVhbSgpIHtcbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyKHtcbiAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiZWxlbWVudCBzdHJlYW1zIGluIG9iamVjdCBtb2RlXCJcbiAgICB9KTtcbiAgfVxufSk7XG52YXIgYXJyYXlPdXRwdXRTdHJhdGVneSA9IChzY2hlbWEpID0+IHtcbiAgY29uc3QgeyAkc2NoZW1hLCAuLi5pdGVtU2NoZW1hIH0gPSBzY2hlbWEuanNvblNjaGVtYTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICAvLyB3cmFwIGluIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFycmF5IG9mIGVsZW1lbnRzLCBzaW5jZSBtb3N0IExMTXMgd2lsbCBub3RcbiAgICAvLyBiZSBhYmxlIHRvIGdlbmVyYXRlIGFuIGFycmF5IGRpcmVjdGx5OlxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBvcHRpbWl6YXRpb246IHVzZSBhcnJheXMgZGlyZWN0bHkgd2hlbiBtb2RlbCBzdXBwb3J0cyBncmFtbWFyLWd1aWRlZCBnZW5lcmF0aW9uXG4gICAganNvblNjaGVtYToge1xuICAgICAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGVsZW1lbnRzOiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IGl0ZW1TY2hlbWEgfVxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkOiBbXCJlbGVtZW50c1wiXSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgIH0sXG4gICAgYXN5bmMgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHtcbiAgICAgIHZhbHVlLFxuICAgICAgbGF0ZXN0T2JqZWN0LFxuICAgICAgaXNGaXJzdERlbHRhLFxuICAgICAgaXNGaW5hbERlbHRhXG4gICAgfSkge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgIWlzSlNPTkFycmF5KHZhbHVlLmVsZW1lbnRzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjIoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFuIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRBcnJheSA9IHZhbHVlLmVsZW1lbnRzO1xuICAgICAgY29uc3QgcmVzdWx0QXJyYXkgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gaW5wdXRBcnJheVtpXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMzKHsgdmFsdWU6IGVsZW1lbnQsIHNjaGVtYSB9KTtcbiAgICAgICAgaWYgKGkgPT09IGlucHV0QXJyYXkubGVuZ3RoIC0gMSAmJiAhaXNGaW5hbERlbHRhKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0QXJyYXkucHVzaChyZXN1bHQudmFsdWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHVibGlzaGVkRWxlbWVudENvdW50ID0gKF9hMTcgPSBsYXRlc3RPYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGxhdGVzdE9iamVjdC5sZW5ndGgpICE9IG51bGwgPyBfYTE3IDogMDtcbiAgICAgIGxldCB0ZXh0RGVsdGEgPSBcIlwiO1xuICAgICAgaWYgKGlzRmlyc3REZWx0YSkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCJbXCI7XG4gICAgICB9XG4gICAgICBpZiAocHVibGlzaGVkRWxlbWVudENvdW50ID4gMCkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCIsXCI7XG4gICAgICB9XG4gICAgICB0ZXh0RGVsdGEgKz0gcmVzdWx0QXJyYXkuc2xpY2UocHVibGlzaGVkRWxlbWVudENvdW50KS5tYXAoKGVsZW1lbnQpID0+IEpTT04uc3RyaW5naWZ5KGVsZW1lbnQpKS5qb2luKFwiLFwiKTtcbiAgICAgIGlmIChpc0ZpbmFsRGVsdGEpIHtcbiAgICAgICAgdGV4dERlbHRhICs9IFwiXVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBwYXJ0aWFsOiByZXN1bHRBcnJheSxcbiAgICAgICAgICB0ZXh0RGVsdGFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzeW5jIHZhbGlkYXRlRmluYWxSZXN1bHQodmFsdWUpIHtcbiAgICAgIGlmICghaXNKU09OT2JqZWN0KHZhbHVlKSB8fCAhaXNKU09OQXJyYXkodmFsdWUuZWxlbWVudHMpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yMih7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYW4gYXJyYXkgb2YgZWxlbWVudHNcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBpbnB1dEFycmF5ID0gdmFsdWUuZWxlbWVudHM7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgaW5wdXRBcnJheSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlczMoeyB2YWx1ZTogZWxlbWVudCwgc2NoZW1hIH0pO1xuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IGlucHV0QXJyYXkgfTtcbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnRTdHJlYW0ob3JpZ2luYWxTdHJlYW0pIHtcbiAgICAgIGxldCBwdWJsaXNoZWRFbGVtZW50cyA9IDA7XG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgICAgb3JpZ2luYWxTdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhcnJheSA9IGNodW5rLm9iamVjdDtcbiAgICAgICAgICAgICAgICAgIGZvciAoOyBwdWJsaXNoZWRFbGVtZW50cyA8IGFycmF5Lmxlbmd0aDsgcHVibGlzaGVkRWxlbWVudHMrKykge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYXJyYXlbcHVibGlzaGVkRWxlbWVudHNdKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9O1xufTtcbnZhciBlbnVtT3V0cHV0U3RyYXRlZ3kgPSAoZW51bVZhbHVlcykgPT4ge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIC8vIHdyYXAgaW4gb2JqZWN0IHRoYXQgY29udGFpbnMgcmVzdWx0LCBzaW5jZSBtb3N0IExMTXMgd2lsbCBub3RcbiAgICAvLyBiZSBhYmxlIHRvIGdlbmVyYXRlIGFuIGVudW0gdmFsdWUgZGlyZWN0bHk6XG4gICAgLy8gcG9zc2libGUgZnV0dXJlIG9wdGltaXphdGlvbjogdXNlIGVudW1zIGRpcmVjdGx5IHdoZW4gbW9kZWwgc3VwcG9ydHMgdG9wLWxldmVsIGVudW1zXG4gICAganNvblNjaGVtYToge1xuICAgICAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHJlc3VsdDogeyB0eXBlOiBcInN0cmluZ1wiLCBlbnVtOiBlbnVtVmFsdWVzIH1cbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogW1wicmVzdWx0XCJdLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlXG4gICAgfSxcbiAgICBhc3luYyB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlKSB7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnJlc3VsdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjIoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogJ3ZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBzdHJpbmcgaW4gdGhlIFwicmVzdWx0XCIgcHJvcGVydHkuJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5yZXN1bHQ7XG4gICAgICByZXR1cm4gZW51bVZhbHVlcy5pbmNsdWRlcyhyZXN1bHQpID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0IH0gOiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3IyKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIGluIHRoZSBlbnVtXCJcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSxcbiAgICBhc3luYyB2YWxpZGF0ZVBhcnRpYWxSZXN1bHQoeyB2YWx1ZSwgdGV4dERlbHRhIH0pIHtcbiAgICAgIGlmICghaXNKU09OT2JqZWN0KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUucmVzdWx0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yMih7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiAndmFsdWUgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIHN0cmluZyBpbiB0aGUgXCJyZXN1bHRcIiBwcm9wZXJ0eS4nXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLnJlc3VsdDtcbiAgICAgIGNvbnN0IHBvc3NpYmxlRW51bVZhbHVlcyA9IGVudW1WYWx1ZXMuZmlsdGVyKFxuICAgICAgICAoZW51bVZhbHVlKSA9PiBlbnVtVmFsdWUuc3RhcnRzV2l0aChyZXN1bHQpXG4gICAgICApO1xuICAgICAgaWYgKHZhbHVlLnJlc3VsdC5sZW5ndGggPT09IDAgfHwgcG9zc2libGVFbnVtVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjIoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIGluIHRoZSBlbnVtXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBwYXJ0aWFsOiBwb3NzaWJsZUVudW1WYWx1ZXMubGVuZ3RoID4gMSA/IHJlc3VsdCA6IHBvc3NpYmxlRW51bVZhbHVlc1swXSxcbiAgICAgICAgICB0ZXh0RGVsdGFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnRTdHJlYW0oKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyKHtcbiAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJlbGVtZW50IHN0cmVhbXMgaW4gZW51bSBtb2RlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBnZXRPdXRwdXRTdHJhdGVneSh7XG4gIG91dHB1dCxcbiAgc2NoZW1hLFxuICBlbnVtVmFsdWVzXG59KSB7XG4gIHN3aXRjaCAob3V0cHV0KSB7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgcmV0dXJuIG9iamVjdE91dHB1dFN0cmF0ZWd5KGFzU2NoZW1hMyhzY2hlbWEpKTtcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIHJldHVybiBhcnJheU91dHB1dFN0cmF0ZWd5KGFzU2NoZW1hMyhzY2hlbWEpKTtcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgcmV0dXJuIGVudW1PdXRwdXRTdHJhdGVneShlbnVtVmFsdWVzKTtcbiAgICBjYXNlIFwibm8tc2NoZW1hXCI6XG4gICAgICByZXR1cm4gbm9TY2hlbWFPdXRwdXRTdHJhdGVneTtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gb3V0cHV0O1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvdXRwdXQ6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC9wYXJzZS1hbmQtdmFsaWRhdGUtb2JqZWN0LXJlc3VsdC50c1xuaW1wb3J0IHsgSlNPTlBhcnNlRXJyb3IgYXMgSlNPTlBhcnNlRXJyb3IyLCBUeXBlVmFsaWRhdGlvbkVycm9yIGFzIFR5cGVWYWxpZGF0aW9uRXJyb3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNhZmVQYXJzZUpTT04gYXMgc2FmZVBhcnNlSlNPTjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VBbmRWYWxpZGF0ZU9iamVjdFJlc3VsdChyZXN1bHQsIG91dHB1dFN0cmF0ZWd5LCBjb250ZXh0KSB7XG4gIGNvbnN0IHBhcnNlUmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTjMoeyB0ZXh0OiByZXN1bHQgfSk7XG4gIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogY291bGQgbm90IHBhcnNlIHRoZSByZXNwb25zZS5cIixcbiAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgIHRleHQ6IHJlc3VsdCxcbiAgICAgIHJlc3BvbnNlOiBjb250ZXh0LnJlc3BvbnNlLFxuICAgICAgdXNhZ2U6IGNvbnRleHQudXNhZ2UsXG4gICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQuZmluaXNoUmVhc29uXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlRmluYWxSZXN1bHQoXG4gICAgcGFyc2VSZXN1bHQudmFsdWUsXG4gICAge1xuICAgICAgdGV4dDogcmVzdWx0LFxuICAgICAgcmVzcG9uc2U6IGNvbnRleHQucmVzcG9uc2UsXG4gICAgICB1c2FnZTogY29udGV4dC51c2FnZVxuICAgIH1cbiAgKTtcbiAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3IsXG4gICAgICB0ZXh0OiByZXN1bHQsXG4gICAgICByZXNwb25zZTogY29udGV4dC5yZXNwb25zZSxcbiAgICAgIHVzYWdlOiBjb250ZXh0LnVzYWdlLFxuICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0LmZpbmlzaFJlYXNvblxuICAgIH0pO1xuICB9XG4gIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlO1xufVxuYXN5bmMgZnVuY3Rpb24gcGFyc2VBbmRWYWxpZGF0ZU9iamVjdFJlc3VsdFdpdGhSZXBhaXIocmVzdWx0LCBvdXRwdXRTdHJhdGVneSwgcmVwYWlyVGV4dCwgY29udGV4dCkge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBwYXJzZUFuZFZhbGlkYXRlT2JqZWN0UmVzdWx0KHJlc3VsdCwgb3V0cHV0U3RyYXRlZ3ksIGNvbnRleHQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChyZXBhaXJUZXh0ICE9IG51bGwgJiYgTm9PYmplY3RHZW5lcmF0ZWRFcnJvci5pc0luc3RhbmNlKGVycm9yKSAmJiAoSlNPTlBhcnNlRXJyb3IyLmlzSW5zdGFuY2UoZXJyb3IuY2F1c2UpIHx8IFR5cGVWYWxpZGF0aW9uRXJyb3IzLmlzSW5zdGFuY2UoZXJyb3IuY2F1c2UpKSkge1xuICAgICAgY29uc3QgcmVwYWlyZWRUZXh0ID0gYXdhaXQgcmVwYWlyVGV4dCh7XG4gICAgICAgIHRleHQ6IHJlc3VsdCxcbiAgICAgICAgZXJyb3I6IGVycm9yLmNhdXNlXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXBhaXJlZFRleHQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgcGFyc2VBbmRWYWxpZGF0ZU9iamVjdFJlc3VsdChcbiAgICAgICAgcmVwYWlyZWRUZXh0LFxuICAgICAgICBvdXRwdXRTdHJhdGVneSxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC92YWxpZGF0ZS1vYmplY3QtZ2VuZXJhdGlvbi1pbnB1dC50c1xuZnVuY3Rpb24gdmFsaWRhdGVPYmplY3RHZW5lcmF0aW9uSW5wdXQoe1xuICBvdXRwdXQsXG4gIHNjaGVtYSxcbiAgc2NoZW1hTmFtZSxcbiAgc2NoZW1hRGVzY3JpcHRpb24sXG4gIGVudW1WYWx1ZXNcbn0pIHtcbiAgaWYgKG91dHB1dCAhPSBudWxsICYmIG91dHB1dCAhPT0gXCJvYmplY3RcIiAmJiBvdXRwdXQgIT09IFwiYXJyYXlcIiAmJiBvdXRwdXQgIT09IFwiZW51bVwiICYmIG91dHB1dCAhPT0gXCJuby1zY2hlbWFcIikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBwYXJhbWV0ZXI6IFwib3V0cHV0XCIsXG4gICAgICB2YWx1ZTogb3V0cHV0LFxuICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIG91dHB1dCB0eXBlLlwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJuby1zY2hlbWFcIikge1xuICAgIGlmIChzY2hlbWEgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFEZXNjcmlwdGlvblwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGRlc2NyaXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hTmFtZSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hTmFtZVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hTmFtZSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgbmFtZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGlzIHJlcXVpcmVkIGZvciBvYmplY3Qgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIG9iamVjdCBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcImFycmF5XCIpIHtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJFbGVtZW50IHNjaGVtYSBpcyByZXF1aXJlZCBmb3IgYXJyYXkgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGFycmF5IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChvdXRwdXQgPT09IFwiZW51bVwiKSB7XG4gICAgaWYgKHNjaGVtYSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFEZXNjcmlwdGlvblwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGRlc2NyaXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYU5hbWUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYU5hbWVcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYU5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIG5hbWUgaXMgbm90IHN1cHBvcnRlZCBmb3IgZW51bSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZW51bVZhbHVlcyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICB2YWx1ZTogZW51bVZhbHVlcyxcbiAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBhcmUgcmVxdWlyZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBlbnVtVmFsdWVzKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIG11c3QgYmUgc3RyaW5ncy5cIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC9nZW5lcmF0ZS1vYmplY3QudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQzID0gY3JlYXRlSWRHZW5lcmF0b3IzKHsgcHJlZml4OiBcImFpb2JqXCIsIHNpemU6IDI0IH0pO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVPYmplY3Qob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgbW9kZWw6IG1vZGVsQXJnLFxuICAgIG91dHB1dCA9IFwib2JqZWN0XCIsXG4gICAgc3lzdGVtLFxuICAgIHByb21wdCxcbiAgICBtZXNzYWdlcyxcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsLFxuICAgIGhlYWRlcnMsXG4gICAgZXhwZXJpbWVudGFsX3JlcGFpclRleHQ6IHJlcGFpclRleHQsXG4gICAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICAgIGV4cGVyaW1lbnRhbF9kb3dubG9hZDogZG93bmxvYWQyLFxuICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICBfaW50ZXJuYWw6IHtcbiAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkMyxcbiAgICAgIGN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICB9ID0ge30sXG4gICAgLi4uc2V0dGluZ3NcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG1vZGVsID0gcmVzb2x2ZUxhbmd1YWdlTW9kZWwobW9kZWxBcmcpO1xuICBjb25zdCBlbnVtVmFsdWVzID0gXCJlbnVtXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZW51bSA6IHZvaWQgMDtcbiAgY29uc3Qge1xuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgc2NoZW1hTmFtZVxuICB9ID0gXCJzY2hlbWFcIiBpbiBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuICB2YWxpZGF0ZU9iamVjdEdlbmVyYXRpb25JbnB1dCh7XG4gICAgb3V0cHV0LFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgc2NoZW1hTmFtZSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBlbnVtVmFsdWVzXG4gIH0pO1xuICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3Qgb3V0cHV0U3RyYXRlZ3kgPSBnZXRPdXRwdXRTdHJhdGVneSh7XG4gICAgb3V0cHV0LFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgY29uc3QgY2FsbFNldHRpbmdzID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IC4uLmNhbGxTZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcmVjb3JkU3Bhbih7XG4gICAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0XCIsXG4gICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlT2JqZWN0XCIsXG4gICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImFpLnNjaGVtYVwiOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hICE9IG51bGwgPyB7IGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hKSB9IDogdm9pZCAwLFxuICAgICAgICAgIFwiYWkuc2NoZW1hLm5hbWVcIjogc2NoZW1hTmFtZSxcbiAgICAgICAgICBcImFpLnNjaGVtYS5kZXNjcmlwdGlvblwiOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgICBcImFpLnNldHRpbmdzLm91dHB1dFwiOiBvdXRwdXRTdHJhdGVneS50eXBlXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICAgIHZhciBfYTE3O1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBsZXQgZmluaXNoUmVhc29uO1xuICAgICAgICBsZXQgdXNhZ2U7XG4gICAgICAgIGxldCB3YXJuaW5ncztcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcmVxdWVzdDtcbiAgICAgICAgbGV0IHJlc3VsdFByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgIGxldCByZWFzb25pbmc7XG4gICAgICAgIGNvbnN0IHN0YW5kYXJkaXplZFByb21wdCA9IGF3YWl0IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgIHByb21wdDogc3RhbmRhcmRpemVkUHJvbXB0LFxuICAgICAgICAgIHN1cHBvcnRlZFVybHM6IGF3YWl0IG1vZGVsLnN1cHBvcnRlZFVybHMsXG4gICAgICAgICAgZG93bmxvYWQ6IGRvd25sb2FkMlxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVSZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZU9iamVjdC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gc3RyaW5naWZ5Rm9yVGVsZW1ldHJ5KHByb21wdE1lc3NhZ2VzKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBjYWxsU2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogY2FsbFNldHRpbmdzLm1heE91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogY2FsbFNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IGNhbGxTZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IGNhbGxTZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogY2FsbFNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTE4LCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlRm9ybWF0OiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICAgIHNjaGVtYTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHNjaGVtYU5hbWUsXG4gICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpZDogKF9iID0gKF9hMTggPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOC5pZCkgIT0gbnVsbCA/IF9iIDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfZCA9IChfYyA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYy50aW1lc3RhbXApICE9IG51bGwgPyBfZCA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgICAgICAgICAgbW9kZWxJZDogKF9mID0gKF9lID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm1vZGVsSWQpICE9IG51bGwgPyBfZiA6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogKF9nID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogKF9oID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9oLmJvZHlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY29uc3QgdGV4dDIgPSBleHRyYWN0VGV4dENvbnRlbnQocmVzdWx0Mi5jb250ZW50KTtcbiAgICAgICAgICAgICAgY29uc3QgcmVhc29uaW5nMiA9IGV4dHJhY3RSZWFzb25pbmdDb250ZW50KHJlc3VsdDIuY29udGVudCk7XG4gICAgICAgICAgICAgIGlmICh0ZXh0MiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiB0aGUgbW9kZWwgZGlkIG5vdCByZXR1cm4gYSByZXNwb25zZS5cIixcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZURhdGEsXG4gICAgICAgICAgICAgICAgICB1c2FnZTogcmVzdWx0Mi51c2FnZSxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogcmVzdWx0Mi5maW5pc2hSZWFzb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiByZXN1bHQyLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IHRleHQyIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiByZXNwb25zZURhdGEudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyByZW5hbWUgdGVsZW1ldHJ5IGF0dHJpYnV0ZXMgdG8gaW5wdXRUb2tlbnMgYW5kIG91dHB1dFRva2Vuc1xuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogcmVzdWx0Mi51c2FnZS5vdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW3Jlc3VsdDIuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5vdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnJlc3VsdDIsXG4gICAgICAgICAgICAgICAgb2JqZWN0VGV4dDogdGV4dDIsXG4gICAgICAgICAgICAgICAgcmVhc29uaW5nOiByZWFzb25pbmcyLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlRGF0YVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlUmVzdWx0Lm9iamVjdFRleHQ7XG4gICAgICAgIGZpbmlzaFJlYXNvbiA9IGdlbmVyYXRlUmVzdWx0LmZpbmlzaFJlYXNvbjtcbiAgICAgICAgdXNhZ2UgPSBnZW5lcmF0ZVJlc3VsdC51c2FnZTtcbiAgICAgICAgd2FybmluZ3MgPSBnZW5lcmF0ZVJlc3VsdC53YXJuaW5ncztcbiAgICAgICAgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YSA9IGdlbmVyYXRlUmVzdWx0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgIHJlcXVlc3QgPSAoX2ExNyA9IGdlbmVyYXRlUmVzdWx0LnJlcXVlc3QpICE9IG51bGwgPyBfYTE3IDoge307XG4gICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmVzcG9uc2VEYXRhO1xuICAgICAgICByZWFzb25pbmcgPSBnZW5lcmF0ZVJlc3VsdC5yZWFzb25pbmc7XG4gICAgICAgIGxvZ1dhcm5pbmdzKHdhcm5pbmdzKTtcbiAgICAgICAgY29uc3Qgb2JqZWN0MiA9IGF3YWl0IHBhcnNlQW5kVmFsaWRhdGVPYmplY3RSZXN1bHRXaXRoUmVwYWlyKFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICBvdXRwdXRTdHJhdGVneSxcbiAgICAgICAgICByZXBhaXJUZXh0LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb25cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QyKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGFcIjogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAvLyBUT0RPIHJlbmFtZSB0ZWxlbWV0cnkgYXR0cmlidXRlcyB0byBpbnB1dFRva2VucyBhbmQgb3V0cHV0VG9rZW5zXG4gICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogdXNhZ2Uub3V0cHV0VG9rZW5zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0R2VuZXJhdGVPYmplY3RSZXN1bHQoe1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0MixcbiAgICAgICAgICByZWFzb25pbmcsXG4gICAgICAgICAgZmluaXNoUmVhc29uLFxuICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgIHdhcm5pbmdzLFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0UHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyB3cmFwR2F0ZXdheUVycm9yKGVycm9yKTtcbiAgfVxufVxudmFyIERlZmF1bHRHZW5lcmF0ZU9iamVjdFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub2JqZWN0ID0gb3B0aW9ucy5vYmplY3Q7XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSBvcHRpb25zLmZpbmlzaFJlYXNvbjtcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgdGhpcy5yZXNwb25zZSA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgdGhpcy5yZXF1ZXN0ID0gb3B0aW9ucy5yZXF1ZXN0O1xuICAgIHRoaXMucmVhc29uaW5nID0gb3B0aW9ucy5yZWFzb25pbmc7XG4gIH1cbiAgdG9Kc29uUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTE3O1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5vYmplY3QpLCB7XG4gICAgICBzdGF0dXM6IChfYTE3ID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTE3IDogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZUhlYWRlcnMoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzLCB7XG4gICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZ2VuZXJhdGUtb2JqZWN0L3N0cmVhbS1vYmplY3QudHNcbmltcG9ydCB7XG4gIGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yNFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9jb3NpbmUtc2ltaWxhcml0eS50c1xuZnVuY3Rpb24gY29zaW5lU2ltaWxhcml0eSh2ZWN0b3IxLCB2ZWN0b3IyKSB7XG4gIGlmICh2ZWN0b3IxLmxlbmd0aCAhPT0gdmVjdG9yMi5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgcGFyYW1ldGVyOiBcInZlY3RvcjEsdmVjdG9yMlwiLFxuICAgICAgdmFsdWU6IHsgdmVjdG9yMUxlbmd0aDogdmVjdG9yMS5sZW5ndGgsIHZlY3RvcjJMZW5ndGg6IHZlY3RvcjIubGVuZ3RoIH0sXG4gICAgICBtZXNzYWdlOiBgVmVjdG9ycyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoYFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IG4gPSB2ZWN0b3IxLmxlbmd0aDtcbiAgaWYgKG4gPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgbWFnbml0dWRlU3F1YXJlZDEgPSAwO1xuICBsZXQgbWFnbml0dWRlU3F1YXJlZDIgPSAwO1xuICBsZXQgZG90UHJvZHVjdCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgY29uc3QgdmFsdWUxID0gdmVjdG9yMVtpXTtcbiAgICBjb25zdCB2YWx1ZTIgPSB2ZWN0b3IyW2ldO1xuICAgIG1hZ25pdHVkZVNxdWFyZWQxICs9IHZhbHVlMSAqIHZhbHVlMTtcbiAgICBtYWduaXR1ZGVTcXVhcmVkMiArPSB2YWx1ZTIgKiB2YWx1ZTI7XG4gICAgZG90UHJvZHVjdCArPSB2YWx1ZTEgKiB2YWx1ZTI7XG4gIH1cbiAgcmV0dXJuIG1hZ25pdHVkZVNxdWFyZWQxID09PSAwIHx8IG1hZ25pdHVkZVNxdWFyZWQyID09PSAwID8gMCA6IGRvdFByb2R1Y3QgLyAoTWF0aC5zcXJ0KG1hZ25pdHVkZVNxdWFyZWQxKSAqIE1hdGguc3FydChtYWduaXR1ZGVTcXVhcmVkMikpO1xufVxuXG4vLyBzcmMvdXRpbC9kYXRhLXVybC50c1xuZnVuY3Rpb24gZ2V0VGV4dEZyb21EYXRhVXJsKGRhdGFVcmwpIHtcbiAgY29uc3QgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBkYXRhVXJsLnNwbGl0KFwiLFwiKTtcbiAgY29uc3QgbWVkaWFUeXBlID0gaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV07XG4gIGlmIChtZWRpYVR5cGUgPT0gbnVsbCB8fCBiYXNlNjRDb250ZW50ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdFwiKTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuYXRvYihiYXNlNjRDb250ZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY29kaW5nIGRhdGEgVVJMYCk7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWwvaXMtZGVlcC1lcXVhbC1kYXRhLnRzXG5mdW5jdGlvbiBpc0RlZXBFcXVhbERhdGEob2JqMSwgb2JqMikge1xuICBpZiAob2JqMSA9PT0gb2JqMilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKG9iajEgPT0gbnVsbCB8fCBvYmoyID09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIG9iajEgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iajIgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIG9iajEgPT09IG9iajI7XG4gIGlmIChvYmoxLmNvbnN0cnVjdG9yICE9PSBvYmoyLmNvbnN0cnVjdG9yKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKG9iajEgaW5zdGFuY2VvZiBEYXRlICYmIG9iajIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG9iajEuZ2V0VGltZSgpID09PSBvYmoyLmdldFRpbWUoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmoxKSkge1xuICAgIGlmIChvYmoxLmxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2ldLCBvYmoyW2ldKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzMSkge1xuICAgIGlmICgha2V5czIuaW5jbHVkZXMoa2V5KSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2tleV0sIG9iajJba2V5XSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy91dGlsL3NlcmlhbC1qb2ItZXhlY3V0b3IudHNcbnZhciBTZXJpYWxKb2JFeGVjdXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc1F1ZXVlKCkge1xuICAgIGlmICh0aGlzLmlzUHJvY2Vzc2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgd2hpbGUgKHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgdGhpcy5xdWV1ZVswXSgpO1xuICAgICAgdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgIH1cbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG4gIGFzeW5jIHJ1bihqb2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUyLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucXVldWUucHVzaChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgam9iKCk7XG4gICAgICAgICAgcmVzb2x2ZTIoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZvaWQgdGhpcy5wcm9jZXNzUXVldWUoKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWwvc2ltdWxhdGUtcmVhZGFibGUtc3RyZWFtLnRzXG5pbXBvcnQgeyBkZWxheSBhcyBkZWxheUZ1bmN0aW9uIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIHNpbXVsYXRlUmVhZGFibGVTdHJlYW0oe1xuICBjaHVua3MsXG4gIGluaXRpYWxEZWxheUluTXMgPSAwLFxuICBjaHVua0RlbGF5SW5NcyA9IDAsXG4gIF9pbnRlcm5hbFxufSkge1xuICB2YXIgX2ExNztcbiAgY29uc3QgZGVsYXkyID0gKF9hMTcgPSBfaW50ZXJuYWwgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnRlcm5hbC5kZWxheSkgIT0gbnVsbCA/IF9hMTcgOiBkZWxheUZ1bmN0aW9uO1xuICBsZXQgaW5kZXggPSAwO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChpbmRleCA8IGNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgYXdhaXQgZGVsYXkyKGluZGV4ID09PSAwID8gaW5pdGlhbERlbGF5SW5NcyA6IGNodW5rRGVsYXlJbk1zKTtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rc1tpbmRleCsrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC9zdHJlYW0tb2JqZWN0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkNCA9IGNyZWF0ZUlkR2VuZXJhdG9yNCh7IHByZWZpeDogXCJhaW9ialwiLCBzaXplOiAyNCB9KTtcbmZ1bmN0aW9uIHN0cmVhbU9iamVjdChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBtb2RlbCxcbiAgICBvdXRwdXQgPSBcIm9iamVjdFwiLFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgbWF4UmV0cmllcyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBoZWFkZXJzLFxuICAgIGV4cGVyaW1lbnRhbF9yZXBhaXJUZXh0OiByZXBhaXJUZXh0LFxuICAgIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgICBleHBlcmltZW50YWxfZG93bmxvYWQ6IGRvd25sb2FkMixcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgb25FcnJvciA9ICh7IGVycm9yIH0pID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH0sXG4gICAgb25GaW5pc2gsXG4gICAgX2ludGVybmFsOiB7XG4gICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZDQsXG4gICAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgbm93OiBub3cyID0gbm93XG4gICAgfSA9IHt9LFxuICAgIC4uLnNldHRpbmdzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBlbnVtVmFsdWVzID0gXCJlbnVtXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmVudW0gPyBvcHRpb25zLmVudW0gOiB2b2lkIDA7XG4gIGNvbnN0IHtcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uLFxuICAgIHNjaGVtYU5hbWVcbiAgfSA9IFwic2NoZW1hXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcbiAgdmFsaWRhdGVPYmplY3RHZW5lcmF0aW9uSW5wdXQoe1xuICAgIG91dHB1dCxcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgY29uc3Qgb3V0cHV0U3RyYXRlZ3kgPSBnZXRPdXRwdXRTdHJhdGVneSh7XG4gICAgb3V0cHV0LFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgcmV0dXJuIG5ldyBEZWZhdWx0U3RyZWFtT2JqZWN0UmVzdWx0KHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5ncyxcbiAgICBtYXhSZXRyaWVzLFxuICAgIGFib3J0U2lnbmFsLFxuICAgIG91dHB1dFN0cmF0ZWd5LFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgc2NoZW1hTmFtZSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgcmVwYWlyVGV4dCxcbiAgICBvbkVycm9yLFxuICAgIG9uRmluaXNoLFxuICAgIGRvd25sb2FkOiBkb3dubG9hZDIsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMsXG4gICAgY3VycmVudERhdGUsXG4gICAgbm93OiBub3cyXG4gIH0pO1xufVxudmFyIERlZmF1bHRTdHJlYW1PYmplY3RSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtb2RlbDogbW9kZWxBcmcsXG4gICAgaGVhZGVycyxcbiAgICB0ZWxlbWV0cnksXG4gICAgc2V0dGluZ3MsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBvdXRwdXRTdHJhdGVneSxcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIHJlcGFpclRleHQsXG4gICAgb25FcnJvcixcbiAgICBvbkZpbmlzaCxcbiAgICBkb3dubG9hZDogZG93bmxvYWQyLFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzLFxuICAgIGN1cnJlbnREYXRlLFxuICAgIG5vdzogbm93MlxuICB9KSB7XG4gICAgdGhpcy5fb2JqZWN0ID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5fdXNhZ2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLl9wcm92aWRlck1ldGFkYXRhID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5fd2FybmluZ3MgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5fcmVzcG9uc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLl9maW5pc2hSZWFzb24gPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICBjb25zdCBtb2RlbCA9IHJlc29sdmVMYW5ndWFnZU1vZGVsKG1vZGVsQXJnKTtcbiAgICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgICAgYWJvcnRTaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBjYWxsU2V0dGluZ3MgPSBwcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIG1vZGVsLFxuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNldHRpbmdzOiB7IC4uLmNhbGxTZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gICAgfSk7XG4gICAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3Qgc3RpdGNoYWJsZVN0cmVhbSA9IGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKTtcbiAgICBjb25zdCBldmVudFByb2Nlc3NvciA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICBvbkVycm9yKHsgZXJyb3I6IHdyYXBHYXRld2F5RXJyb3IoY2h1bmsuZXJyb3IpIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5iYXNlU3RyZWFtID0gc3RpdGNoYWJsZVN0cmVhbS5zdHJlYW0ucGlwZVRocm91Z2goZXZlbnRQcm9jZXNzb3IpO1xuICAgIHJlY29yZFNwYW4oe1xuICAgICAgbmFtZTogXCJhaS5zdHJlYW1PYmplY3RcIixcbiAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtT2JqZWN0XCIsXG4gICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImFpLnNjaGVtYVwiOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hICE9IG51bGwgPyB7IGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hKSB9IDogdm9pZCAwLFxuICAgICAgICAgIFwiYWkuc2NoZW1hLm5hbWVcIjogc2NoZW1hTmFtZSxcbiAgICAgICAgICBcImFpLnNjaGVtYS5kZXNjcmlwdGlvblwiOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgICBcImFpLnNldHRpbmdzLm91dHB1dFwiOiBvdXRwdXRTdHJhdGVneS50eXBlXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgZm46IGFzeW5jIChyb290U3BhbikgPT4ge1xuICAgICAgICBjb25zdCBzdGFuZGFyZGl6ZWRQcm9tcHQgPSBhd2FpdCBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgcmVzcG9uc2VGb3JtYXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hLFxuICAgICAgICAgICAgbmFtZTogc2NoZW1hTmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFEZXNjcmlwdGlvblxuICAgICAgICAgIH0sXG4gICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgcHJvbXB0OiBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgIHByb21wdDogc3RhbmRhcmRpemVkUHJvbXB0LFxuICAgICAgICAgICAgc3VwcG9ydGVkVXJsczogYXdhaXQgbW9kZWwuc3VwcG9ydGVkVXJscyxcbiAgICAgICAgICAgIGRvd25sb2FkOiBkb3dubG9hZDJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBpbmNsdWRlUmF3Q2h1bmtzOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IHtcbiAgICAgICAgICB0cmFuc2Zvcm06IChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLmRlbHRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzdHJlYW0tc3RhcnRcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlc3VsdDogeyBzdHJlYW0sIHJlc3BvbnNlLCByZXF1ZXN0IH0sXG4gICAgICAgICAgZG9TdHJlYW1TcGFuLFxuICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXNcbiAgICAgICAgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5zdHJlYW1PYmplY3QuZG9TdHJlYW1cIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtT2JqZWN0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gc3RyaW5naWZ5Rm9yVGVsZW1ldHJ5KGNhbGxPcHRpb25zLnByb21wdClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogY2FsbFNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IGNhbGxTZXR0aW5ncy5tYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IGNhbGxTZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBjYWxsU2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBjYWxsU2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IGNhbGxTZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb1N0cmVhbVNwYW4yKSA9PiAoe1xuICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zOiBub3cyKCksXG4gICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMixcbiAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBtb2RlbC5kb1N0cmVhbShjYWxsT3B0aW9ucylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgc2VsZi5fcmVxdWVzdC5yZXNvbHZlKHJlcXVlc3QgIT0gbnVsbCA/IHJlcXVlc3QgOiB7fSk7XG4gICAgICAgIGxldCB3YXJuaW5ncztcbiAgICAgICAgbGV0IHVzYWdlID0ge1xuICAgICAgICAgIGlucHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgICAgICAgb3V0cHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgICAgICAgdG90YWxUb2tlbnM6IHZvaWQgMFxuICAgICAgICB9O1xuICAgICAgICBsZXQgZmluaXNoUmVhc29uO1xuICAgICAgICBsZXQgcHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgbGV0IG9iamVjdDI7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgbGV0IGFjY3VtdWxhdGVkVGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCB0ZXh0RGVsdGEgPSBcIlwiO1xuICAgICAgICBsZXQgZnVsbFJlc3BvbnNlID0ge1xuICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgICAgIHRpbWVzdGFtcDogY3VycmVudERhdGUoKSxcbiAgICAgICAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkXG4gICAgICAgIH07XG4gICAgICAgIGxldCBsYXRlc3RPYmplY3RKc29uID0gdm9pZCAwO1xuICAgICAgICBsZXQgbGF0ZXN0T2JqZWN0ID0gdm9pZCAwO1xuICAgICAgICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZTtcbiAgICAgICAgbGV0IGlzRmlyc3REZWx0YSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0odHJhbnNmb3JtZXIpKS5waXBlVGhyb3VnaChcbiAgICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgICB2YXIgX2ExNywgX2IsIF9jO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSBcIm9iamVjdFwiICYmIGNodW5rLnR5cGUgPT09IFwic3RyZWFtLXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICB3YXJuaW5ncyA9IGNodW5rLndhcm5pbmdzO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNGaXJzdENodW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNUb0ZpcnN0Q2h1bmsgPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgICAgIGlzRmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maXJzdENodW5rXCIsIHtcbiAgICAgICAgICAgICAgICAgIFwiYWkuc3RyZWFtLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgXCJhaS5zdHJlYW0ubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRUZXh0ICs9IGNodW5rO1xuICAgICAgICAgICAgICAgIHRleHREZWx0YSArPSBjaHVuaztcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlOiBjdXJyZW50T2JqZWN0SnNvbiwgc3RhdGU6IHBhcnNlU3RhdGUgfSA9IGF3YWl0IHBhcnNlUGFydGlhbEpzb24oYWNjdW11bGF0ZWRUZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE9iamVjdEpzb24gIT09IHZvaWQgMCAmJiAhaXNEZWVwRXF1YWxEYXRhKGxhdGVzdE9iamVjdEpzb24sIGN1cnJlbnRPYmplY3RKc29uKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlUGFydGlhbFJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50T2JqZWN0SnNvbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhLFxuICAgICAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3REZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgaXNGaW5hbERlbHRhOiBwYXJzZVN0YXRlID09PSBcInN1Y2Nlc3NmdWwtcGFyc2VcIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzICYmICFpc0RlZXBFcXVhbERhdGEoXG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC52YWx1ZS5wYXJ0aWFsXG4gICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdEpzb24gPSBjdXJyZW50T2JqZWN0SnNvbjtcbiAgICAgICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0ID0gdmFsaWRhdGlvblJlc3VsdC52YWx1ZS5wYXJ0aWFsO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBsYXRlc3RPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhOiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLnRleHREZWx0YVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdERlbHRhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgICAgICAgZnVsbFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogKF9hMTcgPSBjaHVuay5pZCkgIT0gbnVsbCA/IF9hMTcgOiBmdWxsUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9iID0gY2h1bmsudGltZXN0YW1wKSAhPSBudWxsID8gX2IgOiBmdWxsUmVzcG9uc2UudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2MgPSBjaHVuay5tb2RlbElkKSAhPSBudWxsID8gX2MgOiBmdWxsUmVzcG9uc2UubW9kZWxJZFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlmICh0ZXh0RGVsdGEgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsIHRleHREZWx0YSB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IGNodW5rLmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICAgICAgICAgIHVzYWdlID0gY2h1bmsudXNhZ2U7XG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhID0gY2h1bmsucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNodW5rLFxuICAgICAgICAgICAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGZ1bGxSZXNwb25zZVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBsb2dXYXJuaW5ncyh3YXJuaW5ncyAhPSBudWxsID8gd2FybmluZ3MgOiBbXSk7XG4gICAgICAgICAgICAgICAgICBzZWxmLl91c2FnZS5yZXNvbHZlKHVzYWdlKTtcbiAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb3ZpZGVyTWV0YWRhdGEucmVzb2x2ZShwcm92aWRlck1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgIHNlbGYuX3dhcm5pbmdzLnJlc29sdmUod2FybmluZ3MpO1xuICAgICAgICAgICAgICAgICAgc2VsZi5fcmVzcG9uc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmZ1bGxSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgc2VsZi5fZmluaXNoUmVhc29uLnJlc29sdmUoZmluaXNoUmVhc29uICE9IG51bGwgPyBmaW5pc2hSZWFzb24gOiBcInVua25vd25cIik7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QyID0gYXdhaXQgcGFyc2VBbmRWYWxpZGF0ZU9iamVjdFJlc3VsdFdpdGhSZXBhaXIoXG4gICAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFN0cmF0ZWd5LFxuICAgICAgICAgICAgICAgICAgICAgIHJlcGFpclRleHQsXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGZ1bGxSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9vYmplY3QucmVzb2x2ZShvYmplY3QyKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9vYmplY3QucmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBpbnZva2Ugb25GaW5pc2ggY2FsbGJhY2sgYW5kIHJlc29sdmUgdG9vbFJlc3VsdHMgcHJvbWlzZSB3aGVuIHRoZSBzdHJlYW0gaXMgYWJvdXQgdG8gY2xvc2U6XG4gICAgICAgICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmluYWxVc2FnZSA9IHVzYWdlICE9IG51bGwgPyB1c2FnZSA6IHtcbiAgICAgICAgICAgICAgICAgIHByb21wdFRva2VuczogTmFOLFxuICAgICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogTmFOLFxuICAgICAgICAgICAgICAgICAgdG90YWxUb2tlbnM6IE5hTlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0MilcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogZnVsbFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogZnVsbFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogZnVsbFJlc3BvbnNlLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShwcm92aWRlck1ldGFkYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmlucHV0VG9rZW5zXCI6IGZpbmFsVXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5vdXRwdXRUb2tlbnNcIjogZmluYWxVc2FnZS5vdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b3RhbFRva2Vuc1wiOiBmaW5hbFVzYWdlLnRvdGFsVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucmVhc29uaW5nVG9rZW5zXCI6IGZpbmFsVXNhZ2UucmVhc29uaW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnNcIjogZmluYWxVc2FnZS5jYWNoZWRJbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW2ZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogZnVsbFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IGZ1bGxSZXNwb25zZS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiBmaW5hbFVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogZmluYWxVc2FnZS5vdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICByb290U3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuaW5wdXRUb2tlbnNcIjogZmluYWxVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLm91dHB1dFRva2Vuc1wiOiBmaW5hbFVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRvdGFsVG9rZW5zXCI6IGZpbmFsVXNhZ2UudG90YWxUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5yZWFzb25pbmdUb2tlbnNcIjogZmluYWxVc2FnZS5yZWFzb25pbmdUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jYWNoZWRJbnB1dFRva2Vuc1wiOiBmaW5hbFVzYWdlLmNhY2hlZElucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0MilcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShwcm92aWRlck1ldGFkYXRhKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYXdhaXQgKG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7XG4gICAgICAgICAgICAgICAgICB1c2FnZTogZmluYWxVc2FnZSxcbiAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0MixcbiAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZnVsbFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvcjogZXJyb3IyIH0pO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJvb3RTcGFuLmVuZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgc3RpdGNoYWJsZVN0cmVhbS5hZGRTdHJlYW0odHJhbnNmb3JtZWRTdHJlYW0pO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgc3RpdGNoYWJsZVN0cmVhbS5hZGRTdHJlYW0oXG4gICAgICAgIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgc3RpdGNoYWJsZVN0cmVhbS5jbG9zZSgpO1xuICAgIH0pO1xuICAgIHRoaXMub3V0cHV0U3RyYXRlZ3kgPSBvdXRwdXRTdHJhdGVneTtcbiAgfVxuICBnZXQgb2JqZWN0KCkge1xuICAgIHJldHVybiB0aGlzLl9vYmplY3QucHJvbWlzZTtcbiAgfVxuICBnZXQgdXNhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzYWdlLnByb21pc2U7XG4gIH1cbiAgZ2V0IHByb3ZpZGVyTWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3ZpZGVyTWV0YWRhdGEucHJvbWlzZTtcbiAgfVxuICBnZXQgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dhcm5pbmdzLnByb21pc2U7XG4gIH1cbiAgZ2V0IHJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QucHJvbWlzZTtcbiAgfVxuICBnZXQgcmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlLnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbmlzaFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZmluaXNoUmVhc29uLnByb21pc2U7XG4gIH1cbiAgZ2V0IHBhcnRpYWxPYmplY3RTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICB0aGlzLmJhc2VTdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsub2JqZWN0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVuaztcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGdldCBlbGVtZW50U3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dFN0cmF0ZWd5LmNyZWF0ZUVsZW1lbnRTdHJlYW0odGhpcy5iYXNlU3RyZWFtKTtcbiAgfVxuICBnZXQgdGV4dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMuYmFzZVN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgZ2V0IGZ1bGxTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy5iYXNlU3RyZWFtKTtcbiAgfVxuICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIGluaXQpIHtcbiAgICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICB0ZXh0U3RyZWFtOiB0aGlzLnRleHRTdHJlYW0sXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbiAgdG9UZXh0U3RyZWFtUmVzcG9uc2UoaW5pdCkge1xuICAgIHJldHVybiBjcmVhdGVUZXh0U3RyZWFtUmVzcG9uc2Uoe1xuICAgICAgdGV4dFN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLFxuICAgICAgLi4uaW5pdFxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3Ivbm8tc3BlZWNoLWdlbmVyYXRlZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMjAgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIE5vU3BlZWNoR2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IyMCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkFJX05vU3BlZWNoR2VuZXJhdGVkRXJyb3JcIixcbiAgICAgIG1lc3NhZ2U6IFwiTm8gc3BlZWNoIGF1ZGlvIGdlbmVyYXRlZC5cIlxuICAgIH0pO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gIH1cbn07XG5cbi8vIHNyYy9nZW5lcmF0ZS1zcGVlY2gvZ2VuZXJhdGVkLWF1ZGlvLWZpbGUudHNcbnZhciBEZWZhdWx0R2VuZXJhdGVkQXVkaW9GaWxlID0gY2xhc3MgZXh0ZW5kcyBEZWZhdWx0R2VuZXJhdGVkRmlsZSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXRhLFxuICAgIG1lZGlhVHlwZVxuICB9KSB7XG4gICAgc3VwZXIoeyBkYXRhLCBtZWRpYVR5cGUgfSk7XG4gICAgbGV0IGZvcm1hdCA9IFwibXAzXCI7XG4gICAgaWYgKG1lZGlhVHlwZSkge1xuICAgICAgY29uc3QgbWVkaWFUeXBlUGFydHMgPSBtZWRpYVR5cGUuc3BsaXQoXCIvXCIpO1xuICAgICAgaWYgKG1lZGlhVHlwZVBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBpZiAobWVkaWFUeXBlICE9PSBcImF1ZGlvL21wZWdcIikge1xuICAgICAgICAgIGZvcm1hdCA9IG1lZGlhVHlwZVBhcnRzWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm9ybWF0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQXVkaW8gZm9ybWF0IG11c3QgYmUgcHJvdmlkZWQgb3IgZGV0ZXJtaW5hYmxlIGZyb20gbWVkaWEgdHlwZVwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgfVxufTtcblxuLy8gc3JjL2dlbmVyYXRlLXNwZWVjaC9nZW5lcmF0ZS1zcGVlY2gudHNcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlU3BlZWNoKHtcbiAgbW9kZWwsXG4gIHRleHQ6IHRleHQyLFxuICB2b2ljZSxcbiAgb3V0cHV0Rm9ybWF0LFxuICBpbnN0cnVjdGlvbnMsXG4gIHNwZWVkLFxuICBsYW5ndWFnZSxcbiAgcHJvdmlkZXJPcHRpb25zID0ge30sXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzXG59KSB7XG4gIHZhciBfYTE3O1xuICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjJcIikge1xuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE1vZGVsVmVyc2lvbkVycm9yKHtcbiAgICAgIHZlcnNpb246IG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uLFxuICAgICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHsgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgdm9pY2UsXG4gICAgICBvdXRwdXRGb3JtYXQsXG4gICAgICBpbnN0cnVjdGlvbnMsXG4gICAgICBzcGVlZCxcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBoZWFkZXJzLFxuICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgfSlcbiAgKTtcbiAgaWYgKCFyZXN1bHQuYXVkaW8gfHwgcmVzdWx0LmF1ZGlvLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBOb1NwZWVjaEdlbmVyYXRlZEVycm9yKHsgcmVzcG9uc2VzOiBbcmVzdWx0LnJlc3BvbnNlXSB9KTtcbiAgfVxuICBsb2dXYXJuaW5ncyhyZXN1bHQud2FybmluZ3MpO1xuICByZXR1cm4gbmV3IERlZmF1bHRTcGVlY2hSZXN1bHQoe1xuICAgIGF1ZGlvOiBuZXcgRGVmYXVsdEdlbmVyYXRlZEF1ZGlvRmlsZSh7XG4gICAgICBkYXRhOiByZXN1bHQuYXVkaW8sXG4gICAgICBtZWRpYVR5cGU6IChfYTE3ID0gZGV0ZWN0TWVkaWFUeXBlKHtcbiAgICAgICAgZGF0YTogcmVzdWx0LmF1ZGlvLFxuICAgICAgICBzaWduYXR1cmVzOiBhdWRpb01lZGlhVHlwZVNpZ25hdHVyZXNcbiAgICAgIH0pKSAhPSBudWxsID8gX2ExNyA6IFwiYXVkaW8vbXAzXCJcbiAgICB9KSxcbiAgICB3YXJuaW5nczogcmVzdWx0Lndhcm5pbmdzLFxuICAgIHJlc3BvbnNlczogW3Jlc3VsdC5yZXNwb25zZV0sXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0LnByb3ZpZGVyTWV0YWRhdGFcbiAgfSk7XG59XG52YXIgRGVmYXVsdFNwZWVjaFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfYTE3O1xuICAgIHRoaXMuYXVkaW8gPSBvcHRpb25zLmF1ZGlvO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gKF9hMTcgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYTE3IDoge307XG4gIH1cbn07XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L291dHB1dC50c1xudmFyIG91dHB1dF9leHBvcnRzID0ge307XG5fX2V4cG9ydChvdXRwdXRfZXhwb3J0cywge1xuICBvYmplY3Q6ICgpID0+IG9iamVjdCxcbiAgdGV4dDogKCkgPT4gdGV4dFxufSk7XG5pbXBvcnQge1xuICBhc1NjaGVtYSBhcyBhc1NjaGVtYTQsXG4gIHNhZmVQYXJzZUpTT04gYXMgc2FmZVBhcnNlSlNPTjQsXG4gIHNhZmVWYWxpZGF0ZVR5cGVzIGFzIHNhZmVWYWxpZGF0ZVR5cGVzNFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIHRleHQgPSAoKSA9PiAoe1xuICB0eXBlOiBcInRleHRcIixcbiAgcmVzcG9uc2VGb3JtYXQ6IHsgdHlwZTogXCJ0ZXh0XCIgfSxcbiAgYXN5bmMgcGFyc2VQYXJ0aWFsKHsgdGV4dDogdGV4dDIgfSkge1xuICAgIHJldHVybiB7IHBhcnRpYWw6IHRleHQyIH07XG4gIH0sXG4gIGFzeW5jIHBhcnNlT3V0cHV0KHsgdGV4dDogdGV4dDIgfSkge1xuICAgIHJldHVybiB0ZXh0MjtcbiAgfVxufSk7XG52YXIgb2JqZWN0ID0gKHtcbiAgc2NoZW1hOiBpbnB1dFNjaGVtYVxufSkgPT4ge1xuICBjb25zdCBzY2hlbWEgPSBhc1NjaGVtYTQoaW5wdXRTY2hlbWEpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgcmVzcG9uc2VGb3JtYXQ6IHtcbiAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgc2NoZW1hOiBzY2hlbWEuanNvblNjaGVtYVxuICAgIH0sXG4gICAgYXN5bmMgcGFyc2VQYXJ0aWFsKHsgdGV4dDogdGV4dDIgfSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGFyc2VQYXJ0aWFsSnNvbih0ZXh0Mik7XG4gICAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgICBjYXNlIFwiZmFpbGVkLXBhcnNlXCI6XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWQtaW5wdXRcIjpcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICBjYXNlIFwicmVwYWlyZWQtcGFyc2VcIjpcbiAgICAgICAgY2FzZSBcInN1Y2Nlc3NmdWwtcGFyc2VcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gTm90ZTogY3VycmVudGx5IG5vIHZhbGlkYXRpb24gb2YgcGFydGlhbCByZXN1bHRzOlxuICAgICAgICAgICAgcGFydGlhbDogcmVzdWx0LnZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSByZXN1bHQuc3RhdGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJzZSBzdGF0ZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBwYXJzZU91dHB1dCh7IHRleHQ6IHRleHQyIH0sIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTjQoeyB0ZXh0OiB0ZXh0MiB9KTtcbiAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiBjb3VsZCBub3QgcGFyc2UgdGhlIHJlc3BvbnNlLlwiLFxuICAgICAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICByZXNwb25zZTogY29udGV4dC5yZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogY29udGV4dC51c2FnZSxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQuZmluaXNoUmVhc29uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHNhZmVWYWxpZGF0ZVR5cGVzNCh7XG4gICAgICAgIHZhbHVlOiBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICAgICAgc2NoZW1hXG4gICAgICB9KTtcbiAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgICAgIGNhdXNlOiB2YWxpZGF0aW9uUmVzdWx0LmVycm9yLFxuICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgIHJlc3BvbnNlOiBjb250ZXh0LnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBjb250ZXh0LnVzYWdlLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dC5maW5pc2hSZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsaWRhdGlvblJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9zbW9vdGgtc3RyZWFtLnRzXG5pbXBvcnQgeyBkZWxheSBhcyBvcmlnaW5hbERlbGF5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIGFzIEludmFsaWRBcmd1bWVudEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgQ0hVTktJTkdfUkVHRVhQUyA9IHtcbiAgd29yZDogL1xcUytcXHMrL20sXG4gIGxpbmU6IC9cXG4rL21cbn07XG5mdW5jdGlvbiBzbW9vdGhTdHJlYW0oe1xuICBkZWxheUluTXMgPSAxMCxcbiAgY2h1bmtpbmcgPSBcIndvcmRcIixcbiAgX2ludGVybmFsOiB7IGRlbGF5OiBkZWxheTIgPSBvcmlnaW5hbERlbGF5IH0gPSB7fVxufSA9IHt9KSB7XG4gIGxldCBkZXRlY3RDaHVuaztcbiAgaWYgKHR5cGVvZiBjaHVua2luZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZGV0ZWN0Q2h1bmsgPSAoYnVmZmVyKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaCA9IGNodW5raW5nKGJ1ZmZlcik7XG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghbWF0Y2gubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2h1bmtpbmcgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBub24tZW1wdHkgc3RyaW5nLmApO1xuICAgICAgfVxuICAgICAgaWYgKCFidWZmZXIuc3RhcnRzV2l0aChtYXRjaCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDaHVua2luZyBmdW5jdGlvbiBtdXN0IHJldHVybiBhIG1hdGNoIHRoYXQgaXMgYSBwcmVmaXggb2YgdGhlIGJ1ZmZlci4gUmVjZWl2ZWQ6IFwiJHttYXRjaH1cIiBleHBlY3RlZCB0byBzdGFydCB3aXRoIFwiJHtidWZmZXJ9XCJgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjaHVua2luZ1JlZ2V4ID0gdHlwZW9mIGNodW5raW5nID09PSBcInN0cmluZ1wiID8gQ0hVTktJTkdfUkVHRVhQU1tjaHVua2luZ10gOiBjaHVua2luZztcbiAgICBpZiAoY2h1bmtpbmdSZWdleCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IyKHtcbiAgICAgICAgYXJndW1lbnQ6IFwiY2h1bmtpbmdcIixcbiAgICAgICAgbWVzc2FnZTogYENodW5raW5nIG11c3QgYmUgXCJ3b3JkXCIgb3IgXCJsaW5lXCIgb3IgYSBSZWdFeHAuIFJlY2VpdmVkOiAke2NodW5raW5nfWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkZXRlY3RDaHVuayA9IChidWZmZXIpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoID0gY2h1bmtpbmdSZWdleC5leGVjKGJ1ZmZlcik7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAobWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IG1hdGNoWzBdKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gICAgbGV0IGlkID0gXCJcIjtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKGNodW5rLnR5cGUgIT09IFwidGV4dC1kZWx0YVwiKSB7XG4gICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtZGVsdGFcIiwgdGV4dDogYnVmZmVyLCBpZCB9KTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHVuay5pZCAhPT0gaWQgJiYgYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtZGVsdGFcIiwgdGV4dDogYnVmZmVyLCBpZCB9KTtcbiAgICAgICAgICBidWZmZXIgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlciArPSBjaHVuay50ZXh0O1xuICAgICAgICBpZCA9IGNodW5rLmlkO1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBkZXRlY3RDaHVuayhidWZmZXIpKSAhPSBudWxsKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsIHRleHQ6IG1hdGNoLCBpZCB9KTtcbiAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UobWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgICBhd2FpdCBkZWxheTIoZGVsYXlJbk1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG4vLyBzcmMvbWlkZGxld2FyZS9kZWZhdWx0LXNldHRpbmdzLW1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGRlZmF1bHRTZXR0aW5nc01pZGRsZXdhcmUoe1xuICBzZXR0aW5nc1xufSkge1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmVWZXJzaW9uOiBcInYyXCIsXG4gICAgdHJhbnNmb3JtUGFyYW1zOiBhc3luYyAoeyBwYXJhbXMgfSkgPT4ge1xuICAgICAgcmV0dXJuIG1lcmdlT2JqZWN0cyhzZXR0aW5ncywgcGFyYW1zKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy91dGlsL2dldC1wb3RlbnRpYWwtc3RhcnQtaW5kZXgudHNcbmZ1bmN0aW9uIGdldFBvdGVudGlhbFN0YXJ0SW5kZXgodGV4dDIsIHNlYXJjaGVkVGV4dCkge1xuICBpZiAoc2VhcmNoZWRUZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGRpcmVjdEluZGV4ID0gdGV4dDIuaW5kZXhPZihzZWFyY2hlZFRleHQpO1xuICBpZiAoZGlyZWN0SW5kZXggIT09IC0xKSB7XG4gICAgcmV0dXJuIGRpcmVjdEluZGV4O1xuICB9XG4gIGZvciAobGV0IGkgPSB0ZXh0Mi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHN1ZmZpeCA9IHRleHQyLnN1YnN0cmluZyhpKTtcbiAgICBpZiAoc2VhcmNoZWRUZXh0LnN0YXJ0c1dpdGgoc3VmZml4KSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBzcmMvbWlkZGxld2FyZS9leHRyYWN0LXJlYXNvbmluZy1taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBleHRyYWN0UmVhc29uaW5nTWlkZGxld2FyZSh7XG4gIHRhZ05hbWUsXG4gIHNlcGFyYXRvciA9IFwiXFxuXCIsXG4gIHN0YXJ0V2l0aFJlYXNvbmluZyA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IG9wZW5pbmdUYWcgPSBgPCR7dGFnTmFtZX0+YDtcbiAgY29uc3QgY2xvc2luZ1RhZyA9IGA8LyR7dGFnTmFtZX0+YDtcbiAgcmV0dXJuIHtcbiAgICBtaWRkbGV3YXJlVmVyc2lvbjogXCJ2MlwiLFxuICAgIHdyYXBHZW5lcmF0ZTogYXN5bmMgKHsgZG9HZW5lcmF0ZSB9KSA9PiB7XG4gICAgICBjb25zdCB7IGNvbnRlbnQsIC4uLnJlc3QgfSA9IGF3YWl0IGRvR2VuZXJhdGUoKTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkQ29udGVudCA9IFtdO1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKHBhcnQudHlwZSAhPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1lZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0MiA9IHN0YXJ0V2l0aFJlYXNvbmluZyA/IG9wZW5pbmdUYWcgKyBwYXJ0LnRleHQgOiBwYXJ0LnRleHQ7XG4gICAgICAgIGNvbnN0IHJlZ2V4cCA9IG5ldyBSZWdFeHAoYCR7b3BlbmluZ1RhZ30oLio/KSR7Y2xvc2luZ1RhZ31gLCBcImdzXCIpO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gQXJyYXkuZnJvbSh0ZXh0Mi5tYXRjaEFsbChyZWdleHApKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRyYW5zZm9ybWVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlYXNvbmluZ1RleHQgPSBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IG1hdGNoWzFdKS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIGxldCB0ZXh0V2l0aG91dFJlYXNvbmluZyA9IHRleHQyO1xuICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlc1tpXTtcbiAgICAgICAgICBjb25zdCBiZWZvcmVNYXRjaCA9IHRleHRXaXRob3V0UmVhc29uaW5nLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICBjb25zdCBhZnRlck1hdGNoID0gdGV4dFdpdGhvdXRSZWFzb25pbmcuc2xpY2UoXG4gICAgICAgICAgICBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGV4dFdpdGhvdXRSZWFzb25pbmcgPSBiZWZvcmVNYXRjaCArIChiZWZvcmVNYXRjaC5sZW5ndGggPiAwICYmIGFmdGVyTWF0Y2gubGVuZ3RoID4gMCA/IHNlcGFyYXRvciA6IFwiXCIpICsgYWZ0ZXJNYXRjaDtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2Zvcm1lZENvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICB0ZXh0OiByZWFzb25pbmdUZXh0XG4gICAgICAgIH0pO1xuICAgICAgICB0cmFuc2Zvcm1lZENvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgdGV4dDogdGV4dFdpdGhvdXRSZWFzb25pbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBjb250ZW50OiB0cmFuc2Zvcm1lZENvbnRlbnQsIC4uLnJlc3QgfTtcbiAgICB9LFxuICAgIHdyYXBTdHJlYW06IGFzeW5jICh7IGRvU3RyZWFtIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgc3RyZWFtLCAuLi5yZXN0IH0gPSBhd2FpdCBkb1N0cmVhbSgpO1xuICAgICAgY29uc3QgcmVhc29uaW5nRXh0cmFjdGlvbnMgPSB7fTtcbiAgICAgIGxldCBkZWxheWVkVGV4dFN0YXJ0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RyZWFtOiBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICBkZWxheWVkVGV4dFN0YXJ0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtZW5kXCIgJiYgZGVsYXllZFRleHRTdGFydCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShkZWxheWVkVGV4dFN0YXJ0KTtcbiAgICAgICAgICAgICAgICBkZWxheWVkVGV4dFN0YXJ0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjaHVuay50eXBlICE9PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZWFzb25pbmdFeHRyYWN0aW9uc1tjaHVuay5pZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlYXNvbmluZ0V4dHJhY3Rpb25zW2NodW5rLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgIGlzRmlyc3RSZWFzb25pbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICBpc0ZpcnN0VGV4dDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGFmdGVyU3dpdGNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGlzUmVhc29uaW5nOiBzdGFydFdpdGhSZWFzb25pbmcsXG4gICAgICAgICAgICAgICAgICBidWZmZXI6IFwiXCIsXG4gICAgICAgICAgICAgICAgICBpZENvdW50ZXI6IDAsXG4gICAgICAgICAgICAgICAgICB0ZXh0SWQ6IGNodW5rLmlkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBhY3RpdmVFeHRyYWN0aW9uID0gcmVhc29uaW5nRXh0cmFjdGlvbnNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlciArPSBjaHVuay5kZWx0YTtcbiAgICAgICAgICAgICAgZnVuY3Rpb24gcHVibGlzaCh0ZXh0Mikge1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0Mi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBhY3RpdmVFeHRyYWN0aW9uLmFmdGVyU3dpdGNoICYmIChhY3RpdmVFeHRyYWN0aW9uLmlzUmVhc29uaW5nID8gIWFjdGl2ZUV4dHJhY3Rpb24uaXNGaXJzdFJlYXNvbmluZyA6ICFhY3RpdmVFeHRyYWN0aW9uLmlzRmlyc3RUZXh0KSA/IHNlcGFyYXRvciA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZyAmJiAoYWN0aXZlRXh0cmFjdGlvbi5hZnRlclN3aXRjaCB8fCBhY3RpdmVFeHRyYWN0aW9uLmlzRmlyc3RSZWFzb25pbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctc3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogYHJlYXNvbmluZy0ke2FjdGl2ZUV4dHJhY3Rpb24uaWRDb3VudGVyfWBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZykge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZGVsdGE6IHByZWZpeCArIHRleHQyLFxuICAgICAgICAgICAgICAgICAgICAgIGlkOiBgcmVhc29uaW5nLSR7YWN0aXZlRXh0cmFjdGlvbi5pZENvdW50ZXJ9YFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxheWVkVGV4dFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGRlbGF5ZWRUZXh0U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGF5ZWRUZXh0U3RhcnQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICBkZWx0YTogcHJlZml4ICsgdGV4dDIsXG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IGFjdGl2ZUV4dHJhY3Rpb24udGV4dElkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5hZnRlclN3aXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5pc0ZpcnN0UmVhc29uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVFeHRyYWN0aW9uLmlzRmlyc3RUZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VGFnID0gYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZyA/IGNsb3NpbmdUYWcgOiBvcGVuaW5nVGFnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBnZXRQb3RlbnRpYWxTdGFydEluZGV4KFxuICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5idWZmZXIsXG4gICAgICAgICAgICAgICAgICBuZXh0VGFnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBwdWJsaXNoKGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwdWJsaXNoKGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyLnNsaWNlKDAsIHN0YXJ0SW5kZXgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZEZ1bGxNYXRjaCA9IHN0YXJ0SW5kZXggKyBuZXh0VGFnLmxlbmd0aCA8PSBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kRnVsbE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlciA9IGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ICsgbmV4dFRhZy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZykge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLWVuZFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGlkOiBgcmVhc29uaW5nLSR7YWN0aXZlRXh0cmFjdGlvbi5pZENvdW50ZXIrK31gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZyA9ICFhY3RpdmVFeHRyYWN0aW9uLmlzUmVhc29uaW5nO1xuICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5hZnRlclN3aXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyID0gYWN0aXZlRXh0cmFjdGlvbi5idWZmZXIuc2xpY2Uoc3RhcnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIC4uLnJlc3RcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWlkZGxld2FyZS9zaW11bGF0ZS1zdHJlYW1pbmctbWlkZGxld2FyZS50c1xuZnVuY3Rpb24gc2ltdWxhdGVTdHJlYW1pbmdNaWRkbGV3YXJlKCkge1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmVWZXJzaW9uOiBcInYyXCIsXG4gICAgd3JhcFN0cmVhbTogYXN5bmMgKHsgZG9HZW5lcmF0ZSB9KSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkb0dlbmVyYXRlKCk7XG4gICAgICBsZXQgaWQgPSAwO1xuICAgICAgY29uc3Qgc2ltdWxhdGVkU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcInN0cmVhbS1zdGFydFwiLFxuICAgICAgICAgICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5nc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwicmVzcG9uc2UtbWV0YWRhdGFcIiwgLi4ucmVzdWx0LnJlc3BvbnNlIH0pO1xuICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiByZXN1bHQuY29udGVudCkge1xuICAgICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0LnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0LXN0YXJ0XCIsIGlkOiBTdHJpbmcoaWQpIH0pO1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBTdHJpbmcoaWQpLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YTogcGFydC50ZXh0XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1lbmRcIiwgaWQ6IFN0cmluZyhpZCkgfSk7XG4gICAgICAgICAgICAgICAgICBpZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctc3RhcnRcIixcbiAgICAgICAgICAgICAgICAgIGlkOiBTdHJpbmcoaWQpLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICBpZDogU3RyaW5nKGlkKSxcbiAgICAgICAgICAgICAgICAgIGRlbHRhOiBwYXJ0LnRleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInJlYXNvbmluZy1lbmRcIiwgaWQ6IFN0cmluZyhpZCkgfSk7XG4gICAgICAgICAgICAgICAgaWQrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgZmluaXNoUmVhc29uOiByZXN1bHQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgdXNhZ2U6IHJlc3VsdC51c2FnZSxcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbTogc2ltdWxhdGVkU3RyZWFtLFxuICAgICAgICByZXF1ZXN0OiByZXN1bHQucmVxdWVzdCxcbiAgICAgICAgcmVzcG9uc2U6IHJlc3VsdC5yZXNwb25zZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9taWRkbGV3YXJlL3dyYXAtbGFuZ3VhZ2UtbW9kZWwudHNcbnZhciB3cmFwTGFuZ3VhZ2VNb2RlbCA9ICh7XG4gIG1vZGVsLFxuICBtaWRkbGV3YXJlOiBtaWRkbGV3YXJlQXJnLFxuICBtb2RlbElkLFxuICBwcm92aWRlcklkXG59KSA9PiB7XG4gIHJldHVybiBhc0FycmF5KG1pZGRsZXdhcmVBcmcpLnJldmVyc2UoKS5yZWR1Y2UoKHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSkgPT4ge1xuICAgIHJldHVybiBkb1dyYXAoeyBtb2RlbDogd3JhcHBlZE1vZGVsLCBtaWRkbGV3YXJlLCBtb2RlbElkLCBwcm92aWRlcklkIH0pO1xuICB9LCBtb2RlbCk7XG59O1xudmFyIGRvV3JhcCA9ICh7XG4gIG1vZGVsLFxuICBtaWRkbGV3YXJlOiB7XG4gICAgdHJhbnNmb3JtUGFyYW1zLFxuICAgIHdyYXBHZW5lcmF0ZSxcbiAgICB3cmFwU3RyZWFtLFxuICAgIG92ZXJyaWRlUHJvdmlkZXIsXG4gICAgb3ZlcnJpZGVNb2RlbElkLFxuICAgIG92ZXJyaWRlU3VwcG9ydGVkVXJsc1xuICB9LFxuICBtb2RlbElkLFxuICBwcm92aWRlcklkXG59KSA9PiB7XG4gIHZhciBfYTE3LCBfYiwgX2M7XG4gIGFzeW5jIGZ1bmN0aW9uIGRvVHJhbnNmb3JtKHtcbiAgICBwYXJhbXMsXG4gICAgdHlwZVxuICB9KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBhcmFtcyA/IGF3YWl0IHRyYW5zZm9ybVBhcmFtcyh7IHBhcmFtcywgdHlwZSwgbW9kZWwgfSkgOiBwYXJhbXM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2MlwiLFxuICAgIHByb3ZpZGVyOiAoX2ExNyA9IHByb3ZpZGVySWQgIT0gbnVsbCA/IHByb3ZpZGVySWQgOiBvdmVycmlkZVByb3ZpZGVyID09IG51bGwgPyB2b2lkIDAgOiBvdmVycmlkZVByb3ZpZGVyKHsgbW9kZWwgfSkpICE9IG51bGwgPyBfYTE3IDogbW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWxJZDogKF9iID0gbW9kZWxJZCAhPSBudWxsID8gbW9kZWxJZCA6IG92ZXJyaWRlTW9kZWxJZCA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVNb2RlbElkKHsgbW9kZWwgfSkpICE9IG51bGwgPyBfYiA6IG1vZGVsLm1vZGVsSWQsXG4gICAgc3VwcG9ydGVkVXJsczogKF9jID0gb3ZlcnJpZGVTdXBwb3J0ZWRVcmxzID09IG51bGwgPyB2b2lkIDAgOiBvdmVycmlkZVN1cHBvcnRlZFVybHMoeyBtb2RlbCB9KSkgIT0gbnVsbCA/IF9jIDogbW9kZWwuc3VwcG9ydGVkVXJscyxcbiAgICBhc3luYyBkb0dlbmVyYXRlKHBhcmFtcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCBkb1RyYW5zZm9ybSh7IHBhcmFtcywgdHlwZTogXCJnZW5lcmF0ZVwiIH0pO1xuICAgICAgY29uc3QgZG9HZW5lcmF0ZSA9IGFzeW5jICgpID0+IG1vZGVsLmRvR2VuZXJhdGUodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgY29uc3QgZG9TdHJlYW0gPSBhc3luYyAoKSA9PiBtb2RlbC5kb1N0cmVhbSh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICByZXR1cm4gd3JhcEdlbmVyYXRlID8gd3JhcEdlbmVyYXRlKHtcbiAgICAgICAgZG9HZW5lcmF0ZSxcbiAgICAgICAgZG9TdHJlYW0sXG4gICAgICAgIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsXG4gICAgICAgIG1vZGVsXG4gICAgICB9KSA6IGRvR2VuZXJhdGUoKTtcbiAgICB9LFxuICAgIGFzeW5jIGRvU3RyZWFtKHBhcmFtcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCBkb1RyYW5zZm9ybSh7IHBhcmFtcywgdHlwZTogXCJzdHJlYW1cIiB9KTtcbiAgICAgIGNvbnN0IGRvR2VuZXJhdGUgPSBhc3luYyAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgIGNvbnN0IGRvU3RyZWFtID0gYXN5bmMgKCkgPT4gbW9kZWwuZG9TdHJlYW0odHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBTdHJlYW0gPyB3cmFwU3RyZWFtKHsgZG9HZW5lcmF0ZSwgZG9TdHJlYW0sIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsIG1vZGVsIH0pIDogZG9TdHJlYW0oKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvbWlkZGxld2FyZS93cmFwLXByb3ZpZGVyLnRzXG5mdW5jdGlvbiB3cmFwUHJvdmlkZXIoe1xuICBwcm92aWRlcixcbiAgbGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmVcbn0pIHtcbiAgY29uc3Qgd3JhcHBlZFByb3ZpZGVyID0ge1xuICAgIGxhbmd1YWdlTW9kZWwobW9kZWxJZCkge1xuICAgICAgbGV0IG1vZGVsID0gcHJvdmlkZXIubGFuZ3VhZ2VNb2RlbChtb2RlbElkKTtcbiAgICAgIG1vZGVsID0gd3JhcExhbmd1YWdlTW9kZWwoe1xuICAgICAgICBtb2RlbCxcbiAgICAgICAgbWlkZGxld2FyZTogbGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG4gICAgdGV4dEVtYmVkZGluZ01vZGVsOiBwcm92aWRlci50ZXh0RW1iZWRkaW5nTW9kZWwsXG4gICAgaW1hZ2VNb2RlbDogcHJvdmlkZXIuaW1hZ2VNb2RlbCxcbiAgICB0cmFuc2NyaXB0aW9uTW9kZWw6IHByb3ZpZGVyLnRyYW5zY3JpcHRpb25Nb2RlbCxcbiAgICBzcGVlY2hNb2RlbDogcHJvdmlkZXIuc3BlZWNoTW9kZWxcbiAgfTtcbiAgcmV0dXJuIHdyYXBwZWRQcm92aWRlcjtcbn1cblxuLy8gc3JjL3JlZ2lzdHJ5L2N1c3RvbS1wcm92aWRlci50c1xuaW1wb3J0IHtcbiAgTm9TdWNoTW9kZWxFcnJvciBhcyBOb1N1Y2hNb2RlbEVycm9yMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gY3VzdG9tUHJvdmlkZXIoe1xuICBsYW5ndWFnZU1vZGVscyxcbiAgdGV4dEVtYmVkZGluZ01vZGVscyxcbiAgaW1hZ2VNb2RlbHMsXG4gIHRyYW5zY3JpcHRpb25Nb2RlbHMsXG4gIHNwZWVjaE1vZGVscyxcbiAgZmFsbGJhY2tQcm92aWRlclxufSkge1xuICByZXR1cm4ge1xuICAgIGxhbmd1YWdlTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKGxhbmd1YWdlTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiBsYW5ndWFnZU1vZGVscykge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci5sYW5ndWFnZU1vZGVsKG1vZGVsSWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3IyKHsgbW9kZWxJZCwgbW9kZWxUeXBlOiBcImxhbmd1YWdlTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIHRleHRFbWJlZGRpbmdNb2RlbChtb2RlbElkKSB7XG4gICAgICBpZiAodGV4dEVtYmVkZGluZ01vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gdGV4dEVtYmVkZGluZ01vZGVscykge1xuICAgICAgICByZXR1cm4gdGV4dEVtYmVkZGluZ01vZGVsc1ttb2RlbElkXTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWxsYmFja1Byb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLnRleHRFbWJlZGRpbmdNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJ0ZXh0RW1iZWRkaW5nTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIGltYWdlTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKGltYWdlTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiBpbWFnZU1vZGVscykge1xuICAgICAgICByZXR1cm4gaW1hZ2VNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogZmFsbGJhY2tQcm92aWRlci5pbWFnZU1vZGVsKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLmltYWdlTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwiaW1hZ2VNb2RlbFwiIH0pO1xuICAgIH0sXG4gICAgdHJhbnNjcmlwdGlvbk1vZGVsKG1vZGVsSWQpIHtcbiAgICAgIGlmICh0cmFuc2NyaXB0aW9uTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiB0cmFuc2NyaXB0aW9uTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2NyaXB0aW9uTW9kZWxzW21vZGVsSWRdO1xuICAgICAgfVxuICAgICAgaWYgKGZhbGxiYWNrUHJvdmlkZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGZhbGxiYWNrUHJvdmlkZXIudHJhbnNjcmlwdGlvbk1vZGVsKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLnRyYW5zY3JpcHRpb25Nb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJ0cmFuc2NyaXB0aW9uTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIHNwZWVjaE1vZGVsKG1vZGVsSWQpIHtcbiAgICAgIGlmIChzcGVlY2hNb2RlbHMgIT0gbnVsbCAmJiBtb2RlbElkIGluIHNwZWVjaE1vZGVscykge1xuICAgICAgICByZXR1cm4gc3BlZWNoTW9kZWxzW21vZGVsSWRdO1xuICAgICAgfVxuICAgICAgaWYgKGZhbGxiYWNrUHJvdmlkZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGZhbGxiYWNrUHJvdmlkZXIuc3BlZWNoTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUHJvdmlkZXIuc3BlZWNoTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwic3BlZWNoTW9kZWxcIiB9KTtcbiAgICB9XG4gIH07XG59XG52YXIgZXhwZXJpbWVudGFsX2N1c3RvbVByb3ZpZGVyID0gY3VzdG9tUHJvdmlkZXI7XG5cbi8vIHNyYy9yZWdpc3RyeS9uby1zdWNoLXByb3ZpZGVyLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IyMSwgTm9TdWNoTW9kZWxFcnJvciBhcyBOb1N1Y2hNb2RlbEVycm9yMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTE2ID0gXCJBSV9Ob1N1Y2hQcm92aWRlckVycm9yXCI7XG52YXIgbWFya2VyMTYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTE2fWA7XG52YXIgc3ltYm9sMTYgPSBTeW1ib2wuZm9yKG1hcmtlcjE2KTtcbnZhciBfYTE2O1xudmFyIE5vU3VjaFByb3ZpZGVyRXJyb3IgPSBjbGFzcyBleHRlbmRzIE5vU3VjaE1vZGVsRXJyb3IzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1vZGVsSWQsXG4gICAgbW9kZWxUeXBlLFxuICAgIHByb3ZpZGVySWQsXG4gICAgYXZhaWxhYmxlUHJvdmlkZXJzLFxuICAgIG1lc3NhZ2UgPSBgTm8gc3VjaCBwcm92aWRlcjogJHtwcm92aWRlcklkfSAoYXZhaWxhYmxlIHByb3ZpZGVyczogJHthdmFpbGFibGVQcm92aWRlcnMuam9pbigpfSlgXG4gIH0pIHtcbiAgICBzdXBlcih7IGVycm9yTmFtZTogbmFtZTE2LCBtb2RlbElkLCBtb2RlbFR5cGUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE2XSA9IHRydWU7XG4gICAgdGhpcy5wcm92aWRlcklkID0gcHJvdmlkZXJJZDtcbiAgICB0aGlzLmF2YWlsYWJsZVByb3ZpZGVycyA9IGF2YWlsYWJsZVByb3ZpZGVycztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMjEuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNik7XG4gIH1cbn07XG5fYTE2ID0gc3ltYm9sMTY7XG5cbi8vIHNyYy9yZWdpc3RyeS9wcm92aWRlci1yZWdpc3RyeS50c1xuaW1wb3J0IHtcbiAgTm9TdWNoTW9kZWxFcnJvciBhcyBOb1N1Y2hNb2RlbEVycm9yNFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gY3JlYXRlUHJvdmlkZXJSZWdpc3RyeShwcm92aWRlcnMsIHtcbiAgc2VwYXJhdG9yID0gXCI6XCIsXG4gIGxhbmd1YWdlTW9kZWxNaWRkbGV3YXJlXG59ID0ge30pIHtcbiAgY29uc3QgcmVnaXN0cnkgPSBuZXcgRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkoe1xuICAgIHNlcGFyYXRvcixcbiAgICBsYW5ndWFnZU1vZGVsTWlkZGxld2FyZVxuICB9KTtcbiAgZm9yIChjb25zdCBbaWQsIHByb3ZpZGVyXSBvZiBPYmplY3QuZW50cmllcyhwcm92aWRlcnMpKSB7XG4gICAgcmVnaXN0cnkucmVnaXN0ZXJQcm92aWRlcih7IGlkLCBwcm92aWRlciB9KTtcbiAgfVxuICByZXR1cm4gcmVnaXN0cnk7XG59XG52YXIgZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnkgPSBjcmVhdGVQcm92aWRlclJlZ2lzdHJ5O1xudmFyIERlZmF1bHRQcm92aWRlclJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc2VwYXJhdG9yLFxuICAgIGxhbmd1YWdlTW9kZWxNaWRkbGV3YXJlXG4gIH0pIHtcbiAgICB0aGlzLnByb3ZpZGVycyA9IHt9O1xuICAgIHRoaXMuc2VwYXJhdG9yID0gc2VwYXJhdG9yO1xuICAgIHRoaXMubGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmUgPSBsYW5ndWFnZU1vZGVsTWlkZGxld2FyZTtcbiAgfVxuICByZWdpc3RlclByb3ZpZGVyKHtcbiAgICBpZCxcbiAgICBwcm92aWRlclxuICB9KSB7XG4gICAgdGhpcy5wcm92aWRlcnNbaWRdID0gcHJvdmlkZXI7XG4gIH1cbiAgZ2V0UHJvdmlkZXIoaWQsIG1vZGVsVHlwZSkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5wcm92aWRlcnNbaWRdO1xuICAgIGlmIChwcm92aWRlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoUHJvdmlkZXJFcnJvcih7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGUsXG4gICAgICAgIHByb3ZpZGVySWQ6IGlkLFxuICAgICAgICBhdmFpbGFibGVQcm92aWRlcnM6IE9iamVjdC5rZXlzKHRoaXMucHJvdmlkZXJzKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm92aWRlcjtcbiAgfVxuICBzcGxpdElkKGlkLCBtb2RlbFR5cGUpIHtcbiAgICBjb25zdCBpbmRleCA9IGlkLmluZGV4T2YodGhpcy5zZXBhcmF0b3IpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGUsXG4gICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkICR7bW9kZWxUeXBlfSBpZCBmb3IgcmVnaXN0cnk6ICR7aWR9IChtdXN0IGJlIGluIHRoZSBmb3JtYXQgXCJwcm92aWRlcklkJHt0aGlzLnNlcGFyYXRvcn1tb2RlbElkXCIpYFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbaWQuc2xpY2UoMCwgaW5kZXgpLCBpZC5zbGljZShpbmRleCArIHRoaXMuc2VwYXJhdG9yLmxlbmd0aCldO1xuICB9XG4gIGxhbmd1YWdlTW9kZWwoaWQpIHtcbiAgICB2YXIgX2ExNywgX2I7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcImxhbmd1YWdlTW9kZWxcIik7XG4gICAgbGV0IG1vZGVsID0gKF9iID0gKF9hMTcgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQsIFwibGFuZ3VhZ2VNb2RlbFwiKSkubGFuZ3VhZ2VNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoXG4gICAgICBfYTE3LFxuICAgICAgbW9kZWxJZFxuICAgICk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7IG1vZGVsSWQ6IGlkLCBtb2RlbFR5cGU6IFwibGFuZ3VhZ2VNb2RlbFwiIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5sYW5ndWFnZU1vZGVsTWlkZGxld2FyZSAhPSBudWxsKSB7XG4gICAgICBtb2RlbCA9IHdyYXBMYW5ndWFnZU1vZGVsKHtcbiAgICAgICAgbW9kZWwsXG4gICAgICAgIG1pZGRsZXdhcmU6IHRoaXMubGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgdGV4dEVtYmVkZGluZ01vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcInRleHRFbWJlZGRpbmdNb2RlbFwiKTtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJvdmlkZXJJZCwgXCJ0ZXh0RW1iZWRkaW5nTW9kZWxcIik7XG4gICAgY29uc3QgbW9kZWwgPSAoX2ExNyA9IHByb3ZpZGVyLnRleHRFbWJlZGRpbmdNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGU6IFwidGV4dEVtYmVkZGluZ01vZGVsXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgaW1hZ2VNb2RlbChpZCkge1xuICAgIHZhciBfYTE3O1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCwgXCJpbWFnZU1vZGVsXCIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkLCBcImltYWdlTW9kZWxcIik7XG4gICAgY29uc3QgbW9kZWwgPSAoX2ExNyA9IHByb3ZpZGVyLmltYWdlTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNhbGwocHJvdmlkZXIsIG1vZGVsSWQpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoeyBtb2RlbElkOiBpZCwgbW9kZWxUeXBlOiBcImltYWdlTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHRyYW5zY3JpcHRpb25Nb2RlbChpZCkge1xuICAgIHZhciBfYTE3O1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCwgXCJ0cmFuc2NyaXB0aW9uTW9kZWxcIik7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQsIFwidHJhbnNjcmlwdGlvbk1vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMTcgPSBwcm92aWRlci50cmFuc2NyaXB0aW9uTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNhbGwocHJvdmlkZXIsIG1vZGVsSWQpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlOiBcInRyYW5zY3JpcHRpb25Nb2RlbFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHNwZWVjaE1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcInNwZWVjaE1vZGVsXCIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkLCBcInNwZWVjaE1vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMTcgPSBwcm92aWRlci5zcGVlY2hNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7IG1vZGVsSWQ6IGlkLCBtb2RlbFR5cGU6IFwic3BlZWNoTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG59O1xuXG4vLyBzcmMvdG9vbC9tY3AvbWNwLWNsaWVudC50c1xuaW1wb3J0IHtcbiAgZHluYW1pY1Rvb2wsXG4gIGpzb25TY2hlbWEsXG4gIHRvb2xcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3Rvb2wvbWNwL21jcC1zc2UtdHJhbnNwb3J0LnRzXG5pbXBvcnQgeyBFdmVudFNvdXJjZVBhcnNlclN0cmVhbSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy90b29sL21jcC9qc29uLXJwYy1tZXNzYWdlLnRzXG5pbXBvcnQgeyB6IGFzIHo5IH0gZnJvbSBcInpvZC92NFwiO1xuXG4vLyBzcmMvdG9vbC9tY3AvdHlwZXMudHNcbmltcG9ydCB7IHogYXMgejggfSBmcm9tIFwiem9kL3Y0XCI7XG52YXIgTEFURVNUX1BST1RPQ09MX1ZFUlNJT04gPSBcIjIwMjUtMDYtMThcIjtcbnZhciBTVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTlMgPSBbXG4gIExBVEVTVF9QUk9UT0NPTF9WRVJTSU9OLFxuICBcIjIwMjUtMDMtMjZcIixcbiAgXCIyMDI0LTExLTA1XCJcbl07XG52YXIgQ2xpZW50T3JTZXJ2ZXJJbXBsZW1lbnRhdGlvblNjaGVtYSA9IHo4Lmxvb3NlT2JqZWN0KHtcbiAgbmFtZTogejguc3RyaW5nKCksXG4gIHZlcnNpb246IHo4LnN0cmluZygpXG59KTtcbnZhciBCYXNlUGFyYW1zU2NoZW1hID0gejgubG9vc2VPYmplY3Qoe1xuICBfbWV0YTogejgub3B0aW9uYWwoejgub2JqZWN0KHt9KS5sb29zZSgpKVxufSk7XG52YXIgUmVzdWx0U2NoZW1hID0gQmFzZVBhcmFtc1NjaGVtYTtcbnZhciBSZXF1ZXN0U2NoZW1hID0gejgub2JqZWN0KHtcbiAgbWV0aG9kOiB6OC5zdHJpbmcoKSxcbiAgcGFyYW1zOiB6OC5vcHRpb25hbChCYXNlUGFyYW1zU2NoZW1hKVxufSk7XG52YXIgU2VydmVyQ2FwYWJpbGl0aWVzU2NoZW1hID0gejgubG9vc2VPYmplY3Qoe1xuICBleHBlcmltZW50YWw6IHo4Lm9wdGlvbmFsKHo4Lm9iamVjdCh7fSkubG9vc2UoKSksXG4gIGxvZ2dpbmc6IHo4Lm9wdGlvbmFsKHo4Lm9iamVjdCh7fSkubG9vc2UoKSksXG4gIHByb21wdHM6IHo4Lm9wdGlvbmFsKFxuICAgIHo4Lmxvb3NlT2JqZWN0KHtcbiAgICAgIGxpc3RDaGFuZ2VkOiB6OC5vcHRpb25hbCh6OC5ib29sZWFuKCkpXG4gICAgfSlcbiAgKSxcbiAgcmVzb3VyY2VzOiB6OC5vcHRpb25hbChcbiAgICB6OC5sb29zZU9iamVjdCh7XG4gICAgICBzdWJzY3JpYmU6IHo4Lm9wdGlvbmFsKHo4LmJvb2xlYW4oKSksXG4gICAgICBsaXN0Q2hhbmdlZDogejgub3B0aW9uYWwoejguYm9vbGVhbigpKVxuICAgIH0pXG4gICksXG4gIHRvb2xzOiB6OC5vcHRpb25hbChcbiAgICB6OC5sb29zZU9iamVjdCh7XG4gICAgICBsaXN0Q2hhbmdlZDogejgub3B0aW9uYWwoejguYm9vbGVhbigpKVxuICAgIH0pXG4gIClcbn0pO1xudmFyIEluaXRpYWxpemVSZXN1bHRTY2hlbWEgPSBSZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgcHJvdG9jb2xWZXJzaW9uOiB6OC5zdHJpbmcoKSxcbiAgY2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXNTY2hlbWEsXG4gIHNlcnZlckluZm86IENsaWVudE9yU2VydmVySW1wbGVtZW50YXRpb25TY2hlbWEsXG4gIGluc3RydWN0aW9uczogejgub3B0aW9uYWwoejguc3RyaW5nKCkpXG59KTtcbnZhciBQYWdpbmF0ZWRSZXN1bHRTY2hlbWEgPSBSZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgbmV4dEN1cnNvcjogejgub3B0aW9uYWwoejguc3RyaW5nKCkpXG59KTtcbnZhciBUb29sU2NoZW1hID0gejgub2JqZWN0KHtcbiAgbmFtZTogejguc3RyaW5nKCksXG4gIGRlc2NyaXB0aW9uOiB6OC5vcHRpb25hbCh6OC5zdHJpbmcoKSksXG4gIGlucHV0U2NoZW1hOiB6OC5vYmplY3Qoe1xuICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJvYmplY3RcIiksXG4gICAgcHJvcGVydGllczogejgub3B0aW9uYWwoejgub2JqZWN0KHt9KS5sb29zZSgpKVxuICB9KS5sb29zZSgpXG59KS5sb29zZSgpO1xudmFyIExpc3RUb29sc1Jlc3VsdFNjaGVtYSA9IFBhZ2luYXRlZFJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICB0b29sczogejguYXJyYXkoVG9vbFNjaGVtYSlcbn0pO1xudmFyIFRleHRDb250ZW50U2NoZW1hID0gejgub2JqZWN0KHtcbiAgdHlwZTogejgubGl0ZXJhbChcInRleHRcIiksXG4gIHRleHQ6IHo4LnN0cmluZygpXG59KS5sb29zZSgpO1xudmFyIEltYWdlQ29udGVudFNjaGVtYSA9IHo4Lm9iamVjdCh7XG4gIHR5cGU6IHo4LmxpdGVyYWwoXCJpbWFnZVwiKSxcbiAgZGF0YTogejguYmFzZTY0KCksXG4gIG1pbWVUeXBlOiB6OC5zdHJpbmcoKVxufSkubG9vc2UoKTtcbnZhciBSZXNvdXJjZUNvbnRlbnRzU2NoZW1hID0gejgub2JqZWN0KHtcbiAgLyoqXG4gICAqIFRoZSBVUkkgb2YgdGhpcyByZXNvdXJjZS5cbiAgICovXG4gIHVyaTogejguc3RyaW5nKCksXG4gIC8qKlxuICAgKiBUaGUgTUlNRSB0eXBlIG9mIHRoaXMgcmVzb3VyY2UsIGlmIGtub3duLlxuICAgKi9cbiAgbWltZVR5cGU6IHo4Lm9wdGlvbmFsKHo4LnN0cmluZygpKVxufSkubG9vc2UoKTtcbnZhciBUZXh0UmVzb3VyY2VDb250ZW50c1NjaGVtYSA9IFJlc291cmNlQ29udGVudHNTY2hlbWEuZXh0ZW5kKHtcbiAgdGV4dDogejguc3RyaW5nKClcbn0pO1xudmFyIEJsb2JSZXNvdXJjZUNvbnRlbnRzU2NoZW1hID0gUmVzb3VyY2VDb250ZW50c1NjaGVtYS5leHRlbmQoe1xuICBibG9iOiB6OC5iYXNlNjQoKVxufSk7XG52YXIgRW1iZWRkZWRSZXNvdXJjZVNjaGVtYSA9IHo4Lm9iamVjdCh7XG4gIHR5cGU6IHo4LmxpdGVyYWwoXCJyZXNvdXJjZVwiKSxcbiAgcmVzb3VyY2U6IHo4LnVuaW9uKFtUZXh0UmVzb3VyY2VDb250ZW50c1NjaGVtYSwgQmxvYlJlc291cmNlQ29udGVudHNTY2hlbWFdKVxufSkubG9vc2UoKTtcbnZhciBDYWxsVG9vbFJlc3VsdFNjaGVtYSA9IFJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICBjb250ZW50OiB6OC5hcnJheShcbiAgICB6OC51bmlvbihbVGV4dENvbnRlbnRTY2hlbWEsIEltYWdlQ29udGVudFNjaGVtYSwgRW1iZWRkZWRSZXNvdXJjZVNjaGVtYV0pXG4gICksXG4gIGlzRXJyb3I6IHo4LmJvb2xlYW4oKS5kZWZhdWx0KGZhbHNlKS5vcHRpb25hbCgpXG59KS5vcihcbiAgUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gICAgdG9vbFJlc3VsdDogejgudW5rbm93bigpXG4gIH0pXG4pO1xuXG4vLyBzcmMvdG9vbC9tY3AvanNvbi1ycGMtbWVzc2FnZS50c1xudmFyIEpTT05SUENfVkVSU0lPTiA9IFwiMi4wXCI7XG52YXIgSlNPTlJQQ1JlcXVlc3RTY2hlbWEgPSB6OS5vYmplY3Qoe1xuICBqc29ucnBjOiB6OS5saXRlcmFsKEpTT05SUENfVkVSU0lPTiksXG4gIGlkOiB6OS51bmlvbihbejkuc3RyaW5nKCksIHo5Lm51bWJlcigpLmludCgpXSlcbn0pLm1lcmdlKFJlcXVlc3RTY2hlbWEpLnN0cmljdCgpO1xudmFyIEpTT05SUENSZXNwb25zZVNjaGVtYSA9IHo5Lm9iamVjdCh7XG4gIGpzb25ycGM6IHo5LmxpdGVyYWwoSlNPTlJQQ19WRVJTSU9OKSxcbiAgaWQ6IHo5LnVuaW9uKFt6OS5zdHJpbmcoKSwgejkubnVtYmVyKCkuaW50KCldKSxcbiAgcmVzdWx0OiBSZXN1bHRTY2hlbWFcbn0pLnN0cmljdCgpO1xudmFyIEpTT05SUENFcnJvclNjaGVtYSA9IHo5Lm9iamVjdCh7XG4gIGpzb25ycGM6IHo5LmxpdGVyYWwoSlNPTlJQQ19WRVJTSU9OKSxcbiAgaWQ6IHo5LnVuaW9uKFt6OS5zdHJpbmcoKSwgejkubnVtYmVyKCkuaW50KCldKSxcbiAgZXJyb3I6IHo5Lm9iamVjdCh7XG4gICAgY29kZTogejkubnVtYmVyKCkuaW50KCksXG4gICAgbWVzc2FnZTogejkuc3RyaW5nKCksXG4gICAgZGF0YTogejkub3B0aW9uYWwoejkudW5rbm93bigpKVxuICB9KVxufSkuc3RyaWN0KCk7XG52YXIgSlNPTlJQQ05vdGlmaWNhdGlvblNjaGVtYSA9IHo5Lm9iamVjdCh7XG4gIGpzb25ycGM6IHo5LmxpdGVyYWwoSlNPTlJQQ19WRVJTSU9OKVxufSkubWVyZ2UoXG4gIHo5Lm9iamVjdCh7XG4gICAgbWV0aG9kOiB6OS5zdHJpbmcoKSxcbiAgICBwYXJhbXM6IHo5Lm9wdGlvbmFsKEJhc2VQYXJhbXNTY2hlbWEpXG4gIH0pXG4pLnN0cmljdCgpO1xudmFyIEpTT05SUENNZXNzYWdlU2NoZW1hID0gejkudW5pb24oW1xuICBKU09OUlBDUmVxdWVzdFNjaGVtYSxcbiAgSlNPTlJQQ05vdGlmaWNhdGlvblNjaGVtYSxcbiAgSlNPTlJQQ1Jlc3BvbnNlU2NoZW1hLFxuICBKU09OUlBDRXJyb3JTY2hlbWFcbl0pO1xuXG4vLyBzcmMvdG9vbC9tY3AvbWNwLXNzZS10cmFuc3BvcnQudHNcbnZhciBTc2VNQ1BUcmFuc3BvcnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgaGVhZGVyc1xuICB9KSB7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVybCA9IG5ldyBVUkwodXJsKTtcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICB9XG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZTIsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlMigpO1xuICAgICAgfVxuICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCBlc3RhYmxpc2hDb25uZWN0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB2YXIgX2ExNywgX2IsIF9jO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpO1xuICAgICAgICAgIGhlYWRlcnMuc2V0KFwiQWNjZXB0XCIsIFwidGV4dC9ldmVudC1zdHJlYW1cIik7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLnVybC5ocmVmLCB7XG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiAoX2ExNyA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5zaWduYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rIHx8ICFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGBNQ1AgU1NFIFRyYW5zcG9ydCBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIChfYiA9IHRoaXMub25lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHJlc3BvbnNlLmJvZHkucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpLnBpcGVUaHJvdWdoKG5ldyBFdmVudFNvdXJjZVBhcnNlclN0cmVhbSgpKTtcbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgY29uc3QgcHJvY2Vzc0V2ZW50cyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTE4LCBfYjIsIF9jMjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJNQ1AgU1NFIFRyYW5zcG9ydCBFcnJvcjogQ29ubmVjdGlvbiBjbG9zZWQgdW5leHBlY3RlZGx5XCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXZlbnQsIGRhdGEgfSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChldmVudCA9PT0gXCJlbmRwb2ludFwiKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50ID0gbmV3IFVSTChkYXRhLCB0aGlzLnVybCk7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRwb2ludC5vcmlnaW4gIT09IHRoaXMudXJsLm9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBNQ1AgU1NFIFRyYW5zcG9ydCBFcnJvcjogRW5kcG9pbnQgb3JpZ2luIGRvZXMgbm90IG1hdGNoIGNvbm5lY3Rpb24gb3JpZ2luOiAke3RoaXMuZW5kcG9pbnQub3JpZ2lufWBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlMigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09IFwibWVzc2FnZVwiKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTlJQQ01lc3NhZ2VTY2hlbWEucGFyc2UoXG4gICAgICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShkYXRhKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAoX2ExOCA9IHRoaXMub25tZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOC5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJNQ1AgU1NFIFRyYW5zcG9ydCBFcnJvcjogRmFpbGVkIHRvIHBhcnNlIG1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIChfYjIgPSB0aGlzLm9uZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYjIuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIChfYzIgPSB0aGlzLm9uZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYzIuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLnNzZUNvbm5lY3Rpb24gPSB7XG4gICAgICAgICAgICBjbG9zZTogKCkgPT4gcmVhZGVyLmNhbmNlbCgpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBwcm9jZXNzRXZlbnRzKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgKF9jID0gdGhpcy5vbmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVzdGFibGlzaENvbm5lY3Rpb24oKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICB2YXIgX2ExNywgX2IsIF9jO1xuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgKF9hMTcgPSB0aGlzLnNzZUNvbm5lY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNsb3NlKCk7XG4gICAgKF9iID0gdGhpcy5hYm9ydENvbnRyb2xsZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5hYm9ydCgpO1xuICAgIChfYyA9IHRoaXMub25jbG9zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwodGhpcyk7XG4gIH1cbiAgYXN5bmMgc2VuZChtZXNzYWdlKSB7XG4gICAgdmFyIF9hMTcsIF9iLCBfYztcbiAgICBpZiAoIXRoaXMuZW5kcG9pbnQgfHwgIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIk1DUCBTU0UgVHJhbnNwb3J0IEVycm9yOiBOb3QgY29ubmVjdGVkXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyk7XG4gICAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICBjb25zdCBpbml0ID0ge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSxcbiAgICAgICAgc2lnbmFsOiAoX2ExNyA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5zaWduYWxcbiAgICAgIH07XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuZW5kcG9pbnQsIGluaXQpO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCB0ZXh0MiA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGBNQ1AgU1NFIFRyYW5zcG9ydCBFcnJvcjogUE9TVGluZyB0byBlbmRwb2ludCAoSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30pOiAke3RleHQyfWBcbiAgICAgICAgfSk7XG4gICAgICAgIChfYiA9IHRoaXMub25lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIChfYyA9IHRoaXMub25lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3Rvb2wvbWNwL21jcC10cmFuc3BvcnQudHNcbmZ1bmN0aW9uIGNyZWF0ZU1jcFRyYW5zcG9ydChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy50eXBlICE9PSBcInNzZVwiKSB7XG4gICAgdGhyb3cgbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IFwiVW5zdXBwb3J0ZWQgb3IgaW52YWxpZCB0cmFuc3BvcnQgY29uZmlndXJhdGlvbi4gSWYgeW91IGFyZSB1c2luZyBhIGN1c3RvbSB0cmFuc3BvcnQsIG1ha2Ugc3VyZSBpdCBpbXBsZW1lbnRzIHRoZSBNQ1BUcmFuc3BvcnQgaW50ZXJmYWNlLlwiXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBTc2VNQ1BUcmFuc3BvcnQoY29uZmlnKTtcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tTWNwVHJhbnNwb3J0KHRyYW5zcG9ydCkge1xuICByZXR1cm4gXCJzdGFydFwiIGluIHRyYW5zcG9ydCAmJiB0eXBlb2YgdHJhbnNwb3J0LnN0YXJ0ID09PSBcImZ1bmN0aW9uXCIgJiYgXCJzZW5kXCIgaW4gdHJhbnNwb3J0ICYmIHR5cGVvZiB0cmFuc3BvcnQuc2VuZCA9PT0gXCJmdW5jdGlvblwiICYmIFwiY2xvc2VcIiBpbiB0cmFuc3BvcnQgJiYgdHlwZW9mIHRyYW5zcG9ydC5jbG9zZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vLyBzcmMvdG9vbC9tY3AvbWNwLWNsaWVudC50c1xudmFyIENMSUVOVF9WRVJTSU9OID0gXCIxLjAuMFwiO1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlTUNQQ2xpZW50KGNvbmZpZykge1xuICBjb25zdCBjbGllbnQgPSBuZXcgRGVmYXVsdE1DUENsaWVudChjb25maWcpO1xuICBhd2FpdCBjbGllbnQuaW5pdCgpO1xuICByZXR1cm4gY2xpZW50O1xufVxudmFyIERlZmF1bHRNQ1BDbGllbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0cmFuc3BvcnQ6IHRyYW5zcG9ydENvbmZpZyxcbiAgICBuYW1lOiBuYW1lMTcgPSBcImFpLXNkay1tY3AtY2xpZW50XCIsXG4gICAgb25VbmNhdWdodEVycm9yXG4gIH0pIHtcbiAgICB0aGlzLnJlcXVlc3RNZXNzYWdlSWQgPSAwO1xuICAgIHRoaXMucmVzcG9uc2VIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5zZXJ2ZXJDYXBhYmlsaXRpZXMgPSB7fTtcbiAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLm9uVW5jYXVnaHRFcnJvciA9IG9uVW5jYXVnaHRFcnJvcjtcbiAgICBpZiAoaXNDdXN0b21NY3BUcmFuc3BvcnQodHJhbnNwb3J0Q29uZmlnKSkge1xuICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnRDb25maWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNwb3J0ID0gY3JlYXRlTWNwVHJhbnNwb3J0KHRyYW5zcG9ydENvbmZpZyk7XG4gICAgfVxuICAgIHRoaXMudHJhbnNwb3J0Lm9uY2xvc2UgPSAoKSA9PiB0aGlzLm9uQ2xvc2UoKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5vbmVycm9yID0gKGVycm9yKSA9PiB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgIHRoaXMudHJhbnNwb3J0Lm9ubWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICBpZiAoXCJtZXRob2RcIiBpbiBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMub25FcnJvcihcbiAgICAgICAgICBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJVbnN1cHBvcnRlZCBtZXNzYWdlIHR5cGVcIlxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMub25SZXNwb25zZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50SW5mbyA9IHtcbiAgICAgIG5hbWU6IG5hbWUxNyxcbiAgICAgIHZlcnNpb246IENMSUVOVF9WRVJTSU9OXG4gICAgfTtcbiAgfVxuICBhc3luYyBpbml0KCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnRyYW5zcG9ydC5zdGFydCgpO1xuICAgICAgdGhpcy5pc0Nsb3NlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgIG1ldGhvZDogXCJpbml0aWFsaXplXCIsXG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBwcm90b2NvbFZlcnNpb246IExBVEVTVF9QUk9UT0NPTF9WRVJTSU9OLFxuICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiB7fSxcbiAgICAgICAgICAgIGNsaWVudEluZm86IHRoaXMuY2xpZW50SW5mb1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0U2NoZW1hOiBJbml0aWFsaXplUmVzdWx0U2NoZW1hXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiU2VydmVyIHNlbnQgaW52YWxpZCBpbml0aWFsaXplIHJlc3VsdFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFTVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTlMuaW5jbHVkZXMocmVzdWx0LnByb3RvY29sVmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBgU2VydmVyJ3MgcHJvdG9jb2wgdmVyc2lvbiBpcyBub3Qgc3VwcG9ydGVkOiAke3Jlc3VsdC5wcm90b2NvbFZlcnNpb259YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VydmVyQ2FwYWJpbGl0aWVzID0gcmVzdWx0LmNhcGFiaWxpdGllcztcbiAgICAgIGF3YWl0IHRoaXMubm90aWZpY2F0aW9uKHtcbiAgICAgICAgbWV0aG9kOiBcIm5vdGlmaWNhdGlvbnMvaW5pdGlhbGl6ZWRcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgYXdhaXQgdGhpcy5jbG9zZSgpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHZhciBfYTE3O1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKVxuICAgICAgcmV0dXJuO1xuICAgIGF3YWl0ICgoX2ExNyA9IHRoaXMudHJhbnNwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jbG9zZSgpKTtcbiAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgfVxuICBhc3NlcnRDYXBhYmlsaXR5KG1ldGhvZCkge1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlIFwiaW5pdGlhbGl6ZVwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b29scy9saXN0XCI6XG4gICAgICBjYXNlIFwidG9vbHMvY2FsbFwiOlxuICAgICAgICBpZiAoIXRoaXMuc2VydmVyQ2FwYWJpbGl0aWVzLnRvb2xzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCB0b29sc2BcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogYFVuc3VwcG9ydGVkIG1ldGhvZDogJHttZXRob2R9YFxuICAgICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVxdWVzdCh7XG4gICAgcmVxdWVzdCxcbiAgICByZXN1bHRTY2hlbWEsXG4gICAgb3B0aW9uc1xuICB9KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlMiwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgICAgIG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIkF0dGVtcHRlZCB0byBzZW5kIGEgcmVxdWVzdCBmcm9tIGEgY2xvc2VkIGNsaWVudFwiXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXNzZXJ0Q2FwYWJpbGl0eShyZXF1ZXN0Lm1ldGhvZCk7XG4gICAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbDtcbiAgICAgIHNpZ25hbCA9PSBudWxsID8gdm9pZCAwIDogc2lnbmFsLnRocm93SWZBYm9ydGVkKCk7XG4gICAgICBjb25zdCBtZXNzYWdlSWQgPSB0aGlzLnJlcXVlc3RNZXNzYWdlSWQrKztcbiAgICAgIGNvbnN0IGpzb25ycGNSZXF1ZXN0ID0ge1xuICAgICAgICAuLi5yZXF1ZXN0LFxuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBpZDogbWVzc2FnZUlkXG4gICAgICB9O1xuICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5yZXNwb25zZUhhbmRsZXJzLmRlbGV0ZShtZXNzYWdlSWQpO1xuICAgICAgfTtcbiAgICAgIHRoaXMucmVzcG9uc2VIYW5kbGVycy5zZXQobWVzc2FnZUlkLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKHNpZ25hbCA9PSBudWxsID8gdm9pZCAwIDogc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgICAgICAgbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJSZXF1ZXN0IHdhcyBhYm9ydGVkXCIsXG4gICAgICAgICAgICAgIGNhdXNlOiBzaWduYWwucmVhc29uXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdFNjaGVtYS5wYXJzZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgIHJlc29sdmUyKHJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VFcnJvciA9IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwYXJzZSBzZXJ2ZXIgcmVzcG9uc2VcIixcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlamVjdChwYXJzZUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKGpzb25ycGNSZXF1ZXN0KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgbGlzdFRvb2xzKHtcbiAgICBwYXJhbXMsXG4gICAgb3B0aW9uc1xuICB9ID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kOiBcInRvb2xzL2xpc3RcIiwgcGFyYW1zIH0sXG4gICAgICAgIHJlc3VsdFNjaGVtYTogTGlzdFRvb2xzUmVzdWx0U2NoZW1hLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNhbGxUb29sKHtcbiAgICBuYW1lOiBuYW1lMTcsXG4gICAgYXJncyxcbiAgICBvcHRpb25zXG4gIH0pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kOiBcInRvb2xzL2NhbGxcIiwgcGFyYW1zOiB7IG5hbWU6IG5hbWUxNywgYXJndW1lbnRzOiBhcmdzIH0gfSxcbiAgICAgICAgcmVzdWx0U2NoZW1hOiBDYWxsVG9vbFJlc3VsdFNjaGVtYSxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHNpZ25hbDogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5hYm9ydFNpZ25hbFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIG5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCBqc29ucnBjTm90aWZpY2F0aW9uID0ge1xuICAgICAgLi4ubm90aWZpY2F0aW9uLFxuICAgICAganNvbnJwYzogXCIyLjBcIlxuICAgIH07XG4gICAgYXdhaXQgdGhpcy50cmFuc3BvcnQuc2VuZChqc29ucnBjTm90aWZpY2F0aW9uKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNldCBvZiBBSSBTREsgdG9vbHMgZnJvbSB0aGUgTUNQIHNlcnZlclxuICAgKiBAcmV0dXJucyBBIHJlY29yZCBvZiB0b29sIG5hbWVzIHRvIHRoZWlyIGltcGxlbWVudGF0aW9uc1xuICAgKi9cbiAgYXN5bmMgdG9vbHMoe1xuICAgIHNjaGVtYXMgPSBcImF1dG9tYXRpY1wiXG4gIH0gPSB7fSkge1xuICAgIHZhciBfYTE3O1xuICAgIGNvbnN0IHRvb2xzID0ge307XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGxpc3RUb29sc1Jlc3VsdCA9IGF3YWl0IHRoaXMubGlzdFRvb2xzKCk7XG4gICAgICBmb3IgKGNvbnN0IHsgbmFtZTogbmFtZTE3LCBkZXNjcmlwdGlvbiwgaW5wdXRTY2hlbWEgfSBvZiBsaXN0VG9vbHNSZXN1bHQudG9vbHMpIHtcbiAgICAgICAgaWYgKHNjaGVtYXMgIT09IFwiYXV0b21hdGljXCIgJiYgIShuYW1lMTcgaW4gc2NoZW1hcykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgZXhlY3V0ZSA9IGFzeW5jIChhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMTg7XG4gICAgICAgICAgKF9hMTggPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmFib3J0U2lnbmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOC50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxUb29sKHsgbmFtZTogbmFtZTE3LCBhcmdzLCBvcHRpb25zIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b29sV2l0aEV4ZWN1dGUgPSBzY2hlbWFzID09PSBcImF1dG9tYXRpY1wiID8gZHluYW1pY1Rvb2woe1xuICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgIGlucHV0U2NoZW1hOiBqc29uU2NoZW1hKHtcbiAgICAgICAgICAgIC4uLmlucHV0U2NoZW1hLFxuICAgICAgICAgICAgcHJvcGVydGllczogKF9hMTcgPSBpbnB1dFNjaGVtYS5wcm9wZXJ0aWVzKSAhPSBudWxsID8gX2ExNyA6IHt9LFxuICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlXG4gICAgICAgICAgfSksXG4gICAgICAgICAgZXhlY3V0ZVxuICAgICAgICB9KSA6IHRvb2woe1xuICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgIGlucHV0U2NoZW1hOiBzY2hlbWFzW25hbWUxN10uaW5wdXRTY2hlbWEsXG4gICAgICAgICAgZXhlY3V0ZVxuICAgICAgICB9KTtcbiAgICAgICAgdG9vbHNbbmFtZTE3XSA9IHRvb2xXaXRoRXhlY3V0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b29scztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIG9uQ2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogXCJDb25uZWN0aW9uIGNsb3NlZFwiXG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMucmVzcG9uc2VIYW5kbGVycy52YWx1ZXMoKSkge1xuICAgICAgaGFuZGxlcihlcnJvcik7XG4gICAgfVxuICAgIHRoaXMucmVzcG9uc2VIYW5kbGVycy5jbGVhcigpO1xuICB9XG4gIG9uRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAodGhpcy5vblVuY2F1Z2h0RXJyb3IpIHtcbiAgICAgIHRoaXMub25VbmNhdWdodEVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgb25SZXNwb25zZShyZXNwb25zZSkge1xuICAgIGNvbnN0IG1lc3NhZ2VJZCA9IE51bWJlcihyZXNwb25zZS5pZCk7XG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMucmVzcG9uc2VIYW5kbGVycy5nZXQobWVzc2FnZUlkKTtcbiAgICBpZiAoaGFuZGxlciA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgUHJvdG9jb2wgZXJyb3I6IFJlY2VpdmVkIGEgcmVzcG9uc2UgZm9yIGFuIHVua25vd24gbWVzc2FnZSBJRDogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICByZXNwb25zZVxuICAgICAgICApfWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnJlc3BvbnNlSGFuZGxlcnMuZGVsZXRlKG1lc3NhZ2VJZCk7XG4gICAgaGFuZGxlcihcbiAgICAgIFwicmVzdWx0XCIgaW4gcmVzcG9uc2UgPyByZXNwb25zZSA6IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLmVycm9yLm1lc3NhZ2UsXG4gICAgICAgIGNhdXNlOiByZXNwb25zZS5lcnJvclxuICAgICAgfSlcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvZXJyb3Ivbm8tdHJhbnNjcmlwdC1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjIyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBOb1RyYW5zY3JpcHRHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjIyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiQUlfTm9UcmFuc2NyaXB0R2VuZXJhdGVkRXJyb3JcIixcbiAgICAgIG1lc3NhZ2U6IFwiTm8gdHJhbnNjcmlwdCBnZW5lcmF0ZWQuXCJcbiAgICB9KTtcbiAgICB0aGlzLnJlc3BvbnNlcyA9IG9wdGlvbnMucmVzcG9uc2VzO1xuICB9XG59O1xuXG4vLyBzcmMvdHJhbnNjcmliZS90cmFuc2NyaWJlLnRzXG5hc3luYyBmdW5jdGlvbiB0cmFuc2NyaWJlKHtcbiAgbW9kZWwsXG4gIGF1ZGlvLFxuICBwcm92aWRlck9wdGlvbnMgPSB7fSxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnNcbn0pIHtcbiAgaWYgKG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uICE9PSBcInYyXCIpIHtcbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvcih7XG4gICAgICB2ZXJzaW9uOiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbixcbiAgICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgICB9KTtcbiAgfVxuICBjb25zdCB7IHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3QgYXVkaW9EYXRhID0gYXVkaW8gaW5zdGFuY2VvZiBVUkwgPyAoYXdhaXQgZG93bmxvYWQoeyB1cmw6IGF1ZGlvIH0pKS5kYXRhIDogY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGF1ZGlvKTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgKCkgPT4ge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICByZXR1cm4gbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgIGF1ZGlvOiBhdWRpb0RhdGEsXG4gICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgICAgIG1lZGlhVHlwZTogKF9hMTcgPSBkZXRlY3RNZWRpYVR5cGUoe1xuICAgICAgICAgIGRhdGE6IGF1ZGlvRGF0YSxcbiAgICAgICAgICBzaWduYXR1cmVzOiBhdWRpb01lZGlhVHlwZVNpZ25hdHVyZXNcbiAgICAgICAgfSkpICE9IG51bGwgPyBfYTE3IDogXCJhdWRpby93YXZcIlxuICAgICAgfSk7XG4gICAgfVxuICApO1xuICBsb2dXYXJuaW5ncyhyZXN1bHQud2FybmluZ3MpO1xuICBpZiAoIXJlc3VsdC50ZXh0KSB7XG4gICAgdGhyb3cgbmV3IE5vVHJhbnNjcmlwdEdlbmVyYXRlZEVycm9yKHsgcmVzcG9uc2VzOiBbcmVzdWx0LnJlc3BvbnNlXSB9KTtcbiAgfVxuICByZXR1cm4gbmV3IERlZmF1bHRUcmFuc2NyaXB0aW9uUmVzdWx0KHtcbiAgICB0ZXh0OiByZXN1bHQudGV4dCxcbiAgICBzZWdtZW50czogcmVzdWx0LnNlZ21lbnRzLFxuICAgIGxhbmd1YWdlOiByZXN1bHQubGFuZ3VhZ2UsXG4gICAgZHVyYXRpb25JblNlY29uZHM6IHJlc3VsdC5kdXJhdGlvbkluU2Vjb25kcyxcbiAgICB3YXJuaW5nczogcmVzdWx0Lndhcm5pbmdzLFxuICAgIHJlc3BvbnNlczogW3Jlc3VsdC5yZXNwb25zZV0sXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0LnByb3ZpZGVyTWV0YWRhdGFcbiAgfSk7XG59XG52YXIgRGVmYXVsdFRyYW5zY3JpcHRpb25SZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2ExNztcbiAgICB0aGlzLnRleHQgPSBvcHRpb25zLnRleHQ7XG4gICAgdGhpcy5zZWdtZW50cyA9IG9wdGlvbnMuc2VnbWVudHM7XG4gICAgdGhpcy5sYW5ndWFnZSA9IG9wdGlvbnMubGFuZ3VhZ2U7XG4gICAgdGhpcy5kdXJhdGlvbkluU2Vjb25kcyA9IG9wdGlvbnMuZHVyYXRpb25JblNlY29uZHM7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSAoX2ExNyA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9hMTcgOiB7fTtcbiAgfVxufTtcblxuLy8gc3JjL3VpL2NhbGwtY29tcGxldGlvbi1hcGkudHNcbmltcG9ydCB7IHBhcnNlSnNvbkV2ZW50U3RyZWFtIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3VpL3Byb2Nlc3MtdGV4dC1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NUZXh0U3RyZWFtKHtcbiAgc3RyZWFtLFxuICBvblRleHRQYXJ0XG59KSB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkuZ2V0UmVhZGVyKCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGF3YWl0IG9uVGV4dFBhcnQodmFsdWUpO1xuICB9XG59XG5cbi8vIHNyYy91aS9jYWxsLWNvbXBsZXRpb24tYXBpLnRzXG52YXIgZ2V0T3JpZ2luYWxGZXRjaCA9ICgpID0+IGZldGNoO1xuYXN5bmMgZnVuY3Rpb24gY2FsbENvbXBsZXRpb25BcGkoe1xuICBhcGksXG4gIHByb21wdCxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIHN0cmVhbVByb3RvY29sID0gXCJkYXRhXCIsXG4gIHNldENvbXBsZXRpb24sXG4gIHNldExvYWRpbmcsXG4gIHNldEVycm9yLFxuICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBmZXRjaDogZmV0Y2gyID0gZ2V0T3JpZ2luYWxGZXRjaCgpXG59KSB7XG4gIHZhciBfYTE3O1xuICB0cnkge1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3Iodm9pZCAwKTtcbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKGFib3J0Q29udHJvbGxlcik7XG4gICAgc2V0Q29tcGxldGlvbihcIlwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoMihhcGksIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgLi4uYm9keVxuICAgICAgfSksXG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLmhlYWRlcnNcbiAgICAgIH0sXG4gICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAoX2ExNyA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgIT0gbnVsbCA/IF9hMTcgOiBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS5cIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIHN3aXRjaCAoc3RyZWFtUHJvdG9jb2wpIHtcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgYXdhaXQgcHJvY2Vzc1RleHRTdHJlYW0oe1xuICAgICAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgICBvblRleHRQYXJ0OiAoY2h1bmspID0+IHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaHVuaztcbiAgICAgICAgICAgIHNldENvbXBsZXRpb24ocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkYXRhXCI6IHtcbiAgICAgICAgYXdhaXQgY29uc3VtZVN0cmVhbSh7XG4gICAgICAgICAgc3RyZWFtOiBwYXJzZUpzb25FdmVudFN0cmVhbSh7XG4gICAgICAgICAgICBzdHJlYW06IHJlc3BvbnNlLmJvZHksXG4gICAgICAgICAgICBzY2hlbWE6IHVpTWVzc2FnZUNodW5rU2NoZW1hXG4gICAgICAgICAgfSkucGlwZVRocm91Z2goXG4gICAgICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICAgICAgYXN5bmMgdHJhbnNmb3JtKHBhcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgcGFydC5lcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtUGFydCA9IHBhcnQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbVBhcnQudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHJlYW1QYXJ0LmRlbHRhO1xuICAgICAgICAgICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtUGFydC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHJlYW1QYXJ0LmVycm9yVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICksXG4gICAgICAgICAgb25FcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gc3RyZWFtUHJvdG9jb2w7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gcHJvdG9jb2w6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgIG9uRmluaXNoKHByb21wdCwgcmVzdWx0KTtcbiAgICB9XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0RXJyb3IoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgfVxufVxuXG4vLyBzcmMvdWkvY2hhdC50c1xuaW1wb3J0IHtcbiAgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkRnVuY1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdWkvY29udmVydC1maWxlLWxpc3QtdG8tZmlsZS11aS1wYXJ0cy50c1xuYXN5bmMgZnVuY3Rpb24gY29udmVydEZpbGVMaXN0VG9GaWxlVUlQYXJ0cyhmaWxlcykge1xuICBpZiAoZmlsZXMgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoIWdsb2JhbFRoaXMuRmlsZUxpc3QgfHwgIShmaWxlcyBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRmlsZUxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmlsZUxpc3QgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudFwiKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgQXJyYXkuZnJvbShmaWxlcykubWFwKGFzeW5jIChmaWxlKSA9PiB7XG4gICAgICBjb25zdCB7IG5hbWU6IG5hbWUxNywgdHlwZSB9ID0gZmlsZTtcbiAgICAgIGNvbnN0IGRhdGFVcmwgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZTIsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gKHJlYWRlckV2ZW50KSA9PiB7XG4gICAgICAgICAgdmFyIF9hMTc7XG4gICAgICAgICAgcmVzb2x2ZTIoKF9hMTcgPSByZWFkZXJFdmVudC50YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gKGVycm9yKSA9PiByZWplY3QoZXJyb3IpO1xuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIG1lZGlhVHlwZTogdHlwZSxcbiAgICAgICAgZmlsZW5hbWU6IG5hbWUxNyxcbiAgICAgICAgdXJsOiBkYXRhVXJsXG4gICAgICB9O1xuICAgIH0pXG4gICk7XG59XG5cbi8vIHNyYy91aS9kZWZhdWx0LWNoYXQtdHJhbnNwb3J0LnRzXG5pbXBvcnQgeyBwYXJzZUpzb25FdmVudFN0cmVhbSBhcyBwYXJzZUpzb25FdmVudFN0cmVhbTIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdWkvaHR0cC1jaGF0LXRyYW5zcG9ydC50c1xuaW1wb3J0IHsgcmVzb2x2ZSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgSHR0cENoYXRUcmFuc3BvcnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBhcGkgPSBcIi9hcGkvY2hhdFwiLFxuICAgIGNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keSxcbiAgICBmZXRjaDogZmV0Y2gyLFxuICAgIHByZXBhcmVTZW5kTWVzc2FnZXNSZXF1ZXN0LFxuICAgIHByZXBhcmVSZWNvbm5lY3RUb1N0cmVhbVJlcXVlc3RcbiAgfSkge1xuICAgIHRoaXMuYXBpID0gYXBpO1xuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5mZXRjaCA9IGZldGNoMjtcbiAgICB0aGlzLnByZXBhcmVTZW5kTWVzc2FnZXNSZXF1ZXN0ID0gcHJlcGFyZVNlbmRNZXNzYWdlc1JlcXVlc3Q7XG4gICAgdGhpcy5wcmVwYXJlUmVjb25uZWN0VG9TdHJlYW1SZXF1ZXN0ID0gcHJlcGFyZVJlY29ubmVjdFRvU3RyZWFtUmVxdWVzdDtcbiAgfVxuICBhc3luYyBzZW5kTWVzc2FnZXMoe1xuICAgIGFib3J0U2lnbmFsLFxuICAgIC4uLm9wdGlvbnNcbiAgfSkge1xuICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCByZXNvbHZlZEJvZHkgPSBhd2FpdCByZXNvbHZlKHRoaXMuYm9keSk7XG4gICAgY29uc3QgcmVzb2x2ZWRIZWFkZXJzID0gYXdhaXQgcmVzb2x2ZSh0aGlzLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlc29sdmVkQ3JlZGVudGlhbHMgPSBhd2FpdCByZXNvbHZlKHRoaXMuY3JlZGVudGlhbHMpO1xuICAgIGNvbnN0IHByZXBhcmVkUmVxdWVzdCA9IGF3YWl0ICgoX2ExNyA9IHRoaXMucHJlcGFyZVNlbmRNZXNzYWdlc1JlcXVlc3QpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNhbGwodGhpcywge1xuICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgIGlkOiBvcHRpb25zLmNoYXRJZCxcbiAgICAgIG1lc3NhZ2VzOiBvcHRpb25zLm1lc3NhZ2VzLFxuICAgICAgYm9keTogeyAuLi5yZXNvbHZlZEJvZHksIC4uLm9wdGlvbnMuYm9keSB9LFxuICAgICAgaGVhZGVyczogeyAuLi5yZXNvbHZlZEhlYWRlcnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9LFxuICAgICAgY3JlZGVudGlhbHM6IHJlc29sdmVkQ3JlZGVudGlhbHMsXG4gICAgICByZXF1ZXN0TWV0YWRhdGE6IG9wdGlvbnMubWV0YWRhdGEsXG4gICAgICB0cmlnZ2VyOiBvcHRpb25zLnRyaWdnZXIsXG4gICAgICBtZXNzYWdlSWQ6IG9wdGlvbnMubWVzc2FnZUlkXG4gICAgfSkpO1xuICAgIGNvbnN0IGFwaSA9IChfYiA9IHByZXBhcmVkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZWRSZXF1ZXN0LmFwaSkgIT0gbnVsbCA/IF9iIDogdGhpcy5hcGk7XG4gICAgY29uc3QgaGVhZGVycyA9IChwcmVwYXJlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVkUmVxdWVzdC5oZWFkZXJzKSAhPT0gdm9pZCAwID8gcHJlcGFyZWRSZXF1ZXN0LmhlYWRlcnMgOiB7IC4uLnJlc29sdmVkSGVhZGVycywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgY29uc3QgYm9keSA9IChwcmVwYXJlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVkUmVxdWVzdC5ib2R5KSAhPT0gdm9pZCAwID8gcHJlcGFyZWRSZXF1ZXN0LmJvZHkgOiB7XG4gICAgICAuLi5yZXNvbHZlZEJvZHksXG4gICAgICAuLi5vcHRpb25zLmJvZHksXG4gICAgICBpZDogb3B0aW9ucy5jaGF0SWQsXG4gICAgICBtZXNzYWdlczogb3B0aW9ucy5tZXNzYWdlcyxcbiAgICAgIHRyaWdnZXI6IG9wdGlvbnMudHJpZ2dlcixcbiAgICAgIG1lc3NhZ2VJZDogb3B0aW9ucy5tZXNzYWdlSWRcbiAgICB9O1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gKF9jID0gcHJlcGFyZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlZFJlcXVlc3QuY3JlZGVudGlhbHMpICE9IG51bGwgPyBfYyA6IHJlc29sdmVkQ3JlZGVudGlhbHM7XG4gICAgY29uc3QgZmV0Y2gyID0gKF9kID0gdGhpcy5mZXRjaCkgIT0gbnVsbCA/IF9kIDogZ2xvYmFsVGhpcy5mZXRjaDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoMihhcGksIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5oZWFkZXJzXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIHNpZ25hbDogYWJvcnRTaWduYWxcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIChfZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgIT0gbnVsbCA/IF9lIDogXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVzcG9uc2VTdHJlYW0ocmVzcG9uc2UuYm9keSk7XG4gIH1cbiAgYXN5bmMgcmVjb25uZWN0VG9TdHJlYW0ob3B0aW9ucykge1xuICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCByZXNvbHZlZEJvZHkgPSBhd2FpdCByZXNvbHZlKHRoaXMuYm9keSk7XG4gICAgY29uc3QgcmVzb2x2ZWRIZWFkZXJzID0gYXdhaXQgcmVzb2x2ZSh0aGlzLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlc29sdmVkQ3JlZGVudGlhbHMgPSBhd2FpdCByZXNvbHZlKHRoaXMuY3JlZGVudGlhbHMpO1xuICAgIGNvbnN0IHByZXBhcmVkUmVxdWVzdCA9IGF3YWl0ICgoX2ExNyA9IHRoaXMucHJlcGFyZVJlY29ubmVjdFRvU3RyZWFtUmVxdWVzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbCh0aGlzLCB7XG4gICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgaWQ6IG9wdGlvbnMuY2hhdElkLFxuICAgICAgYm9keTogeyAuLi5yZXNvbHZlZEJvZHksIC4uLm9wdGlvbnMuYm9keSB9LFxuICAgICAgaGVhZGVyczogeyAuLi5yZXNvbHZlZEhlYWRlcnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9LFxuICAgICAgY3JlZGVudGlhbHM6IHJlc29sdmVkQ3JlZGVudGlhbHMsXG4gICAgICByZXF1ZXN0TWV0YWRhdGE6IG9wdGlvbnMubWV0YWRhdGFcbiAgICB9KSk7XG4gICAgY29uc3QgYXBpID0gKF9iID0gcHJlcGFyZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlZFJlcXVlc3QuYXBpKSAhPSBudWxsID8gX2IgOiBgJHt0aGlzLmFwaX0vJHtvcHRpb25zLmNoYXRJZH0vc3RyZWFtYDtcbiAgICBjb25zdCBoZWFkZXJzID0gKHByZXBhcmVkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZWRSZXF1ZXN0LmhlYWRlcnMpICE9PSB2b2lkIDAgPyBwcmVwYXJlZFJlcXVlc3QuaGVhZGVycyA6IHsgLi4ucmVzb2x2ZWRIZWFkZXJzLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IChfYyA9IHByZXBhcmVkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZWRSZXF1ZXN0LmNyZWRlbnRpYWxzKSAhPSBudWxsID8gX2MgOiByZXNvbHZlZENyZWRlbnRpYWxzO1xuICAgIGNvbnN0IGZldGNoMiA9IChfZCA9IHRoaXMuZmV0Y2gpICE9IG51bGwgPyBfZCA6IGdsb2JhbFRoaXMuZmV0Y2g7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaDIoYXBpLCB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgY3JlZGVudGlhbHNcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIChfZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgIT0gbnVsbCA/IF9lIDogXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVzcG9uc2VTdHJlYW0ocmVzcG9uc2UuYm9keSk7XG4gIH1cbn07XG5cbi8vIHNyYy91aS9kZWZhdWx0LWNoYXQtdHJhbnNwb3J0LnRzXG52YXIgRGVmYXVsdENoYXRUcmFuc3BvcnQgPSBjbGFzcyBleHRlbmRzIEh0dHBDaGF0VHJhbnNwb3J0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cbiAgcHJvY2Vzc1Jlc3BvbnNlU3RyZWFtKHN0cmVhbSkge1xuICAgIHJldHVybiBwYXJzZUpzb25FdmVudFN0cmVhbTIoe1xuICAgICAgc3RyZWFtLFxuICAgICAgc2NoZW1hOiB1aU1lc3NhZ2VDaHVua1NjaGVtYVxuICAgIH0pLnBpcGVUaHJvdWdoKFxuICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgIGlmICghY2h1bmsuc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhyb3cgY2h1bmsuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL3VpL2NoYXQudHNcbnZhciBBYnN0cmFjdENoYXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IGdlbmVyYXRlSWRGdW5jLFxuICAgIGlkID0gZ2VuZXJhdGVJZDMoKSxcbiAgICB0cmFuc3BvcnQgPSBuZXcgRGVmYXVsdENoYXRUcmFuc3BvcnQoKSxcbiAgICBtZXNzYWdlTWV0YWRhdGFTY2hlbWEsXG4gICAgZGF0YVBhcnRTY2hlbWFzLFxuICAgIHN0YXRlLFxuICAgIG9uRXJyb3IsXG4gICAgb25Ub29sQ2FsbCxcbiAgICBvbkZpbmlzaCxcbiAgICBvbkRhdGEsXG4gICAgc2VuZEF1dG9tYXRpY2FsbHlXaGVuXG4gIH0pIHtcbiAgICB0aGlzLmFjdGl2ZVJlc3BvbnNlID0gdm9pZCAwO1xuICAgIHRoaXMuam9iRXhlY3V0b3IgPSBuZXcgU2VyaWFsSm9iRXhlY3V0b3IoKTtcbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIG9yIHJlcGxhY2VzIGEgdXNlciBtZXNzYWdlIHRvIHRoZSBjaGF0IGxpc3QuIFRoaXMgdHJpZ2dlcnMgdGhlIEFQSSBjYWxsIHRvIGZldGNoXG4gICAgICogdGhlIGFzc2lzdGFudCdzIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogSWYgYSBtZXNzYWdlSWQgaXMgcHJvdmlkZWQsIHRoZSBtZXNzYWdlIHdpbGwgYmUgcmVwbGFjZWQuXG4gICAgICovXG4gICAgdGhpcy5zZW5kTWVzc2FnZSA9IGFzeW5jIChtZXNzYWdlLCBvcHRpb25zKSA9PiB7XG4gICAgICB2YXIgX2ExNywgX2IsIF9jLCBfZDtcbiAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCh7XG4gICAgICAgICAgdHJpZ2dlcjogXCJzdWJtaXQtbWVzc2FnZVwiLFxuICAgICAgICAgIG1lc3NhZ2VJZDogKF9hMTcgPSB0aGlzLmxhc3RNZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5pZCxcbiAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgdWlNZXNzYWdlO1xuICAgICAgaWYgKFwidGV4dFwiIGluIG1lc3NhZ2UgfHwgXCJmaWxlc1wiIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZmlsZVBhcnRzID0gQXJyYXkuaXNBcnJheShtZXNzYWdlLmZpbGVzKSA/IG1lc3NhZ2UuZmlsZXMgOiBhd2FpdCBjb252ZXJ0RmlsZUxpc3RUb0ZpbGVVSVBhcnRzKG1lc3NhZ2UuZmlsZXMpO1xuICAgICAgICB1aU1lc3NhZ2UgPSB7XG4gICAgICAgICAgcGFydHM6IFtcbiAgICAgICAgICAgIC4uLmZpbGVQYXJ0cyxcbiAgICAgICAgICAgIC4uLlwidGV4dFwiIGluIG1lc3NhZ2UgJiYgbWVzc2FnZS50ZXh0ICE9IG51bGwgPyBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS50ZXh0IH1dIDogW11cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1aU1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UubWVzc2FnZUlkICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZUluZGV4ID0gdGhpcy5zdGF0ZS5tZXNzYWdlcy5maW5kSW5kZXgoXG4gICAgICAgICAgKG0pID0+IG0uaWQgPT09IG1lc3NhZ2UubWVzc2FnZUlkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtZXNzYWdlSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtZXNzYWdlIHdpdGggaWQgJHttZXNzYWdlLm1lc3NhZ2VJZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubWVzc2FnZXNbbWVzc2FnZUluZGV4XS5yb2xlICE9PSBcInVzZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBtZXNzYWdlIHdpdGggaWQgJHttZXNzYWdlLm1lc3NhZ2VJZH0gaXMgbm90IGEgdXNlciBtZXNzYWdlYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5tZXNzYWdlcyA9IHRoaXMuc3RhdGUubWVzc2FnZXMuc2xpY2UoMCwgbWVzc2FnZUluZGV4ICsgMSk7XG4gICAgICAgIHRoaXMuc3RhdGUucmVwbGFjZU1lc3NhZ2UobWVzc2FnZUluZGV4LCB7XG4gICAgICAgICAgLi4udWlNZXNzYWdlLFxuICAgICAgICAgIGlkOiBtZXNzYWdlLm1lc3NhZ2VJZCxcbiAgICAgICAgICByb2xlOiAoX2IgPSB1aU1lc3NhZ2Uucm9sZSkgIT0gbnVsbCA/IF9iIDogXCJ1c2VyXCIsXG4gICAgICAgICAgbWV0YWRhdGE6IG1lc3NhZ2UubWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlLnB1c2hNZXNzYWdlKHtcbiAgICAgICAgICAuLi51aU1lc3NhZ2UsXG4gICAgICAgICAgaWQ6IChfYyA9IHVpTWVzc2FnZS5pZCkgIT0gbnVsbCA/IF9jIDogdGhpcy5nZW5lcmF0ZUlkKCksXG4gICAgICAgICAgcm9sZTogKF9kID0gdWlNZXNzYWdlLnJvbGUpICE9IG51bGwgPyBfZCA6IFwidXNlclwiLFxuICAgICAgICAgIG1ldGFkYXRhOiBtZXNzYWdlLm1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCh7XG4gICAgICAgIHRyaWdnZXI6IFwic3VibWl0LW1lc3NhZ2VcIixcbiAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlLm1lc3NhZ2VJZCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdlbmVyYXRlIHRoZSBhc3Npc3RhbnQgbWVzc2FnZSB3aXRoIHRoZSBwcm92aWRlZCBtZXNzYWdlIGlkLlxuICAgICAqIElmIG5vIG1lc3NhZ2UgaWQgaXMgcHJvdmlkZWQsIHRoZSBsYXN0IGFzc2lzdGFudCBtZXNzYWdlIHdpbGwgYmUgcmVnZW5lcmF0ZWQuXG4gICAgICovXG4gICAgdGhpcy5yZWdlbmVyYXRlID0gYXN5bmMgKHtcbiAgICAgIG1lc3NhZ2VJZCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9ID0ge30pID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VJbmRleCA9IG1lc3NhZ2VJZCA9PSBudWxsID8gdGhpcy5zdGF0ZS5tZXNzYWdlcy5sZW5ndGggLSAxIDogdGhpcy5zdGF0ZS5tZXNzYWdlcy5maW5kSW5kZXgoKG1lc3NhZ2UpID0+IG1lc3NhZ2UuaWQgPT09IG1lc3NhZ2VJZCk7XG4gICAgICBpZiAobWVzc2FnZUluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1lc3NhZ2UgJHttZXNzYWdlSWR9IG5vdCBmb3VuZGApO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZS5tZXNzYWdlcyA9IHRoaXMuc3RhdGUubWVzc2FnZXMuc2xpY2UoXG4gICAgICAgIDAsXG4gICAgICAgIC8vIGlmIHRoZSBtZXNzYWdlIGlzIGEgdXNlciBtZXNzYWdlLCB3ZSBuZWVkIHRvIGluY2x1ZGUgaXQgaW4gdGhlIHJlcXVlc3Q6XG4gICAgICAgIHRoaXMubWVzc2FnZXNbbWVzc2FnZUluZGV4XS5yb2xlID09PSBcImFzc2lzdGFudFwiID8gbWVzc2FnZUluZGV4IDogbWVzc2FnZUluZGV4ICsgMVxuICAgICAgKTtcbiAgICAgIGF3YWl0IHRoaXMubWFrZVJlcXVlc3Qoe1xuICAgICAgICB0cmlnZ2VyOiBcInJlZ2VuZXJhdGUtbWVzc2FnZVwiLFxuICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byByZXN1bWUgYW4gb25nb2luZyBzdHJlYW1pbmcgcmVzcG9uc2UuXG4gICAgICovXG4gICAgdGhpcy5yZXN1bWVTdHJlYW0gPSBhc3luYyAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KHsgdHJpZ2dlcjogXCJyZXN1bWUtc3RyZWFtXCIsIC4uLm9wdGlvbnMgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgZXJyb3Igc3RhdGUgYW5kIHNldCB0aGUgc3RhdHVzIHRvIHJlYWR5IGlmIHRoZSBjaGF0IGlzIGluIGFuIGVycm9yIHN0YXRlLlxuICAgICAqL1xuICAgIHRoaXMuY2xlYXJFcnJvciA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuZXJyb3IgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcInJlYWR5XCIgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZFRvb2xSZXN1bHQgPSBhc3luYyAoe1xuICAgICAgdG9vbDogdG9vbDMsXG4gICAgICB0b29sQ2FsbElkLFxuICAgICAgb3V0cHV0XG4gICAgfSkgPT4gdGhpcy5qb2JFeGVjdXRvci5ydW4oYXN5bmMgKCkgPT4ge1xuICAgICAgdmFyIF9hMTcsIF9iO1xuICAgICAgY29uc3QgbWVzc2FnZXMgPSB0aGlzLnN0YXRlLm1lc3NhZ2VzO1xuICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgIHRoaXMuc3RhdGUucmVwbGFjZU1lc3NhZ2UobWVzc2FnZXMubGVuZ3RoIC0gMSwge1xuICAgICAgICAuLi5sYXN0TWVzc2FnZSxcbiAgICAgICAgcGFydHM6IGxhc3RNZXNzYWdlLnBhcnRzLm1hcChcbiAgICAgICAgICAocGFydCkgPT4gaXNUb29sT3JEeW5hbWljVG9vbFVJUGFydChwYXJ0KSAmJiBwYXJ0LnRvb2xDYWxsSWQgPT09IHRvb2xDYWxsSWQgPyB7IC4uLnBhcnQsIHN0YXRlOiBcIm91dHB1dC1hdmFpbGFibGVcIiwgb3V0cHV0IH0gOiBwYXJ0XG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuYWN0aXZlUmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLnBhcnRzID0gdGhpcy5hY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLnBhcnRzLm1hcChcbiAgICAgICAgICAocGFydCkgPT4gaXNUb29sT3JEeW5hbWljVG9vbFVJUGFydChwYXJ0KSAmJiBwYXJ0LnRvb2xDYWxsSWQgPT09IHRvb2xDYWxsSWQgPyB7XG4gICAgICAgICAgICAuLi5wYXJ0LFxuICAgICAgICAgICAgc3RhdGU6IFwib3V0cHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgZXJyb3JUZXh0OiB2b2lkIDBcbiAgICAgICAgICB9IDogcGFydFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBcInN0cmVhbWluZ1wiICYmIHRoaXMuc3RhdHVzICE9PSBcInN1Ym1pdHRlZFwiICYmICgoX2ExNyA9IHRoaXMuc2VuZEF1dG9tYXRpY2FsbHlXaGVuKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHRoaXMsIHsgbWVzc2FnZXM6IHRoaXMuc3RhdGUubWVzc2FnZXMgfSkpKSB7XG4gICAgICAgIHRoaXMubWFrZVJlcXVlc3Qoe1xuICAgICAgICAgIHRyaWdnZXI6IFwic3VibWl0LW1lc3NhZ2VcIixcbiAgICAgICAgICBtZXNzYWdlSWQ6IChfYiA9IHRoaXMubGFzdE1lc3NhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYi5pZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBYm9ydCB0aGUgY3VycmVudCByZXF1ZXN0IGltbWVkaWF0ZWx5LCBrZWVwIHRoZSBnZW5lcmF0ZWQgdG9rZW5zIGlmIGFueS5cbiAgICAgKi9cbiAgICB0aGlzLnN0b3AgPSBhc3luYyAoKSA9PiB7XG4gICAgICB2YXIgX2ExNztcbiAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gXCJzdHJlYW1pbmdcIiAmJiB0aGlzLnN0YXR1cyAhPT0gXCJzdWJtaXR0ZWRcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKChfYTE3ID0gdGhpcy5hY3RpdmVSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUmVzcG9uc2UuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5nZW5lcmF0ZUlkID0gZ2VuZXJhdGVJZDM7XG4gICAgdGhpcy5tZXNzYWdlTWV0YWRhdGFTY2hlbWEgPSBtZXNzYWdlTWV0YWRhdGFTY2hlbWE7XG4gICAgdGhpcy5kYXRhUGFydFNjaGVtYXMgPSBkYXRhUGFydFNjaGVtYXM7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMub25FcnJvciA9IG9uRXJyb3I7XG4gICAgdGhpcy5vblRvb2xDYWxsID0gb25Ub29sQ2FsbDtcbiAgICB0aGlzLm9uRmluaXNoID0gb25GaW5pc2g7XG4gICAgdGhpcy5vbkRhdGEgPSBvbkRhdGE7XG4gICAgdGhpcy5zZW5kQXV0b21hdGljYWxseVdoZW4gPSBzZW5kQXV0b21hdGljYWxseVdoZW47XG4gIH1cbiAgLyoqXG4gICAqIEhvb2sgc3RhdHVzOlxuICAgKlxuICAgKiAtIGBzdWJtaXR0ZWRgOiBUaGUgbWVzc2FnZSBoYXMgYmVlbiBzZW50IHRvIHRoZSBBUEkgYW5kIHdlJ3JlIGF3YWl0aW5nIHRoZSBzdGFydCBvZiB0aGUgcmVzcG9uc2Ugc3RyZWFtLlxuICAgKiAtIGBzdHJlYW1pbmdgOiBUaGUgcmVzcG9uc2UgaXMgYWN0aXZlbHkgc3RyZWFtaW5nIGluIGZyb20gdGhlIEFQSSwgcmVjZWl2aW5nIGNodW5rcyBvZiBkYXRhLlxuICAgKiAtIGByZWFkeWA6IFRoZSBmdWxsIHJlc3BvbnNlIGhhcyBiZWVuIHJlY2VpdmVkIGFuZCBwcm9jZXNzZWQ7IGEgbmV3IHVzZXIgbWVzc2FnZSBjYW4gYmUgc3VibWl0dGVkLlxuICAgKiAtIGBlcnJvcmA6IEFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgQVBJIHJlcXVlc3QsIHByZXZlbnRpbmcgc3VjY2Vzc2Z1bCBjb21wbGV0aW9uLlxuICAgKi9cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5zdGF0dXM7XG4gIH1cbiAgc2V0U3RhdHVzKHtcbiAgICBzdGF0dXMsXG4gICAgZXJyb3JcbiAgfSkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gc3RhdHVzKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuc3RhdGUuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdGUuZXJyb3IgPSBlcnJvcjtcbiAgfVxuICBnZXQgZXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3I7XG4gIH1cbiAgZ2V0IG1lc3NhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLm1lc3NhZ2VzO1xuICB9XG4gIGdldCBsYXN0TWVzc2FnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5tZXNzYWdlc1t0aGlzLnN0YXRlLm1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHNldCBtZXNzYWdlcyhtZXNzYWdlcykge1xuICAgIHRoaXMuc3RhdGUubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgfVxuICBhc3luYyBtYWtlUmVxdWVzdCh7XG4gICAgdHJpZ2dlcixcbiAgICBtZXRhZGF0YSxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHksXG4gICAgbWVzc2FnZUlkXG4gIH0pIHtcbiAgICB2YXIgX2ExNywgX2IsIF9jO1xuICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcInN1Ym1pdHRlZFwiLCBlcnJvcjogdm9pZCAwIH0pO1xuICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gdGhpcy5sYXN0TWVzc2FnZTtcbiAgICBsZXQgaXNBYm9ydCA9IGZhbHNlO1xuICAgIGxldCBpc0Rpc2Nvbm5lY3QgPSBmYWxzZTtcbiAgICBsZXQgaXNFcnJvciA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhY3RpdmVSZXNwb25zZSA9IHtcbiAgICAgICAgc3RhdGU6IGNyZWF0ZVN0cmVhbWluZ1VJTWVzc2FnZVN0YXRlKHtcbiAgICAgICAgICBsYXN0TWVzc2FnZTogdGhpcy5zdGF0ZS5zbmFwc2hvdChsYXN0TWVzc2FnZSksXG4gICAgICAgICAgbWVzc2FnZUlkOiB0aGlzLmdlbmVyYXRlSWQoKVxuICAgICAgICB9KSxcbiAgICAgICAgYWJvcnRDb250cm9sbGVyOiBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICAgIH07XG4gICAgICBhY3RpdmVSZXNwb25zZS5hYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgIGlzQWJvcnQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFjdGl2ZVJlc3BvbnNlID0gYWN0aXZlUmVzcG9uc2U7XG4gICAgICBsZXQgc3RyZWFtO1xuICAgICAgaWYgKHRyaWdnZXIgPT09IFwicmVzdW1lLXN0cmVhbVwiKSB7XG4gICAgICAgIGNvbnN0IHJlY29ubmVjdCA9IGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlY29ubmVjdFRvU3RyZWFtKHtcbiAgICAgICAgICBjaGF0SWQ6IHRoaXMuaWQsXG4gICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBib2R5XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVjb25uZWN0ID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnNldFN0YXR1cyh7IHN0YXR1czogXCJyZWFkeVwiIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0gPSByZWNvbm5lY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0gPSBhd2FpdCB0aGlzLnRyYW5zcG9ydC5zZW5kTWVzc2FnZXMoe1xuICAgICAgICAgIGNoYXRJZDogdGhpcy5pZCxcbiAgICAgICAgICBtZXNzYWdlczogdGhpcy5zdGF0ZS5tZXNzYWdlcyxcbiAgICAgICAgICBhYm9ydFNpZ25hbDogYWN0aXZlUmVzcG9uc2UuYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgdHJpZ2dlcixcbiAgICAgICAgICBtZXNzYWdlSWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBydW5VcGRhdGVNZXNzYWdlSm9iID0gKGpvYikgPT4gKFxuICAgICAgICAvLyBzZXJpYWxpemUgdGhlIGpvYiBleGVjdXRpb24gdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zOlxuICAgICAgICB0aGlzLmpvYkV4ZWN1dG9yLnJ1bihcbiAgICAgICAgICAoKSA9PiBqb2Ioe1xuICAgICAgICAgICAgc3RhdGU6IGFjdGl2ZVJlc3BvbnNlLnN0YXRlLFxuICAgICAgICAgICAgd3JpdGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTg7XG4gICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcInN0cmVhbWluZ1wiIH0pO1xuICAgICAgICAgICAgICBjb25zdCByZXBsYWNlTGFzdE1lc3NhZ2UgPSBhY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLmlkID09PSAoKF9hMTggPSB0aGlzLmxhc3RNZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOC5pZCk7XG4gICAgICAgICAgICAgIGlmIChyZXBsYWNlTGFzdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnJlcGxhY2VNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5tZXNzYWdlcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgICAgYWN0aXZlUmVzcG9uc2Uuc3RhdGUubWVzc2FnZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wdXNoTWVzc2FnZShhY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBhd2FpdCBjb25zdW1lU3RyZWFtKHtcbiAgICAgICAgc3RyZWFtOiBwcm9jZXNzVUlNZXNzYWdlU3RyZWFtKHtcbiAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgb25Ub29sQ2FsbDogdGhpcy5vblRvb2xDYWxsLFxuICAgICAgICAgIG9uRGF0YTogdGhpcy5vbkRhdGEsXG4gICAgICAgICAgbWVzc2FnZU1ldGFkYXRhU2NoZW1hOiB0aGlzLm1lc3NhZ2VNZXRhZGF0YVNjaGVtYSxcbiAgICAgICAgICBkYXRhUGFydFNjaGVtYXM6IHRoaXMuZGF0YVBhcnRTY2hlbWFzLFxuICAgICAgICAgIHJ1blVwZGF0ZU1lc3NhZ2VKb2IsXG4gICAgICAgICAgb25FcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBvbkVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNldFN0YXR1cyh7IHN0YXR1czogXCJyZWFkeVwiIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGlzQWJvcnQgfHwgZXJyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgIGlzQWJvcnQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyh7IHN0YXR1czogXCJyZWFkeVwiIH0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlzRXJyb3IgPSB0cnVlO1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiAoZXJyLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImZldGNoXCIpIHx8IGVyci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJuZXR3b3JrXCIpKSkge1xuICAgICAgICBpc0Rpc2Nvbm5lY3QgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub25FcnJvciAmJiBlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcImVycm9yXCIsIGVycm9yOiBlcnIgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIChfYTE3ID0gdGhpcy5vbkZpbmlzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgbWVzc2FnZTogdGhpcy5hY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLFxuICAgICAgICAgIG1lc3NhZ2VzOiB0aGlzLnN0YXRlLm1lc3NhZ2VzLFxuICAgICAgICAgIGlzQWJvcnQsXG4gICAgICAgICAgaXNEaXNjb25uZWN0LFxuICAgICAgICAgIGlzRXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3RpdmVSZXNwb25zZSA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKChfYiA9IHRoaXMuc2VuZEF1dG9tYXRpY2FsbHlXaGVuKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzLCB7IG1lc3NhZ2VzOiB0aGlzLnN0YXRlLm1lc3NhZ2VzIH0pKSB7XG4gICAgICBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KHtcbiAgICAgICAgdHJpZ2dlcjogXCJzdWJtaXQtbWVzc2FnZVwiLFxuICAgICAgICBtZXNzYWdlSWQ6IChfYyA9IHRoaXMubGFzdE1lc3NhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYy5pZCxcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3VpL2xhc3QtYXNzaXN0YW50LW1lc3NhZ2UtaXMtY29tcGxldGUtd2l0aC10b29sLWNhbGxzLnRzXG5mdW5jdGlvbiBsYXN0QXNzaXN0YW50TWVzc2FnZUlzQ29tcGxldGVXaXRoVG9vbENhbGxzKHtcbiAgbWVzc2FnZXNcbn0pIHtcbiAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICBpZiAoIW1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG1lc3NhZ2Uucm9sZSAhPT0gXCJhc3Npc3RhbnRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsYXN0U3RlcFN0YXJ0SW5kZXggPSBtZXNzYWdlLnBhcnRzLnJlZHVjZSgobGFzdEluZGV4LCBwYXJ0LCBpbmRleCkgPT4ge1xuICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwic3RlcC1zdGFydFwiID8gaW5kZXggOiBsYXN0SW5kZXg7XG4gIH0sIC0xKTtcbiAgY29uc3QgbGFzdFN0ZXBUb29sSW52b2NhdGlvbnMgPSBtZXNzYWdlLnBhcnRzLnNsaWNlKGxhc3RTdGVwU3RhcnRJbmRleCArIDEpLmZpbHRlcihpc1Rvb2xPckR5bmFtaWNUb29sVUlQYXJ0KTtcbiAgcmV0dXJuIGxhc3RTdGVwVG9vbEludm9jYXRpb25zLmxlbmd0aCA+IDAgJiYgbGFzdFN0ZXBUb29sSW52b2NhdGlvbnMuZXZlcnkoKHBhcnQpID0+IHBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWF2YWlsYWJsZVwiKTtcbn1cblxuLy8gc3JjL3VpL3RyYW5zZm9ybS10ZXh0LXRvLXVpLW1lc3NhZ2Utc3RyZWFtLnRzXG5mdW5jdGlvbiB0cmFuc2Zvcm1UZXh0VG9VaU1lc3NhZ2VTdHJlYW0oe1xuICBzdHJlYW1cbn0pIHtcbiAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJzdGFydFwiIH0pO1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInN0YXJ0LXN0ZXBcIiB9KTtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0LXN0YXJ0XCIsIGlkOiBcInRleHQtMVwiIH0pO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShwYXJ0LCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1kZWx0YVwiLCBpZDogXCJ0ZXh0LTFcIiwgZGVsdGE6IHBhcnQgfSk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtZW5kXCIsIGlkOiBcInRleHQtMVwiIH0pO1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImZpbmlzaC1zdGVwXCIgfSk7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZmluaXNoXCIgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cblxuLy8gc3JjL3VpL3RleHQtc3RyZWFtLWNoYXQtdHJhbnNwb3J0LnRzXG52YXIgVGV4dFN0cmVhbUNoYXRUcmFuc3BvcnQgPSBjbGFzcyBleHRlbmRzIEh0dHBDaGF0VHJhbnNwb3J0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cbiAgcHJvY2Vzc1Jlc3BvbnNlU3RyZWFtKHN0cmVhbSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1UZXh0VG9VaU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgc3RyZWFtOiBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91aS92YWxpZGF0ZS11aS1tZXNzYWdlcy50c1xuaW1wb3J0IHsgVHlwZVZhbGlkYXRpb25FcnJvciBhcyBUeXBlVmFsaWRhdGlvbkVycm9yNCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICB2YWxpZGF0ZVR5cGVzIGFzIHZhbGlkYXRlVHlwZXMyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB6IGFzIHoxMCB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciB0ZXh0VUlQYXJ0U2NoZW1hID0gejEwLm9iamVjdCh7XG4gIHR5cGU6IHoxMC5saXRlcmFsKFwidGV4dFwiKSxcbiAgdGV4dDogejEwLnN0cmluZygpLFxuICBzdGF0ZTogejEwLmVudW0oW1wic3RyZWFtaW5nXCIsIFwiZG9uZVwiXSkub3B0aW9uYWwoKSxcbiAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciByZWFzb25pbmdVSVBhcnRTY2hlbWEgPSB6MTAub2JqZWN0KHtcbiAgdHlwZTogejEwLmxpdGVyYWwoXCJyZWFzb25pbmdcIiksXG4gIHRleHQ6IHoxMC5zdHJpbmcoKSxcbiAgc3RhdGU6IHoxMC5lbnVtKFtcInN0cmVhbWluZ1wiLCBcImRvbmVcIl0pLm9wdGlvbmFsKCksXG4gIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgc291cmNlVXJsVUlQYXJ0U2NoZW1hID0gejEwLm9iamVjdCh7XG4gIHR5cGU6IHoxMC5saXRlcmFsKFwic291cmNlLXVybFwiKSxcbiAgc291cmNlSWQ6IHoxMC5zdHJpbmcoKSxcbiAgdXJsOiB6MTAuc3RyaW5nKCksXG4gIHRpdGxlOiB6MTAuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBzb3VyY2VEb2N1bWVudFVJUGFydFNjaGVtYSA9IHoxMC5vYmplY3Qoe1xuICB0eXBlOiB6MTAubGl0ZXJhbChcInNvdXJjZS1kb2N1bWVudFwiKSxcbiAgc291cmNlSWQ6IHoxMC5zdHJpbmcoKSxcbiAgbWVkaWFUeXBlOiB6MTAuc3RyaW5nKCksXG4gIHRpdGxlOiB6MTAuc3RyaW5nKCksXG4gIGZpbGVuYW1lOiB6MTAuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBmaWxlVUlQYXJ0U2NoZW1hID0gejEwLm9iamVjdCh7XG4gIHR5cGU6IHoxMC5saXRlcmFsKFwiZmlsZVwiKSxcbiAgbWVkaWFUeXBlOiB6MTAuc3RyaW5nKCksXG4gIGZpbGVuYW1lOiB6MTAuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgdXJsOiB6MTAuc3RyaW5nKCksXG4gIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgc3RlcFN0YXJ0VUlQYXJ0U2NoZW1hID0gejEwLm9iamVjdCh7XG4gIHR5cGU6IHoxMC5saXRlcmFsKFwic3RlcC1zdGFydFwiKVxufSk7XG52YXIgZGF0YVVJUGFydFNjaGVtYSA9IHoxMC5vYmplY3Qoe1xuICB0eXBlOiB6MTAuc3RyaW5nKCkuc3RhcnRzV2l0aChcImRhdGEtXCIpLFxuICBpZDogejEwLnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGRhdGE6IHoxMC51bmtub3duKClcbn0pO1xudmFyIGR5bmFtaWNUb29sVUlQYXJ0U2NoZW1hcyA9IFtcbiAgejEwLm9iamVjdCh7XG4gICAgdHlwZTogejEwLmxpdGVyYWwoXCJkeW5hbWljLXRvb2xcIiksXG4gICAgdG9vbE5hbWU6IHoxMC5zdHJpbmcoKSxcbiAgICB0b29sQ2FsbElkOiB6MTAuc3RyaW5nKCksXG4gICAgc3RhdGU6IHoxMC5saXRlcmFsKFwiaW5wdXQtc3RyZWFtaW5nXCIpLFxuICAgIGlucHV0OiB6MTAudW5rbm93bigpLm9wdGlvbmFsKCksXG4gICAgb3V0cHV0OiB6MTAubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgIGVycm9yVGV4dDogejEwLm5ldmVyKCkub3B0aW9uYWwoKVxuICB9KSxcbiAgejEwLm9iamVjdCh7XG4gICAgdHlwZTogejEwLmxpdGVyYWwoXCJkeW5hbWljLXRvb2xcIiksXG4gICAgdG9vbE5hbWU6IHoxMC5zdHJpbmcoKSxcbiAgICB0b29sQ2FsbElkOiB6MTAuc3RyaW5nKCksXG4gICAgc3RhdGU6IHoxMC5saXRlcmFsKFwiaW5wdXQtYXZhaWxhYmxlXCIpLFxuICAgIGlucHV0OiB6MTAudW5rbm93bigpLFxuICAgIG91dHB1dDogejEwLm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICBlcnJvclRleHQ6IHoxMC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICB9KSxcbiAgejEwLm9iamVjdCh7XG4gICAgdHlwZTogejEwLmxpdGVyYWwoXCJkeW5hbWljLXRvb2xcIiksXG4gICAgdG9vbE5hbWU6IHoxMC5zdHJpbmcoKSxcbiAgICB0b29sQ2FsbElkOiB6MTAuc3RyaW5nKCksXG4gICAgc3RhdGU6IHoxMC5saXRlcmFsKFwib3V0cHV0LWF2YWlsYWJsZVwiKSxcbiAgICBpbnB1dDogejEwLnVua25vd24oKSxcbiAgICBvdXRwdXQ6IHoxMC51bmtub3duKCksXG4gICAgZXJyb3JUZXh0OiB6MTAubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgcHJlbGltaW5hcnk6IHoxMC5ib29sZWFuKCkub3B0aW9uYWwoKVxuICB9KSxcbiAgejEwLm9iamVjdCh7XG4gICAgdHlwZTogejEwLmxpdGVyYWwoXCJkeW5hbWljLXRvb2xcIiksXG4gICAgdG9vbE5hbWU6IHoxMC5zdHJpbmcoKSxcbiAgICB0b29sQ2FsbElkOiB6MTAuc3RyaW5nKCksXG4gICAgc3RhdGU6IHoxMC5saXRlcmFsKFwib3V0cHV0LWVycm9yXCIpLFxuICAgIGlucHV0OiB6MTAudW5rbm93bigpLFxuICAgIG91dHB1dDogejEwLm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICBlcnJvclRleHQ6IHoxMC5zdHJpbmcoKSxcbiAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH0pXG5dO1xudmFyIHRvb2xVSVBhcnRTY2hlbWFzID0gW1xuICB6MTAub2JqZWN0KHtcbiAgICB0eXBlOiB6MTAuc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgIHRvb2xDYWxsSWQ6IHoxMC5zdHJpbmcoKSxcbiAgICBzdGF0ZTogejEwLmxpdGVyYWwoXCJpbnB1dC1zdHJlYW1pbmdcIiksXG4gICAgaW5wdXQ6IHoxMC51bmtub3duKCkub3B0aW9uYWwoKSxcbiAgICBvdXRwdXQ6IHoxMC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgZXJyb3JUZXh0OiB6MTAubmV2ZXIoKS5vcHRpb25hbCgpXG4gIH0pLFxuICB6MTAub2JqZWN0KHtcbiAgICB0eXBlOiB6MTAuc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgIHRvb2xDYWxsSWQ6IHoxMC5zdHJpbmcoKSxcbiAgICBzdGF0ZTogejEwLmxpdGVyYWwoXCJpbnB1dC1hdmFpbGFibGVcIiksXG4gICAgaW5wdXQ6IHoxMC51bmtub3duKCksXG4gICAgb3V0cHV0OiB6MTAubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgIGVycm9yVGV4dDogejEwLm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH0pLFxuICB6MTAub2JqZWN0KHtcbiAgICB0eXBlOiB6MTAuc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgIHRvb2xDYWxsSWQ6IHoxMC5zdHJpbmcoKSxcbiAgICBzdGF0ZTogejEwLmxpdGVyYWwoXCJvdXRwdXQtYXZhaWxhYmxlXCIpLFxuICAgIGlucHV0OiB6MTAudW5rbm93bigpLFxuICAgIG91dHB1dDogejEwLnVua25vd24oKSxcbiAgICBlcnJvclRleHQ6IHoxMC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICBwcmVsaW1pbmFyeTogejEwLmJvb2xlYW4oKS5vcHRpb25hbCgpXG4gIH0pLFxuICB6MTAub2JqZWN0KHtcbiAgICB0eXBlOiB6MTAuc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgIHRvb2xDYWxsSWQ6IHoxMC5zdHJpbmcoKSxcbiAgICBzdGF0ZTogejEwLmxpdGVyYWwoXCJvdXRwdXQtZXJyb3JcIiksXG4gICAgaW5wdXQ6IHoxMC51bmtub3duKCksXG4gICAgb3V0cHV0OiB6MTAubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgIGVycm9yVGV4dDogejEwLnN0cmluZygpLFxuICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgfSlcbl07XG52YXIgdWlNZXNzYWdlU2NoZW1hID0gejEwLm9iamVjdCh7XG4gIGlkOiB6MTAuc3RyaW5nKCksXG4gIHJvbGU6IHoxMC5lbnVtKFtcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIl0pLFxuICBtZXRhZGF0YTogejEwLnVua25vd24oKS5vcHRpb25hbCgpLFxuICBwYXJ0czogejEwLmFycmF5KFxuICAgIHoxMC51bmlvbihbXG4gICAgICB0ZXh0VUlQYXJ0U2NoZW1hLFxuICAgICAgcmVhc29uaW5nVUlQYXJ0U2NoZW1hLFxuICAgICAgc291cmNlVXJsVUlQYXJ0U2NoZW1hLFxuICAgICAgc291cmNlRG9jdW1lbnRVSVBhcnRTY2hlbWEsXG4gICAgICBmaWxlVUlQYXJ0U2NoZW1hLFxuICAgICAgc3RlcFN0YXJ0VUlQYXJ0U2NoZW1hLFxuICAgICAgZGF0YVVJUGFydFNjaGVtYSxcbiAgICAgIC4uLmR5bmFtaWNUb29sVUlQYXJ0U2NoZW1hcyxcbiAgICAgIC4uLnRvb2xVSVBhcnRTY2hlbWFzXG4gICAgXSlcbiAgKVxufSk7XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVVJTWVzc2FnZXMoe1xuICBtZXNzYWdlcyxcbiAgbWV0YWRhdGFTY2hlbWEsXG4gIGRhdGFTY2hlbWFzLFxuICB0b29sc1xufSkge1xuICBpZiAobWVzc2FnZXMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBwYXJhbWV0ZXI6IFwibWVzc2FnZXNcIixcbiAgICAgIHZhbHVlOiBtZXNzYWdlcyxcbiAgICAgIG1lc3NhZ2U6IFwibWVzc2FnZXMgcGFyYW1ldGVyIG11c3QgYmUgcHJvdmlkZWRcIlxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHZhbGlkYXRlZE1lc3NhZ2VzID0gYXdhaXQgdmFsaWRhdGVUeXBlczIoe1xuICAgIHZhbHVlOiBtZXNzYWdlcyxcbiAgICBzY2hlbWE6IHoxMC5hcnJheSh1aU1lc3NhZ2VTY2hlbWEpXG4gIH0pO1xuICBpZiAobWV0YWRhdGFTY2hlbWEpIHtcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgdmFsaWRhdGVkTWVzc2FnZXMpIHtcbiAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgdmFsdWU6IG1lc3NhZ2UubWV0YWRhdGEsXG4gICAgICAgIHNjaGVtYTogbWV0YWRhdGFTY2hlbWFcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoZGF0YVNjaGVtYXMpIHtcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgdmFsaWRhdGVkTWVzc2FnZXMpIHtcbiAgICAgIGNvbnN0IGRhdGFQYXJ0cyA9IG1lc3NhZ2UucGFydHMuZmlsdGVyKFxuICAgICAgICAocGFydCkgPT4gcGFydC50eXBlLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKVxuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3QgZGF0YVBhcnQgb2YgZGF0YVBhcnRzKSB7XG4gICAgICAgIGNvbnN0IGRhdGFOYW1lID0gZGF0YVBhcnQudHlwZS5zbGljZSg1KTtcbiAgICAgICAgY29uc3QgZGF0YVNjaGVtYSA9IGRhdGFTY2hlbWFzW2RhdGFOYW1lXTtcbiAgICAgICAgaWYgKCFkYXRhU2NoZW1hKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3I0KHtcbiAgICAgICAgICAgIHZhbHVlOiBkYXRhUGFydC5kYXRhLFxuICAgICAgICAgICAgY2F1c2U6IGBObyBkYXRhIHNjaGVtYSBmb3VuZCBmb3IgZGF0YSBwYXJ0ICR7ZGF0YU5hbWV9YFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgICB2YWx1ZTogZGF0YVBhcnQuZGF0YSxcbiAgICAgICAgICBzY2hlbWE6IGRhdGFTY2hlbWFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh0b29scykge1xuICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiB2YWxpZGF0ZWRNZXNzYWdlcykge1xuICAgICAgY29uc3QgdG9vbFBhcnRzID0gbWVzc2FnZS5wYXJ0cy5maWx0ZXIoXG4gICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUuc3RhcnRzV2l0aChcInRvb2wtXCIpXG4gICAgICApO1xuICAgICAgZm9yIChjb25zdCB0b29sUGFydCBvZiB0b29sUGFydHMpIHtcbiAgICAgICAgY29uc3QgdG9vbE5hbWUgPSB0b29sUGFydC50eXBlLnNsaWNlKDUpO1xuICAgICAgICBjb25zdCB0b29sMyA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgaWYgKCF0b29sMykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yNCh7XG4gICAgICAgICAgICB2YWx1ZTogdG9vbFBhcnQuaW5wdXQsXG4gICAgICAgICAgICBjYXVzZTogYE5vIHRvb2wgc2NoZW1hIGZvdW5kIGZvciB0b29sIHBhcnQgJHt0b29sTmFtZX1gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvb2xQYXJ0LnN0YXRlID09PSBcImlucHV0LWF2YWlsYWJsZVwiIHx8IHRvb2xQYXJ0LnN0YXRlID09PSBcIm91dHB1dC1hdmFpbGFibGVcIiB8fCB0b29sUGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtZXJyb3JcIikge1xuICAgICAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgICAgIHZhbHVlOiB0b29sUGFydC5pbnB1dCxcbiAgICAgICAgICAgIHNjaGVtYTogdG9vbDMuaW5wdXRTY2hlbWFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9vbFBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWF2YWlsYWJsZVwiICYmIHRvb2wzLm91dHB1dFNjaGVtYSkge1xuICAgICAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgICAgIHZhbHVlOiB0b29sUGFydC5vdXRwdXQsXG4gICAgICAgICAgICBzY2hlbWE6IHRvb2wzLm91dHB1dFNjaGVtYVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxpZGF0ZWRNZXNzYWdlcztcbn1cblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL2NyZWF0ZS11aS1tZXNzYWdlLXN0cmVhbS50c1xuaW1wb3J0IHtcbiAgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkRnVuYzIsXG4gIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2U4XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5mdW5jdGlvbiBjcmVhdGVVSU1lc3NhZ2VTdHJlYW0oe1xuICBleGVjdXRlLFxuICBvbkVycm9yID0gZ2V0RXJyb3JNZXNzYWdlOCxcbiAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgb25GaW5pc2gsXG4gIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gZ2VuZXJhdGVJZEZ1bmMyXG59KSB7XG4gIGxldCBjb250cm9sbGVyO1xuICBjb25zdCBvbmdvaW5nU3RyZWFtUHJvbWlzZXMgPSBbXTtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyQXJnKSB7XG4gICAgICBjb250cm9sbGVyID0gY29udHJvbGxlckFyZztcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBzYWZlRW5xdWV1ZShkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGV4ZWN1dGUoe1xuICAgICAgd3JpdGVyOiB7XG4gICAgICAgIHdyaXRlKHBhcnQpIHtcbiAgICAgICAgICBzYWZlRW5xdWV1ZShwYXJ0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyZ2Uoc3RyZWFtQXJnKSB7XG4gICAgICAgICAgb25nb2luZ1N0cmVhbVByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW1BcmcuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHNhZmVFbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgc2FmZUVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBlcnJvclRleHQ6IG9uRXJyb3IoZXJyb3IpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgb25nb2luZ1N0cmVhbVByb21pc2VzLnB1c2goXG4gICAgICAgIHJlc3VsdC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICBzYWZlRW5xdWV1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICBlcnJvclRleHQ6IG9uRXJyb3IoZXJyb3IpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBzYWZlRW5xdWV1ZSh7XG4gICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICBlcnJvclRleHQ6IG9uRXJyb3IoZXJyb3IpXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgd2FpdEZvclN0cmVhbXMgPSBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZTIpID0+IHtcbiAgICB3aGlsZSAob25nb2luZ1N0cmVhbVByb21pc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGF3YWl0IG9uZ29pbmdTdHJlYW1Qcm9taXNlcy5zaGlmdCgpO1xuICAgIH1cbiAgICByZXNvbHZlMigpO1xuICB9KTtcbiAgd2FpdEZvclN0cmVhbXMuZmluYWxseSgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBoYW5kbGVVSU1lc3NhZ2VTdHJlYW1GaW5pc2goe1xuICAgIHN0cmVhbSxcbiAgICBtZXNzYWdlSWQ6IGdlbmVyYXRlSWQzKCksXG4gICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICBvbkZpbmlzaCxcbiAgICBvbkVycm9yXG4gIH0pO1xufVxuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vcmVhZC11aS1tZXNzYWdlLXN0cmVhbS50c1xuZnVuY3Rpb24gcmVhZFVJTWVzc2FnZVN0cmVhbSh7XG4gIG1lc3NhZ2UsXG4gIHN0cmVhbSxcbiAgb25FcnJvcixcbiAgdGVybWluYXRlT25FcnJvciA9IGZhbHNlXG59KSB7XG4gIHZhciBfYTE3O1xuICBsZXQgY29udHJvbGxlcjtcbiAgbGV0IGhhc0Vycm9yZWQgPSBmYWxzZTtcbiAgY29uc3Qgb3V0cHV0U3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyUGFyYW0pIHtcbiAgICAgIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyUGFyYW07XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc3RhdGUgPSBjcmVhdGVTdHJlYW1pbmdVSU1lc3NhZ2VTdGF0ZSh7XG4gICAgbWVzc2FnZUlkOiAoX2ExNyA9IG1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2UuaWQpICE9IG51bGwgPyBfYTE3IDogXCJcIixcbiAgICBsYXN0TWVzc2FnZTogbWVzc2FnZVxuICB9KTtcbiAgY29uc3QgaGFuZGxlRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICBvbkVycm9yID09IG51bGwgPyB2b2lkIDAgOiBvbkVycm9yKGVycm9yKTtcbiAgICBpZiAoIWhhc0Vycm9yZWQgJiYgdGVybWluYXRlT25FcnJvcikge1xuICAgICAgaGFzRXJyb3JlZCA9IHRydWU7XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH07XG4gIGNvbnN1bWVTdHJlYW0oe1xuICAgIHN0cmVhbTogcHJvY2Vzc1VJTWVzc2FnZVN0cmVhbSh7XG4gICAgICBzdHJlYW0sXG4gICAgICBydW5VcGRhdGVNZXNzYWdlSm9iKGpvYikge1xuICAgICAgICByZXR1cm4gam9iKHtcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB3cml0ZTogKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lbnF1ZXVlKHN0cnVjdHVyZWRDbG9uZShzdGF0ZS5tZXNzYWdlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiBoYW5kbGVFcnJvclxuICAgIH0pLFxuICAgIG9uRXJyb3I6IGhhbmRsZUVycm9yXG4gIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgIGlmICghaGFzRXJyb3JlZCkge1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKG91dHB1dFN0cmVhbSk7XG59XG5leHBvcnQge1xuICBBSVNES0Vycm9yMTcgYXMgQUlTREtFcnJvcixcbiAgQVBJQ2FsbEVycm9yLFxuICBBYnN0cmFjdENoYXQsXG4gIERlZmF1bHRDaGF0VHJhbnNwb3J0LFxuICBEb3dubG9hZEVycm9yLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBBZ2VudCBhcyBFeHBlcmltZW50YWxfQWdlbnQsXG4gIEh0dHBDaGF0VHJhbnNwb3J0LFxuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZERhdGFDb250ZW50RXJyb3IsXG4gIEludmFsaWRNZXNzYWdlUm9sZUVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSW52YWxpZFN0cmVhbVBhcnRFcnJvcixcbiAgSW52YWxpZFRvb2xJbnB1dEVycm9yLFxuICBKU09OUGFyc2VFcnJvcixcbiAgSnNvblRvU3NlVHJhbnNmb3JtU3RyZWFtLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIE1DUENsaWVudEVycm9yLFxuICBNZXNzYWdlQ29udmVyc2lvbkVycm9yLFxuICBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvcixcbiAgTm9JbWFnZUdlbmVyYXRlZEVycm9yLFxuICBOb09iamVjdEdlbmVyYXRlZEVycm9yLFxuICBOb091dHB1dEdlbmVyYXRlZEVycm9yLFxuICBOb091dHB1dFNwZWNpZmllZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBOb1N1Y2hQcm92aWRlckVycm9yLFxuICBOb1N1Y2hUb29sRXJyb3IsXG4gIG91dHB1dF9leHBvcnRzIGFzIE91dHB1dCxcbiAgUmV0cnlFcnJvcixcbiAgU2VyaWFsSm9iRXhlY3V0b3IsXG4gIFRleHRTdHJlYW1DaGF0VHJhbnNwb3J0LFxuICBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yLFxuICBUb29sQ2FsbFJlcGFpckVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVSV9NRVNTQUdFX1NUUkVBTV9IRUFERVJTLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcixcbiAgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvcixcbiAgYXNTY2hlbWE1IGFzIGFzU2NoZW1hLFxuICBhc3Npc3RhbnRNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIGNhbGxDb21wbGV0aW9uQXBpLFxuICBjb25zdW1lU3RyZWFtLFxuICBjb252ZXJ0RmlsZUxpc3RUb0ZpbGVVSVBhcnRzLFxuICBjb252ZXJ0VG9Db3JlTWVzc2FnZXMsXG4gIGNvbnZlcnRUb01vZGVsTWVzc2FnZXMsXG4gIGNvcmVBc3Npc3RhbnRNZXNzYWdlU2NoZW1hLFxuICBjb3JlTWVzc2FnZVNjaGVtYSxcbiAgY29yZVN5c3RlbU1lc3NhZ2VTY2hlbWEsXG4gIGNvcmVUb29sTWVzc2FnZVNjaGVtYSxcbiAgY29yZVVzZXJNZXNzYWdlU2NoZW1hLFxuICBjb3NpbmVTaW1pbGFyaXR5LFxuICBjcmVhdGVHYXRld2F5LFxuICBjcmVhdGVJZEdlbmVyYXRvcjUgYXMgY3JlYXRlSWRHZW5lcmF0b3IsXG4gIGNyZWF0ZVByb3ZpZGVyUmVnaXN0cnksXG4gIGNyZWF0ZVRleHRTdHJlYW1SZXNwb25zZSxcbiAgY3JlYXRlVUlNZXNzYWdlU3RyZWFtLFxuICBjcmVhdGVVSU1lc3NhZ2VTdHJlYW1SZXNwb25zZSxcbiAgY3VzdG9tUHJvdmlkZXIsXG4gIGRlZmF1bHRTZXR0aW5nc01pZGRsZXdhcmUsXG4gIGR5bmFtaWNUb29sMiBhcyBkeW5hbWljVG9vbCxcbiAgZW1iZWQsXG4gIGVtYmVkTWFueSxcbiAgY3JlYXRlTUNQQ2xpZW50IGFzIGV4cGVyaW1lbnRhbF9jcmVhdGVNQ1BDbGllbnQsXG4gIGV4cGVyaW1lbnRhbF9jcmVhdGVQcm92aWRlclJlZ2lzdHJ5LFxuICBleHBlcmltZW50YWxfY3VzdG9tUHJvdmlkZXIsXG4gIGdlbmVyYXRlSW1hZ2UgYXMgZXhwZXJpbWVudGFsX2dlbmVyYXRlSW1hZ2UsXG4gIGdlbmVyYXRlU3BlZWNoIGFzIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZVNwZWVjaCxcbiAgdHJhbnNjcmliZSBhcyBleHBlcmltZW50YWxfdHJhbnNjcmliZSxcbiAgZXh0cmFjdFJlYXNvbmluZ01pZGRsZXdhcmUsXG4gIGdhdGV3YXkyIGFzIGdhdGV3YXksXG4gIGdlbmVyYXRlSWQyIGFzIGdlbmVyYXRlSWQsXG4gIGdlbmVyYXRlT2JqZWN0LFxuICBnZW5lcmF0ZVRleHQsXG4gIGdldFRleHRGcm9tRGF0YVVybCxcbiAgZ2V0VG9vbE5hbWUsXG4gIGdldFRvb2xPckR5bmFtaWNUb29sTmFtZSxcbiAgaGFzVG9vbENhbGwsXG4gIGlzRGVlcEVxdWFsRGF0YSxcbiAgaXNUb29sT3JEeW5hbWljVG9vbFVJUGFydCxcbiAgaXNUb29sVUlQYXJ0LFxuICBqc29uU2NoZW1hMiBhcyBqc29uU2NoZW1hLFxuICBsYXN0QXNzaXN0YW50TWVzc2FnZUlzQ29tcGxldGVXaXRoVG9vbENhbGxzLFxuICBtb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHBhcnNlUGFydGlhbEpzb24sXG4gIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZSxcbiAgcGlwZVVJTWVzc2FnZVN0cmVhbVRvUmVzcG9uc2UsXG4gIHJlYWRVSU1lc3NhZ2VTdHJlYW0sXG4gIHNpbXVsYXRlUmVhZGFibGVTdHJlYW0sXG4gIHNpbXVsYXRlU3RyZWFtaW5nTWlkZGxld2FyZSxcbiAgc21vb3RoU3RyZWFtLFxuICBzdGVwQ291bnRJcyxcbiAgc3RyZWFtT2JqZWN0LFxuICBzdHJlYW1UZXh0LFxuICBzeXN0ZW1Nb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHRvb2wyIGFzIHRvb2wsXG4gIHRvb2xNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHVzZXJNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHZhbGlkYXRlVUlNZXNzYWdlcyxcbiAgd3JhcExhbmd1YWdlTW9kZWwsXG4gIHdyYXBQcm92aWRlcixcbiAgem9kU2NoZW1hXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/dist/index.mjs\n");

/***/ })

};
;